
cl-osd.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000070  00800100  00001f84  00002038  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001f84  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000002dc  00800170  00800170  000020a8  2**0
                  ALLOC
  3 .eeprom       00000200  00810000  00810000  000020a8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .stab         00000960  00000000  00000000  000022a8  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      000001af  00000000  00000000  00002c08  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 000001c8  00000000  00000000  00002db8  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000260b  00000000  00000000  00002f80  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000040d  00000000  00000000  0000558b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000010d8  00000000  00000000  00005998  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000318  00000000  00000000  00006a70  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000084e  00000000  00000000  00006d88  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000305d  00000000  00000000  000075d6  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macinfo 0000c122  00000000  00000000  0000a633  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000728  00000000  00000000  00016755  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	47 c0       	rjmp	.+142    	; 0x90 <__ctors_end>
       2:	a4 cd       	rjmp	.-1208   	; 0xfffffb4c <__eeprom_end+0xff7ef94c>
       4:	60 c0       	rjmp	.+192    	; 0xc6 <__bad_interrupt>
       6:	5f c0       	rjmp	.+190    	; 0xc6 <__bad_interrupt>
       8:	5e c0       	rjmp	.+188    	; 0xc6 <__bad_interrupt>
       a:	5d c0       	rjmp	.+186    	; 0xc6 <__bad_interrupt>
       c:	5c c0       	rjmp	.+184    	; 0xc6 <__bad_interrupt>
       e:	5b c0       	rjmp	.+182    	; 0xc6 <__bad_interrupt>
      10:	5a c0       	rjmp	.+180    	; 0xc6 <__bad_interrupt>
      12:	59 c0       	rjmp	.+178    	; 0xc6 <__bad_interrupt>
      14:	58 c0       	rjmp	.+176    	; 0xc6 <__bad_interrupt>
      16:	57 c0       	rjmp	.+174    	; 0xc6 <__bad_interrupt>
      18:	56 c0       	rjmp	.+172    	; 0xc6 <__bad_interrupt>
      1a:	c5 ce       	rjmp	.-630    	; 0xfffffda6 <__eeprom_end+0xff7efba6>
      1c:	54 c0       	rjmp	.+168    	; 0xc6 <__bad_interrupt>
      1e:	53 c0       	rjmp	.+166    	; 0xc6 <__bad_interrupt>
      20:	52 c0       	rjmp	.+164    	; 0xc6 <__bad_interrupt>
      22:	51 c0       	rjmp	.+162    	; 0xc6 <__bad_interrupt>
      24:	50 c0       	rjmp	.+160    	; 0xc6 <__bad_interrupt>
      26:	4f c0       	rjmp	.+158    	; 0xc6 <__bad_interrupt>
      28:	4e c0       	rjmp	.+156    	; 0xc6 <__bad_interrupt>
      2a:	4d c0       	rjmp	.+154    	; 0xc6 <__bad_interrupt>
      2c:	4c c0       	rjmp	.+152    	; 0xc6 <__bad_interrupt>
      2e:	4b c0       	rjmp	.+150    	; 0xc6 <__bad_interrupt>
      30:	4a c0       	rjmp	.+148    	; 0xc6 <__bad_interrupt>
      32:	49 c0       	rjmp	.+146    	; 0xc6 <__bad_interrupt>

00000034 <sinData>:
      34:	00 02 03 05 07 09 0a 0c 0e 10 11 13 15 16 18 1a     ................
      44:	1c 1d 1f 21 22 24 25 27 29 2a 2c 2d 2f 30 32 34     ...!"$%')*,-/024
      54:	35 36 38 39 3b 3c 3e 3f 40 42 43 44 45 47 48 49     5689;<>?@BCDEGHI
      64:	4a 4b 4d 4e 4f 50 51 52 53 54 55 56 57 57 58 59     JKMNOPQRSTUVWWXY
      74:	5a 5b 5b 5c 5d 5d 5e 5f 5f 60 60 61 61 61 62 62     Z[[\]]^__``aaabb
      84:	62 63 63 63 63 64 64 64 64 64 64 00                 bccccdddddd.

00000090 <__ctors_end>:
      90:	11 24       	eor	r1, r1
      92:	1f be       	out	0x3f, r1	; 63
      94:	cf ef       	ldi	r28, 0xFF	; 255
      96:	d4 e0       	ldi	r29, 0x04	; 4
      98:	de bf       	out	0x3e, r29	; 62
      9a:	cd bf       	out	0x3d, r28	; 61

0000009c <__do_copy_data>:
      9c:	11 e0       	ldi	r17, 0x01	; 1
      9e:	a0 e0       	ldi	r26, 0x00	; 0
      a0:	b1 e0       	ldi	r27, 0x01	; 1
      a2:	e4 e8       	ldi	r30, 0x84	; 132
      a4:	ff e1       	ldi	r31, 0x1F	; 31
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x10>
      a8:	05 90       	lpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	a0 37       	cpi	r26, 0x70	; 112
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0xc>

000000b2 <__do_clear_bss>:
      b2:	14 e0       	ldi	r17, 0x04	; 4
      b4:	a0 e7       	ldi	r26, 0x70	; 112
      b6:	b1 e0       	ldi	r27, 0x01	; 1
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	ac 34       	cpi	r26, 0x4C	; 76
      be:	b1 07       	cpc	r27, r17
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	c9 d5       	rcall	.+2962   	; 0xc56 <main>
      c4:	5d cf       	rjmp	.-326    	; 0xffffff80 <__eeprom_end+0xff7efd80>

000000c6 <__bad_interrupt>:
      c6:	9c cf       	rjmp	.-200    	; 0x0 <__vectors>

000000c8 <wgs84ToSec100>:
  uint8_t checksumValid;
} TGpsData;

// Convert nmea WGS84 to seconds * 100
// wgs84 = DDMM[.]MMMM
static int32_t wgs84ToSec100(int32_t wgs84) { 
      c8:	4f 92       	push	r4
      ca:	5f 92       	push	r5
      cc:	6f 92       	push	r6
      ce:	7f 92       	push	r7
      d0:	8f 92       	push	r8
      d2:	9f 92       	push	r9
      d4:	af 92       	push	r10
      d6:	bf 92       	push	r11
      d8:	cf 92       	push	r12
      da:	df 92       	push	r13
      dc:	ef 92       	push	r14
      de:	ff 92       	push	r15
      e0:	1f 93       	push	r17
      e2:	cf 93       	push	r28
      e4:	df 93       	push	r29
      e6:	00 d0       	rcall	.+0      	; 0xe8 <wgs84ToSec100+0x20>
      e8:	00 d0       	rcall	.+0      	; 0xea <wgs84ToSec100+0x22>
      ea:	cd b7       	in	r28, 0x3d	; 61
      ec:	de b7       	in	r29, 0x3e	; 62
      ee:	6b 01       	movw	r12, r22
      f0:	7c 01       	movw	r14, r24
  int8_t mult = 1;
  
  if (wgs84 < 0) {
      f2:	97 fd       	sbrc	r25, 7
      f4:	74 c0       	rjmp	.+232    	; 0x1de <wgs84ToSec100+0x116>
} TGpsData;

// Convert nmea WGS84 to seconds * 100
// wgs84 = DDMM[.]MMMM
static int32_t wgs84ToSec100(int32_t wgs84) { 
  int8_t mult = 1;
      f6:	11 e0       	ldi	r17, 0x01	; 1
  if (wgs84 < 0) {
    mult = -1;
    wgs84 = -wgs84;
  }
  
  uint8_t hour = wgs84 / 1000000; //Get hour part
      f8:	c7 01       	movw	r24, r14
      fa:	b6 01       	movw	r22, r12
      fc:	20 e4       	ldi	r18, 0x40	; 64
      fe:	32 e4       	ldi	r19, 0x42	; 66
     100:	4f e0       	ldi	r20, 0x0F	; 15
     102:	50 e0       	ldi	r21, 0x00	; 0
     104:	f5 de       	rcall	.-534    	; 0xfffffef0 <__eeprom_end+0xff7efcf0>
  uint8_t min = (wgs84 - (hour * 1000000)) / 10000; //Get minute part
     106:	42 2e       	mov	r4, r18
     108:	55 24       	eor	r5, r5
     10a:	66 24       	eor	r6, r6
     10c:	77 24       	eor	r7, r7
  uint32_t minDecimal = wgs84 % 10000; //Get minute decimal part
     10e:	c7 01       	movw	r24, r14
     110:	b6 01       	movw	r22, r12
     112:	20 e1       	ldi	r18, 0x10	; 16
     114:	37 e2       	ldi	r19, 0x27	; 39
     116:	40 e0       	ldi	r20, 0x00	; 0
     118:	50 e0       	ldi	r21, 0x00	; 0
     11a:	ea de       	rcall	.-556    	; 0xfffffef0 <__eeprom_end+0xff7efcf0>
     11c:	69 83       	std	Y+1, r22	; 0x01
     11e:	7a 83       	std	Y+2, r23	; 0x02
     120:	8b 83       	std	Y+3, r24	; 0x03
     122:	9c 83       	std	Y+4, r25	; 0x04
  
  int32_t sec100 = 0;
  sec100 += hour; // Add hour part
  sec100 *= 60;
     124:	c3 01       	movw	r24, r6
     126:	b2 01       	movw	r22, r4
     128:	2c e3       	ldi	r18, 0x3C	; 60
     12a:	30 e0       	ldi	r19, 0x00	; 0
     12c:	40 e0       	ldi	r20, 0x00	; 0
     12e:	50 e0       	ldi	r21, 0x00	; 0
     130:	6b de       	rcall	.-810    	; 0xfffffe08 <__eeprom_end+0xff7efc08>
     132:	4b 01       	movw	r8, r22
     134:	5c 01       	movw	r10, r24
    mult = -1;
    wgs84 = -wgs84;
  }
  
  uint8_t hour = wgs84 / 1000000; //Get hour part
  uint8_t min = (wgs84 - (hour * 1000000)) / 10000; //Get minute part
     136:	c3 01       	movw	r24, r6
     138:	b2 01       	movw	r22, r4
     13a:	20 ec       	ldi	r18, 0xC0	; 192
     13c:	3d eb       	ldi	r19, 0xBD	; 189
     13e:	40 ef       	ldi	r20, 0xF0	; 240
     140:	5f ef       	ldi	r21, 0xFF	; 255
     142:	62 de       	rcall	.-828    	; 0xfffffe08 <__eeprom_end+0xff7efc08>
     144:	6c 0d       	add	r22, r12
     146:	7d 1d       	adc	r23, r13
     148:	8e 1d       	adc	r24, r14
     14a:	9f 1d       	adc	r25, r15
     14c:	20 e1       	ldi	r18, 0x10	; 16
     14e:	37 e2       	ldi	r19, 0x27	; 39
     150:	40 e0       	ldi	r20, 0x00	; 0
     152:	50 e0       	ldi	r21, 0x00	; 0
     154:	cd de       	rcall	.-614    	; 0xfffffef0 <__eeprom_end+0xff7efcf0>
  uint32_t minDecimal = wgs84 % 10000; //Get minute decimal part
  
  int32_t sec100 = 0;
  sec100 += hour; // Add hour part
  sec100 *= 60;
  sec100 += min; // Add minute part
     156:	82 0e       	add	r8, r18
     158:	91 1c       	adc	r9, r1
     15a:	a1 1c       	adc	r10, r1
     15c:	b1 1c       	adc	r11, r1
  sec100 *= 60;
     15e:	c5 01       	movw	r24, r10
     160:	b4 01       	movw	r22, r8
     162:	2c e3       	ldi	r18, 0x3C	; 60
     164:	30 e0       	ldi	r19, 0x00	; 0
     166:	40 e0       	ldi	r20, 0x00	; 0
     168:	50 e0       	ldi	r21, 0x00	; 0
     16a:	4e de       	rcall	.-868    	; 0xfffffe08 <__eeprom_end+0xff7efc08>
     16c:	6b 01       	movw	r12, r22
     16e:	7c 01       	movw	r14, r24
  sec100 *= 100;
  minDecimal *= 60;
     170:	69 81       	ldd	r22, Y+1	; 0x01
     172:	7a 81       	ldd	r23, Y+2	; 0x02
     174:	8b 81       	ldd	r24, Y+3	; 0x03
     176:	9c 81       	ldd	r25, Y+4	; 0x04
     178:	47 de       	rcall	.-882    	; 0xfffffe08 <__eeprom_end+0xff7efc08>
     17a:	4b 01       	movw	r8, r22
     17c:	5c 01       	movw	r10, r24
  int32_t sec100 = 0;
  sec100 += hour; // Add hour part
  sec100 *= 60;
  sec100 += min; // Add minute part
  sec100 *= 60;
  sec100 *= 100;
     17e:	c7 01       	movw	r24, r14
     180:	b6 01       	movw	r22, r12
     182:	24 e6       	ldi	r18, 0x64	; 100
     184:	30 e0       	ldi	r19, 0x00	; 0
     186:	40 e0       	ldi	r20, 0x00	; 0
     188:	50 e0       	ldi	r21, 0x00	; 0
     18a:	3e de       	rcall	.-900    	; 0xfffffe08 <__eeprom_end+0xff7efc08>
     18c:	6b 01       	movw	r12, r22
     18e:	7c 01       	movw	r14, r24
  minDecimal *= 60;
  minDecimal /= 100;
     190:	c5 01       	movw	r24, r10
     192:	b4 01       	movw	r22, r8
     194:	8b de       	rcall	.-746    	; 0xfffffeac <__eeprom_end+0xff7efcac>
  sec100 += minDecimal; // Add minute decimal part
     196:	c2 0e       	add	r12, r18
     198:	d3 1e       	adc	r13, r19
     19a:	e4 1e       	adc	r14, r20
     19c:	f5 1e       	adc	r15, r21
  
  if (mult == -1) {
     19e:	1f 3f       	cpi	r17, 0xFF	; 255
     1a0:	41 f4       	brne	.+16     	; 0x1b2 <wgs84ToSec100+0xea>
    return -sec100;
     1a2:	f0 94       	com	r15
     1a4:	e0 94       	com	r14
     1a6:	d0 94       	com	r13
     1a8:	c0 94       	com	r12
     1aa:	c1 1c       	adc	r12, r1
     1ac:	d1 1c       	adc	r13, r1
     1ae:	e1 1c       	adc	r14, r1
     1b0:	f1 1c       	adc	r15, r1
  } else {
    return sec100;
  }
}
     1b2:	c7 01       	movw	r24, r14
     1b4:	b6 01       	movw	r22, r12
     1b6:	0f 90       	pop	r0
     1b8:	0f 90       	pop	r0
     1ba:	0f 90       	pop	r0
     1bc:	0f 90       	pop	r0
     1be:	df 91       	pop	r29
     1c0:	cf 91       	pop	r28
     1c2:	1f 91       	pop	r17
     1c4:	ff 90       	pop	r15
     1c6:	ef 90       	pop	r14
     1c8:	df 90       	pop	r13
     1ca:	cf 90       	pop	r12
     1cc:	bf 90       	pop	r11
     1ce:	af 90       	pop	r10
     1d0:	9f 90       	pop	r9
     1d2:	8f 90       	pop	r8
     1d4:	7f 90       	pop	r7
     1d6:	6f 90       	pop	r6
     1d8:	5f 90       	pop	r5
     1da:	4f 90       	pop	r4
     1dc:	08 95       	ret
static int32_t wgs84ToSec100(int32_t wgs84) { 
  int8_t mult = 1;
  
  if (wgs84 < 0) {
    mult = -1;
    wgs84 = -wgs84;
     1de:	f0 94       	com	r15
     1e0:	e0 94       	com	r14
     1e2:	d0 94       	com	r13
     1e4:	c0 94       	com	r12
     1e6:	c1 1c       	adc	r12, r1
     1e8:	d1 1c       	adc	r13, r1
     1ea:	e1 1c       	adc	r14, r1
     1ec:	f1 1c       	adc	r15, r1
// wgs84 = DDMM[.]MMMM
static int32_t wgs84ToSec100(int32_t wgs84) { 
  int8_t mult = 1;
  
  if (wgs84 < 0) {
    mult = -1;
     1ee:	1f ef       	ldi	r17, 0xFF	; 255
     1f0:	83 cf       	rjmp	.-250    	; 0xf8 <wgs84ToSec100+0x30>

000001f2 <printNumber>:
	}
	strncpy(&str[pos], str2, length);
	return length+pos;
}

static uint8_t printNumber(char* const str, uint8_t pos, int32_t number) {
     1f2:	4f 92       	push	r4
     1f4:	5f 92       	push	r5
     1f6:	6f 92       	push	r6
     1f8:	7f 92       	push	r7
     1fa:	8f 92       	push	r8
     1fc:	9f 92       	push	r9
     1fe:	af 92       	push	r10
     200:	bf 92       	push	r11
     202:	cf 92       	push	r12
     204:	df 92       	push	r13
     206:	ef 92       	push	r14
     208:	ff 92       	push	r15
     20a:	0f 93       	push	r16
     20c:	1f 93       	push	r17
     20e:	cf 93       	push	r28
     210:	df 93       	push	r29
     212:	2c 01       	movw	r4, r24
     214:	d6 2f       	mov	r29, r22
     216:	49 01       	movw	r8, r18
     218:	5a 01       	movw	r10, r20
#ifndef COMMONUTILS_H_
#define COMMONUTILS_H_

// abs seems to only support 16 bits so I had to make my own.
static uint32_t absi32(int32_t a) {
	return (a > 0) ? a : -a;
     21a:	89 01       	movw	r16, r18
     21c:	9a 01       	movw	r18, r20
     21e:	b7 fc       	sbrc	r11, 7
     220:	79 c0       	rjmp	.+242    	; 0x314 <printNumber+0x122>
	uint8_t length = 1;
	int32_t tmp = absi32(number);
	while (tmp > 9) {
     222:	c1 e0       	ldi	r28, 0x01	; 1
     224:	0a 30       	cpi	r16, 0x0A	; 10
     226:	11 05       	cpc	r17, r1
     228:	21 05       	cpc	r18, r1
     22a:	31 05       	cpc	r19, r1
     22c:	94 f0       	brlt	.+36     	; 0x252 <printNumber+0x60>
		tmp /= 10;
     22e:	9a e0       	ldi	r25, 0x0A	; 10
     230:	c9 2e       	mov	r12, r25
     232:	d1 2c       	mov	r13, r1
     234:	e1 2c       	mov	r14, r1
     236:	f1 2c       	mov	r15, r1
     238:	c9 01       	movw	r24, r18
     23a:	b8 01       	movw	r22, r16
     23c:	a7 01       	movw	r20, r14
     23e:	96 01       	movw	r18, r12
     240:	57 de       	rcall	.-850    	; 0xfffffef0 <__eeprom_end+0xff7efcf0>
     242:	89 01       	movw	r16, r18
     244:	9a 01       	movw	r18, r20
		++length;
     246:	cf 5f       	subi	r28, 0xFF	; 255
}

static uint8_t printNumber(char* const str, uint8_t pos, int32_t number) {
	uint8_t length = 1;
	int32_t tmp = absi32(number);
	while (tmp > 9) {
     248:	0a 30       	cpi	r16, 0x0A	; 10
     24a:	11 05       	cpc	r17, r1
     24c:	21 05       	cpc	r18, r1
     24e:	31 05       	cpc	r19, r1
     250:	9c f7       	brge	.-26     	; 0x238 <printNumber+0x46>
		tmp /= 10;
		++length;
	}
	if (number < 0) {
     252:	b7 fc       	sbrc	r11, 7
     254:	5d c0       	rjmp	.+186    	; 0x310 <printNumber+0x11e>
		++length;
	}
	if (pos + length >= TEXT_LINE_MAX_CHARS) {
     256:	8d 2f       	mov	r24, r29
     258:	90 e0       	ldi	r25, 0x00	; 0
     25a:	9c 01       	movw	r18, r24
     25c:	2c 0f       	add	r18, r28
     25e:	31 1d       	adc	r19, r1
     260:	21 32       	cpi	r18, 0x21	; 33
     262:	31 05       	cpc	r19, r1
     264:	94 f0       	brlt	.+36     	; 0x28a <printNumber+0x98>
    return TEXT_LINE_MAX_CHARS;
     266:	81 e2       	ldi	r24, 0x21	; 33
	}
	myItoa(number, &str[pos]);
	return pos+length;
}
     268:	df 91       	pop	r29
     26a:	cf 91       	pop	r28
     26c:	1f 91       	pop	r17
     26e:	0f 91       	pop	r16
     270:	ff 90       	pop	r15
     272:	ef 90       	pop	r14
     274:	df 90       	pop	r13
     276:	cf 90       	pop	r12
     278:	bf 90       	pop	r11
     27a:	af 90       	pop	r10
     27c:	9f 90       	pop	r9
     27e:	8f 90       	pop	r8
     280:	7f 90       	pop	r7
     282:	6f 90       	pop	r6
     284:	5f 90       	pop	r5
     286:	4f 90       	pop	r4
     288:	08 95       	ret
		++length;
	}
	if (pos + length >= TEXT_LINE_MAX_CHARS) {
    return TEXT_LINE_MAX_CHARS;
	}
	myItoa(number, &str[pos]);
     28a:	48 0e       	add	r4, r24
     28c:	59 1e       	adc	r5, r25
static void myItoa(int32_t n, char s[])
{
  int8_t i;
  int8_t sign = 0;
 
  if (n < 0) {  
     28e:	b7 fc       	sbrc	r11, 7
     290:	49 c0       	rjmp	.+146    	; 0x324 <printNumber+0x132>
}

static void myItoa(int32_t n, char s[])
{
  int8_t i;
  int8_t sign = 0;
     292:	10 e0       	ldi	r17, 0x00	; 0
 
  if (n < 0) {  
	  sign = -1; /* record sign */
    n = -n;          /* make n positive */
     294:	32 01       	movw	r6, r4
  }	
  i = 0;
     296:	00 e0       	ldi	r16, 0x00	; 0
  do {       /* generate digits in reverse order */
    s[i++] = n % 10 + '0';   /* get next digit */
     298:	8a e0       	ldi	r24, 0x0A	; 10
     29a:	c8 2e       	mov	r12, r24
     29c:	d1 2c       	mov	r13, r1
     29e:	e1 2c       	mov	r14, r1
     2a0:	f1 2c       	mov	r15, r1
     2a2:	01 c0       	rjmp	.+2      	; 0x2a6 <printNumber+0xb4>
     2a4:	08 2f       	mov	r16, r24
     2a6:	c5 01       	movw	r24, r10
     2a8:	b4 01       	movw	r22, r8
     2aa:	a7 01       	movw	r20, r14
     2ac:	96 01       	movw	r18, r12
     2ae:	20 de       	rcall	.-960    	; 0xfffffef0 <__eeprom_end+0xff7efcf0>
     2b0:	60 5d       	subi	r22, 0xD0	; 208
     2b2:	f3 01       	movw	r30, r6
     2b4:	61 93       	st	Z+, r22
     2b6:	3f 01       	movw	r6, r30
     2b8:	80 2f       	mov	r24, r16
     2ba:	8f 5f       	subi	r24, 0xFF	; 255
  } while ((n /= 10) > 0);     /* delete it */
     2bc:	49 01       	movw	r8, r18
     2be:	5a 01       	movw	r10, r20
     2c0:	12 16       	cp	r1, r18
     2c2:	13 06       	cpc	r1, r19
     2c4:	14 06       	cpc	r1, r20
     2c6:	15 06       	cpc	r1, r21
     2c8:	6c f3       	brlt	.-38     	; 0x2a4 <printNumber+0xb2>
  if (sign < 0) {
     2ca:	1f 3f       	cpi	r17, 0xFF	; 255
     2cc:	a9 f1       	breq	.+106    	; 0x338 <printNumber+0x146>
    s[i++] = '-';
  }	
  s[i] = '\0';
     2ce:	e8 2f       	mov	r30, r24
     2d0:	ff 27       	eor	r31, r31
     2d2:	e7 fd       	sbrc	r30, 7
     2d4:	f0 95       	com	r31
     2d6:	e4 0d       	add	r30, r4
     2d8:	f5 1d       	adc	r31, r5
     2da:	10 82       	st	Z, r1
}

static void myReverse(char s[], uint8_t size) {
  uint8_t i;
  char c;
  size -= 1;
     2dc:	81 50       	subi	r24, 0x01	; 1
  for (i = 0; i <= size/2; i++) {
     2de:	68 2f       	mov	r22, r24
     2e0:	66 95       	lsr	r22
     2e2:	28 2f       	mov	r18, r24
     2e4:	30 e0       	ldi	r19, 0x00	; 0
     2e6:	40 e0       	ldi	r20, 0x00	; 0
    c = s[i];
     2e8:	84 2f       	mov	r24, r20
     2ea:	90 e0       	ldi	r25, 0x00	; 0
     2ec:	f2 01       	movw	r30, r4
     2ee:	e8 0f       	add	r30, r24
     2f0:	f9 1f       	adc	r31, r25
     2f2:	50 81       	ld	r21, Z
    s[i] = s[size - i];
     2f4:	d9 01       	movw	r26, r18
     2f6:	a8 1b       	sub	r26, r24
     2f8:	b9 0b       	sbc	r27, r25
     2fa:	a4 0d       	add	r26, r4
     2fc:	b5 1d       	adc	r27, r5
     2fe:	8c 91       	ld	r24, X
     300:	80 83       	st	Z, r24
    s[size - i] = c;
     302:	5c 93       	st	X, r21

static void myReverse(char s[], uint8_t size) {
  uint8_t i;
  char c;
  size -= 1;
  for (i = 0; i <= size/2; i++) {
     304:	4f 5f       	subi	r20, 0xFF	; 255
     306:	64 17       	cp	r22, r20
     308:	78 f7       	brcc	.-34     	; 0x2e8 <printNumber+0xf6>
	return pos+length;
     30a:	8c 2f       	mov	r24, r28
     30c:	8d 0f       	add	r24, r29
     30e:	ac cf       	rjmp	.-168    	; 0x268 <printNumber+0x76>
	while (tmp > 9) {
		tmp /= 10;
		++length;
	}
	if (number < 0) {
		++length;
     310:	cf 5f       	subi	r28, 0xFF	; 255
     312:	a1 cf       	rjmp	.-190    	; 0x256 <printNumber+0x64>
#ifndef COMMONUTILS_H_
#define COMMONUTILS_H_

// abs seems to only support 16 bits so I had to make my own.
static uint32_t absi32(int32_t a) {
	return (a > 0) ? a : -a;
     314:	00 27       	eor	r16, r16
     316:	11 27       	eor	r17, r17
     318:	98 01       	movw	r18, r16
     31a:	08 19       	sub	r16, r8
     31c:	19 09       	sbc	r17, r9
     31e:	2a 09       	sbc	r18, r10
     320:	3b 09       	sbc	r19, r11
     322:	7f cf       	rjmp	.-258    	; 0x222 <printNumber+0x30>
  int8_t i;
  int8_t sign = 0;
 
  if (n < 0) {  
	  sign = -1; /* record sign */
    n = -n;          /* make n positive */
     324:	b0 94       	com	r11
     326:	a0 94       	com	r10
     328:	90 94       	com	r9
     32a:	80 94       	com	r8
     32c:	81 1c       	adc	r8, r1
     32e:	91 1c       	adc	r9, r1
     330:	a1 1c       	adc	r10, r1
     332:	b1 1c       	adc	r11, r1
{
  int8_t i;
  int8_t sign = 0;
 
  if (n < 0) {  
	  sign = -1; /* record sign */
     334:	1f ef       	ldi	r17, 0xFF	; 255
     336:	ae cf       	rjmp	.-164    	; 0x294 <printNumber+0xa2>
  i = 0;
  do {       /* generate digits in reverse order */
    s[i++] = n % 10 + '0';   /* get next digit */
  } while ((n /= 10) > 0);     /* delete it */
  if (sign < 0) {
    s[i++] = '-';
     338:	e8 2f       	mov	r30, r24
     33a:	ff 27       	eor	r31, r31
     33c:	e7 fd       	sbrc	r30, 7
     33e:	f0 95       	com	r31
     340:	e4 0d       	add	r30, r4
     342:	f5 1d       	adc	r31, r5
     344:	8d e2       	ldi	r24, 0x2D	; 45
     346:	80 83       	st	Z, r24
     348:	80 2f       	mov	r24, r16
     34a:	8e 5f       	subi	r24, 0xFE	; 254
     34c:	c0 cf       	rjmp	.-128    	; 0x2ce <printNumber+0xdc>

0000034e <printText>:
      gTextPixmap[j + (i*TEXT_LINE_MAX_CHARS)] = gTextLastCharBuffer[i];
	  }		  
	}
}

static uint8_t printText(char* const str, uint8_t pos, const char* const str2) {
     34e:	0f 93       	push	r16
     350:	1f 93       	push	r17
     352:	cf 93       	push	r28
     354:	df 93       	push	r29
     356:	8c 01       	movw	r16, r24
     358:	d6 2f       	mov	r29, r22
     35a:	fa 01       	movw	r30, r20
	uint8_t length = strlen(str2);
     35c:	da 01       	movw	r26, r20
     35e:	0d 90       	ld	r0, X+
     360:	00 20       	and	r0, r0
     362:	e9 f7       	brne	.-6      	; 0x35e <printText+0x10>
     364:	11 97       	sbiw	r26, 0x01	; 1
     366:	ca 2f       	mov	r28, r26
     368:	c4 1b       	sub	r28, r20
	if (pos + length >= TEXT_LINE_MAX_CHARS) {
     36a:	70 e0       	ldi	r23, 0x00	; 0
     36c:	8c 2f       	mov	r24, r28
     36e:	90 e0       	ldi	r25, 0x00	; 0
     370:	9b 01       	movw	r18, r22
     372:	28 0f       	add	r18, r24
     374:	39 1f       	adc	r19, r25
     376:	21 32       	cpi	r18, 0x21	; 33
     378:	31 05       	cpc	r19, r1
     37a:	7c f0       	brlt	.+30     	; 0x39a <printText+0x4c>
     37c:	41 e2       	ldi	r20, 0x21	; 33
     37e:	50 e0       	ldi	r21, 0x00	; 0
    length = TEXT_LINE_MAX_CHARS;
     380:	c1 e2       	ldi	r28, 0x21	; 33
	}
	strncpy(&str[pos], str2, length);
     382:	c8 01       	movw	r24, r16
     384:	86 0f       	add	r24, r22
     386:	97 1f       	adc	r25, r23
     388:	bf 01       	movw	r22, r30
     38a:	db dd       	rcall	.-1098   	; 0xffffff42 <__eeprom_end+0xff7efd42>
	return length+pos;
}
     38c:	8c 2f       	mov	r24, r28
     38e:	8d 0f       	add	r24, r29
     390:	df 91       	pop	r29
     392:	cf 91       	pop	r28
     394:	1f 91       	pop	r17
     396:	0f 91       	pop	r16
     398:	08 95       	ret
	}
}

static uint8_t printText(char* const str, uint8_t pos, const char* const str2) {
	uint8_t length = strlen(str2);
	if (pos + length >= TEXT_LINE_MAX_CHARS) {
     39a:	ac 01       	movw	r20, r24
     39c:	f2 cf       	rjmp	.-28     	; 0x382 <printText+0x34>

0000039e <printGpsNumber>:
/*static uint8_t printBatterLevel(char* const str, uint8_t pos, const uint8_t adcInput) {
	uint8_t batterLevel = gSensorBatteryPercentage;
	return printNumberWithUnit(str, pos, batterLevel, "%");
}*/

static uint8_t printGpsNumber(char* const str, uint8_t pos, int32_t number, uint8_t numberLat) {
     39e:	4f 92       	push	r4
     3a0:	5f 92       	push	r5
     3a2:	6f 92       	push	r6
     3a4:	7f 92       	push	r7
     3a6:	9f 92       	push	r9
     3a8:	af 92       	push	r10
     3aa:	bf 92       	push	r11
     3ac:	cf 92       	push	r12
     3ae:	df 92       	push	r13
     3b0:	ef 92       	push	r14
     3b2:	ff 92       	push	r15
     3b4:	0f 93       	push	r16
     3b6:	1f 93       	push	r17
     3b8:	cf 93       	push	r28
     3ba:	df 93       	push	r29
     3bc:	00 d0       	rcall	.+0      	; 0x3be <printGpsNumber+0x20>
     3be:	00 d0       	rcall	.+0      	; 0x3c0 <printGpsNumber+0x22>
     3c0:	cd b7       	in	r28, 0x3d	; 61
     3c2:	de b7       	in	r29, 0x3e	; 62
     3c4:	5c 01       	movw	r10, r24
     3c6:	96 2e       	mov	r9, r22
     3c8:	da 01       	movw	r26, r20
     3ca:	c9 01       	movw	r24, r18
	if (number == 0) {
     3cc:	21 15       	cp	r18, r1
     3ce:	31 05       	cpc	r19, r1
     3d0:	41 05       	cpc	r20, r1
     3d2:	51 05       	cpc	r21, r1
     3d4:	09 f4       	brne	.+2      	; 0x3d8 <printGpsNumber+0x3a>
     3d6:	c5 c0       	rjmp	.+394    	; 0x562 <__stack+0x63>
#endif
	  return pos;
  }
  
  const char* str2;
  if (numberLat) {
     3d8:	00 23       	and	r16, r16
     3da:	09 f0       	breq	.+2      	; 0x3de <printGpsNumber+0x40>
     3dc:	88 c0       	rjmp	.+272    	; 0x4ee <printGpsNumber+0x150>
	  str2 = number > 0 ? "N" : "S";
  }
  else {
	  str2 = number > 0 ? "E" : "W";
     3de:	12 16       	cp	r1, r18
     3e0:	13 06       	cpc	r1, r19
     3e2:	14 06       	cpc	r1, r20
     3e4:	15 06       	cpc	r1, r21
     3e6:	0c f0       	brlt	.+2      	; 0x3ea <printGpsNumber+0x4c>
     3e8:	c1 c0       	rjmp	.+386    	; 0x56c <__stack+0x6d>
     3ea:	04 e0       	ldi	r16, 0x04	; 4
     3ec:	11 e0       	ldi	r17, 0x01	; 1
#ifndef COMMONUTILS_H_
#define COMMONUTILS_H_

// abs seems to only support 16 bits so I had to make my own.
static uint32_t absi32(int32_t a) {
	return (a > 0) ? a : -a;
     3ee:	6c 01       	movw	r12, r24
     3f0:	7d 01       	movw	r14, r26
     3f2:	b7 fd       	sbrc	r27, 7
     3f4:	c1 c0       	rjmp	.+386    	; 0x578 <__stack+0x79>
  }
  
  number = absi32(number);
 
	
	uint8_t hour = number / 1000000;
     3f6:	c7 01       	movw	r24, r14
     3f8:	b6 01       	movw	r22, r12
     3fa:	20 e4       	ldi	r18, 0x40	; 64
     3fc:	32 e4       	ldi	r19, 0x42	; 66
     3fe:	4f e0       	ldi	r20, 0x0F	; 15
     400:	50 e0       	ldi	r21, 0x00	; 0
     402:	76 dd       	rcall	.-1300   	; 0xfffffef0 <__eeprom_end+0xff7efcf0>
#ifdef GPS_GOOGLE_FORMAT
  uint32_t min = number - (hour * 1000000);
     404:	82 2f       	mov	r24, r18
     406:	90 e0       	ldi	r25, 0x00	; 0
     408:	a0 e0       	ldi	r26, 0x00	; 0
     40a:	b0 e0       	ldi	r27, 0x00	; 0
     40c:	89 83       	std	Y+1, r24	; 0x01
     40e:	9a 83       	std	Y+2, r25	; 0x02
     410:	ab 83       	std	Y+3, r26	; 0x03
     412:	bc 83       	std	Y+4, r27	; 0x04
     414:	bc 01       	movw	r22, r24
     416:	cd 01       	movw	r24, r26
     418:	20 ec       	ldi	r18, 0xC0	; 192
     41a:	3d eb       	ldi	r19, 0xBD	; 189
     41c:	40 ef       	ldi	r20, 0xF0	; 240
     41e:	5f ef       	ldi	r21, 0xFF	; 255
     420:	f3 dc       	rcall	.-1562   	; 0xfffffe08 <__eeprom_end+0xff7efc08>
     422:	6c 0d       	add	r22, r12
     424:	7d 1d       	adc	r23, r13
     426:	8e 1d       	adc	r24, r14
     428:	9f 1d       	adc	r25, r15
  min = (min * 100)/60;
     42a:	24 e6       	ldi	r18, 0x64	; 100
     42c:	30 e0       	ldi	r19, 0x00	; 0
     42e:	40 e0       	ldi	r20, 0x00	; 0
     430:	50 e0       	ldi	r21, 0x00	; 0
     432:	ea dc       	rcall	.-1580   	; 0xfffffe08 <__eeprom_end+0xff7efc08>
     434:	2c e3       	ldi	r18, 0x3C	; 60
     436:	30 e0       	ldi	r19, 0x00	; 0
     438:	40 e0       	ldi	r20, 0x00	; 0
     43a:	50 e0       	ldi	r21, 0x00	; 0
     43c:	37 dd       	rcall	.-1426   	; 0xfffffeac <__eeprom_end+0xff7efcac>
     43e:	29 01       	movw	r4, r18
     440:	3a 01       	movw	r6, r20
  //Calibrate Google GPS Coords
  if (numberLat) {
	  min = min + FUDGE_GOOGLE_LAT;    //Local calibration of Google GPS Lat (Truglodite)
  }
  else {
	  min = min + FUDGE_GOOGLE_LON;    //Local calibration of Google GPS Long (Truglodite)
     442:	84 e7       	ldi	r24, 0x74	; 116
     444:	90 e0       	ldi	r25, 0x00	; 0
     446:	a0 e0       	ldi	r26, 0x00	; 0
     448:	b0 e0       	ldi	r27, 0x00	; 0
     44a:	48 0e       	add	r4, r24
     44c:	59 1e       	adc	r5, r25
     44e:	6a 1e       	adc	r6, r26
     450:	7b 1e       	adc	r7, r27
	}
	return printNumber(str, pos, numberLow);
}

static uint8_t printNumberWithUnit(char* const str, uint8_t pos, int32_t number, const char* unit) {
	pos = printNumber(str, pos, number);
     452:	c5 01       	movw	r24, r10
     454:	69 2d       	mov	r22, r9
     456:	29 81       	ldd	r18, Y+1	; 0x01
     458:	3a 81       	ldd	r19, Y+2	; 0x02
     45a:	4b 81       	ldd	r20, Y+3	; 0x03
     45c:	5c 81       	ldd	r21, Y+4	; 0x04
     45e:	c9 de       	rcall	.-622    	; 0x1f2 <printNumber>
     460:	68 2f       	mov	r22, r24
	return printText(str, pos, unit);
     462:	c5 01       	movw	r24, r10
     464:	44 e1       	ldi	r20, 0x14	; 20
     466:	51 e0       	ldi	r21, 0x01	; 1
     468:	72 df       	rcall	.-284    	; 0x34e <printText>
     46a:	98 2e       	mov	r9, r24
  uint32_t minDecimal = number % 10000; //Get minute decimal part
#endif

#ifdef GPS_GOOGLE_FORMAT
  pos = printNumberWithUnit(str, pos, hour, ".");
  if (min < 10000) { // Added with inspiration from Joern
     46c:	90 e1       	ldi	r25, 0x10	; 16
     46e:	49 16       	cp	r4, r25
     470:	97 e2       	ldi	r25, 0x27	; 39
     472:	59 06       	cpc	r5, r25
     474:	90 e0       	ldi	r25, 0x00	; 0
     476:	69 06       	cpc	r6, r25
     478:	90 e0       	ldi	r25, 0x00	; 0
     47a:	79 06       	cpc	r7, r25
     47c:	d8 f4       	brcc	.+54     	; 0x4b4 <printGpsNumber+0x116>
     47e:	73 01       	movw	r14, r6
     480:	62 01       	movw	r12, r4
	  uint32_t temp = min;
		while (temp < 10000) {
			temp *= 10;
     482:	c7 01       	movw	r24, r14
     484:	b6 01       	movw	r22, r12
     486:	2a e0       	ldi	r18, 0x0A	; 10
     488:	30 e0       	ldi	r19, 0x00	; 0
     48a:	40 e0       	ldi	r20, 0x00	; 0
     48c:	50 e0       	ldi	r21, 0x00	; 0
     48e:	bc dc       	rcall	.-1672   	; 0xfffffe08 <__eeprom_end+0xff7efc08>
     490:	6b 01       	movw	r12, r22
     492:	7c 01       	movw	r14, r24
			pos = printNumber(str, pos, 0);
     494:	c5 01       	movw	r24, r10
     496:	69 2d       	mov	r22, r9
     498:	20 e0       	ldi	r18, 0x00	; 0
     49a:	30 e0       	ldi	r19, 0x00	; 0
     49c:	a9 01       	movw	r20, r18
     49e:	a9 de       	rcall	.-686    	; 0x1f2 <printNumber>
     4a0:	98 2e       	mov	r9, r24

#ifdef GPS_GOOGLE_FORMAT
  pos = printNumberWithUnit(str, pos, hour, ".");
  if (min < 10000) { // Added with inspiration from Joern
	  uint32_t temp = min;
		while (temp < 10000) {
     4a2:	a0 e1       	ldi	r26, 0x10	; 16
     4a4:	ca 16       	cp	r12, r26
     4a6:	a7 e2       	ldi	r26, 0x27	; 39
     4a8:	da 06       	cpc	r13, r26
     4aa:	a0 e0       	ldi	r26, 0x00	; 0
     4ac:	ea 06       	cpc	r14, r26
     4ae:	a0 e0       	ldi	r26, 0x00	; 0
     4b0:	fa 06       	cpc	r15, r26
     4b2:	38 f3       	brcs	.-50     	; 0x482 <printGpsNumber+0xe4>
	}
	return printNumber(str, pos, numberLow);
}

static uint8_t printNumberWithUnit(char* const str, uint8_t pos, int32_t number, const char* unit) {
	pos = printNumber(str, pos, number);
     4b4:	c5 01       	movw	r24, r10
     4b6:	69 2d       	mov	r22, r9
     4b8:	a3 01       	movw	r20, r6
     4ba:	92 01       	movw	r18, r4
     4bc:	9a de       	rcall	.-716    	; 0x1f2 <printNumber>
     4be:	68 2f       	mov	r22, r24
	return printText(str, pos, unit);
     4c0:	c5 01       	movw	r24, r10
     4c2:	a8 01       	movw	r20, r16
     4c4:	44 df       	rcall	.-376    	; 0x34e <printText>
			pos = printNumber(str, pos, 0);
		}
  }
  return printNumberWithUnit(str, pos, minDecimal, str2);
#endif
}
     4c6:	0f 90       	pop	r0
     4c8:	0f 90       	pop	r0
     4ca:	0f 90       	pop	r0
     4cc:	0f 90       	pop	r0
     4ce:	df 91       	pop	r29
     4d0:	cf 91       	pop	r28
     4d2:	1f 91       	pop	r17
     4d4:	0f 91       	pop	r16
     4d6:	ff 90       	pop	r15
     4d8:	ef 90       	pop	r14
     4da:	df 90       	pop	r13
     4dc:	cf 90       	pop	r12
     4de:	bf 90       	pop	r11
     4e0:	af 90       	pop	r10
     4e2:	9f 90       	pop	r9
     4e4:	7f 90       	pop	r7
     4e6:	6f 90       	pop	r6
     4e8:	5f 90       	pop	r5
     4ea:	4f 90       	pop	r4
     4ec:	08 95       	ret
	  return pos;
  }
  
  const char* str2;
  if (numberLat) {
	  str2 = number > 0 ? "N" : "S";
     4ee:	12 16       	cp	r1, r18
     4f0:	13 06       	cpc	r1, r19
     4f2:	14 06       	cpc	r1, r20
     4f4:	15 06       	cpc	r1, r21
     4f6:	ec f5       	brge	.+122    	; 0x572 <__stack+0x73>
     4f8:	02 e0       	ldi	r16, 0x02	; 2
     4fa:	11 e0       	ldi	r17, 0x01	; 1
     4fc:	6c 01       	movw	r12, r24
     4fe:	7d 01       	movw	r14, r26
     500:	b7 fd       	sbrc	r27, 7
     502:	43 c0       	rjmp	.+134    	; 0x58a <__stack+0x8b>
  }
  
  number = absi32(number);
 
	
	uint8_t hour = number / 1000000;
     504:	c7 01       	movw	r24, r14
     506:	b6 01       	movw	r22, r12
     508:	20 e4       	ldi	r18, 0x40	; 64
     50a:	32 e4       	ldi	r19, 0x42	; 66
     50c:	4f e0       	ldi	r20, 0x0F	; 15
     50e:	50 e0       	ldi	r21, 0x00	; 0
     510:	ef dc       	rcall	.-1570   	; 0xfffffef0 <__eeprom_end+0xff7efcf0>
#ifdef GPS_GOOGLE_FORMAT
  uint32_t min = number - (hour * 1000000);
     512:	82 2f       	mov	r24, r18
     514:	90 e0       	ldi	r25, 0x00	; 0
     516:	a0 e0       	ldi	r26, 0x00	; 0
     518:	b0 e0       	ldi	r27, 0x00	; 0
     51a:	89 83       	std	Y+1, r24	; 0x01
     51c:	9a 83       	std	Y+2, r25	; 0x02
     51e:	ab 83       	std	Y+3, r26	; 0x03
     520:	bc 83       	std	Y+4, r27	; 0x04
     522:	bc 01       	movw	r22, r24
     524:	cd 01       	movw	r24, r26
     526:	20 ec       	ldi	r18, 0xC0	; 192
     528:	3d eb       	ldi	r19, 0xBD	; 189
     52a:	40 ef       	ldi	r20, 0xF0	; 240
     52c:	5f ef       	ldi	r21, 0xFF	; 255
     52e:	6c dc       	rcall	.-1832   	; 0xfffffe08 <__eeprom_end+0xff7efc08>
     530:	6c 0d       	add	r22, r12
     532:	7d 1d       	adc	r23, r13
     534:	8e 1d       	adc	r24, r14
     536:	9f 1d       	adc	r25, r15
  min = (min * 100)/60;
     538:	24 e6       	ldi	r18, 0x64	; 100
     53a:	30 e0       	ldi	r19, 0x00	; 0
     53c:	40 e0       	ldi	r20, 0x00	; 0
     53e:	50 e0       	ldi	r21, 0x00	; 0
     540:	63 dc       	rcall	.-1850   	; 0xfffffe08 <__eeprom_end+0xff7efc08>
     542:	2c e3       	ldi	r18, 0x3C	; 60
     544:	30 e0       	ldi	r19, 0x00	; 0
     546:	40 e0       	ldi	r20, 0x00	; 0
     548:	50 e0       	ldi	r21, 0x00	; 0
     54a:	b0 dc       	rcall	.-1696   	; 0xfffffeac <__eeprom_end+0xff7efcac>
     54c:	29 01       	movw	r4, r18
     54e:	3a 01       	movw	r6, r20
  //Calibrate Google GPS Coords
  if (numberLat) {
	  min = min + FUDGE_GOOGLE_LAT;    //Local calibration of Google GPS Lat (Truglodite)
     550:	81 e3       	ldi	r24, 0x31	; 49
     552:	90 e0       	ldi	r25, 0x00	; 0
     554:	a0 e0       	ldi	r26, 0x00	; 0
     556:	b0 e0       	ldi	r27, 0x00	; 0
     558:	48 0e       	add	r4, r24
     55a:	59 1e       	adc	r5, r25
     55c:	6a 1e       	adc	r6, r26
     55e:	7b 1e       	adc	r7, r27
     560:	78 cf       	rjmp	.-272    	; 0x452 <printGpsNumber+0xb4>
}*/

static uint8_t printGpsNumber(char* const str, uint8_t pos, int32_t number, uint8_t numberLat) {
	if (number == 0) {
#ifdef GPS_GOOGLE_FORMAT
    pos = printText(str, pos, "--.-------?");
     562:	c5 01       	movw	r24, r10
     564:	48 e0       	ldi	r20, 0x08	; 8
     566:	51 e0       	ldi	r21, 0x01	; 1
     568:	f2 de       	rcall	.-540    	; 0x34e <printText>
#else
	  pos = printText(str, pos, "--:--.----?");
#endif
	  return pos;
     56a:	ad cf       	rjmp	.-166    	; 0x4c6 <printGpsNumber+0x128>
  const char* str2;
  if (numberLat) {
	  str2 = number > 0 ? "N" : "S";
  }
  else {
	  str2 = number > 0 ? "E" : "W";
     56c:	06 e0       	ldi	r16, 0x06	; 6
     56e:	11 e0       	ldi	r17, 0x01	; 1
     570:	3e cf       	rjmp	.-388    	; 0x3ee <printGpsNumber+0x50>
	  return pos;
  }
  
  const char* str2;
  if (numberLat) {
	  str2 = number > 0 ? "N" : "S";
     572:	00 e0       	ldi	r16, 0x00	; 0
     574:	11 e0       	ldi	r17, 0x01	; 1
     576:	c2 cf       	rjmp	.-124    	; 0x4fc <printGpsNumber+0x15e>
     578:	f0 94       	com	r15
     57a:	e0 94       	com	r14
     57c:	d0 94       	com	r13
     57e:	c0 94       	com	r12
     580:	c1 1c       	adc	r12, r1
     582:	d1 1c       	adc	r13, r1
     584:	e1 1c       	adc	r14, r1
     586:	f1 1c       	adc	r15, r1
     588:	36 cf       	rjmp	.-404    	; 0x3f6 <printGpsNumber+0x58>
     58a:	f0 94       	com	r15
     58c:	e0 94       	com	r14
     58e:	d0 94       	com	r13
     590:	c0 94       	com	r12
     592:	c1 1c       	adc	r12, r1
     594:	d1 1c       	adc	r13, r1
     596:	e1 1c       	adc	r14, r1
     598:	f1 1c       	adc	r15, r1
     59a:	b4 cf       	rjmp	.-152    	; 0x504 <__stack+0x5>

0000059c <parseInt.constprop.4>:
	tmp /= 1000;
	*var = tmp;
}
#endif //IMPERIAL_SYSTEM

static int32_t parseInt(const char* const text, uint8_t maxLength) {
     59c:	ff 92       	push	r15
     59e:	0f 93       	push	r16
     5a0:	1f 93       	push	r17
     5a2:	cf 93       	push	r28
     5a4:	df 93       	push	r29
	uint8_t i = 0;
     5a6:	ff 24       	eor	r15, r15
     5a8:	f3 94       	inc	r15
     5aa:	80 91 d2 03 	lds	r24, 0x03D2
     5ae:	8d 32       	cpi	r24, 0x2D	; 45
     5b0:	09 f0       	breq	.+2      	; 0x5b4 <parseInt.constprop.4+0x18>
     5b2:	ff 24       	eor	r15, r15
	uint8_t neg = 0;
	if (text[0] == '-') {
		++i;
		neg = 1;
	}
	while (isDigit(text[i]) && i < maxLength) {
     5b4:	ef 2d       	mov	r30, r15
     5b6:	f0 e0       	ldi	r31, 0x00	; 0
     5b8:	ee 52       	subi	r30, 0x2E	; 46
     5ba:	fc 4f       	sbci	r31, 0xFC	; 252
     5bc:	d0 81       	ld	r29, Z
  } while (c++ < 25);
  return nv;
}

inline uint8_t isDigit(char c) {
	if (c >= '0' && c <= '9') {
     5be:	8d 2f       	mov	r24, r29
     5c0:	80 53       	subi	r24, 0x30	; 48
     5c2:	8a 30       	cpi	r24, 0x0A	; 10
     5c4:	90 f0       	brcs	.+36     	; 0x5ea <parseInt.constprop.4+0x4e>
     5c6:	00 e0       	ldi	r16, 0x00	; 0
     5c8:	10 e0       	ldi	r17, 0x00	; 0
     5ca:	98 01       	movw	r18, r16
		decimal *= 10;
		decimal += (text[i]) - '0';
		++i;		
	}
	return decimal * (neg ? -1 : 1);
     5cc:	ff 20       	and	r15, r15
     5ce:	a1 f5       	brne	.+104    	; 0x638 <parseInt.constprop.4+0x9c>
     5d0:	61 e0       	ldi	r22, 0x01	; 1
     5d2:	70 e0       	ldi	r23, 0x00	; 0
     5d4:	80 e0       	ldi	r24, 0x00	; 0
     5d6:	90 e0       	ldi	r25, 0x00	; 0
     5d8:	a9 01       	movw	r20, r18
     5da:	98 01       	movw	r18, r16
     5dc:	15 dc       	rcall	.-2006   	; 0xfffffe08 <__eeprom_end+0xff7efc08>
}
     5de:	df 91       	pop	r29
     5e0:	cf 91       	pop	r28
     5e2:	1f 91       	pop	r17
     5e4:	0f 91       	pop	r16
     5e6:	ff 90       	pop	r15
     5e8:	08 95       	ret
     5ea:	cf 2d       	mov	r28, r15
     5ec:	00 e0       	ldi	r16, 0x00	; 0
     5ee:	10 e0       	ldi	r17, 0x00	; 0
     5f0:	98 01       	movw	r18, r16
	if (text[0] == '-') {
		++i;
		neg = 1;
	}
	while (isDigit(text[i]) && i < maxLength) {
		decimal *= 10;
     5f2:	c9 01       	movw	r24, r18
     5f4:	b8 01       	movw	r22, r16
     5f6:	2a e0       	ldi	r18, 0x0A	; 10
     5f8:	30 e0       	ldi	r19, 0x00	; 0
     5fa:	40 e0       	ldi	r20, 0x00	; 0
     5fc:	50 e0       	ldi	r21, 0x00	; 0
     5fe:	04 dc       	rcall	.-2040   	; 0xfffffe08 <__eeprom_end+0xff7efc08>
     600:	dc 01       	movw	r26, r24
     602:	cb 01       	movw	r24, r22
		decimal += (text[i]) - '0';
     604:	0d 2f       	mov	r16, r29
     606:	10 e0       	ldi	r17, 0x00	; 0
     608:	00 53       	subi	r16, 0x30	; 48
     60a:	10 40       	sbci	r17, 0x00	; 0
     60c:	22 27       	eor	r18, r18
     60e:	17 fd       	sbrc	r17, 7
     610:	20 95       	com	r18
     612:	32 2f       	mov	r19, r18
     614:	08 0f       	add	r16, r24
     616:	19 1f       	adc	r17, r25
     618:	2a 1f       	adc	r18, r26
     61a:	3b 1f       	adc	r19, r27
		++i;		
     61c:	cf 5f       	subi	r28, 0xFF	; 255
	uint8_t neg = 0;
	if (text[0] == '-') {
		++i;
		neg = 1;
	}
	while (isDigit(text[i]) && i < maxLength) {
     61e:	ec 2f       	mov	r30, r28
     620:	f0 e0       	ldi	r31, 0x00	; 0
     622:	ee 52       	subi	r30, 0x2E	; 46
     624:	fc 4f       	sbci	r31, 0xFC	; 252
     626:	d0 81       	ld	r29, Z
     628:	8d 2f       	mov	r24, r29
     62a:	80 53       	subi	r24, 0x30	; 48
     62c:	8a 30       	cpi	r24, 0x0A	; 10
     62e:	70 f6       	brcc	.-100    	; 0x5cc <parseInt.constprop.4+0x30>
     630:	cb 30       	cpi	r28, 0x0B	; 11
     632:	f8 f2       	brcs	.-66     	; 0x5f2 <parseInt.constprop.4+0x56>
		decimal *= 10;
		decimal += (text[i]) - '0';
		++i;		
	}
	return decimal * (neg ? -1 : 1);
     634:	ff 20       	and	r15, r15
     636:	61 f2       	breq	.-104    	; 0x5d0 <parseInt.constprop.4+0x34>
     638:	6f ef       	ldi	r22, 0xFF	; 255
     63a:	7f ef       	ldi	r23, 0xFF	; 255
     63c:	cb 01       	movw	r24, r22
     63e:	cc cf       	rjmp	.-104    	; 0x5d8 <parseInt.constprop.4+0x3c>

00000640 <parseFloat.constprop.5>:
}

static int32_t parseFloat(const char* const text, uint8_t maxLength) {
     640:	ff 92       	push	r15
     642:	0f 93       	push	r16
     644:	1f 93       	push	r17
     646:	cf 93       	push	r28
     648:	df 93       	push	r29
	
	uint32_t val = 0;
	uint8_t neg = 0;
     64a:	ff 24       	eor	r15, r15
     64c:	f3 94       	inc	r15
     64e:	80 91 d2 03 	lds	r24, 0x03D2
     652:	8d 32       	cpi	r24, 0x2D	; 45
     654:	09 f0       	breq	.+2      	; 0x658 <parseFloat.constprop.5+0x18>
     656:	ff 24       	eor	r15, r15
     658:	cf 2d       	mov	r28, r15
     65a:	00 e0       	ldi	r16, 0x00	; 0
     65c:	10 e0       	ldi	r17, 0x00	; 0
     65e:	98 01       	movw	r18, r16
     660:	18 c0       	rjmp	.+48     	; 0x692 <parseFloat.constprop.5+0x52>
		++i;
		neg = 1;
	}
	for (; i < maxLength; ++i) {
		if (isDigit(text[i])) {
			val *= 10;
     662:	c9 01       	movw	r24, r18
     664:	b8 01       	movw	r22, r16
     666:	2a e0       	ldi	r18, 0x0A	; 10
     668:	30 e0       	ldi	r19, 0x00	; 0
     66a:	40 e0       	ldi	r20, 0x00	; 0
     66c:	50 e0       	ldi	r21, 0x00	; 0
     66e:	cc db       	rcall	.-2152   	; 0xfffffe08 <__eeprom_end+0xff7efc08>
     670:	dc 01       	movw	r26, r24
     672:	cb 01       	movw	r24, r22
			val += (text[i]) - '0';
     674:	0d 2f       	mov	r16, r29
     676:	10 e0       	ldi	r17, 0x00	; 0
     678:	00 53       	subi	r16, 0x30	; 48
     67a:	10 40       	sbci	r17, 0x00	; 0
     67c:	22 27       	eor	r18, r18
     67e:	17 fd       	sbrc	r17, 7
     680:	20 95       	com	r18
     682:	32 2f       	mov	r19, r18
     684:	08 0f       	add	r16, r24
     686:	19 1f       	adc	r17, r25
     688:	2a 1f       	adc	r18, r26
     68a:	3b 1f       	adc	r19, r27
	uint8_t i = 0;
	if (text[0] == '-') {
		++i;
		neg = 1;
	}
	for (; i < maxLength; ++i) {
     68c:	cf 5f       	subi	r28, 0xFF	; 255
     68e:	cb 30       	cpi	r28, 0x0B	; 11
     690:	58 f4       	brcc	.+22     	; 0x6a8 <parseFloat.constprop.5+0x68>
		if (isDigit(text[i])) {
     692:	ec 2f       	mov	r30, r28
     694:	f0 e0       	ldi	r31, 0x00	; 0
     696:	ee 52       	subi	r30, 0x2E	; 46
     698:	fc 4f       	sbci	r31, 0xFC	; 252
     69a:	d0 81       	ld	r29, Z
     69c:	8d 2f       	mov	r24, r29
     69e:	80 53       	subi	r24, 0x30	; 48
     6a0:	8a 30       	cpi	r24, 0x0A	; 10
     6a2:	f8 f2       	brcs	.-66     	; 0x662 <parseFloat.constprop.5+0x22>
			val *= 10;
			val += (text[i]) - '0';
		}
		else if (text[i] != '.') {
     6a4:	de 32       	cpi	r29, 0x2E	; 46
     6a6:	91 f3       	breq	.-28     	; 0x68c <parseFloat.constprop.5+0x4c>
			break;
		}			
	}
	return val * (neg ? -1 : 1);
     6a8:	ff 20       	and	r15, r15
     6aa:	69 f4       	brne	.+26     	; 0x6c6 <parseFloat.constprop.5+0x86>
     6ac:	61 e0       	ldi	r22, 0x01	; 1
     6ae:	70 e0       	ldi	r23, 0x00	; 0
     6b0:	80 e0       	ldi	r24, 0x00	; 0
     6b2:	90 e0       	ldi	r25, 0x00	; 0
     6b4:	a9 01       	movw	r20, r18
     6b6:	98 01       	movw	r18, r16
     6b8:	a7 db       	rcall	.-2226   	; 0xfffffe08 <__eeprom_end+0xff7efc08>
}
     6ba:	df 91       	pop	r29
     6bc:	cf 91       	pop	r28
     6be:	1f 91       	pop	r17
     6c0:	0f 91       	pop	r16
     6c2:	ff 90       	pop	r15
     6c4:	08 95       	ret
		}
		else if (text[i] != '.') {
			break;
		}			
	}
	return val * (neg ? -1 : 1);
     6c6:	6f ef       	ldi	r22, 0xFF	; 255
     6c8:	7f ef       	ldi	r23, 0xFF	; 255
     6ca:	cb 01       	movw	r24, r22
     6cc:	f3 cf       	rjmp	.-26     	; 0x6b4 <parseFloat.constprop.5+0x74>

000006ce <parseGpsPart>:
	gGpsTextPartLength = strlen((const char*)gGpsText);
}
#endif //GPS_PART_TEXT

static void parseGpsPart() {
	if (gGpsTextType == GPS_TYPE_NONE) {
     6ce:	80 91 d0 03 	lds	r24, 0x03D0
     6d2:	88 23       	and	r24, r24
     6d4:	81 f1       	breq	.+96     	; 0x736 <parseGpsPart+0x68>
			gGpsTextPartStep = GPS_GPRMC_PART_OFFSET;
			//updateParts();
		}
	}
	else if (gGpsTextType != GPS_TYPE_NONE) {
		if (gGpsTextPos != 0) {
     6d6:	80 91 cf 03 	lds	r24, 0x03CF
     6da:	88 23       	and	r24, r24
     6dc:	59 f1       	breq	.+86     	; 0x734 <parseGpsPart+0x66>
			switch (gGpsTextPartStep) {
     6de:	80 91 5d 01 	lds	r24, 0x015D
     6e2:	85 36       	cpi	r24, 0x65	; 101
     6e4:	89 f0       	breq	.+34     	; 0x708 <parseGpsPart+0x3a>
     6e6:	86 36       	cpi	r24, 0x66	; 102
     6e8:	08 f0       	brcs	.+2      	; 0x6ec <parseGpsPart+0x1e>
     6ea:	44 c0       	rjmp	.+136    	; 0x774 <parseGpsPart+0xa6>
     6ec:	84 30       	cpi	r24, 0x04	; 4
     6ee:	09 f4       	brne	.+2      	; 0x6f2 <parseGpsPart+0x24>
     6f0:	75 c0       	rjmp	.+234    	; 0x7dc <parseGpsPart+0x10e>
     6f2:	85 30       	cpi	r24, 0x05	; 5
     6f4:	08 f0       	brcs	.+2      	; 0x6f8 <parseGpsPart+0x2a>
     6f6:	7e c0       	rjmp	.+252    	; 0x7f4 <parseGpsPart+0x126>
     6f8:	82 30       	cpi	r24, 0x02	; 2
     6fa:	09 f4       	brne	.+2      	; 0x6fe <parseGpsPart+0x30>
     6fc:	47 c0       	rjmp	.+142    	; 0x78c <parseGpsPart+0xbe>
     6fe:	83 30       	cpi	r24, 0x03	; 3
     700:	08 f0       	brcs	.+2      	; 0x704 <parseGpsPart+0x36>
     702:	21 c1       	rjmp	.+578    	; 0x946 <parseGpsPart+0x278>
     704:	81 30       	cpi	r24, 0x01	; 1
     706:	b1 f4       	brne	.+44     	; 0x734 <parseGpsPart+0x66>
			case GPS_PART_GPGGA_TIME:
			case GPS_PART_GPRMC_TIME:
				gGpsLastData.gTime = parseInt(gGpsText, GPS_MAX_CHARS);
     708:	49 df       	rcall	.-366    	; 0x59c <parseInt.constprop.4>
     70a:	dc 01       	movw	r26, r24
     70c:	cb 01       	movw	r24, r22
     70e:	80 93 81 01 	sts	0x0181, r24
     712:	90 93 82 01 	sts	0x0182, r25
     716:	a0 93 83 01 	sts	0x0183, r26
     71a:	b0 93 84 01 	sts	0x0184, r27
     71e:	08 95       	ret
}

static uint8_t parseHex(const char* const text, uint8_t maxLength) {
	uint8_t i = 0;
	uint32_t val = 0;
	while (text[i] != 0 && i < maxLength) {
     720:	80 e0       	ldi	r24, 0x00	; 0
     722:	90 e0       	ldi	r25, 0x00	; 0
     724:	dc 01       	movw	r26, r24
			  break;
			case GPS_PART_CHECKSUM:
				//updateParts();
				{
				uint8_t val = parseHex(gGpsText, GPS_MAX_CHARS);
				gGpsLastData.checksumValid = (val == gGpsChecksum);
     726:	21 e0       	ldi	r18, 0x01	; 1
     728:	30 91 d1 03 	lds	r19, 0x03D1
     72c:	38 13       	cpse	r19, r24
     72e:	20 e0       	ldi	r18, 0x00	; 0
     730:	20 93 8f 01 	sts	0x018F, r18
     734:	08 95       	ret
}
#endif //GPS_PART_TEXT

static void parseGpsPart() {
	if (gGpsTextType == GPS_TYPE_NONE) {
		if (!strncmp((const char*)gGpsText, "GPGGA", 5)) {
     736:	82 ed       	ldi	r24, 0xD2	; 210
     738:	93 e0       	ldi	r25, 0x03	; 3
     73a:	66 e1       	ldi	r22, 0x16	; 22
     73c:	71 e0       	ldi	r23, 0x01	; 1
     73e:	45 e0       	ldi	r20, 0x05	; 5
     740:	50 e0       	ldi	r21, 0x00	; 0
     742:	f1 db       	rcall	.-2078   	; 0xffffff26 <__eeprom_end+0xff7efd26>
     744:	00 97       	sbiw	r24, 0x00	; 0
     746:	81 f0       	breq	.+32     	; 0x768 <parseGpsPart+0x9a>
			gGpsTextType = GPS_TYPE_GPGGA;
			gGpsTextPartStep = GPS_PART_NONE;
			//updateParts();
		}
		else if (!strncmp((const char*)gGpsText, "GPRMC", 5)) {
     748:	82 ed       	ldi	r24, 0xD2	; 210
     74a:	93 e0       	ldi	r25, 0x03	; 3
     74c:	6c e1       	ldi	r22, 0x1C	; 28
     74e:	71 e0       	ldi	r23, 0x01	; 1
     750:	45 e0       	ldi	r20, 0x05	; 5
     752:	50 e0       	ldi	r21, 0x00	; 0
     754:	e8 db       	rcall	.-2096   	; 0xffffff26 <__eeprom_end+0xff7efd26>
     756:	00 97       	sbiw	r24, 0x00	; 0
     758:	69 f7       	brne	.-38     	; 0x734 <parseGpsPart+0x66>
			gGpsTextType = GPS_TYPE_GPRMC;
     75a:	82 e0       	ldi	r24, 0x02	; 2
     75c:	80 93 d0 03 	sts	0x03D0, r24
			gGpsTextPartStep = GPS_GPRMC_PART_OFFSET;
     760:	84 e6       	ldi	r24, 0x64	; 100
     762:	80 93 5d 01 	sts	0x015D, r24
     766:	08 95       	ret
#endif //GPS_PART_TEXT

static void parseGpsPart() {
	if (gGpsTextType == GPS_TYPE_NONE) {
		if (!strncmp((const char*)gGpsText, "GPGGA", 5)) {
			gGpsTextType = GPS_TYPE_GPGGA;
     768:	81 e0       	ldi	r24, 0x01	; 1
     76a:	80 93 d0 03 	sts	0x03D0, r24
			gGpsTextPartStep = GPS_PART_NONE;
     76e:	10 92 5d 01 	sts	0x015D, r1
     772:	08 95       	ret
			//updateParts();
		}
	}
	else if (gGpsTextType != GPS_TYPE_NONE) {
		if (gGpsTextPos != 0) {
			switch (gGpsTextPartStep) {
     774:	8a 36       	cpi	r24, 0x6A	; 106
     776:	b1 f0       	breq	.+44     	; 0x7a4 <parseGpsPart+0xd6>
     778:	8b 36       	cpi	r24, 0x6B	; 107
     77a:	08 f0       	brcs	.+2      	; 0x77e <parseGpsPart+0xb0>
     77c:	4e c0       	rjmp	.+156    	; 0x81a <parseGpsPart+0x14c>
     77e:	88 36       	cpi	r24, 0x68	; 104
     780:	09 f4       	brne	.+2      	; 0x784 <parseGpsPart+0xb6>
     782:	e1 c0       	rjmp	.+450    	; 0x946 <parseGpsPart+0x278>
     784:	89 36       	cpi	r24, 0x69	; 105
     786:	50 f5       	brcc	.+84     	; 0x7dc <parseGpsPart+0x10e>
     788:	87 36       	cpi	r24, 0x67	; 103
     78a:	a1 f6       	brne	.-88     	; 0x734 <parseGpsPart+0x66>
				gGpsLastData.gTime = parseInt(gGpsText, GPS_MAX_CHARS);
				//updateParts();
				break;
			case GPS_PART_GPGGA_LAT:
			case GPS_PART_GPRMC_LAT:
				gGpsLastData.pos.latitude = parseFloat(gGpsText, GPS_MAX_CHARS);
     78c:	59 df       	rcall	.-334    	; 0x640 <parseFloat.constprop.5>
     78e:	dc 01       	movw	r26, r24
     790:	cb 01       	movw	r24, r22
     792:	80 93 77 01 	sts	0x0177, r24
     796:	90 93 78 01 	sts	0x0178, r25
     79a:	a0 93 79 01 	sts	0x0179, r26
     79e:	b0 93 7a 01 	sts	0x017A, r27
     7a2:	08 95       	ret
				gGpsLastData.pos.longitude = parseFloat(gGpsText, GPS_MAX_CHARS);
				//updateParts();
				break;
			case GPS_PART_GPGGA_LONG_UNIT:
			case GPS_PART_GPRMC_LONG_UNIT:
				if (gGpsText[0] == 'W') {
     7a4:	80 91 d2 03 	lds	r24, 0x03D2
     7a8:	87 35       	cpi	r24, 0x57	; 87
     7aa:	21 f6       	brne	.-120    	; 0x734 <parseGpsPart+0x66>
					gGpsLastData.pos.longitude = -gGpsLastData.pos.longitude;
     7ac:	80 91 7b 01 	lds	r24, 0x017B
     7b0:	90 91 7c 01 	lds	r25, 0x017C
     7b4:	a0 91 7d 01 	lds	r26, 0x017D
     7b8:	b0 91 7e 01 	lds	r27, 0x017E
     7bc:	b0 95       	com	r27
     7be:	a0 95       	com	r26
     7c0:	90 95       	com	r25
     7c2:	81 95       	neg	r24
     7c4:	9f 4f       	sbci	r25, 0xFF	; 255
     7c6:	af 4f       	sbci	r26, 0xFF	; 255
     7c8:	bf 4f       	sbci	r27, 0xFF	; 255
     7ca:	80 93 7b 01 	sts	0x017B, r24
     7ce:	90 93 7c 01 	sts	0x017C, r25
     7d2:	a0 93 7d 01 	sts	0x017D, r26
     7d6:	b0 93 7e 01 	sts	0x017E, r27
     7da:	08 95       	ret
					gGpsLastData.pos.latitude = -gGpsLastData.pos.latitude;
				}
				break;
			case GPS_PART_GPGGA_LONG:
			case GPS_PART_GPRMC_LONG:
				gGpsLastData.pos.longitude = parseFloat(gGpsText, GPS_MAX_CHARS);
     7dc:	31 df       	rcall	.-414    	; 0x640 <parseFloat.constprop.5>
     7de:	dc 01       	movw	r26, r24
     7e0:	cb 01       	movw	r24, r22
     7e2:	80 93 7b 01 	sts	0x017B, r24
     7e6:	90 93 7c 01 	sts	0x017C, r25
     7ea:	a0 93 7d 01 	sts	0x017D, r26
     7ee:	b0 93 7e 01 	sts	0x017E, r27
     7f2:	08 95       	ret
			//updateParts();
		}
	}
	else if (gGpsTextType != GPS_TYPE_NONE) {
		if (gGpsTextPos != 0) {
			switch (gGpsTextPartStep) {
     7f4:	86 30       	cpi	r24, 0x06	; 6
     7f6:	09 f4       	brne	.+2      	; 0x7fa <parseGpsPart+0x12c>
     7f8:	a0 c0       	rjmp	.+320    	; 0x93a <parseGpsPart+0x26c>
     7fa:	86 30       	cpi	r24, 0x06	; 6
     7fc:	98 f2       	brcs	.-90     	; 0x7a4 <parseGpsPart+0xd6>
     7fe:	87 30       	cpi	r24, 0x07	; 7
     800:	09 f4       	brne	.+2      	; 0x804 <parseGpsPart+0x136>
     802:	95 c0       	rjmp	.+298    	; 0x92e <parseGpsPart+0x260>
     804:	89 30       	cpi	r24, 0x09	; 9
     806:	09 f0       	breq	.+2      	; 0x80a <parseGpsPart+0x13c>
     808:	95 cf       	rjmp	.-214    	; 0x734 <parseGpsPart+0x66>
				break;
			case GPS_PART_GPGGA_DILUTION:
				// Horizontal dilution of position
				break;
			case GPS_PART_GPGGA_ALTITUDE:
				gGpsLastData.pos.altitude = parseInt(gGpsText, GPS_MAX_CHARS);
     80a:	c8 de       	rcall	.-624    	; 0x59c <parseInt.constprop.4>
     80c:	dc 01       	movw	r26, r24
     80e:	cb 01       	movw	r24, r22
     810:	90 93 80 01 	sts	0x0180, r25
     814:	80 93 7f 01 	sts	0x017F, r24
     818:	08 95       	ret
			//updateParts();
		}
	}
	else if (gGpsTextType != GPS_TYPE_NONE) {
		if (gGpsTextPos != 0) {
			switch (gGpsTextPartStep) {
     81a:	8c 36       	cpi	r24, 0x6C	; 108
     81c:	09 f4       	brne	.+2      	; 0x820 <parseGpsPart+0x152>
     81e:	7f c0       	rjmp	.+254    	; 0x91e <parseGpsPart+0x250>
     820:	8c 36       	cpi	r24, 0x6C	; 108
     822:	08 f4       	brcc	.+2      	; 0x826 <parseGpsPart+0x158>
     824:	68 c0       	rjmp	.+208    	; 0x8f6 <parseGpsPart+0x228>
     826:	8d 36       	cpi	r24, 0x6D	; 109
     828:	09 f4       	brne	.+2      	; 0x82c <parseGpsPart+0x15e>
     82a:	59 c0       	rjmp	.+178    	; 0x8de <parseGpsPart+0x210>
     82c:	88 3c       	cpi	r24, 0xC8	; 200
     82e:	09 f0       	breq	.+2      	; 0x832 <parseGpsPart+0x164>
     830:	81 cf       	rjmp	.-254    	; 0x734 <parseGpsPart+0x66>
     832:	20 91 d2 03 	lds	r18, 0x03D2
     836:	22 23       	and	r18, r18
     838:	09 f4       	brne	.+2      	; 0x83c <parseGpsPart+0x16e>
     83a:	72 cf       	rjmp	.-284    	; 0x720 <parseGpsPart+0x52>
				break;
			case GPS_PART_GPRMC_ANGLE:
				gGpsLastData.angle = parseInt(gGpsText, GPS_MAX_CHARS); // Only use int part
				break;
			case GPS_PART_GPRMC_DATE:
			  gGpsLastData.date = parseInt(gGpsText, GPS_MAX_CHARS);
     83c:	e3 ed       	ldi	r30, 0xD3	; 211
     83e:	f3 e0       	ldi	r31, 0x03	; 3
	strncpy((char*)gGpsTextPart, (char*)gGpsText, GPS_MAX_CHARS);
	gGpsTextPartLength = strlen((const char*)gGpsText);
}
#endif //GPS_PART_TEXT

static void parseGpsPart() {
     840:	80 e0       	ldi	r24, 0x00	; 0
     842:	90 e0       	ldi	r25, 0x00	; 0
     844:	dc 01       	movw	r26, r24
     846:	15 c0       	rjmp	.+42     	; 0x872 <parseGpsPart+0x1a4>
		val *= 16;
		if (text[i] >= 'A' && text[i] <= 'F') {
			val += 10 + text[i] - 'A';
     848:	30 e0       	ldi	r19, 0x00	; 0
     84a:	27 53       	subi	r18, 0x37	; 55
     84c:	30 40       	sbci	r19, 0x00	; 0
     84e:	a9 01       	movw	r20, r18
     850:	66 27       	eor	r22, r22
     852:	57 fd       	sbrc	r21, 7
     854:	60 95       	com	r22
     856:	76 2f       	mov	r23, r22
     858:	84 0f       	add	r24, r20
     85a:	95 1f       	adc	r25, r21
     85c:	a6 1f       	adc	r26, r22
     85e:	b7 1f       	adc	r27, r23
}

static uint8_t parseHex(const char* const text, uint8_t maxLength) {
	uint8_t i = 0;
	uint32_t val = 0;
	while (text[i] != 0 && i < maxLength) {
     860:	21 91       	ld	r18, Z+
     862:	22 23       	and	r18, r18
     864:	09 f4       	brne	.+2      	; 0x868 <parseGpsPart+0x19a>
     866:	5f cf       	rjmp	.-322    	; 0x726 <parseGpsPart+0x58>
     868:	33 e0       	ldi	r19, 0x03	; 3
     86a:	ee 3d       	cpi	r30, 0xDE	; 222
     86c:	f3 07       	cpc	r31, r19
     86e:	09 f4       	brne	.+2      	; 0x872 <parseGpsPart+0x1a4>
     870:	5a cf       	rjmp	.-332    	; 0x726 <parseGpsPart+0x58>
		val *= 16;
     872:	88 0f       	add	r24, r24
     874:	99 1f       	adc	r25, r25
     876:	aa 1f       	adc	r26, r26
     878:	bb 1f       	adc	r27, r27
     87a:	88 0f       	add	r24, r24
     87c:	99 1f       	adc	r25, r25
     87e:	aa 1f       	adc	r26, r26
     880:	bb 1f       	adc	r27, r27
     882:	88 0f       	add	r24, r24
     884:	99 1f       	adc	r25, r25
     886:	aa 1f       	adc	r26, r26
     888:	bb 1f       	adc	r27, r27
     88a:	88 0f       	add	r24, r24
     88c:	99 1f       	adc	r25, r25
     88e:	aa 1f       	adc	r26, r26
     890:	bb 1f       	adc	r27, r27
		if (text[i] >= 'A' && text[i] <= 'F') {
     892:	32 2f       	mov	r19, r18
     894:	31 54       	subi	r19, 0x41	; 65
     896:	36 30       	cpi	r19, 0x06	; 6
     898:	b8 f2       	brcs	.-82     	; 0x848 <parseGpsPart+0x17a>
			val += 10 + text[i] - 'A';
		}
		else if (text[i] >= 'a' && text[i] <= 'f') {
     89a:	32 2f       	mov	r19, r18
     89c:	31 56       	subi	r19, 0x61	; 97
     89e:	36 30       	cpi	r19, 0x06	; 6
     8a0:	68 f4       	brcc	.+26     	; 0x8bc <parseGpsPart+0x1ee>
			val += 10 + text[i] - 'a';
     8a2:	30 e0       	ldi	r19, 0x00	; 0
     8a4:	27 55       	subi	r18, 0x57	; 87
     8a6:	30 40       	sbci	r19, 0x00	; 0
     8a8:	a9 01       	movw	r20, r18
     8aa:	66 27       	eor	r22, r22
     8ac:	57 fd       	sbrc	r21, 7
     8ae:	60 95       	com	r22
     8b0:	76 2f       	mov	r23, r22
     8b2:	84 0f       	add	r24, r20
     8b4:	95 1f       	adc	r25, r21
     8b6:	a6 1f       	adc	r26, r22
     8b8:	b7 1f       	adc	r27, r23
     8ba:	d2 cf       	rjmp	.-92     	; 0x860 <parseGpsPart+0x192>
		}
		else if (text[i] >= '0' && text[i] <= '9') {
     8bc:	32 2f       	mov	r19, r18
     8be:	30 53       	subi	r19, 0x30	; 48
     8c0:	3a 30       	cpi	r19, 0x0A	; 10
     8c2:	70 f6       	brcc	.-100    	; 0x860 <parseGpsPart+0x192>
			val += text[i] - '0';
     8c4:	30 e0       	ldi	r19, 0x00	; 0
     8c6:	20 53       	subi	r18, 0x30	; 48
     8c8:	30 40       	sbci	r19, 0x00	; 0
     8ca:	a9 01       	movw	r20, r18
     8cc:	66 27       	eor	r22, r22
     8ce:	57 fd       	sbrc	r21, 7
     8d0:	60 95       	com	r22
     8d2:	76 2f       	mov	r23, r22
     8d4:	84 0f       	add	r24, r20
     8d6:	95 1f       	adc	r25, r21
     8d8:	a6 1f       	adc	r26, r22
     8da:	b7 1f       	adc	r27, r23
     8dc:	c1 cf       	rjmp	.-126    	; 0x860 <parseGpsPart+0x192>
				break;
			case GPS_PART_GPRMC_ANGLE:
				gGpsLastData.angle = parseInt(gGpsText, GPS_MAX_CHARS); // Only use int part
				break;
			case GPS_PART_GPRMC_DATE:
			  gGpsLastData.date = parseInt(gGpsText, GPS_MAX_CHARS);
     8de:	5e de       	rcall	.-836    	; 0x59c <parseInt.constprop.4>
     8e0:	dc 01       	movw	r26, r24
     8e2:	cb 01       	movw	r24, r22
     8e4:	80 93 8b 01 	sts	0x018B, r24
     8e8:	90 93 8c 01 	sts	0x018C, r25
     8ec:	a0 93 8d 01 	sts	0x018D, r26
     8f0:	b0 93 8e 01 	sts	0x018E, r27
     8f4:	08 95       	ret
				break;
			case GPS_PART_GPGGA_GEOID_HEIGHT_UNIT:
				// Geoid unit
				break;
			case GPS_PART_GPRMC_SPEED:
				gGpsLastData.speed = parseInt(gGpsText, GPS_MAX_CHARS); // Only use int part
     8f6:	52 de       	rcall	.-860    	; 0x59c <parseInt.constprop.4>
     8f8:	ab 01       	movw	r20, r22
     8fa:	bc 01       	movw	r22, r24
#ifdef METRIC_SYSTEM
#ifndef GOSDII_GPS_SPEED_BUGFIX
				// Convert to km/h. 1 knot = 1.852 km/h = 463/250
				gGpsLastData.speed *= 463; // Might need bigger var if you go really fast! :-)
     8fc:	2f ec       	ldi	r18, 0xCF	; 207
     8fe:	31 e0       	ldi	r19, 0x01	; 1
     900:	42 9f       	mul	r20, r18
     902:	c0 01       	movw	r24, r0
     904:	43 9f       	mul	r20, r19
     906:	90 0d       	add	r25, r0
     908:	52 9f       	mul	r21, r18
     90a:	90 0d       	add	r25, r0
     90c:	11 24       	eor	r1, r1
				gGpsLastData.speed /= 250;
     90e:	6a ef       	ldi	r22, 0xFA	; 250
     910:	70 e0       	ldi	r23, 0x00	; 0
     912:	a5 da       	rcall	.-2742   	; 0xfffffe5e <__eeprom_end+0xff7efc5e>
     914:	70 93 88 01 	sts	0x0188, r23
     918:	60 93 87 01 	sts	0x0187, r22
     91c:	08 95       	ret
		    kmphToMph(&gGpsLastData.speed);
#endif
#endif // METRIC_SYSTEM
				break;
			case GPS_PART_GPRMC_ANGLE:
				gGpsLastData.angle = parseInt(gGpsText, GPS_MAX_CHARS); // Only use int part
     91e:	3e de       	rcall	.-900    	; 0x59c <parseInt.constprop.4>
     920:	dc 01       	movw	r26, r24
     922:	cb 01       	movw	r24, r22
     924:	90 93 8a 01 	sts	0x018A, r25
     928:	80 93 89 01 	sts	0x0189, r24
     92c:	08 95       	ret
				break;
			case GPS_PART_GPRMC_STATUS:
				// Status
				break;
			case GPS_PART_GPGGA_SATS:
				gGpsLastData.sats = parseInt(gGpsText, GPS_MAX_CHARS);
     92e:	36 de       	rcall	.-916    	; 0x59c <parseInt.constprop.4>
     930:	dc 01       	movw	r26, r24
     932:	cb 01       	movw	r24, r22
     934:	80 93 86 01 	sts	0x0186, r24
     938:	08 95       	ret
					gGpsLastData.pos.longitude = -gGpsLastData.pos.longitude;
				}
				//updateParts();
				break;
			case GPS_PART_GPGGA_FIX:
				gGpsLastData.fix = parseInt(gGpsText, GPS_MAX_CHARS);
     93a:	30 de       	rcall	.-928    	; 0x59c <parseInt.constprop.4>
     93c:	dc 01       	movw	r26, r24
     93e:	cb 01       	movw	r24, r22
     940:	80 93 85 01 	sts	0x0185, r24
     944:	08 95       	ret
				gGpsLastData.pos.latitude = parseFloat(gGpsText, GPS_MAX_CHARS);
				//updateParts();
				break;
			case GPS_PART_GPGGA_LAT_UNIT:
			case GPS_PART_GPRMC_LAT_UNIT:
				if (gGpsText[0] == 'S') {
     946:	80 91 d2 03 	lds	r24, 0x03D2
     94a:	83 35       	cpi	r24, 0x53	; 83
     94c:	09 f0       	breq	.+2      	; 0x950 <parseGpsPart+0x282>
     94e:	f2 ce       	rjmp	.-540    	; 0x734 <parseGpsPart+0x66>
					gGpsLastData.pos.latitude = -gGpsLastData.pos.latitude;
     950:	80 91 77 01 	lds	r24, 0x0177
     954:	90 91 78 01 	lds	r25, 0x0178
     958:	a0 91 79 01 	lds	r26, 0x0179
     95c:	b0 91 7a 01 	lds	r27, 0x017A
     960:	b0 95       	com	r27
     962:	a0 95       	com	r26
     964:	90 95       	com	r25
     966:	81 95       	neg	r24
     968:	9f 4f       	sbci	r25, 0xFF	; 255
     96a:	af 4f       	sbci	r26, 0xFF	; 255
     96c:	bf 4f       	sbci	r27, 0xFF	; 255
     96e:	80 93 77 01 	sts	0x0177, r24
     972:	90 93 78 01 	sts	0x0178, r25
     976:	a0 93 79 01 	sts	0x0179, r26
     97a:	b0 93 7a 01 	sts	0x017A, r27
     97e:	08 95       	ret

00000980 <printAdc.constprop.7>:
		str[pos++] = '0';
	}	
	return printNumber(str, pos, gTime.sec);
}

static uint8_t printAdc(char* const str, uint8_t pos, const uint8_t adcInput) {
     980:	cf 92       	push	r12
     982:	df 92       	push	r13
     984:	ef 92       	push	r14
     986:	ff 92       	push	r15
     988:	cf 93       	push	r28
     98a:	df 93       	push	r29
     98c:	ec 01       	movw	r28, r24
	uint8_t low = gAnalogInputs[adcInput].low;
     98e:	e6 2f       	mov	r30, r22
     990:	f0 e0       	ldi	r31, 0x00	; 0
     992:	ee 0f       	add	r30, r30
     994:	ff 1f       	adc	r31, r31
     996:	ef 5c       	subi	r30, 0xCF	; 207
     998:	fb 4f       	sbci	r31, 0xFB	; 251
	uint8_t high = gAnalogInputs[adcInput].high;
	return printFloatNumberWithUnit(str, pos, low, high, "V");		
     99a:	c0 80       	ld	r12, Z
     99c:	dd 24       	eor	r13, r13
     99e:	ee 24       	eor	r14, r14
     9a0:	ff 24       	eor	r15, r15
     9a2:	21 81       	ldd	r18, Z+1	; 0x01
     9a4:	30 e0       	ldi	r19, 0x00	; 0
     9a6:	40 e0       	ldi	r20, 0x00	; 0
     9a8:	50 e0       	ldi	r21, 0x00	; 0
	myItoa(number, &str[pos]);
	return pos+length;
}

static uint8_t printFloatNumber(char* const str, uint8_t pos, int32_t numberLow, int32_t numberHigh) {
	pos = printNumber(str, pos, numberHigh);
     9aa:	64 e0       	ldi	r22, 0x04	; 4
     9ac:	22 dc       	rcall	.-1980   	; 0x1f2 <printNumber>
	str[pos++] = '.';
     9ae:	fe 01       	movw	r30, r28
     9b0:	e8 0f       	add	r30, r24
     9b2:	f1 1d       	adc	r31, r1
     9b4:	9e e2       	ldi	r25, 0x2E	; 46
     9b6:	90 83       	st	Z, r25
     9b8:	68 2f       	mov	r22, r24
     9ba:	6f 5f       	subi	r22, 0xFF	; 255
	if(numberLow < 10) {
     9bc:	9a e0       	ldi	r25, 0x0A	; 10
     9be:	c9 16       	cp	r12, r25
     9c0:	d1 04       	cpc	r13, r1
     9c2:	e1 04       	cpc	r14, r1
     9c4:	f1 04       	cpc	r15, r1
     9c6:	34 f4       	brge	.+12     	; 0x9d4 <printAdc.constprop.7+0x54>
		str[pos++] = '0';
     9c8:	fe 01       	movw	r30, r28
     9ca:	e6 0f       	add	r30, r22
     9cc:	f1 1d       	adc	r31, r1
     9ce:	90 e3       	ldi	r25, 0x30	; 48
     9d0:	90 83       	st	Z, r25
     9d2:	6f 5f       	subi	r22, 0xFF	; 255
	}
	return printNumber(str, pos, numberLow);
     9d4:	ce 01       	movw	r24, r28
     9d6:	a7 01       	movw	r20, r14
     9d8:	96 01       	movw	r18, r12
     9da:	0b dc       	rcall	.-2026   	; 0x1f2 <printNumber>
     9dc:	68 2f       	mov	r22, r24
	return printText(str, pos, unit);
}

static uint8_t printFloatNumberWithUnit(char* const str, uint8_t pos, int32_t numberLow, int32_t numberHigh, const char* unit) {
	pos = printFloatNumber(str, pos, numberLow, numberHigh);
	return printText(str, pos, unit);
     9de:	ce 01       	movw	r24, r28
     9e0:	42 e2       	ldi	r20, 0x22	; 34
     9e2:	51 e0       	ldi	r21, 0x01	; 1
     9e4:	b4 dc       	rcall	.-1688   	; 0x34e <printText>

static uint8_t printAdc(char* const str, uint8_t pos, const uint8_t adcInput) {
	uint8_t low = gAnalogInputs[adcInput].low;
	uint8_t high = gAnalogInputs[adcInput].high;
	return printFloatNumberWithUnit(str, pos, low, high, "V");		
}
     9e6:	df 91       	pop	r29
     9e8:	cf 91       	pop	r28
     9ea:	ff 90       	pop	r15
     9ec:	ef 90       	pop	r14
     9ee:	df 90       	pop	r13
     9f0:	cf 90       	pop	r12
     9f2:	08 95       	ret

000009f4 <setPixel.constprop.8>:
		}		
	}
}	

inline uint8_t validPos(uint8_t x, uint8_t y) {
	if (x >= GRAPHICS_WIDTH_REAL || y >= GRAPHICS_HEIGHT) {
     9f4:	88 31       	cpi	r24, 0x18	; 24
     9f6:	10 f4       	brcc	.+4      	; 0x9fc <setPixel.constprop.8+0x8>
     9f8:	68 31       	cpi	r22, 0x18	; 24
     9fa:	08 f0       	brcs	.+2      	; 0x9fe <setPixel.constprop.8+0xa>
     9fc:	08 95       	ret
static void setPixel(uint8_t x, uint8_t y, uint8_t state) {
	if (!validPos(x, y)) {
		return;
	}
	uint8_t bitPos = 7-(x%8);
	uint8_t temp = gPixelData[x/8][y];
     9fe:	48 2f       	mov	r20, r24
     a00:	46 95       	lsr	r20
     a02:	46 95       	lsr	r20
     a04:	46 95       	lsr	r20
     a06:	50 e0       	ldi	r21, 0x00	; 0

static void setPixel(uint8_t x, uint8_t y, uint8_t state) {
	if (!validPos(x, y)) {
		return;
	}
	uint8_t bitPos = 7-(x%8);
     a08:	80 95       	com	r24
     a0a:	87 70       	andi	r24, 0x07	; 7
	uint8_t temp = gPixelData[x/8][y];
	if (state == 0) {
		temp &= ~(1<<bitPos);
	}
	else if (state == 1) {
		temp |= (1<<bitPos);
     a0c:	21 e0       	ldi	r18, 0x01	; 1
     a0e:	30 e0       	ldi	r19, 0x00	; 0
     a10:	02 c0       	rjmp	.+4      	; 0xa16 <setPixel.constprop.8+0x22>
     a12:	22 0f       	add	r18, r18
     a14:	33 1f       	adc	r19, r19
     a16:	8a 95       	dec	r24
     a18:	e2 f7       	brpl	.-8      	; 0xa12 <setPixel.constprop.8+0x1e>
static void setPixel(uint8_t x, uint8_t y, uint8_t state) {
	if (!validPos(x, y)) {
		return;
	}
	uint8_t bitPos = 7-(x%8);
	uint8_t temp = gPixelData[x/8][y];
     a1a:	fa 01       	movw	r30, r20
     a1c:	ee 0f       	add	r30, r30
     a1e:	ff 1f       	adc	r31, r31
     a20:	e4 0f       	add	r30, r20
     a22:	f5 1f       	adc	r31, r21
     a24:	ee 0f       	add	r30, r30
     a26:	ff 1f       	adc	r31, r31
     a28:	ee 0f       	add	r30, r30
     a2a:	ff 1f       	adc	r31, r31
     a2c:	ee 0f       	add	r30, r30
     a2e:	ff 1f       	adc	r31, r31
     a30:	e6 0f       	add	r30, r22
     a32:	f1 1d       	adc	r31, r1
     a34:	ef 51       	subi	r30, 0x1F	; 31
     a36:	fc 4f       	sbci	r31, 0xFC	; 252
	if (state == 0) {
		temp &= ~(1<<bitPos);
	}
	else if (state == 1) {
		temp |= (1<<bitPos);
     a38:	80 81       	ld	r24, Z
     a3a:	82 2b       	or	r24, r18
	}
	else {
		temp ^= (1<<bitPos);
	}
	gPixelData[x/8][y] = temp;
     a3c:	80 83       	st	Z, r24
     a3e:	08 95       	ret

00000a40 <drawLine>:
	uint8_t temp = *a;
	*a = *b;
	*b = temp;
}

static void drawLine(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
     a40:	cf 92       	push	r12
     a42:	df 92       	push	r13
     a44:	ef 92       	push	r14
     a46:	ff 92       	push	r15
     a48:	0f 93       	push	r16
     a4a:	1f 93       	push	r17
     a4c:	cf 93       	push	r28
     a4e:	df 93       	push	r29
     a50:	98 2f       	mov	r25, r24
     a52:	c4 2f       	mov	r28, r20
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
     a54:	02 2f       	mov	r16, r18
     a56:	10 e0       	ldi	r17, 0x00	; 0
     a58:	e6 2e       	mov	r14, r22
     a5a:	ff 24       	eor	r15, r15
     a5c:	c4 2e       	mov	r12, r20
     a5e:	dd 24       	eor	r13, r13
     a60:	a8 2f       	mov	r26, r24
     a62:	b0 e0       	ldi	r27, 0x00	; 0
     a64:	a8 01       	movw	r20, r16
     a66:	4e 19       	sub	r20, r14
     a68:	5f 09       	sbc	r21, r15
     a6a:	57 fd       	sbrc	r21, 7
     a6c:	5a c0       	rjmp	.+180    	; 0xb22 <drawLine+0xe2>
     a6e:	f6 01       	movw	r30, r12
     a70:	ea 1b       	sub	r30, r26
     a72:	fb 0b       	sbc	r31, r27
     a74:	f7 fd       	sbrc	r31, 7
     a76:	5d c0       	rjmp	.+186    	; 0xb32 <drawLine+0xf2>
     a78:	d1 e0       	ldi	r29, 0x01	; 1
     a7a:	e4 17       	cp	r30, r20
     a7c:	f5 07       	cpc	r31, r21
     a7e:	ec f1       	brlt	.+122    	; 0xafa <drawLine+0xba>
     a80:	d0 e0       	ldi	r29, 0x00	; 0
	if (steep) {
     a82:	68 01       	movw	r12, r16
     a84:	d7 01       	movw	r26, r14
		swap(&x0, &y0);
		swap(&x1, &y1);
	}		 
	if (x0 > x1) {
     a86:	c9 17       	cp	r28, r25
     a88:	08 f4       	brcc	.+2      	; 0xa8c <drawLine+0x4c>
     a8a:	3f c0       	rjmp	.+126    	; 0xb0a <drawLine+0xca>
     a8c:	ad 01       	movw	r20, r26
     a8e:	d6 01       	movw	r26, r12
     a90:	6a 01       	movw	r12, r20
	int8_t deltax = x1 - x0;
	int8_t deltay = abs(y1 - y0);
	int8_t error = deltax / 2;
	int8_t ystep;
	int8_t y = y0;
	if (y0 < y1) { 
     a92:	62 17       	cp	r22, r18
     a94:	08 f4       	brcc	.+2      	; 0xa98 <drawLine+0x58>
     a96:	42 c0       	rjmp	.+132    	; 0xb1c <drawLine+0xdc>
		ystep = 1; 
	}
	else {
		ystep = -1;
     a98:	ee 24       	eor	r14, r14
     a9a:	ea 94       	dec	r14
	}		
	for (uint8_t x = x0; x <= x1; ++x) {
     a9c:	c9 17       	cp	r28, r25
     a9e:	20 f1       	brcs	.+72     	; 0xae8 <drawLine+0xa8>
	}		 
	if (x0 > x1) {
		swap(&x0, &x1);
		swap(&y0, &y1);
	}		 
	int8_t deltax = x1 - x0;
     aa0:	fc 2e       	mov	r15, r28
     aa2:	f9 1a       	sub	r15, r25
	int8_t deltay = abs(y1 - y0);
	int8_t error = deltax / 2;
     aa4:	1f 2d       	mov	r17, r15
     aa6:	f7 fc       	sbrc	r15, 7
     aa8:	4c c0       	rjmp	.+152    	; 0xb42 <drawLine+0x102>
     aaa:	15 95       	asr	r17
	int8_t ystep;
	int8_t y = y0;
     aac:	06 2f       	mov	r16, r22
	if (x0 > x1) {
		swap(&x0, &x1);
		swap(&y0, &y1);
	}		 
	int8_t deltax = x1 - x0;
	int8_t deltay = abs(y1 - y0);
     aae:	ac 19       	sub	r26, r12
     ab0:	bd 09       	sbc	r27, r13
     ab2:	b7 fd       	sbrc	r27, 7
     ab4:	42 c0       	rjmp	.+132    	; 0xb3a <drawLine+0xfa>
     ab6:	da 2e       	mov	r13, r26
     ab8:	c9 2e       	mov	r12, r25
     aba:	09 c0       	rjmp	.+18     	; 0xace <drawLine+0x8e>
	else {
		ystep = -1;
	}		
	for (uint8_t x = x0; x <= x1; ++x) {
		if (steep) {
			setPixel(y, x, 1);
     abc:	80 2f       	mov	r24, r16
     abe:	6c 2d       	mov	r22, r12
     ac0:	99 df       	rcall	.-206    	; 0x9f4 <setPixel.constprop.8>
		}
		else { 
			setPixel(x, y, 1);
		}			
		error = error - deltay;
     ac2:	1d 19       	sub	r17, r13
		if (error < 0) {
     ac4:	17 fd       	sbrc	r17, 7
     ac6:	0b c0       	rjmp	.+22     	; 0xade <drawLine+0x9e>
		ystep = 1; 
	}
	else {
		ystep = -1;
	}		
	for (uint8_t x = x0; x <= x1; ++x) {
     ac8:	c3 94       	inc	r12
     aca:	cc 15       	cp	r28, r12
     acc:	68 f0       	brcs	.+26     	; 0xae8 <drawLine+0xa8>
		if (steep) {
     ace:	dd 23       	and	r29, r29
     ad0:	a9 f7       	brne	.-22     	; 0xabc <drawLine+0x7c>
			setPixel(y, x, 1);
		}
		else { 
			setPixel(x, y, 1);
     ad2:	8c 2d       	mov	r24, r12
     ad4:	60 2f       	mov	r22, r16
     ad6:	8e df       	rcall	.-228    	; 0x9f4 <setPixel.constprop.8>
		}			
		error = error - deltay;
     ad8:	1d 19       	sub	r17, r13
		if (error < 0) {
     ada:	17 ff       	sbrs	r17, 7
     adc:	f5 cf       	rjmp	.-22     	; 0xac8 <drawLine+0x88>
			y = y + ystep;
     ade:	0e 0d       	add	r16, r14
			error = error + deltax;
     ae0:	1f 0d       	add	r17, r15
		ystep = 1; 
	}
	else {
		ystep = -1;
	}		
	for (uint8_t x = x0; x <= x1; ++x) {
     ae2:	c3 94       	inc	r12
     ae4:	cc 15       	cp	r28, r12
     ae6:	98 f7       	brcc	.-26     	; 0xace <drawLine+0x8e>
		if (error < 0) {
			y = y + ystep;
			error = error + deltax;
		}
	}				 
}
     ae8:	df 91       	pop	r29
     aea:	cf 91       	pop	r28
     aec:	1f 91       	pop	r17
     aee:	0f 91       	pop	r16
     af0:	ff 90       	pop	r15
     af2:	ef 90       	pop	r14
     af4:	df 90       	pop	r13
     af6:	cf 90       	pop	r12
     af8:	08 95       	ret
	*b = temp;
}

static void drawLine(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep) {
     afa:	8c 2f       	mov	r24, r28
  }
}

static void swap(uint8_t* a, uint8_t* b) {
	uint8_t temp = *a;
	*a = *b;
     afc:	c2 2f       	mov	r28, r18
	*b = temp;
     afe:	28 2f       	mov	r18, r24
}

static void drawLine(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep) {
     b00:	89 2f       	mov	r24, r25
  }
}

static void swap(uint8_t* a, uint8_t* b) {
	uint8_t temp = *a;
	*a = *b;
     b02:	96 2f       	mov	r25, r22
	*b = temp;
     b04:	68 2f       	mov	r22, r24
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep) {
		swap(&x0, &y0);
		swap(&x1, &y1);
	}		 
	if (x0 > x1) {
     b06:	c9 17       	cp	r28, r25
     b08:	08 f6       	brcc	.-126    	; 0xa8c <drawLine+0x4c>
     b0a:	86 2f       	mov	r24, r22
  }
}

static void swap(uint8_t* a, uint8_t* b) {
	uint8_t temp = *a;
	*a = *b;
     b0c:	62 2f       	mov	r22, r18
	*b = temp;
     b0e:	28 2f       	mov	r18, r24
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep) {
		swap(&x0, &y0);
		swap(&x1, &y1);
	}		 
	if (x0 > x1) {
     b10:	89 2f       	mov	r24, r25
     b12:	9c 2f       	mov	r25, r28
     b14:	c8 2f       	mov	r28, r24
	int8_t deltax = x1 - x0;
	int8_t deltay = abs(y1 - y0);
	int8_t error = deltax / 2;
	int8_t ystep;
	int8_t y = y0;
	if (y0 < y1) { 
     b16:	62 17       	cp	r22, r18
     b18:	08 f0       	brcs	.+2      	; 0xb1c <drawLine+0xdc>
     b1a:	be cf       	rjmp	.-132    	; 0xa98 <drawLine+0x58>
		ystep = 1; 
     b1c:	ee 24       	eor	r14, r14
     b1e:	e3 94       	inc	r14
     b20:	bd cf       	rjmp	.-134    	; 0xa9c <drawLine+0x5c>
	*a = *b;
	*b = temp;
}

static void drawLine(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
     b22:	50 95       	com	r21
     b24:	41 95       	neg	r20
     b26:	5f 4f       	sbci	r21, 0xFF	; 255
     b28:	f6 01       	movw	r30, r12
     b2a:	ea 1b       	sub	r30, r26
     b2c:	fb 0b       	sbc	r31, r27
     b2e:	f7 ff       	sbrs	r31, 7
     b30:	a3 cf       	rjmp	.-186    	; 0xa78 <drawLine+0x38>
     b32:	f0 95       	com	r31
     b34:	e1 95       	neg	r30
     b36:	ff 4f       	sbci	r31, 0xFF	; 255
     b38:	9f cf       	rjmp	.-194    	; 0xa78 <drawLine+0x38>
	if (x0 > x1) {
		swap(&x0, &x1);
		swap(&y0, &y1);
	}		 
	int8_t deltax = x1 - x0;
	int8_t deltay = abs(y1 - y0);
     b3a:	b0 95       	com	r27
     b3c:	a1 95       	neg	r26
     b3e:	bf 4f       	sbci	r27, 0xFF	; 255
     b40:	ba cf       	rjmp	.-140    	; 0xab6 <drawLine+0x76>
	int8_t error = deltax / 2;
     b42:	1f 5f       	subi	r17, 0xFF	; 255
     b44:	b2 cf       	rjmp	.-156    	; 0xaaa <drawLine+0x6a>

00000b46 <drawCircle.constprop.9>:
	gPixelData[x/8][y] = temp;
}

// Credit for this one goes to wikipedia! :-)
// Some mods done by me ( name, int -> uint8 )
static void drawCircle(uint8_t x0, uint8_t y0, uint8_t radius) {
     b46:	ff 92       	push	r15
     b48:	0f 93       	push	r16
     b4a:	1f 93       	push	r17
     b4c:	cf 93       	push	r28
     b4e:	df 93       	push	r29
     b50:	00 d0       	rcall	.+0      	; 0xb52 <drawCircle.constprop.9+0xc>
     b52:	00 d0       	rcall	.+0      	; 0xb54 <drawCircle.constprop.9+0xe>
     b54:	0f 92       	push	r0
     b56:	cd b7       	in	r28, 0x3d	; 61
     b58:	de b7       	in	r29, 0x3e	; 62
     b5a:	18 2f       	mov	r17, r24
  volatile int8_t f = 1 - radius;
     b5c:	81 e0       	ldi	r24, 0x01	; 1
     b5e:	98 2f       	mov	r25, r24
     b60:	91 1b       	sub	r25, r17
     b62:	9d 83       	std	Y+5, r25	; 0x05
  volatile int8_t ddF_x = 1;
     b64:	8c 83       	std	Y+4, r24	; 0x04
  volatile int8_t ddF_y = -2 * radius;
     b66:	81 2f       	mov	r24, r17
     b68:	81 95       	neg	r24
     b6a:	88 0f       	add	r24, r24
     b6c:	8b 83       	std	Y+3, r24	; 0x03
  volatile int8_t x = 0;
     b6e:	1a 82       	std	Y+2, r1	; 0x02
  volatile int8_t y = radius;
     b70:	19 83       	std	Y+1, r17	; 0x01
 
  setPixel(x0, y0 + radius, 1);
     b72:	bb e0       	ldi	r27, 0x0B	; 11
     b74:	fb 2e       	mov	r15, r27
     b76:	f1 0e       	add	r15, r17
     b78:	8b e0       	ldi	r24, 0x0B	; 11
     b7a:	6f 2d       	mov	r22, r15
     b7c:	3b df       	rcall	.-394    	; 0x9f4 <setPixel.constprop.8>
  setPixel(x0, y0 - radius, 1);
     b7e:	0b e0       	ldi	r16, 0x0B	; 11
     b80:	01 1b       	sub	r16, r17
     b82:	8b e0       	ldi	r24, 0x0B	; 11
     b84:	60 2f       	mov	r22, r16
     b86:	36 df       	rcall	.-404    	; 0x9f4 <setPixel.constprop.8>
  setPixel(x0 + radius, y0, 1);
     b88:	8f 2d       	mov	r24, r15
     b8a:	6b e0       	ldi	r22, 0x0B	; 11
     b8c:	33 df       	rcall	.-410    	; 0x9f4 <setPixel.constprop.8>
  setPixel(x0 - radius, y0, 1);
     b8e:	80 2f       	mov	r24, r16
     b90:	6b e0       	ldi	r22, 0x0B	; 11
     b92:	30 df       	rcall	.-416    	; 0x9f4 <setPixel.constprop.8>
 
  while(x < y) {
     b94:	9a 81       	ldd	r25, Y+2	; 0x02
     b96:	89 81       	ldd	r24, Y+1	; 0x01
     b98:	98 17       	cp	r25, r24
     b9a:	0c f0       	brlt	.+2      	; 0xb9e <drawCircle.constprop.9+0x58>
     b9c:	51 c0       	rjmp	.+162    	; 0xc40 <drawCircle.constprop.9+0xfa>
    }
    x++;
    ddF_x += 2;
    f += ddF_x;    
    setPixel(x0 + x, y0 + y, 1);
    setPixel(x0 - x, y0 + y, 1);
     b9e:	1b e0       	ldi	r17, 0x0B	; 11
 
  while(x < y) {
    // ddF_x == 2 * x + 1;
    // ddF_y == -2 * y;
    // f == x*x + y*y - radius*radius + 2*x - y + 1;
    if(f >= 0) {
     ba0:	8d 81       	ldd	r24, Y+5	; 0x05
     ba2:	87 fd       	sbrc	r24, 7
     ba4:	0a c0       	rjmp	.+20     	; 0xbba <drawCircle.constprop.9+0x74>
      y--;
     ba6:	89 81       	ldd	r24, Y+1	; 0x01
     ba8:	81 50       	subi	r24, 0x01	; 1
     baa:	89 83       	std	Y+1, r24	; 0x01
      ddF_y += 2;
     bac:	8b 81       	ldd	r24, Y+3	; 0x03
     bae:	8e 5f       	subi	r24, 0xFE	; 254
     bb0:	8b 83       	std	Y+3, r24	; 0x03
      f += ddF_y;
     bb2:	9d 81       	ldd	r25, Y+5	; 0x05
     bb4:	8b 81       	ldd	r24, Y+3	; 0x03
     bb6:	89 0f       	add	r24, r25
     bb8:	8d 83       	std	Y+5, r24	; 0x05
    }
    x++;
     bba:	8a 81       	ldd	r24, Y+2	; 0x02
     bbc:	8f 5f       	subi	r24, 0xFF	; 255
     bbe:	8a 83       	std	Y+2, r24	; 0x02
    ddF_x += 2;
     bc0:	8c 81       	ldd	r24, Y+4	; 0x04
     bc2:	8e 5f       	subi	r24, 0xFE	; 254
     bc4:	8c 83       	std	Y+4, r24	; 0x04
    f += ddF_x;    
     bc6:	9d 81       	ldd	r25, Y+5	; 0x05
     bc8:	8c 81       	ldd	r24, Y+4	; 0x04
     bca:	89 0f       	add	r24, r25
     bcc:	8d 83       	std	Y+5, r24	; 0x05
    setPixel(x0 + x, y0 + y, 1);
     bce:	8a 81       	ldd	r24, Y+2	; 0x02
     bd0:	69 81       	ldd	r22, Y+1	; 0x01
     bd2:	65 5f       	subi	r22, 0xF5	; 245
     bd4:	85 5f       	subi	r24, 0xF5	; 245
     bd6:	0e df       	rcall	.-484    	; 0x9f4 <setPixel.constprop.8>
    setPixel(x0 - x, y0 + y, 1);
     bd8:	8a 81       	ldd	r24, Y+2	; 0x02
     bda:	69 81       	ldd	r22, Y+1	; 0x01
     bdc:	65 5f       	subi	r22, 0xF5	; 245
     bde:	91 2f       	mov	r25, r17
     be0:	98 1b       	sub	r25, r24
     be2:	89 2f       	mov	r24, r25
     be4:	07 df       	rcall	.-498    	; 0x9f4 <setPixel.constprop.8>
    setPixel(x0 + x, y0 - y, 1);
     be6:	8a 81       	ldd	r24, Y+2	; 0x02
     be8:	99 81       	ldd	r25, Y+1	; 0x01
     bea:	61 2f       	mov	r22, r17
     bec:	69 1b       	sub	r22, r25
     bee:	85 5f       	subi	r24, 0xF5	; 245
     bf0:	01 df       	rcall	.-510    	; 0x9f4 <setPixel.constprop.8>
    setPixel(x0 - x, y0 - y, 1);
     bf2:	8a 81       	ldd	r24, Y+2	; 0x02
     bf4:	99 81       	ldd	r25, Y+1	; 0x01
     bf6:	61 2f       	mov	r22, r17
     bf8:	69 1b       	sub	r22, r25
     bfa:	91 2f       	mov	r25, r17
     bfc:	98 1b       	sub	r25, r24
     bfe:	89 2f       	mov	r24, r25
     c00:	f9 de       	rcall	.-526    	; 0x9f4 <setPixel.constprop.8>
    setPixel(x0 + y, y0 + x, 1);
     c02:	89 81       	ldd	r24, Y+1	; 0x01
     c04:	6a 81       	ldd	r22, Y+2	; 0x02
     c06:	65 5f       	subi	r22, 0xF5	; 245
     c08:	85 5f       	subi	r24, 0xF5	; 245
     c0a:	f4 de       	rcall	.-536    	; 0x9f4 <setPixel.constprop.8>
    setPixel(x0 - y, y0 + x, 1);
     c0c:	89 81       	ldd	r24, Y+1	; 0x01
     c0e:	6a 81       	ldd	r22, Y+2	; 0x02
     c10:	65 5f       	subi	r22, 0xF5	; 245
     c12:	91 2f       	mov	r25, r17
     c14:	98 1b       	sub	r25, r24
     c16:	89 2f       	mov	r24, r25
     c18:	ed de       	rcall	.-550    	; 0x9f4 <setPixel.constprop.8>
    setPixel(x0 + y, y0 - x, 1);
     c1a:	89 81       	ldd	r24, Y+1	; 0x01
     c1c:	9a 81       	ldd	r25, Y+2	; 0x02
     c1e:	61 2f       	mov	r22, r17
     c20:	69 1b       	sub	r22, r25
     c22:	85 5f       	subi	r24, 0xF5	; 245
     c24:	e7 de       	rcall	.-562    	; 0x9f4 <setPixel.constprop.8>
    setPixel(x0 - y, y0 - x, 1);
     c26:	89 81       	ldd	r24, Y+1	; 0x01
     c28:	9a 81       	ldd	r25, Y+2	; 0x02
     c2a:	61 2f       	mov	r22, r17
     c2c:	69 1b       	sub	r22, r25
     c2e:	91 2f       	mov	r25, r17
     c30:	98 1b       	sub	r25, r24
     c32:	89 2f       	mov	r24, r25
     c34:	df de       	rcall	.-578    	; 0x9f4 <setPixel.constprop.8>
  setPixel(x0, y0 + radius, 1);
  setPixel(x0, y0 - radius, 1);
  setPixel(x0 + radius, y0, 1);
  setPixel(x0 - radius, y0, 1);
 
  while(x < y) {
     c36:	9a 81       	ldd	r25, Y+2	; 0x02
     c38:	89 81       	ldd	r24, Y+1	; 0x01
     c3a:	98 17       	cp	r25, r24
     c3c:	0c f4       	brge	.+2      	; 0xc40 <drawCircle.constprop.9+0xfa>
     c3e:	b0 cf       	rjmp	.-160    	; 0xba0 <drawCircle.constprop.9+0x5a>
    setPixel(x0 + y, y0 + x, 1);
    setPixel(x0 - y, y0 + x, 1);
    setPixel(x0 + y, y0 - x, 1);
    setPixel(x0 - y, y0 - x, 1);
  }
}
     c40:	0f 90       	pop	r0
     c42:	0f 90       	pop	r0
     c44:	0f 90       	pop	r0
     c46:	0f 90       	pop	r0
     c48:	0f 90       	pop	r0
     c4a:	df 91       	pop	r29
     c4c:	cf 91       	pop	r28
     c4e:	1f 91       	pop	r17
     c50:	0f 91       	pop	r16
     c52:	ff 90       	pop	r15
     c54:	08 95       	ret

00000c56 <main>:
#endif //GRAPICSENABLED
}

void main(void) __attribute__ ((noreturn)); // Main never returns, saves a few bytes

void main(void) {
     c56:	cf 93       	push	r28
     c58:	df 93       	push	r29
     c5a:	cd b7       	in	r28, 0x3d	; 61
     c5c:	de b7       	in	r29, 0x3e	; 62
     c5e:	67 97       	sbiw	r28, 0x17	; 23
     c60:	0f b6       	in	r0, 0x3f	; 63
     c62:	f8 94       	cli
     c64:	de bf       	out	0x3e, r29	; 62
     c66:	0f be       	out	0x3f, r0	; 63
     c68:	cd bf       	out	0x3d, r28	; 61
static uint8_t gKeyPressTime = 0;

static void setup(void)
{
	// Port setup
	PORTD = KEY; //key pullup & led off
     c6a:	20 e1       	ldi	r18, 0x10	; 16
     c6c:	2b b9       	out	0x0b, r18	; 11
	DDRD  = LED; // led output
     c6e:	88 e0       	ldi	r24, 0x08	; 8
     c70:	8a b9       	out	0x0a, r24	; 10
	PORTB &= ~OUT1;
     c72:	29 98       	cbi	0x05, 1	; 5
	DDRB  = OUT2 | SS;
     c74:	8c e0       	ldi	r24, 0x0C	; 12
     c76:	84 b9       	out	0x04, r24	; 4
	
	TIMSK1 |= (1 << TOIE1); // Enable overflow interrupt
     c78:	80 91 6f 00 	lds	r24, 0x006F
     c7c:	81 60       	ori	r24, 0x01	; 1
     c7e:	80 93 6f 00 	sts	0x006F, r24
	TCCR1B |= (1 << CS11); // Start timer at Fcpu/8
     c82:	80 91 81 00 	lds	r24, 0x0081
     c86:	82 60       	ori	r24, 0x02	; 2
     c88:	80 93 81 00 	sts	0x0081, r24
static uint16_t gActiveTextLastLine = 2;
static uint8_t gLineType = LINE_TYPE_UNKNOWN;

static void setupLine() {
  // Line trigger
	EICRA = (1<<ISC00) | (1<<ISC01); //set INT0 as rising edge trigger
     c8c:	83 e0       	ldi	r24, 0x03	; 3
     c8e:	80 93 69 00 	sts	0x0069, r24
	EIMSK = (1<<INT0); //enable INTO in global interrupt mask
     c92:	31 e0       	ldi	r19, 0x01	; 1
     c94:	3d bb       	out	0x1d, r19	; 29
	ACSR = (1<<ACD); //Comparator disabled
     c96:	80 e8       	ldi	r24, 0x80	; 128
     c98:	80 bf       	out	0x30, r24	; 48
	ADCSRB = 0x00;
     c9a:	10 92 7b 00 	sts	0x007B, r1

	// SPI setup
	SPDR = 0x00; // Clear spi reg or thrash will show on video
     c9e:	1e bc       	out	0x2e, r1	; 46
#ifdef TEXT_SMALL_ENABLED
	SPSR |= (1<<SPI2X); // Set dual speed
#else
	SPSR &= ~(1<<SPI2X); // Clear dual speed
     ca0:	8d b5       	in	r24, 0x2d	; 45
     ca2:	8e 7f       	andi	r24, 0xFE	; 254
     ca4:	8d bd       	out	0x2d, r24	; 45
#endif //TEXT_SMALL_ENABLED
	SPCR = (1<<SPE) | (1<<MSTR) | (1<<CPHA);
     ca6:	84 e5       	ldi	r24, 0x54	; 84
     ca8:	8c bd       	out	0x2c, r24	; 44
	
#ifdef TEXT_ENABLED
	gActiveTextLine = gTextLines[gActiveTextId];
     caa:	e0 91 b4 01 	lds	r30, 0x01B4
     cae:	f0 e0       	ldi	r31, 0x00	; 0
     cb0:	ee 0f       	add	r30, r30
     cb2:	ff 1f       	adc	r31, r31
     cb4:	ef 5a       	subi	r30, 0xAF	; 175
     cb6:	fe 4f       	sbci	r31, 0xFE	; 254
     cb8:	80 81       	ld	r24, Z
     cba:	91 81       	ldd	r25, Z+1	; 0x01
     cbc:	90 93 ce 03 	sts	0x03CE, r25
     cc0:	80 93 cd 03 	sts	0x03CD, r24

#ifdef ADC_ENABLED

static void setupAdc() {
  // ADC setup
	DIDR0 = 0x00;
     cc4:	10 92 7e 00 	sts	0x007E, r1
	ADMUX |= (1<<REFS0); // Ref is AVCC
     cc8:	80 91 7c 00 	lds	r24, 0x007C
     ccc:	80 64       	ori	r24, 0x40	; 64
     cce:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA |= (1<<ADPS2) | (1<<ADPS1); // | (1<<ADPS0); 
     cd2:	80 91 7a 00 	lds	r24, 0x007A
     cd6:	86 60       	ori	r24, 0x06	; 6
     cd8:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // Free running
     cdc:	10 92 7b 00 	sts	0x007B, r1
static TGpsData gGpsLastData = {};
static TTime gLastFix = {};

static void setupGps() {
	// USART setup
	UBRR0H = (uint8_t)(GPS_UBRR>>8); // set baud
     ce0:	30 93 c5 00 	sts	0x00C5, r19
	UBRR0L = (uint8_t)GPS_UBRR;
     ce4:	87 e3       	ldi	r24, 0x37	; 55
     ce6:	80 93 c4 00 	sts	0x00C4, r24
	UCSR0C = (3<<UCSZ00); // 8N1
     cea:	86 e0       	ldi	r24, 0x06	; 6
     cec:	80 93 c2 00 	sts	0x00C2, r24
	UCSR0B = (1<<RXEN0); // Enable RX
     cf0:	20 93 c1 00 	sts	0x00C1, r18

#ifdef GPS_ENABLED
	setupGps();
#endif //GPS_ENABLED
	
	sei();
     cf4:	78 94       	sei
     cf6:	6d eb       	ldi	r22, 0xBD	; 189
     cf8:	66 2e       	mov	r6, r22
     cfa:	62 e0       	ldi	r22, 0x02	; 2
     cfc:	76 2e       	mov	r7, r22
	setup();

	while(1) {
    
#ifdef GPS_ENABLED
    if(UCSR0A & (1<<RXC0)) {
     cfe:	80 91 c0 00 	lds	r24, 0x00C0
     d02:	87 fd       	sbrc	r24, 7
     d04:	11 c1       	rjmp	.+546    	; 0xf28 <main+0x2d2>
      decodeGpsData(UDR0);
    }
#endif //GPS_ENABLED
    
#ifndef DEBUG
		if((PIND & KEY) != KEY) {
     d06:	4c 99       	sbic	0x09, 4	; 9
     d08:	92 c0       	rjmp	.+292    	; 0xe2e <main+0x1d8>
			gKeyPressed = 1;
     d0a:	81 e0       	ldi	r24, 0x01	; 1
     d0c:	80 93 75 01 	sts	0x0175, r24
			if(gKeyPressTime > 50) {
     d10:	80 91 76 01 	lds	r24, 0x0176
     d14:	83 33       	cpi	r24, 0x33	; 51
     d16:	e8 f0       	brcs	.+58     	; 0xd52 <main+0xfc>
				gKeyPressTime = 0;
     d18:	10 92 76 01 	sts	0x0176, r1
				PORTD |= LED; // long press!
     d1c:	5b 9a       	sbi	0x0b, 3	; 11
#ifdef GPS_ENABLED
#ifdef HOME_SET_WITH_BUTTON
      if (gGpsLastData.checksumValid != 0 && gGpsLastData.fix != 0) { // (Improved thanks to Yury Smirnov)
     d1e:	80 91 8f 01 	lds	r24, 0x018F
     d22:	88 23       	and	r24, r24
     d24:	b1 f0       	breq	.+44     	; 0xd52 <main+0xfc>
     d26:	80 91 85 01 	lds	r24, 0x0185
     d2a:	88 23       	and	r24, r24
     d2c:	91 f0       	breq	.+36     	; 0xd52 <main+0xfc>
}

static void setHomePos() {

	gHomePos = gGpsLastValidData.pos;
     d2e:	a0 e9       	ldi	r26, 0x90	; 144
     d30:	b1 e0       	ldi	r27, 0x01	; 1
     d32:	ea e9       	ldi	r30, 0x9A	; 154
     d34:	f1 e0       	ldi	r31, 0x01	; 1
     d36:	8a e0       	ldi	r24, 0x0A	; 10
     d38:	01 90       	ld	r0, Z+
     d3a:	0d 92       	st	X+, r0
     d3c:	81 50       	subi	r24, 0x01	; 1
     d3e:	e1 f7       	brne	.-8      	; 0xd38 <main+0xe2>
	gHomePosSet = 1;
     d40:	81 e0       	ldi	r24, 0x01	; 1
     d42:	80 93 b3 01 	sts	0x01B3, r24
	}
#endif //TIME_HOUR_ENABLED
}

static void resetTime() {
	gTimeTick = 0;
     d46:	10 92 74 01 	sts	0x0174, r1
	gTime.sec = 0;
     d4a:	10 92 72 01 	sts	0x0172, r1
	gTime.min = 0;
     d4e:	10 92 73 01 	sts	0x0173, r1
#ifdef DEBUG
		gUpdateScreenData = 2;
#endif //DEBUG

#ifdef TEXT_ENABLED
    if (gUpdateScreenData == 2) {
     d52:	80 91 70 01 	lds	r24, 0x0170
     d56:	82 30       	cpi	r24, 0x02	; 2
     d58:	09 f4       	brne	.+2      	; 0xd5c <main+0x106>
     d5a:	76 c0       	rjmp	.+236    	; 0xe48 <main+0x1f2>
      //DDRB |= OUT1;
      updateTextCharStartPos(gActiveTextId);
	    updateTextPixmap(gActiveTextId);
		  //DDRB &= ~OUT1;
	  }
	  else if (gUpdateScreenData == 1) {
     d5c:	80 91 70 01 	lds	r24, 0x0170
     d60:	81 30       	cpi	r24, 0x01	; 1
     d62:	69 f6       	brne	.-102    	; 0xcfe <main+0xa8>
#else
    if (gUpdateScreenData == 1) {
#endif //TEXTENABLED
			gUpdateScreenData = 0;
     d64:	10 92 70 01 	sts	0x0170, r1
#endif // ALARM_ENABLED

}  

static void updateOnceEveryFrame() {
  if (gKeyPressed) {
     d68:	80 91 75 01 	lds	r24, 0x0175
     d6c:	88 23       	and	r24, r24
     d6e:	29 f0       	breq	.+10     	; 0xd7a <main+0x124>
		++gKeyPressTime;
     d70:	80 91 76 01 	lds	r24, 0x0176
     d74:	8f 5f       	subi	r24, 0xFF	; 255
     d76:	80 93 76 01 	sts	0x0176, r24
	}

	if ((gTimeTick%(TIME_FRAMES_PER_SEC/SCREEN_AND_SENSOR_UPDATES_PER_SEC) == 0)) {
     d7a:	80 91 74 01 	lds	r24, 0x0174
     d7e:	69 e1       	ldi	r22, 0x19	; 25
     d80:	62 d8       	rcall	.-3900   	; 0xfffffe46 <__eeprom_end+0xff7efc46>
     d82:	99 23       	and	r25, r25
     d84:	09 f4       	brne	.+2      	; 0xd88 <main+0x132>
     d86:	96 c2       	rjmp	.+1324   	; 0x12b4 <main+0x65e>
static volatile uint8_t gBlink1Hz = 0;

#ifdef TIME_ENABLED

static void updateTime() {
	++gTimeTick;
     d88:	80 91 74 01 	lds	r24, 0x0174
     d8c:	8f 5f       	subi	r24, 0xFF	; 255
     d8e:	80 93 74 01 	sts	0x0174, r24
	if (gTimeTick >= TIME_FRAMES_PER_SEC) {
     d92:	80 91 74 01 	lds	r24, 0x0174
     d96:	82 33       	cpi	r24, 0x32	; 50
     d98:	78 f0       	brcs	.+30     	; 0xdb8 <main+0x162>
		gTimeTick = 0;
     d9a:	10 92 74 01 	sts	0x0174, r1
		gTime.sec++;
     d9e:	80 91 72 01 	lds	r24, 0x0172
     da2:	8f 5f       	subi	r24, 0xFF	; 255
     da4:	80 93 72 01 	sts	0x0172, r24
		gBlink1Hz = (gBlink1Hz+1)%2;
     da8:	80 91 71 01 	lds	r24, 0x0171
     dac:	90 e0       	ldi	r25, 0x00	; 0
     dae:	01 96       	adiw	r24, 0x01	; 1
     db0:	81 70       	andi	r24, 0x01	; 1
     db2:	90 70       	andi	r25, 0x00	; 0
     db4:	80 93 71 01 	sts	0x0171, r24
	}
	if (gTime.sec >= 60) {
     db8:	80 91 72 01 	lds	r24, 0x0172
     dbc:	8c 33       	cpi	r24, 0x3C	; 60
     dbe:	38 f0       	brcs	.+14     	; 0xdce <main+0x178>
		gTime.sec = 0;
     dc0:	10 92 72 01 	sts	0x0172, r1
		gTime.min++;
     dc4:	80 91 73 01 	lds	r24, 0x0173
     dc8:	8f 5f       	subi	r24, 0xFF	; 255
     dca:	80 93 73 01 	sts	0x0173, r24
	}
	if (gTime.min >= 60) {
     dce:	80 91 73 01 	lds	r24, 0x0173
     dd2:	8c 33       	cpi	r24, 0x3C	; 60
     dd4:	10 f0       	brcs	.+4      	; 0xdda <main+0x184>
		gTime.min = 0;
     dd6:	10 92 73 01 	sts	0x0173, r1
		str[pos++] = '0';
	}
	pos = printNumberWithUnit(str, pos, gTime.hour, ":");
#endif //TIME_HOUR_ENABLED
	if (gTime.min < 10) {
		str[pos++] = '0';
     dda:	81 e0       	ldi	r24, 0x01	; 1
     ddc:	10 e0       	ldi	r17, 0x00	; 0
     dde:	e8 2e       	mov	r14, r24
#endif //GRAPICSENABLED
}

void main(void) __attribute__ ((noreturn)); // Main never returns, saves a few bytes

void main(void) {
     de0:	21 2f       	mov	r18, r17
     de2:	30 e0       	ldi	r19, 0x00	; 0
     de4:	81 e2       	ldi	r24, 0x21	; 33
     de6:	90 e0       	ldi	r25, 0x00	; 0
     de8:	28 9f       	mul	r18, r24
     dea:	f0 01       	movw	r30, r0
     dec:	29 9f       	mul	r18, r25
     dee:	f0 0d       	add	r31, r0
     df0:	38 9f       	mul	r19, r24
     df2:	f0 0d       	add	r31, r0
     df4:	11 24       	eor	r1, r1
     df6:	eb 54       	subi	r30, 0x4B	; 75
     df8:	fe 4f       	sbci	r31, 0xFE	; 254
     dfa:	81 e2       	ldi	r24, 0x21	; 33
#endif // TEXT_INVERTED_ENABLED

// Functions
static void clearText(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
		gText[textId][j] = 0;
     dfc:	11 92       	st	Z+, r1
     dfe:	81 50       	subi	r24, 0x01	; 1
static uint8_t gTextInverted[TEXT_LINES][TEXT_LINE_MAX_CHARS/8];
#endif // TEXT_INVERTED_ENABLED

// Functions
static void clearText(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
     e00:	e9 f7       	brne	.-6      	; 0xdfc <main+0x1a6>
static void updateText(uint8_t textId) {
  //testPrintDebugInfo();
  uint8_t pos = 0;

  // --------------- TEXT LINE 1 (From top) -----------------------
	if (textId == 0) {
     e02:	11 23       	and	r17, r17
     e04:	09 f4       	brne	.+2      	; 0xe08 <main+0x1b2>
     e06:	b8 c0       	rjmp	.+368    	; 0xf78 <main+0x322>
#ifdef SHOW_GPS_IN_FLIGHT
	 printGpsNumber(gText[textId], pos, gGpsLastValidData.pos.latitude, 1); 
#endif	
  }
  // --------------- TEXT LINE 2 (From top) -----------------------
  else if (textId == 1) {
     e08:	11 30       	cpi	r17, 0x01	; 1
     e0a:	09 f4       	brne	.+2      	; 0xe0e <main+0x1b8>
     e0c:	c2 c1       	rjmp	.+900    	; 0x1192 <main+0x53c>
#ifdef SHOW_GPS_IN_FLIGHT
	 printGpsNumber(gText[textId], pos, gGpsLastValidData.pos.longitude, 0); 
#endif	
  }
  // --------------- TEXT LINE 3 (From top) -----------------------
  else if (textId == 2) {
     e0e:	12 30       	cpi	r17, 0x02	; 2
     e10:	09 f4       	brne	.+2      	; 0xe14 <main+0x1be>
     e12:	f8 c1       	rjmp	.+1008   	; 0x1204 <main+0x5ae>
	
	
#endif //GPS_ENABLED
  }
  // --------------- TEXT LINE 4 (From top) -----------------------
  else if (textId == 3) {
     e14:	13 30       	cpi	r17, 0x03	; 3
     e16:	09 f4       	brne	.+2      	; 0xe1a <main+0x1c4>
     e18:	54 c3       	rjmp	.+1704   	; 0x14c2 <main+0x86c>
		  pos = printNumber(gText[textId], TEXT_LINE_MAX_CHARS-4, gGpsLastValidData.angle);
		 
#endif //GPS_ENABLED	  
	}
	// --------------- TEXT LINE 5 (From top) -----------------------
	else if (textId == 4) {
     e1a:	14 30       	cpi	r17, 0x04	; 4
     e1c:	09 f4       	brne	.+2      	; 0xe20 <main+0x1ca>
     e1e:	0a c2       	rjmp	.+1044   	; 0x1234 <main+0x5de>
#ifdef TIME_ENABLED
	updateTime();
#endif //TIMEENABLED

#ifdef TEXT_ENABLED
  for (uint8_t i = 0; i < TEXT_LINES; ++i) {
     e20:	76 e0       	ldi	r23, 0x06	; 6
     e22:	e7 16       	cp	r14, r23
     e24:	09 f4       	brne	.+2      	; 0xe28 <main+0x1d2>
     e26:	dc c0       	rjmp	.+440    	; 0xfe0 <main+0x38a>
     e28:	1f 5f       	subi	r17, 0xFF	; 255
     e2a:	e3 94       	inc	r14
     e2c:	d9 cf       	rjmp	.-78     	; 0xde0 <main+0x18a>
#endif //HOME_SET_WITH_BUTTON
#endif //GPS_ENABLED
			}
		}
		else {
			if (gKeyPressed) {
     e2e:	80 91 75 01 	lds	r24, 0x0175
     e32:	81 11       	cpse	r24, r1
				PORTD &= ~LED;  // led off
     e34:	5b 98       	cbi	0x0b, 3	; 11
			}				
			gKeyPressed = 0;
     e36:	10 92 75 01 	sts	0x0175, r1
			gKeyPressTime = 0;
     e3a:	10 92 76 01 	sts	0x0176, r1
#ifdef DEBUG
		gUpdateScreenData = 2;
#endif //DEBUG

#ifdef TEXT_ENABLED
    if (gUpdateScreenData == 2) {
     e3e:	80 91 70 01 	lds	r24, 0x0170
     e42:	82 30       	cpi	r24, 0x02	; 2
     e44:	09 f0       	breq	.+2      	; 0xe48 <main+0x1f2>
     e46:	8a cf       	rjmp	.-236    	; 0xd5c <main+0x106>
		  gUpdateScreenData = 0;
     e48:	10 92 70 01 	sts	0x0170, r1
#endif //GRAPICSENABLED
}

void main(void) __attribute__ ((noreturn)); // Main never returns, saves a few bytes

void main(void) {
     e4c:	20 91 b4 01 	lds	r18, 0x01B4
     e50:	30 e0       	ldi	r19, 0x00	; 0
     e52:	81 e2       	ldi	r24, 0x21	; 33
     e54:	90 e0       	ldi	r25, 0x00	; 0
     e56:	28 9f       	mul	r18, r24
     e58:	d0 01       	movw	r26, r0
     e5a:	29 9f       	mul	r18, r25
     e5c:	b0 0d       	add	r27, r0
     e5e:	38 9f       	mul	r19, r24
     e60:	b0 0d       	add	r27, r0
     e62:	11 24       	eor	r1, r1
     e64:	ab 54       	subi	r26, 0x4B	; 75
     e66:	be 4f       	sbci	r27, 0xFE	; 254
		gUpdateScreenData = 2;
#endif //DEBUG

#ifdef TEXT_ENABLED
    if (gUpdateScreenData == 2) {
		  gUpdateScreenData = 0;
     e68:	4b e7       	ldi	r20, 0x7B	; 123
     e6a:	e4 2e       	mov	r14, r20
     e6c:	42 e0       	ldi	r20, 0x02	; 2
     e6e:	f4 2e       	mov	r15, r20
#endif //GRAPICSENABLED
}

void main(void) __attribute__ ((noreturn)); // Main never returns, saves a few bytes

void main(void) {
     e70:	f7 01       	movw	r30, r14
     e72:	80 e0       	ldi	r24, 0x00	; 0
     e74:	90 e0       	ldi	r25, 0x00	; 0
     e76:	13 c0       	rjmp	.+38     	; 0xe9e <main+0x248>
		uint8_t character = gText[textId][j];
		int16_t eepromPos;
		if (character == ' ' || character == 0) {
			eepromPos = -1;
		}
		else if (character < CHAR_OFFSET + CHAR_LENGTH) {
     e78:	2b 35       	cpi	r18, 0x5B	; 91
     e7a:	08 f0       	brcs	.+2      	; 0xe7e <main+0x228>
     e7c:	71 c1       	rjmp	.+738    	; 0x1160 <main+0x50a>
			uint16_t charPos = ((character - CHAR_OFFSET) * TEXT_CHAR_HEIGHT);
     e7e:	82 2f       	mov	r24, r18
     e80:	90 e0       	ldi	r25, 0x00	; 0
     e82:	88 0f       	add	r24, r24
     e84:	99 1f       	adc	r25, r25
     e86:	88 0f       	add	r24, r24
     e88:	99 1f       	adc	r25, r25
     e8a:	88 0f       	add	r24, r24
     e8c:	99 1f       	adc	r25, r25
			eepromPos = (int16_t)&(oem6x8[charPos]);
     e8e:	88 52       	subi	r24, 0x28	; 40
     e90:	91 40       	sbci	r25, 0x01	; 1
		else if (character > CHAR_SPECIAL_OFFSET && character < CHAR_SPECIAL_OFFSET+CHAR_SPECIAL_LENGTH) {
			uint16_t charPos = ((character - CHAR_SPECIAL_OFFSET) * TEXT_CHAR_HEIGHT);
			eepromPos = (int16_t)&(specialChars[charPos]);
		}
#endif //TEXT_USE_SPECIAL_CHARS
		gTextCharEepromPos[j] = eepromPos;
     e92:	81 93       	st	Z+, r24
     e94:	91 93       	st	Z+, r25
}
#endif // TEXT_INVERTED_ENABLED
*/

static void updateTextCharStartPos(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
     e96:	42 e0       	ldi	r20, 0x02	; 2
     e98:	ed 3b       	cpi	r30, 0xBD	; 189
     e9a:	f4 07       	cpc	r31, r20
     e9c:	69 f0       	breq	.+26     	; 0xeb8 <main+0x262>
		uint8_t character = gText[textId][j];
     e9e:	2d 91       	ld	r18, X+
		int16_t eepromPos;
		if (character == ' ' || character == 0) {
     ea0:	20 32       	cpi	r18, 0x20	; 32
     ea2:	11 f0       	breq	.+4      	; 0xea8 <main+0x252>
     ea4:	22 23       	and	r18, r18
     ea6:	41 f7       	brne	.-48     	; 0xe78 <main+0x222>
			eepromPos = -1;
     ea8:	8f ef       	ldi	r24, 0xFF	; 255
     eaa:	9f ef       	ldi	r25, 0xFF	; 255
		else if (character > CHAR_SPECIAL_OFFSET && character < CHAR_SPECIAL_OFFSET+CHAR_SPECIAL_LENGTH) {
			uint16_t charPos = ((character - CHAR_SPECIAL_OFFSET) * TEXT_CHAR_HEIGHT);
			eepromPos = (int16_t)&(specialChars[charPos]);
		}
#endif //TEXT_USE_SPECIAL_CHARS
		gTextCharEepromPos[j] = eepromPos;
     eac:	81 93       	st	Z+, r24
     eae:	91 93       	st	Z+, r25
}
#endif // TEXT_INVERTED_ENABLED
*/

static void updateTextCharStartPos(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
     eb0:	42 e0       	ldi	r20, 0x02	; 2
     eb2:	ed 3b       	cpi	r30, 0xBD	; 189
     eb4:	f4 07       	cpc	r31, r20
     eb6:	99 f7       	brne	.-26     	; 0xe9e <main+0x248>
     eb8:	00 e0       	ldi	r16, 0x00	; 0
     eba:	10 e0       	ldi	r17, 0x00	; 0
		  if (eepromPos != -1) {
		  eeprom_read_block((void*)gTextLastCharBuffer, (const void*)eepromPos, 8);
			  gTextLastCharEepromPos = eepromPos;
		  }
		  else {
			  memset(gTextLastCharBuffer, 0, 8);
     ebc:	a8 e0       	ldi	r26, 0x08	; 8
     ebe:	da 2e       	mov	r13, r26
			  gTextLastCharEepromPos = -1;
     ec0:	cc 24       	eor	r12, r12
     ec2:	ca 94       	dec	r12
	}		
}

static void updateTextPixmap(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
		int16_t eepromPos = gTextCharEepromPos[j];
     ec4:	d7 01       	movw	r26, r14
     ec6:	8d 90       	ld	r8, X+
     ec8:	9d 90       	ld	r9, X+
     eca:	7d 01       	movw	r14, r26
		if (gTextLastCharEepromPos != eepromPos) {
     ecc:	80 91 50 01 	lds	r24, 0x0150
     ed0:	99 27       	eor	r25, r25
     ed2:	87 fd       	sbrc	r24, 7
     ed4:	90 95       	com	r25
     ed6:	88 16       	cp	r8, r24
     ed8:	99 06       	cpc	r9, r25
     eda:	71 f0       	breq	.+28     	; 0xef8 <main+0x2a2>
		  if (eepromPos != -1) {
     edc:	bf ef       	ldi	r27, 0xFF	; 255
     ede:	8b 16       	cp	r8, r27
     ee0:	bf ef       	ldi	r27, 0xFF	; 255
     ee2:	9b 06       	cpc	r9, r27
     ee4:	09 f4       	brne	.+2      	; 0xee8 <main+0x292>
     ee6:	4c c1       	rjmp	.+664    	; 0x1180 <main+0x52a>
		  eeprom_read_block((void*)gTextLastCharBuffer, (const void*)eepromPos, 8);
     ee8:	8d eb       	ldi	r24, 0xBD	; 189
     eea:	92 e0       	ldi	r25, 0x02	; 2
     eec:	b4 01       	movw	r22, r8
     eee:	48 e0       	ldi	r20, 0x08	; 8
     ef0:	50 e0       	ldi	r21, 0x00	; 0
     ef2:	36 d8       	rcall	.-3988   	; 0xffffff60 <__eeprom_end+0xff7efd60>
			  gTextLastCharEepromPos = eepromPos;
     ef4:	80 92 50 01 	sts	0x0150, r8
     ef8:	80 91 bd 02 	lds	r24, 0x02BD
     efc:	f8 01       	movw	r30, r16
     efe:	eb 53       	subi	r30, 0x3B	; 59
     f00:	fd 4f       	sbci	r31, 0xFD	; 253
     f02:	ae eb       	ldi	r26, 0xBE	; 190
     f04:	b2 e0       	ldi	r27, 0x02	; 2
     f06:	01 c0       	rjmp	.+2      	; 0xf0a <main+0x2b4>
		  }
		  else {
			  memset(gTextLastCharBuffer, 0, 8);
			  gTextLastCharEepromPos = -1;
     f08:	8d 91       	ld	r24, X+
		  gTextLastCharBuffer[i] = ~gTextLastCharBuffer[i];
		}
#endif // TEXT_INVERTED_ENABLED


      gTextPixmap[j + (i*TEXT_LINE_MAX_CHARS)] = gTextLastCharBuffer[i];
     f0a:	80 83       	st	Z, r24
     f0c:	b1 96       	adiw	r30, 0x21	; 33
			  memset(gTextLastCharBuffer, 0, 8);
			  gTextLastCharEepromPos = -1;
		  }
		}		  

	  for (uint8_t i = 0; i < TEXT_CHAR_HEIGHT; i++) {
     f0e:	22 e0       	ldi	r18, 0x02	; 2
     f10:	a5 3c       	cpi	r26, 0xC5	; 197
     f12:	b2 07       	cpc	r27, r18
     f14:	c9 f7       	brne	.-14     	; 0xf08 <main+0x2b2>
     f16:	0f 5f       	subi	r16, 0xFF	; 255
     f18:	1f 4f       	sbci	r17, 0xFF	; 255
		gTextCharEepromPos[j] = eepromPos;
	}		
}

static void updateTextPixmap(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
     f1a:	01 32       	cpi	r16, 0x21	; 33
     f1c:	11 05       	cpc	r17, r1
     f1e:	91 f6       	brne	.-92     	; 0xec4 <main+0x26e>
	setup();

	while(1) {
    
#ifdef GPS_ENABLED
    if(UCSR0A & (1<<RXC0)) {
     f20:	80 91 c0 00 	lds	r24, 0x00C0
     f24:	87 ff       	sbrs	r24, 7
     f26:	ef ce       	rjmp	.-546    	; 0xd06 <main+0xb0>
      decodeGpsData(UDR0);
     f28:	10 91 c6 00 	lds	r17, 0x00C6
		}			
	}
}

static void decodeGpsData(char data) {
	if (gGpsTextPartStep == GPS_PART_FINISHED && data != '$') {
     f2c:	90 91 5d 01 	lds	r25, 0x015D
     f30:	9f 3f       	cpi	r25, 0xFF	; 255
     f32:	09 f4       	brne	.+2      	; 0xf36 <main+0x2e0>
     f34:	ff c3       	rjmp	.+2046   	; 0x1734 <main+0xade>
		return;
	}
	
	switch (data) {
     f36:	14 32       	cpi	r17, 0x24	; 36
     f38:	09 f4       	brne	.+2      	; 0xf3c <main+0x2e6>
     f3a:	ff c3       	rjmp	.+2046   	; 0x173a <main+0xae4>
     f3c:	15 32       	cpi	r17, 0x25	; 37
     f3e:	08 f0       	brcs	.+2      	; 0xf42 <main+0x2ec>
     f40:	12 c3       	rjmp	.+1572   	; 0x1566 <main+0x910>
     f42:	1a 30       	cpi	r17, 0x0A	; 10
     f44:	09 f4       	brne	.+2      	; 0xf48 <main+0x2f2>
     f46:	09 c4       	rjmp	.+2066   	; 0x175a <main+0xb04>
     f48:	1d 30       	cpi	r17, 0x0D	; 13
     f4a:	09 f4       	brne	.+2      	; 0xf4e <main+0x2f8>
     f4c:	06 c4       	rjmp	.+2060   	; 0x175a <main+0xb04>
	  gGpsTextPartStep = GPS_PART_FINISHED;
	  finishGpsDecoding();
		return;
		break;
	default:
		gGpsText[gGpsTextPos] = data;
     f4e:	80 91 cf 03 	lds	r24, 0x03CF
     f52:	e8 2f       	mov	r30, r24
     f54:	f0 e0       	ldi	r31, 0x00	; 0
     f56:	ee 52       	subi	r30, 0x2E	; 46
     f58:	fc 4f       	sbci	r31, 0xFC	; 252
     f5a:	10 83       	st	Z, r17
		if (gGpsTextPartStep != GPS_PART_CHECKSUM) {
     f5c:	98 3c       	cpi	r25, 0xC8	; 200
     f5e:	29 f0       	breq	.+10     	; 0xf6a <main+0x314>
		  gGpsChecksum ^= data;
     f60:	90 91 d1 03 	lds	r25, 0x03D1
     f64:	91 27       	eor	r25, r17
     f66:	90 93 d1 03 	sts	0x03D1, r25
		}
		if (gGpsTextPos < GPS_MAX_CHARS-1) {
     f6a:	8a 30       	cpi	r24, 0x0A	; 10
     f6c:	08 f0       	brcs	.+2      	; 0xf70 <main+0x31a>
     f6e:	cb ce       	rjmp	.-618    	; 0xd06 <main+0xb0>
		  ++gGpsTextPos;
     f70:	8f 5f       	subi	r24, 0xFF	; 255
     f72:	80 93 cf 03 	sts	0x03CF, r24
     f76:	c7 ce       	rjmp	.-626    	; 0xd06 <main+0xb0>
  uint8_t pos = 0;

  // --------------- TEXT LINE 1 (From top) -----------------------
	if (textId == 0) {
#ifdef SENSOR_VOLTAGE_1_ENABLED
		printText(gText[textId], pos+ 1, "\1521"); //Battery symbol + '1'
     f78:	85 eb       	ldi	r24, 0xB5	; 181
     f7a:	91 e0       	ldi	r25, 0x01	; 1
     f7c:	61 e0       	ldi	r22, 0x01	; 1
     f7e:	44 e2       	ldi	r20, 0x24	; 36
     f80:	51 e0       	ldi	r21, 0x01	; 1
     f82:	e5 d9       	rcall	.-3126   	; 0x34e <printText>
#endif
		pos += 4 ;

#ifdef SENSOR_VOLTAGE_1_ENABLED
		 if (!gAlarmBatt1 || gBlink1Hz) {
     f84:	80 91 3c 04 	lds	r24, 0x043C
     f88:	88 23       	and	r24, r24
     f8a:	21 f0       	breq	.+8      	; 0xf94 <main+0x33e>
     f8c:	80 91 71 01 	lds	r24, 0x0171
     f90:	88 23       	and	r24, r24
     f92:	21 f0       	breq	.+8      	; 0xf9c <main+0x346>
			 printAdc(gText[textId], pos , ANALOG_IN_1); // Voltage 1
     f94:	85 eb       	ldi	r24, 0xB5	; 181
     f96:	91 e0       	ldi	r25, 0x01	; 1
     f98:	60 e0       	ldi	r22, 0x00	; 0
     f9a:	f2 dc       	rcall	.-1564   	; 0x980 <printAdc.constprop.7>
		 }
#endif
		 pos += 8;

#ifdef SENSOR_RSSI_ENABLED
     if (gSensorRssi > 0) {
     f9c:	80 91 3b 04 	lds	r24, 0x043B
     fa0:	88 23       	and	r24, r24
     fa2:	31 f0       	breq	.+12     	; 0xfb0 <main+0x35a>
	  printText(gText[textId], pos, "\151"); //Antenna symbol (RSSI)
     fa4:	85 eb       	ldi	r24, 0xB5	; 181
     fa6:	91 e0       	ldi	r25, 0x01	; 1
     fa8:	6c e0       	ldi	r22, 0x0C	; 12
     faa:	47 e2       	ldi	r20, 0x27	; 39
     fac:	51 e0       	ldi	r21, 0x01	; 1
     fae:	cf d9       	rcall	.-3170   	; 0x34e <printText>
#endif
         pos += 6 ;
		 
#ifdef GPS_ENABLED

  		  pos = printText(gText[textId], pos, "\150"); // Satellites symbol
     fb0:	85 eb       	ldi	r24, 0xB5	; 181
     fb2:	91 e0       	ldi	r25, 0x01	; 1
     fb4:	62 e1       	ldi	r22, 0x12	; 18
     fb6:	49 e2       	ldi	r20, 0x29	; 41
     fb8:	51 e0       	ldi	r21, 0x01	; 1
     fba:	c9 d9       	rcall	.-3182   	; 0x34e <printText>
		
	#endif
	  pos += 2 ;	  
     fbc:	68 2f       	mov	r22, r24
     fbe:	6e 5f       	subi	r22, 0xFE	; 254
	  

#ifdef SHOW_GPS_IN_FLIGHT
	 printGpsNumber(gText[textId], pos, gGpsLastValidData.pos.latitude, 1); 
     fc0:	20 91 9a 01 	lds	r18, 0x019A
     fc4:	30 91 9b 01 	lds	r19, 0x019B
     fc8:	40 91 9c 01 	lds	r20, 0x019C
     fcc:	50 91 9d 01 	lds	r21, 0x019D
     fd0:	85 eb       	ldi	r24, 0xB5	; 181
     fd2:	91 e0       	ldi	r25, 0x01	; 1
     fd4:	01 e0       	ldi	r16, 0x01	; 1
     fd6:	e3 d9       	rcall	.-3130   	; 0x39e <printGpsNumber>
#ifdef TIME_ENABLED
	updateTime();
#endif //TIMEENABLED

#ifdef TEXT_ENABLED
  for (uint8_t i = 0; i < TEXT_LINES; ++i) {
     fd8:	76 e0       	ldi	r23, 0x06	; 6
     fda:	e7 16       	cp	r14, r23
     fdc:	09 f0       	breq	.+2      	; 0xfe0 <main+0x38a>
     fde:	24 cf       	rjmp	.-440    	; 0xe28 <main+0x1d2>
     fe0:	80 e0       	ldi	r24, 0x00	; 0
     fe2:	90 e0       	ldi	r25, 0x00	; 0
#endif //GRAPICSENABLED
}

void main(void) __attribute__ ((noreturn)); // Main never returns, saves a few bytes

void main(void) {
     fe4:	fc 01       	movw	r30, r24
     fe6:	ee 0f       	add	r30, r30
     fe8:	ff 1f       	adc	r31, r31
     fea:	e8 0f       	add	r30, r24
     fec:	f9 1f       	adc	r31, r25
     fee:	ee 0f       	add	r30, r30
     ff0:	ff 1f       	adc	r31, r31
     ff2:	ee 0f       	add	r30, r30
     ff4:	ff 1f       	adc	r31, r31
     ff6:	ee 0f       	add	r30, r30
     ff8:	ff 1f       	adc	r31, r31
     ffa:	ef 51       	subi	r30, 0x1F	; 31
     ffc:	fc 4f       	sbci	r31, 0xFC	; 252
     ffe:	20 e0       	ldi	r18, 0x00	; 0
// Functions

static void clearGraphics() {
	for (uint8_t x = 0; x < GRAPHICS_WIDTH; ++x) {
	  for (uint8_t y = 0; y < GRAPHICS_HEIGHT; ++y) {
			gPixelData[x][y] = 0x00;
    1000:	11 92       	st	Z+, r1

// Functions

static void clearGraphics() {
	for (uint8_t x = 0; x < GRAPHICS_WIDTH; ++x) {
	  for (uint8_t y = 0; y < GRAPHICS_HEIGHT; ++y) {
    1002:	2f 5f       	subi	r18, 0xFF	; 255
    1004:	28 31       	cpi	r18, 0x18	; 24
    1006:	e1 f7       	brne	.-8      	; 0x1000 <main+0x3aa>
    1008:	01 96       	adiw	r24, 0x01	; 1
static uint8_t gPixelData[GRAPHICS_WIDTH][GRAPHICS_HEIGHT];

// Functions

static void clearGraphics() {
	for (uint8_t x = 0; x < GRAPHICS_WIDTH; ++x) {
    100a:	83 30       	cpi	r24, 0x03	; 3
    100c:	91 05       	cpc	r25, r1
    100e:	51 f7       	brne	.-44     	; 0xfe4 <main+0x38e>
}
#endif //TEXT_ENABLED

static void updateGrapics() {
#ifdef GPS_ENABLED
  drawArrow(gHomeBearing - gGpsLastValidData.angle);
    1010:	e0 90 29 04 	lds	r14, 0x0429
    1014:	f0 90 2a 04 	lds	r15, 0x042A
    1018:	00 91 ac 01 	lds	r16, 0x01AC
    101c:	10 91 ad 01 	lds	r17, 0x01AD
		}
	}				 
}

static void drawArrow(uint16_t angle) {
	drawCircle(GRAPHICS_MID, GRAPHICS_MID, GRAPHICS_MID);
    1020:	8b e0       	ldi	r24, 0x0B	; 11
    1022:	91 dd       	rcall	.-1246   	; 0xb46 <drawCircle.constprop.9>
	if (gHomeDistance < 10) {
    1024:	80 91 2b 04 	lds	r24, 0x042B
    1028:	90 91 2c 04 	lds	r25, 0x042C
    102c:	a0 91 2d 04 	lds	r26, 0x042D
    1030:	b0 91 2e 04 	lds	r27, 0x042E
    1034:	8a 30       	cpi	r24, 0x0A	; 10
    1036:	91 05       	cpc	r25, r1
    1038:	a1 05       	cpc	r26, r1
    103a:	b1 05       	cpc	r27, r1
    103c:	08 f4       	brcc	.+2      	; 0x1040 <main+0x3ea>
    103e:	6c c2       	rjmp	.+1240   	; 0x1518 <main+0x8c2>
	  drawCircle(GRAPHICS_MID, GRAPHICS_MID, 2);
	  return;
	}
	if (gGpsLastData.fix == 0) {
    1040:	80 91 85 01 	lds	r24, 0x0185
    1044:	88 23       	and	r24, r24
    1046:	09 f4       	brne	.+2      	; 0x104a <main+0x3f4>
    1048:	6a c2       	rjmp	.+1236   	; 0x151e <main+0x8c8>
    104a:	c7 01       	movw	r24, r14
    104c:	80 1b       	sub	r24, r16
    104e:	91 0b       	sbc	r25, r17
    1050:	8c 01       	movw	r16, r24
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
}

static int8_t myCos(uint16_t angle) {
	return mySin(angle + 90);
    1052:	86 5a       	subi	r24, 0xA6	; 166
    1054:	9f 4f       	sbci	r25, 0xFF	; 255
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    1056:	68 e6       	ldi	r22, 0x68	; 104
    1058:	71 e0       	ldi	r23, 0x01	; 1
    105a:	01 d7       	rcall	.+3586   	; 0x1e5e <__udivmodhi4>
	int8_t mult = 1;
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    105c:	84 3b       	cpi	r24, 0xB4	; 180
    105e:	91 05       	cpc	r25, r1
    1060:	08 f4       	brcc	.+2      	; 0x1064 <main+0x40e>
    1062:	26 c1       	rjmp	.+588    	; 0x12b0 <main+0x65a>
		pos = pos - 180;
    1064:	84 5b       	subi	r24, 0xB4	; 180
    1066:	90 40       	sbci	r25, 0x00	; 0
    1068:	4f ef       	ldi	r20, 0xFF	; 255
		mult = -1;
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
    106a:	8a 35       	cpi	r24, 0x5A	; 90
    106c:	91 05       	cpc	r25, r1
    106e:	30 f0       	brcs	.+12     	; 0x107c <main+0x426>
		pos = 180 - pos;
    1070:	24 eb       	ldi	r18, 0xB4	; 180
    1072:	30 e0       	ldi	r19, 0x00	; 0
    1074:	d9 01       	movw	r26, r18
    1076:	a8 1b       	sub	r26, r24
    1078:	b9 0b       	sbc	r27, r25
    107a:	cd 01       	movw	r24, r26
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
    107c:	8c 5c       	subi	r24, 0xCC	; 204
    107e:	9f 4f       	sbci	r25, 0xFF	; 255
    1080:	fc 01       	movw	r30, r24
    1082:	84 91       	lpm	r24, Z
    1084:	84 9f       	mul	r24, r20
    1086:	20 2d       	mov	r18, r0
    1088:	11 24       	eor	r1, r1
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    108a:	c8 01       	movw	r24, r16
    108c:	68 e6       	ldi	r22, 0x68	; 104
    108e:	71 e0       	ldi	r23, 0x01	; 1
    1090:	e6 d6       	rcall	.+3532   	; 0x1e5e <__udivmodhi4>
	int8_t mult = 1;
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    1092:	84 3b       	cpi	r24, 0xB4	; 180
    1094:	91 05       	cpc	r25, r1
    1096:	08 f4       	brcc	.+2      	; 0x109a <main+0x444>
    1098:	09 c1       	rjmp	.+530    	; 0x12ac <main+0x656>
		pos = pos - 180;
    109a:	84 5b       	subi	r24, 0xB4	; 180
    109c:	90 40       	sbci	r25, 0x00	; 0
    109e:	3f ef       	ldi	r19, 0xFF	; 255
		mult = -1;
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
    10a0:	8a 35       	cpi	r24, 0x5A	; 90
    10a2:	91 05       	cpc	r25, r1
    10a4:	30 f0       	brcs	.+12     	; 0x10b2 <main+0x45c>
		pos = 180 - pos;
    10a6:	64 eb       	ldi	r22, 0xB4	; 180
    10a8:	70 e0       	ldi	r23, 0x00	; 0
    10aa:	4b 01       	movw	r8, r22
    10ac:	88 1a       	sub	r8, r24
    10ae:	99 0a       	sbc	r9, r25
    10b0:	c4 01       	movw	r24, r8
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
    10b2:	8c 5c       	subi	r24, 0xCC	; 204
    10b4:	9f 4f       	sbci	r25, 0xFF	; 255
    10b6:	fc 01       	movw	r30, r24
    10b8:	84 91       	lpm	r24, Z
    10ba:	83 9f       	mul	r24, r19
    10bc:	40 2d       	mov	r20, r0
    10be:	11 24       	eor	r1, r1
		drawLine(GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID - (GRAPHICS_SIZE/4));
		return;
	}
	int16_t a = myCos(angle);
	int16_t b = mySin(angle);
	a = (a * (GRAPHICS_SIZE / 3)) / 100;
    10c0:	82 2f       	mov	r24, r18
    10c2:	99 27       	eor	r25, r25
    10c4:	87 fd       	sbrc	r24, 7
    10c6:	90 95       	com	r25
    10c8:	88 0f       	add	r24, r24
    10ca:	99 1f       	adc	r25, r25
    10cc:	88 0f       	add	r24, r24
    10ce:	99 1f       	adc	r25, r25
    10d0:	88 0f       	add	r24, r24
    10d2:	99 1f       	adc	r25, r25
    10d4:	24 e6       	ldi	r18, 0x64	; 100
    10d6:	30 e0       	ldi	r19, 0x00	; 0
    10d8:	b9 01       	movw	r22, r18
    10da:	d5 d6       	rcall	.+3498   	; 0x1e86 <__divmodhi4>
    10dc:	4b 01       	movw	r8, r22
	b = (b * (GRAPHICS_SIZE / 3)) / 100;
    10de:	84 2f       	mov	r24, r20
    10e0:	99 27       	eor	r25, r25
    10e2:	87 fd       	sbrc	r24, 7
    10e4:	90 95       	com	r25
    10e6:	88 0f       	add	r24, r24
    10e8:	99 1f       	adc	r25, r25
    10ea:	88 0f       	add	r24, r24
    10ec:	99 1f       	adc	r25, r25
    10ee:	88 0f       	add	r24, r24
    10f0:	99 1f       	adc	r25, r25
    10f2:	b9 01       	movw	r22, r18
    10f4:	c8 d6       	rcall	.+3472   	; 0x1e86 <__divmodhi4>
    10f6:	8b 01       	movw	r16, r22
	drawLine(GRAPHICS_MID - b, GRAPHICS_MID + a, GRAPHICS_MID + b, GRAPHICS_MID - a); //Direction line
    10f8:	68 2d       	mov	r22, r8
    10fa:	bb e0       	ldi	r27, 0x0B	; 11
    10fc:	eb 2e       	mov	r14, r27
    10fe:	e0 0e       	add	r14, r16
    1100:	8b e0       	ldi	r24, 0x0B	; 11
    1102:	d8 2e       	mov	r13, r24
    1104:	d8 18       	sub	r13, r8
    1106:	65 5f       	subi	r22, 0xF5	; 245
    1108:	80 1b       	sub	r24, r16
    110a:	4e 2d       	mov	r20, r14
    110c:	2d 2d       	mov	r18, r13
    110e:	98 dc       	rcall	.-1744   	; 0xa40 <drawLine>
	//drawLine(GRAPHICS_MID_X + a/2, GRAPHICS_MID_X + b/2, GRAPHICS_MID_X - a/2, GRAPHICS_MID_X - b/2); //Arrow bottom line
	drawLine(GRAPHICS_MID + b, GRAPHICS_MID - a, GRAPHICS_MID - a/2, GRAPHICS_MID - b/2); // Arrow "wings"
    1110:	c4 01       	movw	r24, r8
    1112:	97 fc       	sbrc	r9, 7
    1114:	5c c3       	rjmp	.+1720   	; 0x17ce <main+0xb78>
    1116:	95 95       	asr	r25
    1118:	87 95       	ror	r24
    111a:	90 95       	com	r25
    111c:	81 95       	neg	r24
    111e:	9f 4f       	sbci	r25, 0xFF	; 255
    1120:	48 2f       	mov	r20, r24
    1122:	45 5f       	subi	r20, 0xF5	; 245
    1124:	98 01       	movw	r18, r16
    1126:	17 fd       	sbrc	r17, 7
    1128:	4f c3       	rjmp	.+1694   	; 0x17c8 <main+0xb72>
    112a:	c9 01       	movw	r24, r18
    112c:	95 95       	asr	r25
    112e:	87 95       	ror	r24
    1130:	90 95       	com	r25
    1132:	81 95       	neg	r24
    1134:	9f 4f       	sbci	r25, 0xFF	; 255
    1136:	28 2f       	mov	r18, r24
    1138:	25 5f       	subi	r18, 0xF5	; 245
    113a:	8e 2d       	mov	r24, r14
    113c:	6d 2d       	mov	r22, r13
    113e:	80 dc       	rcall	.-1792   	; 0xa40 <drawLine>
	drawLine(GRAPHICS_MID + b, GRAPHICS_MID - a, GRAPHICS_MID + a/2, GRAPHICS_MID + b/2);
    1140:	97 fc       	sbrc	r9, 7
    1142:	3e c3       	rjmp	.+1660   	; 0x17c0 <main+0xb6a>
    1144:	a4 01       	movw	r20, r8
    1146:	55 95       	asr	r21
    1148:	47 95       	ror	r20
    114a:	45 5f       	subi	r20, 0xF5	; 245
    114c:	17 fd       	sbrc	r17, 7
    114e:	35 c3       	rjmp	.+1642   	; 0x17ba <main+0xb64>
    1150:	15 95       	asr	r17
    1152:	07 95       	ror	r16
    1154:	20 2f       	mov	r18, r16
    1156:	25 5f       	subi	r18, 0xF5	; 245
    1158:	8e 2d       	mov	r24, r14
    115a:	6d 2d       	mov	r22, r13
    115c:	71 dc       	rcall	.-1822   	; 0xa40 <drawLine>
    115e:	cf cd       	rjmp	.-1122   	; 0xcfe <main+0xa8>
		else if (character < CHAR_OFFSET + CHAR_LENGTH) {
			uint16_t charPos = ((character - CHAR_OFFSET) * TEXT_CHAR_HEIGHT);
			eepromPos = (int16_t)&(oem6x8[charPos]);
		}
#ifdef TEXT_USE_SPECIAL_CHARS
		else if (character > CHAR_SPECIAL_OFFSET && character < CHAR_SPECIAL_OFFSET+CHAR_SPECIAL_LENGTH) {
    1160:	32 2f       	mov	r19, r18
    1162:	35 56       	subi	r19, 0x65	; 101
    1164:	39 30       	cpi	r19, 0x09	; 9
    1166:	08 f0       	brcs	.+2      	; 0x116a <main+0x514>
    1168:	94 ce       	rjmp	.-728    	; 0xe92 <main+0x23c>
			uint16_t charPos = ((character - CHAR_SPECIAL_OFFSET) * TEXT_CHAR_HEIGHT);
    116a:	82 2f       	mov	r24, r18
    116c:	90 e0       	ldi	r25, 0x00	; 0
    116e:	88 0f       	add	r24, r24
    1170:	99 1f       	adc	r25, r25
    1172:	88 0f       	add	r24, r24
    1174:	99 1f       	adc	r25, r25
    1176:	88 0f       	add	r24, r24
    1178:	99 1f       	adc	r25, r25
			eepromPos = (int16_t)&(specialChars[charPos]);
    117a:	80 57       	subi	r24, 0x70	; 112
    117c:	91 40       	sbci	r25, 0x01	; 1
    117e:	89 ce       	rjmp	.-750    	; 0xe92 <main+0x23c>
		  if (eepromPos != -1) {
		  eeprom_read_block((void*)gTextLastCharBuffer, (const void*)eepromPos, 8);
			  gTextLastCharEepromPos = eepromPos;
		  }
		  else {
			  memset(gTextLastCharBuffer, 0, 8);
    1180:	f3 01       	movw	r30, r6
    1182:	8d 2c       	mov	r8, r13
    1184:	11 92       	st	Z+, r1
    1186:	8a 94       	dec	r8
    1188:	e9 f7       	brne	.-6      	; 0x1184 <main+0x52e>
			  gTextLastCharEepromPos = -1;
    118a:	c0 92 50 01 	sts	0x0150, r12
    118e:	80 e0       	ldi	r24, 0x00	; 0
    1190:	b5 ce       	rjmp	.-662    	; 0xefc <main+0x2a6>
  }
  // --------------- TEXT LINE 2 (From top) -----------------------
  else if (textId == 1) {
	  
#ifdef SENSOR_VOLTAGE_2_ENABLED
		if(((gSensorVoltage2.high * 100) + gSensorVoltage2.low) > 0) {
    1192:	90 91 3a 04 	lds	r25, 0x043A
    1196:	84 e6       	ldi	r24, 0x64	; 100
    1198:	98 9f       	mul	r25, r24
    119a:	c0 01       	movw	r24, r0
    119c:	11 24       	eor	r1, r1
    119e:	20 91 39 04 	lds	r18, 0x0439
    11a2:	82 0f       	add	r24, r18
    11a4:	91 1d       	adc	r25, r1
    11a6:	00 97       	sbiw	r24, 0x00	; 0
    11a8:	91 f0       	breq	.+36     	; 0x11ce <main+0x578>
		printText(gText[textId], pos+ 1, "\1522"); //Battery symbol + '2'
    11aa:	86 ed       	ldi	r24, 0xD6	; 214
    11ac:	91 e0       	ldi	r25, 0x01	; 1
    11ae:	61 e0       	ldi	r22, 0x01	; 1
    11b0:	4b e2       	ldi	r20, 0x2B	; 43
    11b2:	51 e0       	ldi	r21, 0x01	; 1
    11b4:	cc d8       	rcall	.-3688   	; 0x34e <printText>
		}
#endif		
		pos += 4 ;
#ifdef SENSOR_VOLTAGE_2_ENABLED
		 if(((gSensorVoltage2.high * 100) + gSensorVoltage2.low) > 0) {
     if (!gAlarmBatt2 || gBlink1Hz) {
    11b6:	80 91 3d 04 	lds	r24, 0x043D
    11ba:	88 23       	and	r24, r24
    11bc:	21 f0       	breq	.+8      	; 0x11c6 <main+0x570>
    11be:	80 91 71 01 	lds	r24, 0x0171
    11c2:	88 23       	and	r24, r24
    11c4:	21 f0       	breq	.+8      	; 0x11ce <main+0x578>
			 printAdc(gText[textId], pos , ANALOG_IN_2); // Voltage 2
    11c6:	86 ed       	ldi	r24, 0xD6	; 214
    11c8:	91 e0       	ldi	r25, 0x01	; 1
    11ca:	61 e0       	ldi	r22, 0x01	; 1
    11cc:	d9 db       	rcall	.-2126   	; 0x980 <printAdc.constprop.7>
	  pos += 6 ;
-------------------------------------------------*/	  


#ifdef GPS_ENABLED
    if (gGpsLastValidData.fix) {
    11ce:	80 91 a8 01 	lds	r24, 0x01A8
    11d2:	88 23       	and	r24, r24
    11d4:	41 f1       	breq	.+80     	; 0x1226 <main+0x5d0>
		printNumber(gText[textId], pos, gGpsLastValidData.sats); 
    11d6:	20 91 a9 01 	lds	r18, 0x01A9
    11da:	30 e0       	ldi	r19, 0x00	; 0
    11dc:	40 e0       	ldi	r20, 0x00	; 0
    11de:	50 e0       	ldi	r21, 0x00	; 0
    11e0:	86 ed       	ldi	r24, 0xD6	; 214
    11e2:	91 e0       	ldi	r25, 0x01	; 1
    11e4:	6c e0       	ldi	r22, 0x0C	; 12
    11e6:	05 d8       	rcall	.-4086   	; 0x1f2 <printNumber>
	  }
#endif
	  pos += 3 ;	  
	  
#ifdef SHOW_GPS_IN_FLIGHT
	 printGpsNumber(gText[textId], pos, gGpsLastValidData.pos.longitude, 0); 
    11e8:	20 91 9e 01 	lds	r18, 0x019E
    11ec:	30 91 9f 01 	lds	r19, 0x019F
    11f0:	40 91 a0 01 	lds	r20, 0x01A0
    11f4:	50 91 a1 01 	lds	r21, 0x01A1
    11f8:	86 ed       	ldi	r24, 0xD6	; 214
    11fa:	91 e0       	ldi	r25, 0x01	; 1
    11fc:	6f e0       	ldi	r22, 0x0F	; 15
    11fe:	00 e0       	ldi	r16, 0x00	; 0
    1200:	ce d8       	rcall	.-3684   	; 0x39e <printGpsNumber>
    1202:	0e ce       	rjmp	.-996    	; 0xe20 <main+0x1ca>
  }
  // --------------- TEXT LINE 3 (From top) -----------------------
  else if (textId == 2) {
	 
#ifdef GPS_ENABLED
	  if (gHomePosSet) {
    1204:	80 91 b3 01 	lds	r24, 0x01B3
    1208:	88 23       	and	r24, r24
    120a:	09 f0       	breq	.+2      	; 0x120e <main+0x5b8>
    120c:	93 c1       	rjmp	.+806    	; 0x1534 <main+0x8de>
			 pos = printText(gText[textId], pos, "\146");
			 pos = printText(gText[textId], 2, "MT");
			 pos = printNumber(gText[textId], 5 , gHomeDistance);
		}
	    else if (gBlink1Hz) {
    120e:	80 91 71 01 	lds	r24, 0x0171
    1212:	88 23       	and	r24, r24
    1214:	09 f4       	brne	.+2      	; 0x1218 <main+0x5c2>
    1216:	04 ce       	rjmp	.-1016   	; 0xe20 <main+0x1ca>
	      pos = printText(gText[textId], 10, "NO HOME POS");
    1218:	87 ef       	ldi	r24, 0xF7	; 247
    121a:	91 e0       	ldi	r25, 0x01	; 1
    121c:	6a e0       	ldi	r22, 0x0A	; 10
    121e:	45 e3       	ldi	r20, 0x35	; 53
    1220:	51 e0       	ldi	r21, 0x01	; 1
    1222:	95 d8       	rcall	.-3798   	; 0x34e <printText>
    1224:	fd cd       	rjmp	.-1030   	; 0xe20 <main+0x1ca>
#ifdef GPS_ENABLED
    if (gGpsLastValidData.fix) {
		printNumber(gText[textId], pos, gGpsLastValidData.sats); 
		}
		else {			
		printText(gText[textId], pos, "-");
    1226:	86 ed       	ldi	r24, 0xD6	; 214
    1228:	91 e0       	ldi	r25, 0x01	; 1
    122a:	6c e0       	ldi	r22, 0x0C	; 12
    122c:	4e e2       	ldi	r20, 0x2E	; 46
    122e:	51 e0       	ldi	r21, 0x01	; 1
    1230:	8e d8       	rcall	.-3812   	; 0x34e <printText>
    1232:	da cf       	rjmp	.-76     	; 0x11e8 <main+0x592>
	}
	// --------------- TEXT LINE 5 (From top) -----------------------
	else if (textId == 4) {
#ifdef GPS_ENABLED

	    pos = printNumber(gText[textId], 0, gGpsLastValidData.speed); // Speed
    1234:	20 91 aa 01 	lds	r18, 0x01AA
    1238:	30 91 ab 01 	lds	r19, 0x01AB
    123c:	40 e0       	ldi	r20, 0x00	; 0
    123e:	50 e0       	ldi	r21, 0x00	; 0
    1240:	89 e3       	ldi	r24, 0x39	; 57
    1242:	92 e0       	ldi	r25, 0x02	; 2
    1244:	60 e0       	ldi	r22, 0x00	; 0
    1246:	d5 d7       	rcall	.+4010   	; 0x21f2 <__data_load_end+0x1fe>
			
        pos = printText(gText[textId],5 , "KM/H");
    1248:	89 e3       	ldi	r24, 0x39	; 57
    124a:	92 e0       	ldi	r25, 0x02	; 2
    124c:	65 e0       	ldi	r22, 0x05	; 5
    124e:	49 e4       	ldi	r20, 0x49	; 73
    1250:	51 e0       	ldi	r21, 0x01	; 1
    1252:	7d d8       	rcall	.-3846   	; 0x34e <printText>
	if (gTime.hour < 10) {
		str[pos++] = '0';
	}
	pos = printNumberWithUnit(str, pos, gTime.hour, ":");
#endif //TIME_HOUR_ENABLED
	if (gTime.min < 10) {
    1254:	80 91 73 01 	lds	r24, 0x0173
    1258:	8a 30       	cpi	r24, 0x0A	; 10
    125a:	08 f0       	brcs	.+2      	; 0x125e <main+0x608>
    125c:	5b c1       	rjmp	.+694    	; 0x1514 <main+0x8be>
		str[pos++] = '0';
    125e:	80 e3       	ldi	r24, 0x30	; 48
    1260:	80 93 54 02 	sts	0x0254, r24
    1264:	6c e1       	ldi	r22, 0x1C	; 28
	}	
	pos = printNumberWithUnit(str, pos, gTime.min, ":");
    1266:	20 91 73 01 	lds	r18, 0x0173
    126a:	30 e0       	ldi	r19, 0x00	; 0
    126c:	40 e0       	ldi	r20, 0x00	; 0
    126e:	50 e0       	ldi	r21, 0x00	; 0
	}
	return printNumber(str, pos, numberLow);
}

static uint8_t printNumberWithUnit(char* const str, uint8_t pos, int32_t number, const char* unit) {
	pos = printNumber(str, pos, number);
    1270:	89 e3       	ldi	r24, 0x39	; 57
    1272:	92 e0       	ldi	r25, 0x02	; 2
    1274:	be d7       	rcall	.+3964   	; 0x21f2 <__data_load_end+0x1fe>
    1276:	68 2f       	mov	r22, r24
	return printText(str, pos, unit);
    1278:	89 e3       	ldi	r24, 0x39	; 57
    127a:	92 e0       	ldi	r25, 0x02	; 2
    127c:	4e e4       	ldi	r20, 0x4E	; 78
    127e:	51 e0       	ldi	r21, 0x01	; 1
    1280:	66 d8       	rcall	.-3892   	; 0x34e <printText>
    1282:	68 2f       	mov	r22, r24
#endif //TIME_HOUR_ENABLED
	if (gTime.min < 10) {
		str[pos++] = '0';
	}	
	pos = printNumberWithUnit(str, pos, gTime.min, ":");
	if (gTime.sec < 10) {
    1284:	80 91 72 01 	lds	r24, 0x0172
    1288:	8a 30       	cpi	r24, 0x0A	; 10
    128a:	38 f4       	brcc	.+14     	; 0x129a <main+0x644>
		str[pos++] = '0';
    128c:	e6 2f       	mov	r30, r22
    128e:	f0 e0       	ldi	r31, 0x00	; 0
    1290:	e7 5c       	subi	r30, 0xC7	; 199
    1292:	fd 4f       	sbci	r31, 0xFD	; 253
    1294:	80 e3       	ldi	r24, 0x30	; 48
    1296:	80 83       	st	Z, r24
    1298:	6f 5f       	subi	r22, 0xFF	; 255
	}	
	return printNumber(str, pos, gTime.sec);
    129a:	20 91 72 01 	lds	r18, 0x0172
    129e:	30 e0       	ldi	r19, 0x00	; 0
    12a0:	40 e0       	ldi	r20, 0x00	; 0
    12a2:	50 e0       	ldi	r21, 0x00	; 0
    12a4:	89 e3       	ldi	r24, 0x39	; 57
    12a6:	92 e0       	ldi	r25, 0x02	; 2
    12a8:	a4 d7       	rcall	.+3912   	; 0x21f2 <__data_load_end+0x1fe>
    12aa:	ba cd       	rjmp	.-1164   	; 0xe20 <main+0x1ca>
static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
	int8_t mult = 1;
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    12ac:	31 e0       	ldi	r19, 0x01	; 1
    12ae:	f8 ce       	rjmp	.-528    	; 0x10a0 <main+0x44a>
    12b0:	41 e0       	ldi	r20, 0x01	; 1
    12b2:	db ce       	rjmp	.-586    	; 0x106a <main+0x414>

static void updateSensorsAndScreen() {
#ifndef GPS_ENABLED
  PORTD |= LED;
#else //GPS_ENABLED
  if (gGpsLastData.fix != 0) {
    12b4:	80 91 85 01 	lds	r24, 0x0185
    12b8:	88 23       	and	r24, r24
    12ba:	09 f4       	brne	.+2      	; 0x12be <main+0x668>
    12bc:	74 c1       	rjmp	.+744    	; 0x15a6 <main+0x950>
		PORTD |= LED;
    12be:	5b 9a       	sbi	0x0b, 3	; 11
	
#ifdef DEBUG
  //testCalcHome();
#endif // DEBUG
  
	if (gHomePosSet) {
    12c0:	80 91 b3 01 	lds	r24, 0x01B3
    12c4:	88 23       	and	r24, r24
    12c6:	09 f0       	breq	.+2      	; 0x12ca <main+0x674>
    12c8:	77 c1       	rjmp	.+750    	; 0x15b8 <main+0x962>
  distance *= mult;
#ifdef IMPERIAL_SYSTEM  
  distance *= 3281;
	distance /= 1000;
#endif //IMPERIAL_SYSTEM
  *distanceResult = distance;
    12ca:	ff e3       	ldi	r31, 0x3F	; 63
    12cc:	4f 2e       	mov	r4, r31
    12ce:	f4 e0       	ldi	r31, 0x04	; 4
    12d0:	5f 2e       	mov	r5, r31
    12d2:	ae e5       	ldi	r26, 0x5E	; 94
    12d4:	2a 2e       	mov	r2, r26
    12d6:	a1 e0       	ldi	r26, 0x01	; 1
    12d8:	3a 2e       	mov	r3, r26
    12da:	22 e6       	ldi	r18, 0x62	; 98
    12dc:	31 e0       	ldi	r19, 0x01	; 1
    12de:	3e 83       	std	Y+6, r19	; 0x06
    12e0:	2d 83       	std	Y+5, r18	; 0x05
    12e2:	82 e3       	ldi	r24, 0x32	; 50
    12e4:	94 e0       	ldi	r25, 0x04	; 4
      if (deltaLat == 0) {
        if (deltaLong >= 0) { // Home = East
          bearing = 90; 
        } 
	      else { // Home = West
          bearing = 270;
    12e6:	19 82       	std	Y+1, r1	; 0x01
	  ADCSRA &= ~(1<<ADEN) & ~(1<<ADATE); // ADC disabled & ADC auto trigger disabled
	  temp = ADCW;
#ifdef ADC_ENABLE_RAW	  
    gAnalogInputsRaw[i] = temp;
#endif
	  temp = (temp * 5 * 62) / 10;
    12e8:	ba e0       	ldi	r27, 0x0A	; 10
    12ea:	cb 2e       	mov	r12, r27
    12ec:	d1 2c       	mov	r13, r1
    12ee:	e1 2c       	mov	r14, r1
    12f0:	f1 2c       	mov	r15, r1
    12f2:	98 8b       	std	Y+16, r25	; 0x10
    12f4:	8f 87       	std	Y+15, r24	; 0x0f
static void measureAnalog() {
  uint32_t temp = 0;
	uint8_t adcLow = 0; 
  uint8_t adcHigh = 0;
  for (uint8_t i = 0; i < ANALOG_IN_NUMBER; ++i) {
	  ADMUX &= 0xF0; // Clear mux
    12f6:	80 91 7c 00 	lds	r24, 0x007C
    12fa:	80 7f       	andi	r24, 0xF0	; 240
    12fc:	80 93 7c 00 	sts	0x007C, r24
    ADMUX |= (i + ADC_OFFSET);	 //Setup adc mux
    1300:	80 91 7c 00 	lds	r24, 0x007C
    1304:	89 80       	ldd	r8, Y+1	; 0x01
    1306:	88 29       	or	r24, r8
    1308:	80 93 7c 00 	sts	0x007C, r24
	  ADCSRA |= (1<<ADEN) | (1<<ADATE); // ADC enable & ADC auto trigger enable
    130c:	80 91 7a 00 	lds	r24, 0x007A
    1310:	80 6a       	ori	r24, 0xA0	; 160
    1312:	80 93 7a 00 	sts	0x007A, r24
	  ADCSRA |= (1<<ADSC); // Start measure
    1316:	80 91 7a 00 	lds	r24, 0x007A
    131a:	80 64       	ori	r24, 0x40	; 64
    131c:	80 93 7a 00 	sts	0x007A, r24
    1320:	2f 85       	ldd	r18, Y+15	; 0x0f
    1322:	38 89       	ldd	r19, Y+16	; 0x10
	  while ((ADCSRA & (1<<ADIF)) == 0); // Wait to finish
    1324:	80 91 7a 00 	lds	r24, 0x007A
    1328:	84 ff       	sbrs	r24, 4
    132a:	fc cf       	rjmp	.-8      	; 0x1324 <main+0x6ce>
    132c:	38 8b       	std	Y+16, r19	; 0x10
    132e:	2f 87       	std	Y+15, r18	; 0x0f
	  ADCSRA |= (1<<ADIF); // Clear ADC interrupt flag with a 1
    1330:	80 91 7a 00 	lds	r24, 0x007A
    1334:	80 61       	ori	r24, 0x10	; 16
    1336:	80 93 7a 00 	sts	0x007A, r24
	  ADCSRA &= ~(1<<ADEN) & ~(1<<ADATE); // ADC disabled & ADC auto trigger disabled
    133a:	80 91 7a 00 	lds	r24, 0x007A
    133e:	8f 75       	andi	r24, 0x5F	; 95
    1340:	80 93 7a 00 	sts	0x007A, r24
	  temp = ADCW;
    1344:	20 91 78 00 	lds	r18, 0x0078
    1348:	30 91 79 00 	lds	r19, 0x0079
#ifdef ADC_ENABLE_RAW	  
    gAnalogInputsRaw[i] = temp;
    134c:	d2 01       	movw	r26, r4
    134e:	2d 93       	st	X+, r18
    1350:	3d 93       	st	X+, r19
    1352:	2d 01       	movw	r4, r26
#endif
	  temp = (temp * 5 * 62) / 10;
    1354:	46 e3       	ldi	r20, 0x36	; 54
    1356:	51 e0       	ldi	r21, 0x01	; 1
    1358:	48 d5       	rcall	.+2704   	; 0x1dea <__umulhisi3>
    135a:	a7 01       	movw	r20, r14
    135c:	96 01       	movw	r18, r12
    135e:	a6 d5       	rcall	.+2892   	; 0x1eac <__udivmodsi4>
	  temp *= gAnalogMult[i];
    1360:	f1 01       	movw	r30, r2
    1362:	61 91       	ld	r22, Z+
    1364:	1f 01       	movw	r2, r30
    1366:	70 e0       	ldi	r23, 0x00	; 0
    1368:	80 e0       	ldi	r24, 0x00	; 0
    136a:	90 e0       	ldi	r25, 0x00	; 0
    136c:	4d d5       	rcall	.+2714   	; 0x1e08 <__mulsi3>
	  temp /= gAnalogDiv[i];
    136e:	ad 81       	ldd	r26, Y+5	; 0x05
    1370:	be 81       	ldd	r27, Y+6	; 0x06
    1372:	2d 91       	ld	r18, X+
    1374:	be 83       	std	Y+6, r27	; 0x06
    1376:	ad 83       	std	Y+5, r26	; 0x05
    1378:	30 e0       	ldi	r19, 0x00	; 0
    137a:	40 e0       	ldi	r20, 0x00	; 0
    137c:	50 e0       	ldi	r21, 0x00	; 0
    137e:	96 d5       	rcall	.+2860   	; 0x1eac <__udivmodsi4>
    1380:	89 01       	movw	r16, r18
    1382:	9a 01       	movw	r18, r20
	  adcHigh = temp / 1024;
    1384:	48 01       	movw	r8, r16
    1386:	59 01       	movw	r10, r18
    1388:	8a e0       	ldi	r24, 0x0A	; 10
    138a:	b6 94       	lsr	r11
    138c:	a7 94       	ror	r10
    138e:	97 94       	ror	r9
    1390:	87 94       	ror	r8
    1392:	8a 95       	dec	r24
    1394:	d1 f7       	brne	.-12     	; 0x138a <main+0x734>
    1396:	8b 86       	std	Y+11, r8	; 0x0b
    1398:	9c 86       	std	Y+12, r9	; 0x0c
    139a:	ad 86       	std	Y+13, r10	; 0x0d
    139c:	be 86       	std	Y+14, r11	; 0x0e
#endif //GRAPICSENABLED
}

void main(void) __attribute__ ((noreturn)); // Main never returns, saves a few bytes

void main(void) {
    139e:	4f 85       	ldd	r20, Y+15	; 0x0f
    13a0:	58 89       	ldd	r21, Y+16	; 0x10
    13a2:	41 50       	subi	r20, 0x01	; 1
    13a4:	50 40       	sbci	r21, 0x00	; 0
    13a6:	5a 87       	std	Y+10, r21	; 0x0a
    13a8:	49 87       	std	Y+9, r20	; 0x09
	  temp -= (uint16_t)(adcHigh) * 1024;
    13aa:	88 2d       	mov	r24, r8
    13ac:	90 e0       	ldi	r25, 0x00	; 0
    13ae:	98 2f       	mov	r25, r24
    13b0:	88 27       	eor	r24, r24
    13b2:	99 0f       	add	r25, r25
    13b4:	99 0f       	add	r25, r25
    13b6:	a0 e0       	ldi	r26, 0x00	; 0
    13b8:	b0 e0       	ldi	r27, 0x00	; 0
    13ba:	48 01       	movw	r8, r16
    13bc:	59 01       	movw	r10, r18
    13be:	88 1a       	sub	r8, r24
    13c0:	99 0a       	sbc	r9, r25
    13c2:	aa 0a       	sbc	r10, r26
    13c4:	bb 0a       	sbc	r11, r27
    13c6:	c5 01       	movw	r24, r10
    13c8:	b4 01       	movw	r22, r8
	  adcLow = (temp * 100) / 1024;
    13ca:	24 e6       	ldi	r18, 0x64	; 100
    13cc:	30 e0       	ldi	r19, 0x00	; 0
    13ce:	40 e0       	ldi	r20, 0x00	; 0
    13d0:	50 e0       	ldi	r21, 0x00	; 0
    13d2:	1a d5       	rcall	.+2612   	; 0x1e08 <__mulsi3>
    13d4:	dc 01       	movw	r26, r24
    13d6:	cb 01       	movw	r24, r22
    13d8:	ea e0       	ldi	r30, 0x0A	; 10
    13da:	b6 95       	lsr	r27
    13dc:	a7 95       	ror	r26
    13de:	97 95       	ror	r25
    13e0:	87 95       	ror	r24
    13e2:	ea 95       	dec	r30
    13e4:	d1 f7       	brne	.-12     	; 0x13da <main+0x784>
    13e6:	e9 85       	ldd	r30, Y+9	; 0x09
    13e8:	fa 85       	ldd	r31, Y+10	; 0x0a
    13ea:	80 83       	st	Z, r24
	
	  gAnalogInputs[i].low = adcLow;
    gAnalogInputs[i].high = adcHigh;
    13ec:	eb 85       	ldd	r30, Y+11	; 0x0b
    13ee:	af 85       	ldd	r26, Y+15	; 0x0f
    13f0:	b8 89       	ldd	r27, Y+16	; 0x10
    13f2:	ec 93       	st	X, r30

static void measureAnalog() {
  uint32_t temp = 0;
	uint8_t adcLow = 0; 
  uint8_t adcHigh = 0;
  for (uint8_t i = 0; i < ANALOG_IN_NUMBER; ++i) {
    13f4:	f9 81       	ldd	r31, Y+1	; 0x01
    13f6:	ff 5f       	subi	r31, 0xFF	; 255
    13f8:	f9 83       	std	Y+1, r31	; 0x01
    13fa:	12 96       	adiw	r26, 0x02	; 2
    13fc:	b8 8b       	std	Y+16, r27	; 0x10
    13fe:	af 87       	std	Y+15, r26	; 0x0f
    1400:	f4 30       	cpi	r31, 0x04	; 4
    1402:	09 f0       	breq	.+2      	; 0x1406 <main+0x7b0>
    1404:	78 cf       	rjmp	.-272    	; 0x12f6 <main+0x6a0>
	return outMax - value + outMin;
}
*/
static void updateSensors() {
#ifdef SENSOR_VOLTAGE_1_ENABLED
    gSensorVoltage1 = gAnalogInputs[ANALOG_IN_1];
    1406:	80 91 31 04 	lds	r24, 0x0431
    140a:	90 91 32 04 	lds	r25, 0x0432
    140e:	90 93 30 04 	sts	0x0430, r25
    1412:	80 93 2f 04 	sts	0x042F, r24
#endif
#ifdef SENSOR_VOLTAGE_2_ENABLED
    gSensorVoltage2 = gAnalogInputs[ANALOG_IN_2];
    1416:	80 91 33 04 	lds	r24, 0x0433
    141a:	90 91 34 04 	lds	r25, 0x0434
    141e:	90 93 3a 04 	sts	0x043A, r25
    1422:	80 93 39 04 	sts	0x0439, r24
static void updateSensors() { DUMMY_FUNC }

#else //ADC_ENABLED

static uint8_t calcGenericVoltageLevel(uint8_t adcInput, uint16_t inMin, uint16_t inMax, uint16_t outMin, uint16_t outMax) {
	uint16_t level = ((gAnalogInputs[adcInput].high * 100) + gAnalogInputs[adcInput].low);
    1426:	20 91 36 04 	lds	r18, 0x0436
    142a:	84 e6       	ldi	r24, 0x64	; 100
    142c:	28 9f       	mul	r18, r24
    142e:	90 01       	movw	r18, r0
    1430:	11 24       	eor	r1, r1
    1432:	80 91 35 04 	lds	r24, 0x0435
    1436:	28 0f       	add	r18, r24
    1438:	31 1d       	adc	r19, r1
	if (level > inMax) {
    143a:	41 e0       	ldi	r20, 0x01	; 1
    143c:	25 3f       	cpi	r18, 0xF5	; 245
    143e:	34 07       	cpc	r19, r20
    1440:	08 f0       	brcs	.+2      	; 0x1444 <main+0x7ee>
    1442:	b8 c1       	rjmp	.+880    	; 0x17b4 <main+0xb5e>
		level = outMax;
	}		
	else if (level > inMin) {
    1444:	29 37       	cpi	r18, 0x79	; 121
    1446:	31 05       	cpc	r19, r1
    1448:	08 f4       	brcc	.+2      	; 0x144c <main+0x7f6>
    144a:	c3 c1       	rjmp	.+902    	; 0x17d2 <main+0xb7c>
		level -= inMin;
    144c:	28 57       	subi	r18, 0x78	; 120
    144e:	30 40       	sbci	r19, 0x00	; 0
		level *= outMax - outMin;
    1450:	44 e6       	ldi	r20, 0x64	; 100
    1452:	50 e0       	ldi	r21, 0x00	; 0
    1454:	24 9f       	mul	r18, r20
    1456:	c0 01       	movw	r24, r0
    1458:	25 9f       	mul	r18, r21
    145a:	90 0d       	add	r25, r0
    145c:	34 9f       	mul	r19, r20
    145e:	90 0d       	add	r25, r0
    1460:	11 24       	eor	r1, r1
		level /= inMax - inMin;
    1462:	6c e7       	ldi	r22, 0x7C	; 124
    1464:	71 e0       	ldi	r23, 0x01	; 1
    1466:	fb d4       	rcall	.+2550   	; 0x1e5e <__udivmodhi4>
	if (level > inMax) {
		level = outMax;
	}		
	else if (level > inMin) {
		level -= inMin;
		level *= outMax - outMin;
    1468:	21 e0       	ldi	r18, 0x01	; 1
    146a:	6e 31       	cpi	r22, 0x1E	; 30
    146c:	08 f0       	brcs	.+2      	; 0x1470 <main+0x81a>
    146e:	20 e0       	ldi	r18, 0x00	; 0
#endif
#ifdef SENSOR_RSSI_ENABLED
#ifdef SENSOR_RSSI_REVERSED
   gSensorRssi = calcGenericVoltageLevelReverse(SENSOR_RSSI_INPUT, RSSI_MIN_VOLTAGE_INT, RSSI_MAX_VOLTAGE_INT, 0, 100);
#else
   gSensorRssi = calcGenericVoltageLevel(SENSOR_RSSI_INPUT, RSSI_MIN_VOLTAGE_INT, RSSI_MAX_VOLTAGE_INT, 0, 100);
    1470:	60 93 3b 04 	sts	0x043B, r22
	gAlarmDistance = (gHomeDistance > ALARM_DISTANCE_HIGH);
#endif
#endif //GPS_ENABLED

#ifdef ALARM_BATT1_LOW_INT
	gAlarmBatt1 = ((gSensorVoltage1.high * 100) + gSensorVoltage1.low) < ALARM_BATT1_LOW_INT;
    1474:	90 91 30 04 	lds	r25, 0x0430
    1478:	84 e6       	ldi	r24, 0x64	; 100
    147a:	98 9f       	mul	r25, r24
    147c:	c0 01       	movw	r24, r0
    147e:	11 24       	eor	r1, r1
    1480:	30 91 2f 04 	lds	r19, 0x042F
    1484:	83 0f       	add	r24, r19
    1486:	91 1d       	adc	r25, r1
    1488:	31 e0       	ldi	r19, 0x01	; 1
    148a:	53 e0       	ldi	r21, 0x03	; 3
    148c:	88 3e       	cpi	r24, 0xE8	; 232
    148e:	95 07       	cpc	r25, r21
    1490:	08 f0       	brcs	.+2      	; 0x1494 <main+0x83e>
    1492:	30 e0       	ldi	r19, 0x00	; 0
    1494:	30 93 3c 04 	sts	0x043C, r19
#ifdef ALARM_POWER_USAGE_HIGH
  gAlarmPowerUsage = (gSensorPowerUsage/1000) < ALARM_POWER_USAGE_HIGH;
#endif
#else // ANALOG_IN_NUMBER > 2
#ifdef ALARM_BATT2_LOW_INT
	gAlarmBatt2 = ((gSensorVoltage2.high * 100) + gSensorVoltage2.low) < ALARM_BATT2_LOW_INT; //Bugfix thanks to Benson
    1498:	90 91 3a 04 	lds	r25, 0x043A
    149c:	84 e6       	ldi	r24, 0x64	; 100
    149e:	98 9f       	mul	r25, r24
    14a0:	c0 01       	movw	r24, r0
    14a2:	11 24       	eor	r1, r1
    14a4:	30 91 39 04 	lds	r19, 0x0439
    14a8:	83 0f       	add	r24, r19
    14aa:	91 1d       	adc	r25, r1
    14ac:	31 e0       	ldi	r19, 0x01	; 1
    14ae:	63 e0       	ldi	r22, 0x03	; 3
    14b0:	88 3e       	cpi	r24, 0xE8	; 232
    14b2:	96 07       	cpc	r25, r22
    14b4:	08 f0       	brcs	.+2      	; 0x14b8 <main+0x862>
    14b6:	30 e0       	ldi	r19, 0x00	; 0
    14b8:	30 93 3d 04 	sts	0x043D, r19
#endif
#ifdef ALARM_RSSI_LOW
	gAlarmRssi = gSensorRssi < ALARM_RSSI_LOW;
    14bc:	20 93 3e 04 	sts	0x043E, r18
    14c0:	63 cc       	rjmp	.-1850   	; 0xd88 <main+0x132>
#endif //GPS_ENABLED
  }
  // --------------- TEXT LINE 4 (From top) -----------------------
  else if (textId == 3) {
#ifdef GPS_ENABLED
        printText(gText[textId], pos, "ALT"); //ALTITUDE
    14c2:	88 e1       	ldi	r24, 0x18	; 24
    14c4:	92 e0       	ldi	r25, 0x02	; 2
    14c6:	60 e0       	ldi	r22, 0x00	; 0
    14c8:	41 e4       	ldi	r20, 0x41	; 65
    14ca:	51 e0       	ldi	r21, 0x01	; 1
    14cc:	40 d7       	rcall	.+3712   	; 0x234e <__data_load_end+0x35a>
	  
		  
	 else pos = printText(gText[textId], 5, "=");
*/	 
	
		 pos = printNumber(gText[textId], 7 , gGpsLastValidData.pos.altitude - gHomePos.altitude); // Altitude
    14ce:	20 91 a2 01 	lds	r18, 0x01A2
    14d2:	30 91 a3 01 	lds	r19, 0x01A3
    14d6:	80 91 98 01 	lds	r24, 0x0198
    14da:	90 91 99 01 	lds	r25, 0x0199
    14de:	28 1b       	sub	r18, r24
    14e0:	39 0b       	sbc	r19, r25
    14e2:	44 27       	eor	r20, r20
    14e4:	37 fd       	sbrc	r19, 7
    14e6:	40 95       	com	r20
    14e8:	54 2f       	mov	r21, r20
    14ea:	88 e1       	ldi	r24, 0x18	; 24
    14ec:	92 e0       	ldi	r25, 0x02	; 2
    14ee:	67 e0       	ldi	r22, 0x07	; 7
    14f0:	80 d6       	rcall	.+3328   	; 0x21f2 <__data_load_end+0x1fe>
	   		
	  
          pos = printText(gText[textId],TEXT_LINE_MAX_CHARS-8 , "HDG");
    14f2:	88 e1       	ldi	r24, 0x18	; 24
    14f4:	92 e0       	ldi	r25, 0x02	; 2
    14f6:	69 e1       	ldi	r22, 0x19	; 25
    14f8:	45 e4       	ldi	r20, 0x45	; 69
    14fa:	51 e0       	ldi	r21, 0x01	; 1
    14fc:	28 d7       	rcall	.+3664   	; 0x234e <__data_load_end+0x35a>
		  pos = printNumber(gText[textId], TEXT_LINE_MAX_CHARS-4, gGpsLastValidData.angle);
    14fe:	20 91 ac 01 	lds	r18, 0x01AC
    1502:	30 91 ad 01 	lds	r19, 0x01AD
    1506:	40 e0       	ldi	r20, 0x00	; 0
    1508:	50 e0       	ldi	r21, 0x00	; 0
    150a:	88 e1       	ldi	r24, 0x18	; 24
    150c:	92 e0       	ldi	r25, 0x02	; 2
    150e:	6d e1       	ldi	r22, 0x1D	; 29
    1510:	70 d6       	rcall	.+3296   	; 0x21f2 <__data_load_end+0x1fe>
    1512:	8a cc       	rjmp	.-1772   	; 0xe28 <main+0x1d2>
	if (gTime.hour < 10) {
		str[pos++] = '0';
	}
	pos = printNumberWithUnit(str, pos, gTime.hour, ":");
#endif //TIME_HOUR_ENABLED
	if (gTime.min < 10) {
    1514:	6b e1       	ldi	r22, 0x1B	; 27
    1516:	a7 ce       	rjmp	.-690    	; 0x1266 <main+0x610>
}

static void drawArrow(uint16_t angle) {
	drawCircle(GRAPHICS_MID, GRAPHICS_MID, GRAPHICS_MID);
	if (gHomeDistance < 10) {
	  drawCircle(GRAPHICS_MID, GRAPHICS_MID, 2);
    1518:	82 e0       	ldi	r24, 0x02	; 2
    151a:	15 db       	rcall	.-2518   	; 0xb46 <drawCircle.constprop.9>
    151c:	f0 cb       	rjmp	.-2080   	; 0xcfe <main+0xa8>
	  return;
	}
	if (gGpsLastData.fix == 0) {
		drawLine(GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4));
    151e:	85 e0       	ldi	r24, 0x05	; 5
    1520:	65 e0       	ldi	r22, 0x05	; 5
    1522:	41 e1       	ldi	r20, 0x11	; 17
    1524:	21 e1       	ldi	r18, 0x11	; 17
    1526:	8c da       	rcall	.-2792   	; 0xa40 <drawLine>
		drawLine(GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID - (GRAPHICS_SIZE/4));
    1528:	85 e0       	ldi	r24, 0x05	; 5
    152a:	61 e1       	ldi	r22, 0x11	; 17
    152c:	41 e1       	ldi	r20, 0x11	; 17
    152e:	25 e0       	ldi	r18, 0x05	; 5
    1530:	87 da       	rcall	.-2802   	; 0xa40 <drawLine>
    1532:	e5 cb       	rjmp	.-2102   	; 0xcfe <main+0xa8>
  // --------------- TEXT LINE 3 (From top) -----------------------
  else if (textId == 2) {
	 
#ifdef GPS_ENABLED
	  if (gHomePosSet) {
			 pos = printText(gText[textId], pos, "\146");
    1534:	87 ef       	ldi	r24, 0xF7	; 247
    1536:	91 e0       	ldi	r25, 0x01	; 1
    1538:	60 e0       	ldi	r22, 0x00	; 0
    153a:	40 e3       	ldi	r20, 0x30	; 48
    153c:	51 e0       	ldi	r21, 0x01	; 1
    153e:	07 d7       	rcall	.+3598   	; 0x234e <__data_load_end+0x35a>
			 pos = printText(gText[textId], 2, "MT");
    1540:	87 ef       	ldi	r24, 0xF7	; 247
    1542:	91 e0       	ldi	r25, 0x01	; 1
    1544:	62 e0       	ldi	r22, 0x02	; 2
    1546:	42 e3       	ldi	r20, 0x32	; 50
    1548:	51 e0       	ldi	r21, 0x01	; 1
    154a:	01 d7       	rcall	.+3586   	; 0x234e <__data_load_end+0x35a>
			 pos = printNumber(gText[textId], 5 , gHomeDistance);
    154c:	20 91 2b 04 	lds	r18, 0x042B
    1550:	30 91 2c 04 	lds	r19, 0x042C
    1554:	40 91 2d 04 	lds	r20, 0x042D
    1558:	50 91 2e 04 	lds	r21, 0x042E
    155c:	87 ef       	ldi	r24, 0xF7	; 247
    155e:	91 e0       	ldi	r25, 0x01	; 1
    1560:	65 e0       	ldi	r22, 0x05	; 5
    1562:	47 d6       	rcall	.+3214   	; 0x21f2 <__data_load_end+0x1fe>
    1564:	61 cc       	rjmp	.-1854   	; 0xe28 <main+0x1d2>
static void decodeGpsData(char data) {
	if (gGpsTextPartStep == GPS_PART_FINISHED && data != '$') {
		return;
	}
	
	switch (data) {
    1566:	1a 32       	cpi	r17, 0x2A	; 42
    1568:	41 f0       	breq	.+16     	; 0x157a <main+0x924>
    156a:	1c 32       	cpi	r17, 0x2C	; 44
    156c:	09 f0       	breq	.+2      	; 0x1570 <main+0x91a>
    156e:	ef cc       	rjmp	.-1570   	; 0xf4e <main+0x2f8>
		clearFullGpsText();
		gGpsFullTextPos = 0;
#endif // FULLGPSTEXT
		break;
	case ',':
		gGpsChecksum ^= data;
    1570:	80 91 d1 03 	lds	r24, 0x03D1
    1574:	81 27       	eor	r24, r17
    1576:	80 93 d1 03 	sts	0x03D1, r24
	case '*':
		parseGpsPart();
    157a:	a9 d8       	rcall	.-3758   	; 0x6ce <parseGpsPart>
    157c:	e2 ed       	ldi	r30, 0xD2	; 210
    157e:	f3 e0       	ldi	r31, 0x03	; 3
static uint8_t gGpsTextPartLength = 0;
#endif //GPS_PART_TEXT

static void clearGpsText() {
	for (uint8_t i = 0; i < GPS_MAX_CHARS; ++i) {
		gGpsText[i] = 0;
    1580:	11 92       	st	Z+, r1
static char gGpsTextPart[GPS_MAX_CHARS];
static uint8_t gGpsTextPartLength = 0;
#endif //GPS_PART_TEXT

static void clearGpsText() {
	for (uint8_t i = 0; i < GPS_MAX_CHARS; ++i) {
    1582:	33 e0       	ldi	r19, 0x03	; 3
    1584:	ed 3d       	cpi	r30, 0xDD	; 221
    1586:	f3 07       	cpc	r31, r19
    1588:	d9 f7       	brne	.-10     	; 0x1580 <main+0x92a>
	case ',':
		gGpsChecksum ^= data;
	case '*':
		parseGpsPart();
		clearGpsText();		
		gGpsTextPos = 0;
    158a:	10 92 cf 03 	sts	0x03CF, r1
		gGpsTextPartStep++;
    158e:	80 91 5d 01 	lds	r24, 0x015D
    1592:	8f 5f       	subi	r24, 0xFF	; 255
    1594:	80 93 5d 01 	sts	0x015D, r24
		if (data =='*') {
    1598:	1a 32       	cpi	r17, 0x2A	; 42
    159a:	09 f0       	breq	.+2      	; 0x159e <main+0x948>
    159c:	b4 cb       	rjmp	.-2200   	; 0xd06 <main+0xb0>
			gGpsTextPartStep = GPS_PART_CHECKSUM;
    159e:	88 ec       	ldi	r24, 0xC8	; 200
    15a0:	80 93 5d 01 	sts	0x015D, r24
    15a4:	b0 cb       	rjmp	.-2208   	; 0xd06 <main+0xb0>
#else //GPS_ENABLED
  if (gGpsLastData.fix != 0) {
		PORTD |= LED;
	}
	else {
		PORTD ^= LED;
    15a6:	8b b1       	in	r24, 0x0b	; 11
    15a8:	98 e0       	ldi	r25, 0x08	; 8
    15aa:	89 27       	eor	r24, r25
    15ac:	8b b9       	out	0x0b, r24	; 11
	
#ifdef DEBUG
  //testCalcHome();
#endif // DEBUG
  
	if (gHomePosSet) {
    15ae:	80 91 b3 01 	lds	r24, 0x01B3
    15b2:	88 23       	and	r24, r24
    15b4:	09 f4       	brne	.+2      	; 0x15b8 <main+0x962>
    15b6:	89 ce       	rjmp	.-750    	; 0x12ca <main+0x674>
	  calcHome(gGpsLastValidData.pos.latitude,
    15b8:	c0 90 9a 01 	lds	r12, 0x019A
    15bc:	d0 90 9b 01 	lds	r13, 0x019B
    15c0:	e0 90 9c 01 	lds	r14, 0x019C
    15c4:	f0 90 9d 01 	lds	r15, 0x019D
    15c8:	20 90 9e 01 	lds	r2, 0x019E
    15cc:	30 90 9f 01 	lds	r3, 0x019F
    15d0:	40 90 a0 01 	lds	r4, 0x01A0
    15d4:	50 90 a1 01 	lds	r5, 0x01A1
    15d8:	80 90 90 01 	lds	r8, 0x0190
    15dc:	90 90 91 01 	lds	r9, 0x0191
    15e0:	a0 90 92 01 	lds	r10, 0x0192
    15e4:	b0 90 93 01 	lds	r11, 0x0193
    15e8:	40 91 94 01 	lds	r20, 0x0194
    15ec:	50 91 95 01 	lds	r21, 0x0195
    15f0:	60 91 96 01 	lds	r22, 0x0196
    15f4:	70 91 97 01 	lds	r23, 0x0197
    15f8:	49 83       	std	Y+1, r20	; 0x01
    15fa:	5a 83       	std	Y+2, r21	; 0x02
    15fc:	6b 83       	std	Y+3, r22	; 0x03
    15fe:	7c 83       	std	Y+4, r23	; 0x04

  // considers flat earth around vehicle and reference

  // Ernani Reis, Aug 2011
  
  if (currLat == homeLat && currLong == homeLong) {
    1600:	c8 14       	cp	r12, r8
    1602:	d9 04       	cpc	r13, r9
    1604:	ea 04       	cpc	r14, r10
    1606:	fb 04       	cpc	r15, r11
    1608:	09 f4       	brne	.+2      	; 0x160c <main+0x9b6>
    160a:	18 c2       	rjmp	.+1072   	; 0x1a3c <main+0xde6>
  int32_t deltaLat; 
  int32_t deltaLong;
  uint32_t distance;
  uint16_t bearing;
      
  c = myCos(absi32(homeLat + currLat) / 2000000); // c ~ cos(lat) -> long to fix the delta
    160c:	d7 01       	movw	r26, r14
    160e:	c6 01       	movw	r24, r12
    1610:	88 0d       	add	r24, r8
    1612:	99 1d       	adc	r25, r9
    1614:	aa 1d       	adc	r26, r10
    1616:	bb 1d       	adc	r27, r11
#ifndef COMMONUTILS_H_
#define COMMONUTILS_H_

// abs seems to only support 16 bits so I had to make my own.
static uint32_t absi32(int32_t a) {
	return (a > 0) ? a : -a;
    1618:	b7 fd       	sbrc	r27, 7
    161a:	81 c2       	rjmp	.+1282   	; 0x1b1e <main+0xec8>
    161c:	bc 01       	movw	r22, r24
    161e:	cd 01       	movw	r24, r26
    1620:	20 e8       	ldi	r18, 0x80	; 128
    1622:	34 e8       	ldi	r19, 0x84	; 132
    1624:	4e e1       	ldi	r20, 0x1E	; 30
    1626:	50 e0       	ldi	r21, 0x00	; 0
    1628:	41 d4       	rcall	.+2178   	; 0x1eac <__udivmodsi4>
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
}

static int8_t myCos(uint16_t angle) {
	return mySin(angle + 90);
    162a:	c9 01       	movw	r24, r18
    162c:	86 5a       	subi	r24, 0xA6	; 166
    162e:	9f 4f       	sbci	r25, 0xFF	; 255
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    1630:	68 e6       	ldi	r22, 0x68	; 104
    1632:	71 e0       	ldi	r23, 0x01	; 1
    1634:	14 d4       	rcall	.+2088   	; 0x1e5e <__udivmodhi4>
	int8_t mult = 1;
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    1636:	84 3b       	cpi	r24, 0xB4	; 180
    1638:	91 05       	cpc	r25, r1
    163a:	08 f4       	brcc	.+2      	; 0x163e <main+0x9e8>
    163c:	19 c2       	rjmp	.+1074   	; 0x1a70 <main+0xe1a>
		pos = pos - 180;
    163e:	84 5b       	subi	r24, 0xB4	; 180
    1640:	90 40       	sbci	r25, 0x00	; 0
    1642:	5f ef       	ldi	r21, 0xFF	; 255
    1644:	5d 83       	std	Y+5, r21	; 0x05
		mult = -1;
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
    1646:	8a 35       	cpi	r24, 0x5A	; 90
    1648:	91 05       	cpc	r25, r1
    164a:	30 f0       	brcs	.+12     	; 0x1658 <main+0xa02>
		pos = 180 - pos;
    164c:	24 eb       	ldi	r18, 0xB4	; 180
    164e:	30 e0       	ldi	r19, 0x00	; 0
    1650:	a9 01       	movw	r20, r18
    1652:	48 1b       	sub	r20, r24
    1654:	59 0b       	sbc	r21, r25
    1656:	ca 01       	movw	r24, r20
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
    1658:	8c 5c       	subi	r24, 0xCC	; 204
    165a:	9f 4f       	sbci	r25, 0xFF	; 255
    165c:	fc 01       	movw	r30, r24
    165e:	44 91       	lpm	r20, Z

  int32_t currLatSec100 = wgs84ToSec100(currLat); // Convert wgs84 to sec * 100
    1660:	c7 01       	movw	r24, r14
    1662:	b6 01       	movw	r22, r12
    1664:	4f 8b       	std	Y+23, r20	; 0x17
    1666:	30 d5       	rcall	.+2656   	; 0x20c8 <__data_load_end+0xd4>
    1668:	8b 01       	movw	r16, r22
    166a:	9c 01       	movw	r18, r24
  int32_t homeLatSec100 = wgs84ToSec100(homeLat);
    166c:	c5 01       	movw	r24, r10
    166e:	b4 01       	movw	r22, r8
    1670:	2b 8b       	std	Y+19, r18	; 0x13
    1672:	3c 8b       	std	Y+20, r19	; 0x14
    1674:	29 d5       	rcall	.+2642   	; 0x20c8 <__data_load_end+0xd4>
    1676:	4b 01       	movw	r8, r22
    1678:	5c 01       	movw	r10, r24
  int32_t currLongSec100 = wgs84ToSec100(currLong);
    167a:	c2 01       	movw	r24, r4
    167c:	b1 01       	movw	r22, r2
    167e:	24 d5       	rcall	.+2632   	; 0x20c8 <__data_load_end+0xd4>
    1680:	6b 01       	movw	r12, r22
    1682:	7c 01       	movw	r14, r24
  int32_t homeLongSec100 = wgs84ToSec100(homeLong);
    1684:	69 81       	ldd	r22, Y+1	; 0x01
    1686:	7a 81       	ldd	r23, Y+2	; 0x02
    1688:	8b 81       	ldd	r24, Y+3	; 0x03
    168a:	9c 81       	ldd	r25, Y+4	; 0x04
    168c:	1d d5       	rcall	.+2618   	; 0x20c8 <__data_load_end+0xd4>

  deltaLong = homeLongSec100 - currLongSec100; // Calculate deltas
    168e:	6c 19       	sub	r22, r12
    1690:	7d 09       	sbc	r23, r13
    1692:	8e 09       	sbc	r24, r14
    1694:	9f 09       	sbc	r25, r15
  deltaLat = homeLatSec100 - currLatSec100; // delta long ainda com erro (Delta still long with error?)
    1696:	2b 89       	ldd	r18, Y+19	; 0x13
    1698:	3c 89       	ldd	r19, Y+20	; 0x14
    169a:	80 1a       	sub	r8, r16
    169c:	91 0a       	sbc	r9, r17
    169e:	a2 0a       	sbc	r10, r18
    16a0:	b3 0a       	sbc	r11, r19
    16a2:	4f 89       	ldd	r20, Y+23	; 0x17
    16a4:	3d 81       	ldd	r19, Y+5	; 0x05
    16a6:	43 9f       	mul	r20, r19
    16a8:	20 2d       	mov	r18, r0
    16aa:	11 24       	eor	r1, r1

  deltaLong = deltaLong * c;   // corrige dla p/ lat da regio
    16ac:	33 27       	eor	r19, r19
    16ae:	27 fd       	sbrc	r18, 7
    16b0:	30 95       	com	r19
    16b2:	43 2f       	mov	r20, r19
    16b4:	53 2f       	mov	r21, r19
    16b6:	a8 d3       	rcall	.+1872   	; 0x1e08 <__mulsi3>
  deltaLong = deltaLong / 100; // cosine is 0-100 so divide with 100
    16b8:	24 e6       	ldi	r18, 0x64	; 100
    16ba:	30 e0       	ldi	r19, 0x00	; 0
    16bc:	40 e0       	ldi	r20, 0x00	; 0
    16be:	50 e0       	ldi	r21, 0x00	; 0
    16c0:	17 d4       	rcall	.+2094   	; 0x1ef0 <__divmodsi4>
    16c2:	69 01       	movw	r12, r18
    16c4:	7a 01       	movw	r14, r20

  // Make sure we don't go over uin32_t when doing sqr of deltaLong & deltaLat
  uint8_t mult = 1;
  while ((absi32(deltaLong) >= 0xFFFF) 
         || (absi32(deltaLat) >= 0xFFFF)) {
	  deltaLong /= 2;
    16c6:	f2 e0       	ldi	r31, 0x02	; 2
    16c8:	2f 2e       	mov	r2, r31
    16ca:	31 2c       	mov	r3, r1
    16cc:	41 2c       	mov	r4, r1
    16ce:	51 2c       	mov	r5, r1
    16d0:	11 e0       	ldi	r17, 0x01	; 1
    16d2:	24 c0       	rjmp	.+72     	; 0x171c <main+0xac6>
  deltaLong = deltaLong * c;   // corrige dla p/ lat da regio
  deltaLong = deltaLong / 100; // cosine is 0-100 so divide with 100

  // Make sure we don't go over uin32_t when doing sqr of deltaLong & deltaLat
  uint8_t mult = 1;
  while ((absi32(deltaLong) >= 0xFFFF) 
    16d4:	4f 3f       	cpi	r20, 0xFF	; 255
    16d6:	8f ef       	ldi	r24, 0xFF	; 255
    16d8:	58 07       	cpc	r21, r24
    16da:	80 e0       	ldi	r24, 0x00	; 0
    16dc:	68 07       	cpc	r22, r24
    16de:	80 e0       	ldi	r24, 0x00	; 0
    16e0:	78 07       	cpc	r23, r24
    16e2:	68 f4       	brcc	.+26     	; 0x16fe <main+0xaa8>
    16e4:	d5 01       	movw	r26, r10
    16e6:	c4 01       	movw	r24, r8
    16e8:	b7 fc       	sbrc	r11, 7
    16ea:	76 c0       	rjmp	.+236    	; 0x17d8 <main+0xb82>
         || (absi32(deltaLat) >= 0xFFFF)) {
    16ec:	8f 3f       	cpi	r24, 0xFF	; 255
    16ee:	ef ef       	ldi	r30, 0xFF	; 255
    16f0:	9e 07       	cpc	r25, r30
    16f2:	e0 e0       	ldi	r30, 0x00	; 0
    16f4:	ae 07       	cpc	r26, r30
    16f6:	e0 e0       	ldi	r30, 0x00	; 0
    16f8:	be 07       	cpc	r27, r30
    16fa:	08 f4       	brcc	.+2      	; 0x16fe <main+0xaa8>
    16fc:	75 c0       	rjmp	.+234    	; 0x17e8 <main+0xb92>
	  deltaLong /= 2;
    16fe:	c7 01       	movw	r24, r14
    1700:	b6 01       	movw	r22, r12
    1702:	a2 01       	movw	r20, r4
    1704:	91 01       	movw	r18, r2
    1706:	f4 d3       	rcall	.+2024   	; 0x1ef0 <__divmodsi4>
    1708:	69 01       	movw	r12, r18
    170a:	7a 01       	movw	r14, r20
	  deltaLat /= 2;
    170c:	c5 01       	movw	r24, r10
    170e:	b4 01       	movw	r22, r8
    1710:	a2 01       	movw	r20, r4
    1712:	91 01       	movw	r18, r2
    1714:	ed d3       	rcall	.+2010   	; 0x1ef0 <__divmodsi4>
    1716:	49 01       	movw	r8, r18
    1718:	5a 01       	movw	r10, r20
	  mult *= 2;
    171a:	11 0f       	add	r17, r17
    171c:	b7 01       	movw	r22, r14
    171e:	a6 01       	movw	r20, r12
    1720:	f7 fe       	sbrs	r15, 7
    1722:	d8 cf       	rjmp	.-80     	; 0x16d4 <main+0xa7e>
    1724:	44 27       	eor	r20, r20
    1726:	55 27       	eor	r21, r21
    1728:	ba 01       	movw	r22, r20
    172a:	4c 19       	sub	r20, r12
    172c:	5d 09       	sbc	r21, r13
    172e:	6e 09       	sbc	r22, r14
    1730:	7f 09       	sbc	r23, r15
    1732:	d0 cf       	rjmp	.-96     	; 0x16d4 <main+0xa7e>
		}			
	}
}

static void decodeGpsData(char data) {
	if (gGpsTextPartStep == GPS_PART_FINISHED && data != '$') {
    1734:	14 32       	cpi	r17, 0x24	; 36
    1736:	09 f0       	breq	.+2      	; 0x173a <main+0xae4>
    1738:	e6 ca       	rjmp	.-2612   	; 0xd06 <main+0xb0>
		return;
	}
	
	switch (data) {
	case '$':
		gGpsTextPos = 0;
    173a:	10 92 cf 03 	sts	0x03CF, r1
		gGpsTextType = GPS_TYPE_NONE;
    173e:	10 92 d0 03 	sts	0x03D0, r1
		gGpsChecksum = 0;
    1742:	10 92 d1 03 	sts	0x03D1, r1
		gGpsTextPartStep = 0;
    1746:	10 92 5d 01 	sts	0x015D, r1
    174a:	e2 ed       	ldi	r30, 0xD2	; 210
    174c:	f3 e0       	ldi	r31, 0x03	; 3
static uint8_t gGpsTextPartLength = 0;
#endif //GPS_PART_TEXT

static void clearGpsText() {
	for (uint8_t i = 0; i < GPS_MAX_CHARS; ++i) {
		gGpsText[i] = 0;
    174e:	11 92       	st	Z+, r1
static char gGpsTextPart[GPS_MAX_CHARS];
static uint8_t gGpsTextPartLength = 0;
#endif //GPS_PART_TEXT

static void clearGpsText() {
	for (uint8_t i = 0; i < GPS_MAX_CHARS; ++i) {
    1750:	23 e0       	ldi	r18, 0x03	; 3
    1752:	ed 3d       	cpi	r30, 0xDD	; 221
    1754:	f2 07       	cpc	r31, r18
    1756:	d9 f7       	brne	.-10     	; 0x174e <main+0xaf8>
    1758:	d6 ca       	rjmp	.-2644   	; 0xd06 <main+0xb0>
			gGpsTextPartStep = GPS_PART_CHECKSUM;
		}			
		break;
	case '\r':
	case '\n':
	  parseGpsPart();
    175a:	b9 d7       	rcall	.+3954   	; 0x26ce <__data_load_end+0x6da>
	  gGpsTextPartStep = GPS_PART_FINISHED;
    175c:	4f ef       	ldi	r20, 0xFF	; 255
    175e:	40 93 5d 01 	sts	0x015D, r20



static void finishGpsDecoding() {
	
if (gGpsLastData.pos.altitude > gGpsLastValidData.pos.altitude) 
    1762:	20 91 7f 01 	lds	r18, 0x017F
    1766:	30 91 80 01 	lds	r19, 0x0180
    176a:	80 91 a2 01 	lds	r24, 0x01A2
    176e:	90 91 a3 01 	lds	r25, 0x01A3
    1772:	82 17       	cp	r24, r18
    1774:	93 07       	cpc	r25, r19
    1776:	0c f0       	brlt	.+2      	; 0x177a <main+0xb24>
    1778:	74 c1       	rjmp	.+744    	; 0x1a62 <main+0xe0c>
altitudeArrow = 1;
    177a:	81 e0       	ldi	r24, 0x01	; 1
    177c:	80 93 dd 03 	sts	0x03DD, r24
		
else if (gGpsLastData.pos.altitude < gGpsLastValidData.pos.altitude)
altitudeArrow = -1;


	if (gGpsLastData.checksumValid != 0) {
    1780:	80 91 8f 01 	lds	r24, 0x018F
    1784:	88 23       	and	r24, r24
    1786:	09 f4       	brne	.+2      	; 0x178a <main+0xb34>
    1788:	be ca       	rjmp	.-2692   	; 0xd06 <main+0xb0>

		gGpsLastValidData = gGpsLastData;
    178a:	aa e9       	ldi	r26, 0x9A	; 154
    178c:	b1 e0       	ldi	r27, 0x01	; 1
    178e:	e7 e7       	ldi	r30, 0x77	; 119
    1790:	f1 e0       	ldi	r31, 0x01	; 1
    1792:	89 e1       	ldi	r24, 0x19	; 25
    1794:	01 90       	ld	r0, Z+
    1796:	0d 92       	st	X+, r0
    1798:	81 50       	subi	r24, 0x01	; 1
    179a:	e1 f7       	brne	.-8      	; 0x1794 <main+0xb3e>
		gGpsValidData = 1;
    179c:	81 e0       	ldi	r24, 0x01	; 1
    179e:	80 93 de 03 	sts	0x03DE, r24
		gLastFix = gTime;
    17a2:	80 91 72 01 	lds	r24, 0x0172
    17a6:	90 91 73 01 	lds	r25, 0x0173
    17aa:	90 93 e0 03 	sts	0x03E0, r25
    17ae:	80 93 df 03 	sts	0x03DF, r24
    17b2:	a9 ca       	rjmp	.-2734   	; 0xd06 <main+0xb0>

#else //ADC_ENABLED

static uint8_t calcGenericVoltageLevel(uint8_t adcInput, uint16_t inMin, uint16_t inMax, uint16_t outMin, uint16_t outMax) {
	uint16_t level = ((gAnalogInputs[adcInput].high * 100) + gAnalogInputs[adcInput].low);
	if (level > inMax) {
    17b4:	20 e0       	ldi	r18, 0x00	; 0
    17b6:	64 e6       	ldi	r22, 0x64	; 100
    17b8:	5b ce       	rjmp	.-842    	; 0x1470 <main+0x81a>
	a = (a * (GRAPHICS_SIZE / 3)) / 100;
	b = (b * (GRAPHICS_SIZE / 3)) / 100;
	drawLine(GRAPHICS_MID - b, GRAPHICS_MID + a, GRAPHICS_MID + b, GRAPHICS_MID - a); //Direction line
	//drawLine(GRAPHICS_MID_X + a/2, GRAPHICS_MID_X + b/2, GRAPHICS_MID_X - a/2, GRAPHICS_MID_X - b/2); //Arrow bottom line
	drawLine(GRAPHICS_MID + b, GRAPHICS_MID - a, GRAPHICS_MID - a/2, GRAPHICS_MID - b/2); // Arrow "wings"
	drawLine(GRAPHICS_MID + b, GRAPHICS_MID - a, GRAPHICS_MID + a/2, GRAPHICS_MID + b/2);
    17ba:	0f 5f       	subi	r16, 0xFF	; 255
    17bc:	1f 4f       	sbci	r17, 0xFF	; 255
    17be:	c8 cc       	rjmp	.-1648   	; 0x1150 <main+0x4fa>
    17c0:	08 94       	sec
    17c2:	81 1c       	adc	r8, r1
    17c4:	91 1c       	adc	r9, r1
    17c6:	be cc       	rjmp	.-1668   	; 0x1144 <main+0x4ee>
	int16_t b = mySin(angle);
	a = (a * (GRAPHICS_SIZE / 3)) / 100;
	b = (b * (GRAPHICS_SIZE / 3)) / 100;
	drawLine(GRAPHICS_MID - b, GRAPHICS_MID + a, GRAPHICS_MID + b, GRAPHICS_MID - a); //Direction line
	//drawLine(GRAPHICS_MID_X + a/2, GRAPHICS_MID_X + b/2, GRAPHICS_MID_X - a/2, GRAPHICS_MID_X - b/2); //Arrow bottom line
	drawLine(GRAPHICS_MID + b, GRAPHICS_MID - a, GRAPHICS_MID - a/2, GRAPHICS_MID - b/2); // Arrow "wings"
    17c8:	2f 5f       	subi	r18, 0xFF	; 255
    17ca:	3f 4f       	sbci	r19, 0xFF	; 255
    17cc:	ae cc       	rjmp	.-1700   	; 0x112a <main+0x4d4>
    17ce:	01 96       	adiw	r24, 0x01	; 1
    17d0:	a2 cc       	rjmp	.-1724   	; 0x1116 <main+0x4c0>
		level = outMax;
	}		
	else if (level > inMin) {
    17d2:	21 e0       	ldi	r18, 0x01	; 1
    17d4:	60 e0       	ldi	r22, 0x00	; 0
    17d6:	4c ce       	rjmp	.-872    	; 0x1470 <main+0x81a>
    17d8:	88 27       	eor	r24, r24
    17da:	99 27       	eor	r25, r25
    17dc:	dc 01       	movw	r26, r24
    17de:	88 19       	sub	r24, r8
    17e0:	99 09       	sbc	r25, r9
    17e2:	aa 09       	sbc	r26, r10
    17e4:	bb 09       	sbc	r27, r11
    17e6:	82 cf       	rjmp	.-252    	; 0x16ec <main+0xa96>
    17e8:	19 87       	std	Y+9, r17	; 0x09
    17ea:	1a 01       	movw	r2, r20
    17ec:	2b 01       	movw	r4, r22
    17ee:	8f 87       	std	Y+15, r24	; 0x0f
    17f0:	98 8b       	std	Y+16, r25	; 0x10
    17f2:	a9 8b       	std	Y+17, r26	; 0x11
    17f4:	ba 8b       	std	Y+18, r27	; 0x12
  }
  
  uint32_t a = (deltaLong * deltaLong);
    17f6:	c7 01       	movw	r24, r14
    17f8:	b6 01       	movw	r22, r12
    17fa:	a7 01       	movw	r20, r14
    17fc:	96 01       	movw	r18, r12
    17fe:	04 d3       	rcall	.+1544   	; 0x1e08 <__mulsi3>
    1800:	69 83       	std	Y+1, r22	; 0x01
    1802:	7a 83       	std	Y+2, r23	; 0x02
    1804:	8b 83       	std	Y+3, r24	; 0x03
    1806:	9c 83       	std	Y+4, r25	; 0x04
  uint32_t b = (deltaLat * deltaLat);
    1808:	c5 01       	movw	r24, r10
    180a:	b4 01       	movw	r22, r8
    180c:	a5 01       	movw	r20, r10
    180e:	94 01       	movw	r18, r8
    1810:	fb d2       	rcall	.+1526   	; 0x1e08 <__mulsi3>
    1812:	8b 01       	movw	r16, r22
    1814:	9c 01       	movw	r18, r24

  // Make sure that the squared deltas don't go over uin32_t when adding them together.
  // This should only activate at long distances!
  uint8_t mult2 = 1;
  while ((a >> 24) + (b >> 24) > 0xFF) {
    1816:	89 2f       	mov	r24, r25
    1818:	99 27       	eor	r25, r25
    181a:	aa 27       	eor	r26, r26
    181c:	bb 27       	eor	r27, r27
    181e:	49 81       	ldd	r20, Y+1	; 0x01
    1820:	5a 81       	ldd	r21, Y+2	; 0x02
    1822:	6b 81       	ldd	r22, Y+3	; 0x03
    1824:	7c 81       	ldd	r23, Y+4	; 0x04
    1826:	47 2f       	mov	r20, r23
    1828:	55 27       	eor	r21, r21
    182a:	66 27       	eor	r22, r22
    182c:	77 27       	eor	r23, r23
    182e:	84 0f       	add	r24, r20
    1830:	95 1f       	adc	r25, r21
    1832:	a6 1f       	adc	r26, r22
    1834:	b7 1f       	adc	r27, r23
    1836:	8f 3f       	cpi	r24, 0xFF	; 255
    1838:	91 05       	cpc	r25, r1
    183a:	a1 05       	cpc	r26, r1
    183c:	b1 05       	cpc	r27, r1
    183e:	09 f0       	breq	.+2      	; 0x1842 <main+0xbec>
    1840:	08 f4       	brcc	.+2      	; 0x1844 <main+0xbee>
    1842:	19 c1       	rjmp	.+562    	; 0x1a76 <main+0xe20>
    a /= 4;
    1844:	69 81       	ldd	r22, Y+1	; 0x01
    1846:	7a 81       	ldd	r23, Y+2	; 0x02
    1848:	8b 81       	ldd	r24, Y+3	; 0x03
    184a:	9c 81       	ldd	r25, Y+4	; 0x04
    184c:	96 95       	lsr	r25
    184e:	87 95       	ror	r24
    1850:	77 95       	ror	r23
    1852:	67 95       	ror	r22
    1854:	96 95       	lsr	r25
    1856:	87 95       	ror	r24
    1858:	77 95       	ror	r23
    185a:	67 95       	ror	r22
    185c:	69 83       	std	Y+1, r22	; 0x01
    185e:	7a 83       	std	Y+2, r23	; 0x02
    1860:	8b 83       	std	Y+3, r24	; 0x03
    1862:	9c 83       	std	Y+4, r25	; 0x04
    b /= 4;
    1864:	36 95       	lsr	r19
    1866:	27 95       	ror	r18
    1868:	17 95       	ror	r17
    186a:	07 95       	ror	r16
    186c:	36 95       	lsr	r19
    186e:	27 95       	ror	r18
    1870:	17 95       	ror	r17
    1872:	07 95       	ror	r16
    1874:	82 e0       	ldi	r24, 0x02	; 2
    1876:	90 e0       	ldi	r25, 0x00	; 0
    1878:	a0 e0       	ldi	r26, 0x00	; 0
    187a:	b0 e0       	ldi	r27, 0x00	; 0
    187c:	8b 87       	std	Y+11, r24	; 0x0b
    187e:	9c 87       	std	Y+12, r25	; 0x0c
    1880:	ad 87       	std	Y+13, r26	; 0x0d
    1882:	be 87       	std	Y+14, r27	; 0x0e
    mult2 *= 2;
  }
  
  distance = calcSqrt(a + b);
    1884:	69 81       	ldd	r22, Y+1	; 0x01
    1886:	7a 81       	ldd	r23, Y+2	; 0x02
    1888:	8b 81       	ldd	r24, Y+3	; 0x03
    188a:	9c 81       	ldd	r25, Y+4	; 0x04
    188c:	60 0f       	add	r22, r16
    188e:	71 1f       	adc	r23, r17
    1890:	82 1f       	adc	r24, r18
    1892:	93 1f       	adc	r25, r19
    1894:	69 83       	std	Y+1, r22	; 0x01
    1896:	7a 83       	std	Y+2, r23	; 0x02
    1898:	8b 83       	std	Y+3, r24	; 0x03
    189a:	9c 83       	std	Y+4, r25	; 0x04
}

static uint32_t calcSqrt(uint32_t input)
{
  int32_t nv;
  int32_t v = input>>1;
    189c:	96 95       	lsr	r25
    189e:	87 95       	ror	r24
    18a0:	77 95       	ror	r23
    18a2:	67 95       	ror	r22
    18a4:	6d 83       	std	Y+5, r22	; 0x05
    18a6:	7e 83       	std	Y+6, r23	; 0x06
    18a8:	8f 83       	std	Y+7, r24	; 0x07
    18aa:	98 87       	std	Y+8, r25	; 0x08
  int32_t c = 0;
  if (!v) {
    18ac:	61 15       	cp	r22, r1
    18ae:	71 05       	cpc	r23, r1
    18b0:	81 05       	cpc	r24, r1
    18b2:	91 05       	cpc	r25, r1
    18b4:	09 f4       	brne	.+2      	; 0x18b8 <main+0xc62>
    18b6:	bd c0       	rjmp	.+378    	; 0x1a32 <main+0xddc>
    18b8:	80 e0       	ldi	r24, 0x00	; 0
    18ba:	90 e0       	ldi	r25, 0x00	; 0
    18bc:	9e 8b       	std	Y+22, r25	; 0x16
    18be:	8d 8b       	std	Y+21, r24	; 0x15
    18c0:	0c c0       	rjmp	.+24     	; 0x18da <main+0xc84>
    return input;
  }	
  do {
    nv = (v + input / v)>>1;
    if (absu32(v - nv) <= 1) {
    18c2:	ad 89       	ldd	r26, Y+21	; 0x15
    18c4:	be 89       	ldd	r27, Y+22	; 0x16
    18c6:	11 96       	adiw	r26, 0x01	; 1
    18c8:	be 8b       	std	Y+22, r27	; 0x16
    18ca:	ad 8b       	std	Y+21, r26	; 0x15
      return nv;
	  }	  
    v = nv;
  } while (c++ < 25);
    18cc:	aa 31       	cpi	r26, 0x1A	; 26
    18ce:	b1 05       	cpc	r27, r1
    18d0:	21 f1       	breq	.+72     	; 0x191a <main+0xcc4>
  do {
    nv = (v + input / v)>>1;
    if (absu32(v - nv) <= 1) {
      return nv;
	  }	  
    v = nv;
    18d2:	0d 83       	std	Y+5, r16	; 0x05
    18d4:	1e 83       	std	Y+6, r17	; 0x06
    18d6:	2f 83       	std	Y+7, r18	; 0x07
    18d8:	38 87       	std	Y+8, r19	; 0x08
  int32_t c = 0;
  if (!v) {
    return input;
  }	
  do {
    nv = (v + input / v)>>1;
    18da:	69 81       	ldd	r22, Y+1	; 0x01
    18dc:	7a 81       	ldd	r23, Y+2	; 0x02
    18de:	8b 81       	ldd	r24, Y+3	; 0x03
    18e0:	9c 81       	ldd	r25, Y+4	; 0x04
    18e2:	2d 81       	ldd	r18, Y+5	; 0x05
    18e4:	3e 81       	ldd	r19, Y+6	; 0x06
    18e6:	4f 81       	ldd	r20, Y+7	; 0x07
    18e8:	58 85       	ldd	r21, Y+8	; 0x08
    18ea:	e0 d2       	rcall	.+1472   	; 0x1eac <__udivmodsi4>
    18ec:	89 01       	movw	r16, r18
    18ee:	9a 01       	movw	r18, r20
    18f0:	8d 81       	ldd	r24, Y+5	; 0x05
    18f2:	9e 81       	ldd	r25, Y+6	; 0x06
    18f4:	af 81       	ldd	r26, Y+7	; 0x07
    18f6:	b8 85       	ldd	r27, Y+8	; 0x08
    18f8:	08 0f       	add	r16, r24
    18fa:	19 1f       	adc	r17, r25
    18fc:	2a 1f       	adc	r18, r26
    18fe:	3b 1f       	adc	r19, r27
    1900:	36 95       	lsr	r19
    1902:	27 95       	ror	r18
    1904:	17 95       	ror	r17
    1906:	07 95       	ror	r16
    if (absu32(v - nv) <= 1) {
    1908:	80 1b       	sub	r24, r16
    190a:	91 0b       	sbc	r25, r17
    190c:	a2 0b       	sbc	r26, r18
    190e:	b3 0b       	sbc	r27, r19
    1910:	82 30       	cpi	r24, 0x02	; 2
    1912:	91 05       	cpc	r25, r1
    1914:	a1 05       	cpc	r26, r1
    1916:	b1 05       	cpc	r27, r1
    1918:	a0 f6       	brcc	.-88     	; 0x18c2 <main+0xc6c>
  distance *= mult2;
    191a:	c9 01       	movw	r24, r18
    191c:	b8 01       	movw	r22, r16
    191e:	2b 85       	ldd	r18, Y+11	; 0x0b
    1920:	3c 85       	ldd	r19, Y+12	; 0x0c
    1922:	4d 85       	ldd	r20, Y+13	; 0x0d
    1924:	5e 85       	ldd	r21, Y+14	; 0x0e
    1926:	70 d2       	rcall	.+1248   	; 0x1e08 <__mulsi3>
    1928:	69 83       	std	Y+1, r22	; 0x01
    192a:	7a 83       	std	Y+2, r23	; 0x02
    192c:	8b 83       	std	Y+3, r24	; 0x03
    192e:	9c 83       	std	Y+4, r25	; 0x04

  // Only calculate bearing if bearing pointer is set.
  if (bearingResult != NULL) {
    bearing = 0;
    if (distance > 0) { // Over home -> do not compute; Home forced to 0
    1930:	61 15       	cp	r22, r1
    1932:	71 05       	cpc	r23, r1
    1934:	81 05       	cpc	r24, r1
    1936:	91 05       	cpc	r25, r1
    1938:	09 f4       	brne	.+2      	; 0x193c <main+0xce6>
    193a:	78 c0       	rjmp	.+240    	; 0x1a2c <main+0xdd6>
      if (absi32(deltaLong) >= absi32(deltaLat)) { // low angle, sine is better
    193c:	2f 85       	ldd	r18, Y+15	; 0x0f
    193e:	38 89       	ldd	r19, Y+16	; 0x10
    1940:	49 89       	ldd	r20, Y+17	; 0x11
    1942:	5a 89       	ldd	r21, Y+18	; 0x12
    1944:	22 16       	cp	r2, r18
    1946:	33 06       	cpc	r3, r19
    1948:	44 06       	cpc	r4, r20
    194a:	55 06       	cpc	r5, r21
    194c:	08 f4       	brcc	.+2      	; 0x1950 <main+0xcfa>
    194e:	ac c0       	rjmp	.+344    	; 0x1aa8 <main+0xe52>
        c = (absi32(deltaLat) * 100) / distance; // computes sine -> dist > 0
    1950:	ca 01       	movw	r24, r20
    1952:	b9 01       	movw	r22, r18
    1954:	24 e6       	ldi	r18, 0x64	; 100
    1956:	30 e0       	ldi	r19, 0x00	; 0
    1958:	40 e0       	ldi	r20, 0x00	; 0
    195a:	50 e0       	ldi	r21, 0x00	; 0
    195c:	55 d2       	rcall	.+1194   	; 0x1e08 <__mulsi3>
    195e:	29 81       	ldd	r18, Y+1	; 0x01
    1960:	3a 81       	ldd	r19, Y+2	; 0x02
    1962:	4b 81       	ldd	r20, Y+3	; 0x03
    1964:	5c 81       	ldd	r21, Y+4	; 0x04
    1966:	a2 d2       	rcall	.+1348   	; 0x1eac <__udivmodsi4>
    1968:	42 2e       	mov	r4, r18
  distance = calcSqrt(a + b);
  distance *= mult2;

  // Only calculate bearing if bearing pointer is set.
  if (bearingResult != NULL) {
    bearing = 0;
    196a:	20 e0       	ldi	r18, 0x00	; 0
    196c:	30 e0       	ldi	r19, 0x00	; 0
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
	int8_t mult = 1;
    196e:	41 e0       	ldi	r20, 0x01	; 1
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    1970:	80 e0       	ldi	r24, 0x00	; 0
    1972:	90 e0       	ldi	r25, 0x00	; 0
    1974:	18 e6       	ldi	r17, 0x68	; 104
    1976:	21 2e       	mov	r2, r17
    1978:	11 e0       	ldi	r17, 0x01	; 1
    197a:	31 2e       	mov	r3, r17
		pos = pos - 180;
		mult = -1;
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
		pos = 180 - pos;
    197c:	04 eb       	ldi	r16, 0xB4	; 180
    197e:	10 e0       	ldi	r17, 0x00	; 0
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
    1980:	8c 5c       	subi	r24, 0xCC	; 204
    1982:	9f 4f       	sbci	r25, 0xFF	; 255
    1984:	fc 01       	movw	r30, r24
    1986:	84 91       	lpm	r24, Z
    1988:	84 9f       	mul	r24, r20
    198a:	40 2d       	mov	r20, r0
    198c:	11 24       	eor	r1, r1
    if (distance > 0) { // Over home -> do not compute; Home forced to 0
      if (absi32(deltaLong) >= absi32(deltaLat)) { // low angle, sine is better
        c = (absi32(deltaLat) * 100) / distance; // computes sine -> dist > 0
        while((mySin(bearing) <= c) && (bearing < 90)) {
    198e:	44 16       	cp	r4, r20
    1990:	e4 f0       	brlt	.+56     	; 0x19ca <main+0xd74>
    1992:	2a 35       	cpi	r18, 0x5A	; 90
    1994:	31 05       	cpc	r19, r1
    1996:	c9 f0       	breq	.+50     	; 0x19ca <main+0xd74>
          ++bearing;
    1998:	2f 5f       	subi	r18, 0xFF	; 255
    199a:	3f 4f       	sbci	r19, 0xFF	; 255
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    199c:	c9 01       	movw	r24, r18
    199e:	b1 01       	movw	r22, r2
    19a0:	5e d2       	rcall	.+1212   	; 0x1e5e <__udivmodhi4>
	int8_t mult = 1;
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    19a2:	84 3b       	cpi	r24, 0xB4	; 180
    19a4:	91 05       	cpc	r25, r1
    19a6:	58 f0       	brcs	.+22     	; 0x19be <main+0xd68>
		pos = pos - 180;
    19a8:	84 5b       	subi	r24, 0xB4	; 180
    19aa:	90 40       	sbci	r25, 0x00	; 0
		mult = -1;
    19ac:	4f ef       	ldi	r20, 0xFF	; 255
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
    19ae:	8a 35       	cpi	r24, 0x5A	; 90
    19b0:	91 05       	cpc	r25, r1
    19b2:	30 f3       	brcs	.-52     	; 0x1980 <main+0xd2a>
		pos = 180 - pos;
    19b4:	b8 01       	movw	r22, r16
    19b6:	68 1b       	sub	r22, r24
    19b8:	79 0b       	sbc	r23, r25
    19ba:	cb 01       	movw	r24, r22
    19bc:	e1 cf       	rjmp	.-62     	; 0x1980 <main+0xd2a>
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
	int8_t mult = 1;
    19be:	41 e0       	ldi	r20, 0x01	; 1
    19c0:	f6 cf       	rjmp	.-20     	; 0x19ae <main+0xd58>
	    else { // high angle, cosine is better
        c = (absi32(deltaLong) * 100) / distance; // Computes cosine
        while((mySin(bearing) <= c) && (bearing < 90)) {
          ++bearing;
        }
        bearing = 90 - bearing;
    19c2:	2a e5       	ldi	r18, 0x5A	; 90
    19c4:	30 e0       	ldi	r19, 0x00	; 0
    19c6:	22 19       	sub	r18, r2
    19c8:	33 09       	sbc	r19, r3
      }
      if (deltaLat == 0) {
    19ca:	81 14       	cp	r8, r1
    19cc:	91 04       	cpc	r9, r1
    19ce:	a1 04       	cpc	r10, r1
    19d0:	b1 04       	cpc	r11, r1
    19d2:	09 f0       	breq	.+2      	; 0x19d6 <main+0xd80>
    19d4:	5c c0       	rjmp	.+184    	; 0x1a8e <main+0xe38>
        if (deltaLong >= 0) { // Home = East
    19d6:	f7 fc       	sbrc	r15, 7
    19d8:	57 c0       	rjmp	.+174    	; 0x1a88 <main+0xe32>
          bearing = 90; 
    19da:	8a e5       	ldi	r24, 0x5A	; 90
    19dc:	90 e0       	ldi	r25, 0x00	; 0
	      else { // SW quadrant
          bearing = 270 - bearing;
        }
      }
    }
    *bearingResult = bearing;
    19de:	90 93 2a 04 	sts	0x042A, r25
    19e2:	80 93 29 04 	sts	0x0429, r24
	}
  distance = distance * 309; // ate aqui em segundo * 100
    19e6:	69 81       	ldd	r22, Y+1	; 0x01
    19e8:	7a 81       	ldd	r23, Y+2	; 0x02
    19ea:	8b 81       	ldd	r24, Y+3	; 0x03
    19ec:	9c 81       	ldd	r25, Y+4	; 0x04
    19ee:	25 e3       	ldi	r18, 0x35	; 53
    19f0:	31 e0       	ldi	r19, 0x01	; 1
    19f2:	40 e0       	ldi	r20, 0x00	; 0
    19f4:	50 e0       	ldi	r21, 0x00	; 0
    19f6:	08 d2       	rcall	.+1040   	; 0x1e08 <__mulsi3>
  distance = distance / 1000; // metros, agora
    19f8:	28 ee       	ldi	r18, 0xE8	; 232
    19fa:	33 e0       	ldi	r19, 0x03	; 3
    19fc:	40 e0       	ldi	r20, 0x00	; 0
    19fe:	50 e0       	ldi	r21, 0x00	; 0
    1a00:	55 d2       	rcall	.+1194   	; 0x1eac <__udivmodsi4>
    1a02:	69 01       	movw	r12, r18
    1a04:	7a 01       	movw	r14, r20
  distance *= mult;
    1a06:	89 84       	ldd	r8, Y+9	; 0x09
    1a08:	28 2d       	mov	r18, r8
    1a0a:	30 e0       	ldi	r19, 0x00	; 0
    1a0c:	40 e0       	ldi	r20, 0x00	; 0
    1a0e:	50 e0       	ldi	r21, 0x00	; 0
    1a10:	c7 01       	movw	r24, r14
    1a12:	b6 01       	movw	r22, r12
    1a14:	f9 d1       	rcall	.+1010   	; 0x1e08 <__mulsi3>
    1a16:	dc 01       	movw	r26, r24
    1a18:	cb 01       	movw	r24, r22
#ifdef IMPERIAL_SYSTEM  
  distance *= 3281;
	distance /= 1000;
#endif //IMPERIAL_SYSTEM
  *distanceResult = distance;
    1a1a:	80 93 2b 04 	sts	0x042B, r24
    1a1e:	90 93 2c 04 	sts	0x042C, r25
    1a22:	a0 93 2d 04 	sts	0x042D, r26
    1a26:	b0 93 2e 04 	sts	0x042E, r27
    1a2a:	4f cc       	rjmp	.-1890   	; 0x12ca <main+0x674>
  distance = calcSqrt(a + b);
  distance *= mult2;

  // Only calculate bearing if bearing pointer is set.
  if (bearingResult != NULL) {
    bearing = 0;
    1a2c:	80 e0       	ldi	r24, 0x00	; 0
    1a2e:	90 e0       	ldi	r25, 0x00	; 0
    1a30:	d6 cf       	rjmp	.-84     	; 0x19de <main+0xd88>
{
  int32_t nv;
  int32_t v = input>>1;
  int32_t c = 0;
  if (!v) {
    return input;
    1a32:	09 81       	ldd	r16, Y+1	; 0x01
    1a34:	1a 81       	ldd	r17, Y+2	; 0x02
    1a36:	2b 81       	ldd	r18, Y+3	; 0x03
    1a38:	3c 81       	ldd	r19, Y+4	; 0x04
    1a3a:	6f cf       	rjmp	.-290    	; 0x191a <main+0xcc4>

  // considers flat earth around vehicle and reference

  // Ernani Reis, Aug 2011
  
  if (currLat == homeLat && currLong == homeLong) {
    1a3c:	24 16       	cp	r2, r20
    1a3e:	35 06       	cpc	r3, r21
    1a40:	46 06       	cpc	r4, r22
    1a42:	57 06       	cpc	r5, r23
    1a44:	09 f0       	breq	.+2      	; 0x1a48 <main+0xdf2>
    1a46:	e2 cd       	rjmp	.-1084   	; 0x160c <main+0x9b6>
	  *distanceResult = 0;
    1a48:	10 92 2b 04 	sts	0x042B, r1
    1a4c:	10 92 2c 04 	sts	0x042C, r1
    1a50:	10 92 2d 04 	sts	0x042D, r1
    1a54:	10 92 2e 04 	sts	0x042E, r1
	  *bearingResult = 0;
    1a58:	10 92 2a 04 	sts	0x042A, r1
    1a5c:	10 92 29 04 	sts	0x0429, r1
    1a60:	34 cc       	rjmp	.-1944   	; 0x12ca <main+0x674>
static void finishGpsDecoding() {
	
if (gGpsLastData.pos.altitude > gGpsLastValidData.pos.altitude) 
altitudeArrow = 1;
		
else if (gGpsLastData.pos.altitude < gGpsLastValidData.pos.altitude)
    1a62:	28 17       	cp	r18, r24
    1a64:	39 07       	cpc	r19, r25
    1a66:	0c f0       	brlt	.+2      	; 0x1a6a <main+0xe14>
    1a68:	8b ce       	rjmp	.-746    	; 0x1780 <main+0xb2a>
altitudeArrow = -1;
    1a6a:	40 93 dd 03 	sts	0x03DD, r20
    1a6e:	88 ce       	rjmp	.-752    	; 0x1780 <main+0xb2a>
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    1a70:	21 e0       	ldi	r18, 0x01	; 1
    1a72:	2d 83       	std	Y+5, r18	; 0x05
    1a74:	e8 cd       	rjmp	.-1072   	; 0x1646 <main+0x9f0>
  uint32_t b = (deltaLat * deltaLat);

  // Make sure that the squared deltas don't go over uin32_t when adding them together.
  // This should only activate at long distances!
  uint8_t mult2 = 1;
  while ((a >> 24) + (b >> 24) > 0xFF) {
    1a76:	41 e0       	ldi	r20, 0x01	; 1
    1a78:	50 e0       	ldi	r21, 0x00	; 0
    1a7a:	60 e0       	ldi	r22, 0x00	; 0
    1a7c:	70 e0       	ldi	r23, 0x00	; 0
    1a7e:	4b 87       	std	Y+11, r20	; 0x0b
    1a80:	5c 87       	std	Y+12, r21	; 0x0c
    1a82:	6d 87       	std	Y+13, r22	; 0x0d
    1a84:	7e 87       	std	Y+14, r23	; 0x0e
    1a86:	fe ce       	rjmp	.-516    	; 0x1884 <main+0xc2e>
      if (deltaLat == 0) {
        if (deltaLong >= 0) { // Home = East
          bearing = 90; 
        } 
	      else { // Home = West
          bearing = 270;
    1a88:	8e e0       	ldi	r24, 0x0E	; 14
    1a8a:	91 e0       	ldi	r25, 0x01	; 1
    1a8c:	a8 cf       	rjmp	.-176    	; 0x19de <main+0xd88>
        }
      } 
      else if (deltaLat > 0) {
    1a8e:	18 14       	cp	r1, r8
    1a90:	19 04       	cpc	r1, r9
    1a92:	1a 04       	cpc	r1, r10
    1a94:	1b 04       	cpc	r1, r11
    1a96:	0c f0       	brlt	.+2      	; 0x1a9a <main+0xe44>
    1a98:	4e c0       	rjmp	.+156    	; 0x1b36 <main+0xee0>
        if (deltaLong >= 0) { // NE quadrant
    1a9a:	f7 fc       	sbrc	r15, 7
    1a9c:	48 c0       	rjmp	.+144    	; 0x1b2e <main+0xed8>
          bearing = 90 - bearing;
    1a9e:	8a e5       	ldi	r24, 0x5A	; 90
    1aa0:	90 e0       	ldi	r25, 0x00	; 0
    1aa2:	82 1b       	sub	r24, r18
    1aa4:	93 0b       	sbc	r25, r19
    1aa6:	9b cf       	rjmp	.-202    	; 0x19de <main+0xd88>
        while((mySin(bearing) <= c) && (bearing < 90)) {
          ++bearing;
        }
      } 
	    else { // high angle, cosine is better
        c = (absi32(deltaLong) * 100) / distance; // Computes cosine
    1aa8:	c2 01       	movw	r24, r4
    1aaa:	b1 01       	movw	r22, r2
    1aac:	24 e6       	ldi	r18, 0x64	; 100
    1aae:	30 e0       	ldi	r19, 0x00	; 0
    1ab0:	40 e0       	ldi	r20, 0x00	; 0
    1ab2:	50 e0       	ldi	r21, 0x00	; 0
    1ab4:	a9 d1       	rcall	.+850    	; 0x1e08 <__mulsi3>
    1ab6:	29 81       	ldd	r18, Y+1	; 0x01
    1ab8:	3a 81       	ldd	r19, Y+2	; 0x02
    1aba:	4b 81       	ldd	r20, Y+3	; 0x03
    1abc:	5c 81       	ldd	r21, Y+4	; 0x04
    1abe:	f6 d1       	rcall	.+1004   	; 0x1eac <__udivmodsi4>
    1ac0:	42 2e       	mov	r4, r18
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
	int8_t mult = 1;
    1ac2:	41 e0       	ldi	r20, 0x01	; 1
  distance = calcSqrt(a + b);
  distance *= mult2;

  // Only calculate bearing if bearing pointer is set.
  if (bearingResult != NULL) {
    bearing = 0;
    1ac4:	22 24       	eor	r2, r2
    1ac6:	33 24       	eor	r3, r3
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    1ac8:	80 e0       	ldi	r24, 0x00	; 0
    1aca:	90 e0       	ldi	r25, 0x00	; 0
    1acc:	28 e6       	ldi	r18, 0x68	; 104
    1ace:	31 e0       	ldi	r19, 0x01	; 1
		pos = pos - 180;
		mult = -1;
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
		pos = 180 - pos;
    1ad0:	04 eb       	ldi	r16, 0xB4	; 180
    1ad2:	10 e0       	ldi	r17, 0x00	; 0
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
    1ad4:	8c 5c       	subi	r24, 0xCC	; 204
    1ad6:	9f 4f       	sbci	r25, 0xFF	; 255
    1ad8:	fc 01       	movw	r30, r24
    1ada:	84 91       	lpm	r24, Z
    1adc:	84 9f       	mul	r24, r20
    1ade:	40 2d       	mov	r20, r0
    1ae0:	11 24       	eor	r1, r1
          ++bearing;
        }
      } 
	    else { // high angle, cosine is better
        c = (absi32(deltaLong) * 100) / distance; // Computes cosine
        while((mySin(bearing) <= c) && (bearing < 90)) {
    1ae2:	44 16       	cp	r4, r20
    1ae4:	0c f4       	brge	.+2      	; 0x1ae8 <main+0xe92>
    1ae6:	6d cf       	rjmp	.-294    	; 0x19c2 <main+0xd6c>
    1ae8:	fa e5       	ldi	r31, 0x5A	; 90
    1aea:	2f 16       	cp	r2, r31
    1aec:	31 04       	cpc	r3, r1
    1aee:	09 f4       	brne	.+2      	; 0x1af2 <main+0xe9c>
    1af0:	68 cf       	rjmp	.-304    	; 0x19c2 <main+0xd6c>
          ++bearing;
    1af2:	08 94       	sec
    1af4:	21 1c       	adc	r2, r1
    1af6:	31 1c       	adc	r3, r1
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    1af8:	c1 01       	movw	r24, r2
    1afa:	b9 01       	movw	r22, r18
    1afc:	b0 d1       	rcall	.+864    	; 0x1e5e <__udivmodhi4>
	int8_t mult = 1;
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    1afe:	84 3b       	cpi	r24, 0xB4	; 180
    1b00:	91 05       	cpc	r25, r1
    1b02:	58 f0       	brcs	.+22     	; 0x1b1a <main+0xec4>
		pos = pos - 180;
    1b04:	84 5b       	subi	r24, 0xB4	; 180
    1b06:	90 40       	sbci	r25, 0x00	; 0
		mult = -1;
    1b08:	4f ef       	ldi	r20, 0xFF	; 255
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
    1b0a:	8a 35       	cpi	r24, 0x5A	; 90
    1b0c:	91 05       	cpc	r25, r1
    1b0e:	10 f3       	brcs	.-60     	; 0x1ad4 <main+0xe7e>
		pos = 180 - pos;
    1b10:	b8 01       	movw	r22, r16
    1b12:	68 1b       	sub	r22, r24
    1b14:	79 0b       	sbc	r23, r25
    1b16:	cb 01       	movw	r24, r22
    1b18:	dd cf       	rjmp	.-70     	; 0x1ad4 <main+0xe7e>
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
	int8_t mult = 1;
    1b1a:	41 e0       	ldi	r20, 0x01	; 1
    1b1c:	f6 cf       	rjmp	.-20     	; 0x1b0a <main+0xeb4>
#ifndef COMMONUTILS_H_
#define COMMONUTILS_H_

// abs seems to only support 16 bits so I had to make my own.
static uint32_t absi32(int32_t a) {
	return (a > 0) ? a : -a;
    1b1e:	b0 95       	com	r27
    1b20:	a0 95       	com	r26
    1b22:	90 95       	com	r25
    1b24:	81 95       	neg	r24
    1b26:	9f 4f       	sbci	r25, 0xFF	; 255
    1b28:	af 4f       	sbci	r26, 0xFF	; 255
    1b2a:	bf 4f       	sbci	r27, 0xFF	; 255
    1b2c:	77 cd       	rjmp	.-1298   	; 0x161c <main+0x9c6>
      else if (deltaLat > 0) {
        if (deltaLong >= 0) { // NE quadrant
          bearing = 90 - bearing;
        } 
	      else { // NW quadrant
          bearing = 270 + bearing;
    1b2e:	c9 01       	movw	r24, r18
    1b30:	82 5f       	subi	r24, 0xF2	; 242
    1b32:	9e 4f       	sbci	r25, 0xFE	; 254
    1b34:	54 cf       	rjmp	.-344    	; 0x19de <main+0xd88>
        }
      } 
	    else {
        if (deltaLong >= 0) { // SE quadrant
    1b36:	f7 fc       	sbrc	r15, 7
    1b38:	04 c0       	rjmp	.+8      	; 0x1b42 <main+0xeec>
          bearing = 90 + bearing;
    1b3a:	c9 01       	movw	r24, r18
    1b3c:	86 5a       	subi	r24, 0xA6	; 166
    1b3e:	9f 4f       	sbci	r25, 0xFF	; 255
    1b40:	4e cf       	rjmp	.-356    	; 0x19de <main+0xd88>
        } 
	      else { // SW quadrant
          bearing = 270 - bearing;
    1b42:	8e e0       	ldi	r24, 0x0E	; 14
    1b44:	91 e0       	ldi	r25, 0x01	; 1
    1b46:	82 1b       	sub	r24, r18
    1b48:	93 0b       	sbc	r25, r19
    1b4a:	49 cf       	rjmp	.-366    	; 0x19de <main+0xd88>

00001b4c <__vector_1>:
			//DDRB &= ~OUT1;
		}
	}
}

ISR(INT0_vect) {
    1b4c:	1f 92       	push	r1
    1b4e:	0f 92       	push	r0
    1b50:	0f b6       	in	r0, 0x3f	; 63
    1b52:	0f 92       	push	r0
    1b54:	11 24       	eor	r1, r1
    1b56:	2f 93       	push	r18
    1b58:	3f 93       	push	r19
    1b5a:	4f 93       	push	r20
    1b5c:	5f 93       	push	r21
    1b5e:	6f 93       	push	r22
    1b60:	7f 93       	push	r23
    1b62:	8f 93       	push	r24
    1b64:	9f 93       	push	r25
    1b66:	af 93       	push	r26
    1b68:	bf 93       	push	r27
    1b6a:	ef 93       	push	r30
    1b6c:	ff 93       	push	r31
	TCNT1 = 0; // Reset sync lost timeout.
    1b6e:	10 92 85 00 	sts	0x0085, r1
    1b72:	10 92 84 00 	sts	0x0084, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1b76:	88 e2       	ldi	r24, 0x28	; 40
    1b78:	8a 95       	dec	r24
    1b7a:	f1 f7       	brne	.-4      	; 0x1b78 <__vector_1+0x2c>
}  

static void updateLine() {
  _delay_us(5); // wait 5us to see if H or V sync

	if(!(PIND & LTRIG)) { // H sync
    1b7c:	4a 99       	sbic	0x09, 2	; 9
    1b7e:	7e c0       	rjmp	.+252    	; 0x1c7c <__vector_1+0x130>
		if (gActiveLine != 0) {
    1b80:	60 91 47 04 	lds	r22, 0x0447
    1b84:	70 91 48 04 	lds	r23, 0x0448
    1b88:	61 15       	cp	r22, r1
    1b8a:	71 05       	cpc	r23, r1
    1b8c:	09 f4       	brne	.+2      	; 0x1b90 <__vector_1+0x44>
    1b8e:	39 c0       	rjmp	.+114    	; 0x1c02 <__vector_1+0xb6>
			switch(gLineType) {
    1b90:	80 91 49 04 	lds	r24, 0x0449
    1b94:	81 30       	cpi	r24, 0x01	; 1
    1b96:	09 f4       	brne	.+2      	; 0x1b9a <__vector_1+0x4e>
    1b98:	8f c0       	rjmp	.+286    	; 0x1cb8 <__vector_1+0x16c>
    1b9a:	82 30       	cpi	r24, 0x02	; 2
    1b9c:	09 f0       	breq	.+2      	; 0x1ba0 <__vector_1+0x54>
    1b9e:	31 c0       	rjmp	.+98     	; 0x1c02 <__vector_1+0xb6>
    1ba0:	e3 e1       	ldi	r30, 0x13	; 19
    1ba2:	f1 e0       	ldi	r31, 0x01	; 1
    1ba4:	31 97       	sbiw	r30, 0x01	; 1
    1ba6:	f1 f7       	brne	.-4      	; 0x1ba4 <__vector_1+0x58>
    1ba8:	00 c0       	rjmp	.+0      	; 0x1baa <__vector_1+0x5e>
    1baa:	00 00       	nop
{
#ifdef TEXT_SMALL_ENABLED
	SPSR &= ~(1<<SPI2X); // Set normal speed
#endif //TEXT_SMALL_ENABLED
  _delay_us(GRAPHICS_OFFSET);
  uint16_t currLine = gActivePixmapLine;
    1bac:	20 91 4a 04 	lds	r18, 0x044A
    1bb0:	30 e0       	ldi	r19, 0x00	; 0
    1bb2:	80 e0       	ldi	r24, 0x00	; 0
    1bb4:	90 e0       	ldi	r25, 0x00	; 0
    1bb6:	2f 51       	subi	r18, 0x1F	; 31
    1bb8:	3c 4f       	sbci	r19, 0xFC	; 252
			//DDRB &= ~OUT1;
		}
	}
}

ISR(INT0_vect) {
    1bba:	f9 01       	movw	r30, r18
    1bbc:	e8 0f       	add	r30, r24
    1bbe:	f9 1f       	adc	r31, r25
  for (uint8_t i = 0; i < GRAPHICS_WIDTH; ++i) {
	  SPDR = gPixelData[i][currLine];
    1bc0:	40 81       	ld	r20, Z
    1bc2:	4e bd       	out	0x2e, r20	; 46
	  DDRB |= OUT1;
    1bc4:	21 9a       	sbi	0x04, 1	; 4
	...
	  DELAY_9_NOP();
	  DELAY_9_NOP();
	  DELAY_5_NOP();
    1bf2:	00 00       	nop
    1bf4:	48 96       	adiw	r24, 0x18	; 24
#ifdef TEXT_SMALL_ENABLED
	SPSR &= ~(1<<SPI2X); // Set normal speed
#endif //TEXT_SMALL_ENABLED
  _delay_us(GRAPHICS_OFFSET);
  uint16_t currLine = gActivePixmapLine;
  for (uint8_t i = 0; i < GRAPHICS_WIDTH; ++i) {
    1bf6:	88 34       	cpi	r24, 0x48	; 72
    1bf8:	91 05       	cpc	r25, r1
    1bfa:	f9 f6       	brne	.-66     	; 0x1bba <__vector_1+0x6e>
	  DDRB |= OUT1;
	  DELAY_9_NOP();
	  DELAY_9_NOP();
	  DELAY_5_NOP();
  }
  DDRB &= ~OUT1;
    1bfc:	21 98       	cbi	0x04, 1	; 4
  DELAY_1_NOP();
    1bfe:	00 00       	nop
  SPDR = 0x00;
    1c00:	1e bc       	out	0x2e, r1	; 46
					break;
			}
		}
		
		// We save some time in beginning of line by pre-calculating next type.
		gLineType = LINE_TYPE_UNKNOWN; // Default case
    1c02:	10 92 49 04 	sts	0x0449, r1
		gActiveLine++;
    1c06:	cb 01       	movw	r24, r22
    1c08:	01 96       	adiw	r24, 0x01	; 1
    1c0a:	90 93 48 04 	sts	0x0448, r25
    1c0e:	80 93 47 04 	sts	0x0447, r24
		if (gActiveLine == UPDATE_LINE) {
    1c12:	8e 36       	cpi	r24, 0x6E	; 110
    1c14:	91 05       	cpc	r25, r1
    1c16:	f1 f1       	breq	.+124    	; 0x1c94 <__vector_1+0x148>
			gUpdateScreenData = 1;
		}
		else if (gActiveLine == UPDATE_LINE + 1) {
    1c18:	8f 36       	cpi	r24, 0x6F	; 111
    1c1a:	91 05       	cpc	r25, r1
    1c1c:	09 f4       	brne	.+2      	; 0x1c20 <__vector_1+0xd4>
    1c1e:	84 c0       	rjmp	.+264    	; 0x1d28 <__vector_1+0x1dc>
			gUpdateScreenData = 2;
		}

#ifdef TEXT_ENABLED	
		if (gActiveLine >= gActiveTextLine && gActiveLine < gActiveTextLastLine) {
    1c20:	40 91 cd 03 	lds	r20, 0x03CD
    1c24:	50 91 ce 03 	lds	r21, 0x03CE
    1c28:	20 91 66 01 	lds	r18, 0x0166
    1c2c:	30 91 67 01 	lds	r19, 0x0167
    1c30:	84 17       	cp	r24, r20
    1c32:	95 07       	cpc	r25, r21
    1c34:	18 f0       	brcs	.+6      	; 0x1c3c <__vector_1+0xf0>
    1c36:	82 17       	cp	r24, r18
    1c38:	93 07       	cpc	r25, r19
    1c3a:	80 f1       	brcs	.+96     	; 0x1c9c <__vector_1+0x150>
		  gActivePixmapLine = (gActiveLine - gActiveTextLine);
		  if (gActiveTextSize == TEXT_SIZE_LARGE_MULT) {
		    gActivePixmapLine /= TEXT_SIZE_LARGE_MULT;
		  }
		}
		else if (gActiveLine == gActiveTextLastLine) {
    1c3c:	82 17       	cp	r24, r18
    1c3e:	93 07       	cpc	r25, r19
    1c40:	09 f4       	brne	.+2      	; 0x1c44 <__vector_1+0xf8>
    1c42:	83 c0       	rjmp	.+262    	; 0x1d4a <__vector_1+0x1fe>
			gActivePixmapLine = 1;
			return;
		}
#endif //TEXT_ENABLED		
#ifdef GRAPICSENABLED		
		else if (gActiveLine >= GRAPHICS_LINE && gActiveLine < (GRAPHICS_LINE + GRAPHICS_HEIGHT)) {
    1c44:	68 56       	subi	r22, 0x68	; 104
    1c46:	70 40       	sbci	r23, 0x00	; 0
    1c48:	68 31       	cpi	r22, 0x18	; 24
    1c4a:	71 05       	cpc	r23, r1
    1c4c:	30 f4       	brcc	.+12     	; 0x1c5a <__vector_1+0x10e>
			gLineType = LINE_TYPE_GRAPHICS;
    1c4e:	92 e0       	ldi	r25, 0x02	; 2
    1c50:	90 93 49 04 	sts	0x0449, r25
			gActivePixmapLine = (gActiveLine - GRAPHICS_LINE);
    1c54:	89 56       	subi	r24, 0x69	; 105
    1c56:	80 93 4a 04 	sts	0x044A, r24
	TCNT1 = 0; // Reset sync lost timeout.
	updateLine();
}
    1c5a:	ff 91       	pop	r31
    1c5c:	ef 91       	pop	r30
    1c5e:	bf 91       	pop	r27
    1c60:	af 91       	pop	r26
    1c62:	9f 91       	pop	r25
    1c64:	8f 91       	pop	r24
    1c66:	7f 91       	pop	r23
    1c68:	6f 91       	pop	r22
    1c6a:	5f 91       	pop	r21
    1c6c:	4f 91       	pop	r20
    1c6e:	3f 91       	pop	r19
    1c70:	2f 91       	pop	r18
    1c72:	0f 90       	pop	r0
    1c74:	0f be       	out	0x3f, r0	; 63
    1c76:	0f 90       	pop	r0
    1c78:	1f 90       	pop	r1
    1c7a:	18 95       	reti
		}
#endif //GRAPICSENABLED
	}
	else { // V sync
		if(gActiveLine > 200) {
    1c7c:	80 91 47 04 	lds	r24, 0x0447
    1c80:	90 91 48 04 	lds	r25, 0x0448
    1c84:	89 3c       	cpi	r24, 0xC9	; 201
    1c86:	91 05       	cpc	r25, r1
    1c88:	40 f3       	brcs	.-48     	; 0x1c5a <__vector_1+0x10e>
			gActiveLine = 0;
    1c8a:	10 92 48 04 	sts	0x0448, r1
    1c8e:	10 92 47 04 	sts	0x0447, r1
    1c92:	e3 cf       	rjmp	.-58     	; 0x1c5a <__vector_1+0x10e>
		
		// We save some time in beginning of line by pre-calculating next type.
		gLineType = LINE_TYPE_UNKNOWN; // Default case
		gActiveLine++;
		if (gActiveLine == UPDATE_LINE) {
			gUpdateScreenData = 1;
    1c94:	21 e0       	ldi	r18, 0x01	; 1
    1c96:	20 93 70 01 	sts	0x0170, r18
    1c9a:	c2 cf       	rjmp	.-124    	; 0x1c20 <__vector_1+0xd4>
			gUpdateScreenData = 2;
		}

#ifdef TEXT_ENABLED	
		if (gActiveLine >= gActiveTextLine && gActiveLine < gActiveTextLastLine) {
	    gLineType = LINE_TYPE_TEXT;
    1c9c:	91 e0       	ldi	r25, 0x01	; 1
    1c9e:	90 93 49 04 	sts	0x0449, r25
		  gActivePixmapLine = (gActiveLine - gActiveTextLine);
    1ca2:	84 1b       	sub	r24, r20
    1ca4:	80 93 4a 04 	sts	0x044A, r24
		  if (gActiveTextSize == TEXT_SIZE_LARGE_MULT) {
    1ca8:	90 91 68 01 	lds	r25, 0x0168
    1cac:	92 30       	cpi	r25, 0x02	; 2
    1cae:	a9 f6       	brne	.-86     	; 0x1c5a <__vector_1+0x10e>
		    gActivePixmapLine /= TEXT_SIZE_LARGE_MULT;
    1cb0:	86 95       	lsr	r24
    1cb2:	80 93 4a 04 	sts	0x044A, r24
    1cb6:	d1 cf       	rjmp	.-94     	; 0x1c5a <__vector_1+0x10e>
	if(!(PIND & LTRIG)) { // H sync
		if (gActiveLine != 0) {
			switch(gLineType) {
				case LINE_TYPE_TEXT:
#ifdef TEXT_ENABLED				
					drawTextLine(gActiveTextId);
    1cb8:	20 91 b4 01 	lds	r18, 0x01B4
    1cbc:	98 e1       	ldi	r25, 0x18	; 24
    1cbe:	9a 95       	dec	r25
    1cc0:	f1 f7       	brne	.-4      	; 0x1cbe <__vector_1+0x172>
#endif //VBI_TESTING_ENABLED

static void drawTextLine(uint8_t textId)
{
	_delay_us(3);
	uint8_t currLine = gActivePixmapLine;
    1cc2:	a0 91 4a 04 	lds	r26, 0x044A
			//DDRB &= ~OUT1;
		}
	}
}

ISR(INT0_vect) {
    1cc6:	30 e0       	ldi	r19, 0x00	; 0
    1cc8:	81 e2       	ldi	r24, 0x21	; 33
    1cca:	90 e0       	ldi	r25, 0x00	; 0
    1ccc:	28 9f       	mul	r18, r24
    1cce:	f0 01       	movw	r30, r0
    1cd0:	29 9f       	mul	r18, r25
    1cd2:	f0 0d       	add	r31, r0
    1cd4:	38 9f       	mul	r19, r24
    1cd6:	f0 0d       	add	r31, r0
    1cd8:	11 24       	eor	r1, r1
    1cda:	eb 54       	subi	r30, 0x4B	; 75
    1cdc:	fe 4f       	sbci	r31, 0xFE	; 254
    1cde:	81 e2       	ldi	r24, 0x21	; 33
    1ce0:	a8 9f       	mul	r26, r24
    1ce2:	d0 01       	movw	r26, r0
    1ce4:	11 24       	eor	r1, r1
    1ce6:	ab 53       	subi	r26, 0x3B	; 59
    1ce8:	bd 4f       	sbci	r27, 0xFD	; 253
    1cea:	16 c0       	rjmp	.+44     	; 0x1d18 <__vector_1+0x1cc>
	for (uint8_t i = 0; i < TEXT_LINE_MAX_CHARS; ++i) {
		if (gText[textId][i] != ' ' && gText[textId][i] != 0) {
			DDRB |= OUT1;
    1cec:	21 9a       	sbi	0x04, 1	; 4
		}
		else {
			DDRB &= ~OUT1;
			DELAY_1_NOP();
		}
		SPDR = gTextPixmap[(uint16_t)(currLine)*TEXT_LINE_MAX_CHARS + i];
    1cee:	9d 91       	ld	r25, X+
    1cf0:	9e bd       	out	0x2e, r25	; 46
	...
		DELAY_4_NOP();
#ifndef TEXT_SMALL_ENABLED
		DELAY_6_NOP();
		DELAY_7_NOP();
    1d12:	00 00       	nop
    1d14:	81 50       	subi	r24, 0x01	; 1

static void drawTextLine(uint8_t textId)
{
	_delay_us(3);
	uint8_t currLine = gActivePixmapLine;
	for (uint8_t i = 0; i < TEXT_LINE_MAX_CHARS; ++i) {
    1d16:	61 f0       	breq	.+24     	; 0x1d30 <__vector_1+0x1e4>
		if (gText[textId][i] != ' ' && gText[textId][i] != 0) {
    1d18:	91 91       	ld	r25, Z+
    1d1a:	90 32       	cpi	r25, 0x20	; 32
    1d1c:	11 f0       	breq	.+4      	; 0x1d22 <__vector_1+0x1d6>
    1d1e:	99 23       	and	r25, r25
    1d20:	29 f7       	brne	.-54     	; 0x1cec <__vector_1+0x1a0>
			DDRB |= OUT1;
		}
		else {
			DDRB &= ~OUT1;
    1d22:	21 98       	cbi	0x04, 1	; 4
			DELAY_1_NOP();
    1d24:	00 00       	nop
    1d26:	e3 cf       	rjmp	.-58     	; 0x1cee <__vector_1+0x1a2>
		gActiveLine++;
		if (gActiveLine == UPDATE_LINE) {
			gUpdateScreenData = 1;
		}
		else if (gActiveLine == UPDATE_LINE + 1) {
			gUpdateScreenData = 2;
    1d28:	22 e0       	ldi	r18, 0x02	; 2
    1d2a:	20 93 70 01 	sts	0x0170, r18
    1d2e:	78 cf       	rjmp	.-272    	; 0x1c20 <__vector_1+0xd4>
	...
		DELAY_6_NOP();
		DELAY_7_NOP();
#endif //TEXT_SMALL_ENABLED	
	}
	DELAY_10_NOP();
	SPDR = 0x00;
    1d44:	1e bc       	out	0x2e, r1	; 46
	DDRB &= ~OUT1;
    1d46:	21 98       	cbi	0x04, 1	; 4
    1d48:	5c cf       	rjmp	.-328    	; 0x1c02 <__vector_1+0xb6>
		  if (gActiveTextSize == TEXT_SIZE_LARGE_MULT) {
		    gActivePixmapLine /= TEXT_SIZE_LARGE_MULT;
		  }
		}
		else if (gActiveLine == gActiveTextLastLine) {
		  gUpdateScreenData = 2;
    1d4a:	82 e0       	ldi	r24, 0x02	; 2
    1d4c:	80 93 70 01 	sts	0x0170, r24
			gActiveTextId = (gActiveTextId+1) % TEXT_LINES;
    1d50:	80 91 b4 01 	lds	r24, 0x01B4
    1d54:	90 e0       	ldi	r25, 0x00	; 0
    1d56:	01 96       	adiw	r24, 0x01	; 1
    1d58:	66 e0       	ldi	r22, 0x06	; 6
    1d5a:	70 e0       	ldi	r23, 0x00	; 0
    1d5c:	94 d0       	rcall	.+296    	; 0x1e86 <__divmodhi4>
    1d5e:	80 93 b4 01 	sts	0x01B4, r24
			gActiveTextLine = gTextLines[gActiveTextId];
    1d62:	fc 01       	movw	r30, r24
    1d64:	ee 0f       	add	r30, r30
    1d66:	ff 1f       	adc	r31, r31
    1d68:	ef 5a       	subi	r30, 0xAF	; 175
    1d6a:	fe 4f       	sbci	r31, 0xFE	; 254
    1d6c:	20 81       	ld	r18, Z
    1d6e:	31 81       	ldd	r19, Z+1	; 0x01
    1d70:	30 93 ce 03 	sts	0x03CE, r19
    1d74:	20 93 cd 03 	sts	0x03CD, r18
			gActiveTextSize = gTextLineSizes[gActiveTextId];
    1d78:	87 59       	subi	r24, 0x97	; 151
    1d7a:	9e 4f       	sbci	r25, 0xFE	; 254
    1d7c:	fc 01       	movw	r30, r24
    1d7e:	80 81       	ld	r24, Z
    1d80:	80 93 68 01 	sts	0x0168, r24
			gActiveTextLastLine = gActiveTextLine + TEXT_CHAR_HEIGHT * gActiveTextSize;
    1d84:	90 e0       	ldi	r25, 0x00	; 0
    1d86:	88 0f       	add	r24, r24
    1d88:	99 1f       	adc	r25, r25
    1d8a:	88 0f       	add	r24, r24
    1d8c:	99 1f       	adc	r25, r25
    1d8e:	88 0f       	add	r24, r24
    1d90:	99 1f       	adc	r25, r25
    1d92:	82 0f       	add	r24, r18
    1d94:	93 1f       	adc	r25, r19
    1d96:	90 93 67 01 	sts	0x0167, r25
    1d9a:	80 93 66 01 	sts	0x0166, r24
			gActivePixmapLine = 1;
    1d9e:	81 e0       	ldi	r24, 0x01	; 1
    1da0:	80 93 4a 04 	sts	0x044A, r24
    1da4:	5a cf       	rjmp	.-332    	; 0x1c5a <__vector_1+0x10e>

00001da6 <__vector_13>:
	TCNT1 = 0; // Reset sync lost timeout.
	updateLine();
}

ISR(TIMER1_OVF_vect)
{
    1da6:	1f 92       	push	r1
    1da8:	0f 92       	push	r0
    1daa:	0f b6       	in	r0, 0x3f	; 63
    1dac:	0f 92       	push	r0
    1dae:	11 24       	eor	r1, r1
    1db0:	2f 93       	push	r18
    1db2:	3f 93       	push	r19
    1db4:	8f 93       	push	r24
    1db6:	9f 93       	push	r25
	static uint8_t lastLine = 0;
	if (lastLine == gActiveLine) {
    1db8:	80 91 47 04 	lds	r24, 0x0447
    1dbc:	90 91 48 04 	lds	r25, 0x0448
    1dc0:	20 91 4b 04 	lds	r18, 0x044B
    1dc4:	30 e0       	ldi	r19, 0x00	; 0
    1dc6:	28 17       	cp	r18, r24
    1dc8:	39 07       	cpc	r19, r25
    1dca:	21 f4       	brne	.+8      	; 0x1dd4 <__vector_13+0x2e>
    PORTD ^= LED; // Toggle the LED
    1dcc:	2b b1       	in	r18, 0x0b	; 11
    1dce:	38 e0       	ldi	r19, 0x08	; 8
    1dd0:	23 27       	eor	r18, r19
    1dd2:	2b b9       	out	0x0b, r18	; 11
	}
	lastLine = gActiveLine;
    1dd4:	80 93 4b 04 	sts	0x044B, r24
}
    1dd8:	9f 91       	pop	r25
    1dda:	8f 91       	pop	r24
    1ddc:	3f 91       	pop	r19
    1dde:	2f 91       	pop	r18
    1de0:	0f 90       	pop	r0
    1de2:	0f be       	out	0x3f, r0	; 63
    1de4:	0f 90       	pop	r0
    1de6:	1f 90       	pop	r1
    1de8:	18 95       	reti

00001dea <__umulhisi3>:
    1dea:	53 9f       	mul	r21, r19
    1dec:	c0 01       	movw	r24, r0
    1dee:	42 9f       	mul	r20, r18
    1df0:	b0 01       	movw	r22, r0
    1df2:	52 9f       	mul	r21, r18
    1df4:	70 0d       	add	r23, r0
    1df6:	81 1d       	adc	r24, r1
    1df8:	11 24       	eor	r1, r1
    1dfa:	91 1d       	adc	r25, r1
    1dfc:	34 9f       	mul	r19, r20
    1dfe:	70 0d       	add	r23, r0
    1e00:	81 1d       	adc	r24, r1
    1e02:	11 24       	eor	r1, r1
    1e04:	91 1d       	adc	r25, r1
    1e06:	08 95       	ret

00001e08 <__mulsi3>:
    1e08:	62 9f       	mul	r22, r18
    1e0a:	d0 01       	movw	r26, r0
    1e0c:	73 9f       	mul	r23, r19
    1e0e:	f0 01       	movw	r30, r0
    1e10:	82 9f       	mul	r24, r18
    1e12:	e0 0d       	add	r30, r0
    1e14:	f1 1d       	adc	r31, r1
    1e16:	64 9f       	mul	r22, r20
    1e18:	e0 0d       	add	r30, r0
    1e1a:	f1 1d       	adc	r31, r1
    1e1c:	92 9f       	mul	r25, r18
    1e1e:	f0 0d       	add	r31, r0
    1e20:	83 9f       	mul	r24, r19
    1e22:	f0 0d       	add	r31, r0
    1e24:	74 9f       	mul	r23, r20
    1e26:	f0 0d       	add	r31, r0
    1e28:	65 9f       	mul	r22, r21
    1e2a:	f0 0d       	add	r31, r0
    1e2c:	99 27       	eor	r25, r25
    1e2e:	72 9f       	mul	r23, r18
    1e30:	b0 0d       	add	r27, r0
    1e32:	e1 1d       	adc	r30, r1
    1e34:	f9 1f       	adc	r31, r25
    1e36:	63 9f       	mul	r22, r19
    1e38:	b0 0d       	add	r27, r0
    1e3a:	e1 1d       	adc	r30, r1
    1e3c:	f9 1f       	adc	r31, r25
    1e3e:	bd 01       	movw	r22, r26
    1e40:	cf 01       	movw	r24, r30
    1e42:	11 24       	eor	r1, r1
    1e44:	08 95       	ret

00001e46 <__udivmodqi4>:
    1e46:	99 1b       	sub	r25, r25
    1e48:	79 e0       	ldi	r23, 0x09	; 9
    1e4a:	04 c0       	rjmp	.+8      	; 0x1e54 <__udivmodqi4_ep>

00001e4c <__udivmodqi4_loop>:
    1e4c:	99 1f       	adc	r25, r25
    1e4e:	96 17       	cp	r25, r22
    1e50:	08 f0       	brcs	.+2      	; 0x1e54 <__udivmodqi4_ep>
    1e52:	96 1b       	sub	r25, r22

00001e54 <__udivmodqi4_ep>:
    1e54:	88 1f       	adc	r24, r24
    1e56:	7a 95       	dec	r23
    1e58:	c9 f7       	brne	.-14     	; 0x1e4c <__udivmodqi4_loop>
    1e5a:	80 95       	com	r24
    1e5c:	08 95       	ret

00001e5e <__udivmodhi4>:
    1e5e:	aa 1b       	sub	r26, r26
    1e60:	bb 1b       	sub	r27, r27
    1e62:	51 e1       	ldi	r21, 0x11	; 17
    1e64:	07 c0       	rjmp	.+14     	; 0x1e74 <__udivmodhi4_ep>

00001e66 <__udivmodhi4_loop>:
    1e66:	aa 1f       	adc	r26, r26
    1e68:	bb 1f       	adc	r27, r27
    1e6a:	a6 17       	cp	r26, r22
    1e6c:	b7 07       	cpc	r27, r23
    1e6e:	10 f0       	brcs	.+4      	; 0x1e74 <__udivmodhi4_ep>
    1e70:	a6 1b       	sub	r26, r22
    1e72:	b7 0b       	sbc	r27, r23

00001e74 <__udivmodhi4_ep>:
    1e74:	88 1f       	adc	r24, r24
    1e76:	99 1f       	adc	r25, r25
    1e78:	5a 95       	dec	r21
    1e7a:	a9 f7       	brne	.-22     	; 0x1e66 <__udivmodhi4_loop>
    1e7c:	80 95       	com	r24
    1e7e:	90 95       	com	r25
    1e80:	bc 01       	movw	r22, r24
    1e82:	cd 01       	movw	r24, r26
    1e84:	08 95       	ret

00001e86 <__divmodhi4>:
    1e86:	97 fb       	bst	r25, 7
    1e88:	09 2e       	mov	r0, r25
    1e8a:	07 26       	eor	r0, r23
    1e8c:	0a d0       	rcall	.+20     	; 0x1ea2 <__divmodhi4_neg1>
    1e8e:	77 fd       	sbrc	r23, 7
    1e90:	04 d0       	rcall	.+8      	; 0x1e9a <__divmodhi4_neg2>
    1e92:	e5 df       	rcall	.-54     	; 0x1e5e <__udivmodhi4>
    1e94:	06 d0       	rcall	.+12     	; 0x1ea2 <__divmodhi4_neg1>
    1e96:	00 20       	and	r0, r0
    1e98:	1a f4       	brpl	.+6      	; 0x1ea0 <__divmodhi4_exit>

00001e9a <__divmodhi4_neg2>:
    1e9a:	70 95       	com	r23
    1e9c:	61 95       	neg	r22
    1e9e:	7f 4f       	sbci	r23, 0xFF	; 255

00001ea0 <__divmodhi4_exit>:
    1ea0:	08 95       	ret

00001ea2 <__divmodhi4_neg1>:
    1ea2:	f6 f7       	brtc	.-4      	; 0x1ea0 <__divmodhi4_exit>
    1ea4:	90 95       	com	r25
    1ea6:	81 95       	neg	r24
    1ea8:	9f 4f       	sbci	r25, 0xFF	; 255
    1eaa:	08 95       	ret

00001eac <__udivmodsi4>:
    1eac:	a1 e2       	ldi	r26, 0x21	; 33
    1eae:	1a 2e       	mov	r1, r26
    1eb0:	aa 1b       	sub	r26, r26
    1eb2:	bb 1b       	sub	r27, r27
    1eb4:	fd 01       	movw	r30, r26
    1eb6:	0d c0       	rjmp	.+26     	; 0x1ed2 <__udivmodsi4_ep>

00001eb8 <__udivmodsi4_loop>:
    1eb8:	aa 1f       	adc	r26, r26
    1eba:	bb 1f       	adc	r27, r27
    1ebc:	ee 1f       	adc	r30, r30
    1ebe:	ff 1f       	adc	r31, r31
    1ec0:	a2 17       	cp	r26, r18
    1ec2:	b3 07       	cpc	r27, r19
    1ec4:	e4 07       	cpc	r30, r20
    1ec6:	f5 07       	cpc	r31, r21
    1ec8:	20 f0       	brcs	.+8      	; 0x1ed2 <__udivmodsi4_ep>
    1eca:	a2 1b       	sub	r26, r18
    1ecc:	b3 0b       	sbc	r27, r19
    1ece:	e4 0b       	sbc	r30, r20
    1ed0:	f5 0b       	sbc	r31, r21

00001ed2 <__udivmodsi4_ep>:
    1ed2:	66 1f       	adc	r22, r22
    1ed4:	77 1f       	adc	r23, r23
    1ed6:	88 1f       	adc	r24, r24
    1ed8:	99 1f       	adc	r25, r25
    1eda:	1a 94       	dec	r1
    1edc:	69 f7       	brne	.-38     	; 0x1eb8 <__udivmodsi4_loop>
    1ede:	60 95       	com	r22
    1ee0:	70 95       	com	r23
    1ee2:	80 95       	com	r24
    1ee4:	90 95       	com	r25
    1ee6:	9b 01       	movw	r18, r22
    1ee8:	ac 01       	movw	r20, r24
    1eea:	bd 01       	movw	r22, r26
    1eec:	cf 01       	movw	r24, r30
    1eee:	08 95       	ret

00001ef0 <__divmodsi4>:
    1ef0:	97 fb       	bst	r25, 7
    1ef2:	09 2e       	mov	r0, r25
    1ef4:	05 26       	eor	r0, r21
    1ef6:	0e d0       	rcall	.+28     	; 0x1f14 <__divmodsi4_neg1>
    1ef8:	57 fd       	sbrc	r21, 7
    1efa:	04 d0       	rcall	.+8      	; 0x1f04 <__divmodsi4_neg2>
    1efc:	d7 df       	rcall	.-82     	; 0x1eac <__udivmodsi4>
    1efe:	0a d0       	rcall	.+20     	; 0x1f14 <__divmodsi4_neg1>
    1f00:	00 1c       	adc	r0, r0
    1f02:	38 f4       	brcc	.+14     	; 0x1f12 <__divmodsi4_exit>

00001f04 <__divmodsi4_neg2>:
    1f04:	50 95       	com	r21
    1f06:	40 95       	com	r20
    1f08:	30 95       	com	r19
    1f0a:	21 95       	neg	r18
    1f0c:	3f 4f       	sbci	r19, 0xFF	; 255
    1f0e:	4f 4f       	sbci	r20, 0xFF	; 255
    1f10:	5f 4f       	sbci	r21, 0xFF	; 255

00001f12 <__divmodsi4_exit>:
    1f12:	08 95       	ret

00001f14 <__divmodsi4_neg1>:
    1f14:	f6 f7       	brtc	.-4      	; 0x1f12 <__divmodsi4_exit>
    1f16:	90 95       	com	r25
    1f18:	80 95       	com	r24
    1f1a:	70 95       	com	r23
    1f1c:	61 95       	neg	r22
    1f1e:	7f 4f       	sbci	r23, 0xFF	; 255
    1f20:	8f 4f       	sbci	r24, 0xFF	; 255
    1f22:	9f 4f       	sbci	r25, 0xFF	; 255
    1f24:	08 95       	ret

00001f26 <strncmp>:
    1f26:	fb 01       	movw	r30, r22
    1f28:	dc 01       	movw	r26, r24
    1f2a:	41 50       	subi	r20, 0x01	; 1
    1f2c:	50 40       	sbci	r21, 0x00	; 0
    1f2e:	30 f0       	brcs	.+12     	; 0x1f3c <strncmp+0x16>
    1f30:	8d 91       	ld	r24, X+
    1f32:	01 90       	ld	r0, Z+
    1f34:	80 19       	sub	r24, r0
    1f36:	19 f4       	brne	.+6      	; 0x1f3e <strncmp+0x18>
    1f38:	00 20       	and	r0, r0
    1f3a:	b9 f7       	brne	.-18     	; 0x1f2a <strncmp+0x4>
    1f3c:	88 1b       	sub	r24, r24
    1f3e:	99 0b       	sbc	r25, r25
    1f40:	08 95       	ret

00001f42 <strncpy>:
    1f42:	fb 01       	movw	r30, r22
    1f44:	dc 01       	movw	r26, r24
    1f46:	41 50       	subi	r20, 0x01	; 1
    1f48:	50 40       	sbci	r21, 0x00	; 0
    1f4a:	48 f0       	brcs	.+18     	; 0x1f5e <strncpy+0x1c>
    1f4c:	01 90       	ld	r0, Z+
    1f4e:	0d 92       	st	X+, r0
    1f50:	00 20       	and	r0, r0
    1f52:	c9 f7       	brne	.-14     	; 0x1f46 <strncpy+0x4>
    1f54:	01 c0       	rjmp	.+2      	; 0x1f58 <strncpy+0x16>
    1f56:	1d 92       	st	X+, r1
    1f58:	41 50       	subi	r20, 0x01	; 1
    1f5a:	50 40       	sbci	r21, 0x00	; 0
    1f5c:	e0 f7       	brcc	.-8      	; 0x1f56 <strncpy+0x14>
    1f5e:	08 95       	ret

00001f60 <__eerd_block_m88pa>:
    1f60:	dc 01       	movw	r26, r24
    1f62:	cb 01       	movw	r24, r22

00001f64 <__eerd_blraw_m88pa>:
    1f64:	fc 01       	movw	r30, r24
    1f66:	f9 99       	sbic	0x1f, 1	; 31
    1f68:	fe cf       	rjmp	.-4      	; 0x1f66 <__eerd_blraw_m88pa+0x2>
    1f6a:	06 c0       	rjmp	.+12     	; 0x1f78 <__eerd_blraw_m88pa+0x14>
    1f6c:	f2 bd       	out	0x22, r31	; 34
    1f6e:	e1 bd       	out	0x21, r30	; 33
    1f70:	f8 9a       	sbi	0x1f, 0	; 31
    1f72:	31 96       	adiw	r30, 0x01	; 1
    1f74:	00 b4       	in	r0, 0x20	; 32
    1f76:	0d 92       	st	X+, r0
    1f78:	41 50       	subi	r20, 0x01	; 1
    1f7a:	50 40       	sbci	r21, 0x00	; 0
    1f7c:	b8 f7       	brcc	.-18     	; 0x1f6c <__eerd_blraw_m88pa+0x8>
    1f7e:	08 95       	ret

00001f80 <_exit>:
    1f80:	f8 94       	cli

00001f82 <__stop_program>:
    1f82:	ff cf       	rjmp	.-2      	; 0x1f82 <__stop_program>
