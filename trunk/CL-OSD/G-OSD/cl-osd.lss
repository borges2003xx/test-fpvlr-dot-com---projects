
cl-osd.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000072  00800100  00001dee  00001ea2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001dee  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000002d3  00800172  00800172  00001f14  2**0
                  ALLOC
  3 .eeprom       00000200  00810000  00810000  00001f14  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .stab         00000960  00000000  00000000  00002114  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      000001af  00000000  00000000  00002a74  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 000001b0  00000000  00000000  00002c28  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002400  00000000  00000000  00002dd8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000003f9  00000000  00000000  000051d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000fc9  00000000  00000000  000055d1  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000334  00000000  00000000  0000659c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000007f5  00000000  00000000  000068d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00002d77  00000000  00000000  000070c5  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macinfo 0000bfdc  00000000  00000000  00009e3c  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 000007b0  00000000  00000000  00015e18  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	47 c0       	rjmp	.+142    	; 0x90 <__ctors_end>
       2:	e8 cc       	rjmp	.-1584   	; 0xfffff9d4 <__eeprom_end+0xff7ef7d4>
       4:	60 c0       	rjmp	.+192    	; 0xc6 <__bad_interrupt>
       6:	5f c0       	rjmp	.+190    	; 0xc6 <__bad_interrupt>
       8:	5e c0       	rjmp	.+188    	; 0xc6 <__bad_interrupt>
       a:	5d c0       	rjmp	.+186    	; 0xc6 <__bad_interrupt>
       c:	5c c0       	rjmp	.+184    	; 0xc6 <__bad_interrupt>
       e:	5b c0       	rjmp	.+182    	; 0xc6 <__bad_interrupt>
      10:	5a c0       	rjmp	.+180    	; 0xc6 <__bad_interrupt>
      12:	59 c0       	rjmp	.+178    	; 0xc6 <__bad_interrupt>
      14:	58 c0       	rjmp	.+176    	; 0xc6 <__bad_interrupt>
      16:	57 c0       	rjmp	.+174    	; 0xc6 <__bad_interrupt>
      18:	56 c0       	rjmp	.+172    	; 0xc6 <__bad_interrupt>
      1a:	06 ce       	rjmp	.-1012   	; 0xfffffc28 <__eeprom_end+0xff7efa28>
      1c:	54 c0       	rjmp	.+168    	; 0xc6 <__bad_interrupt>
      1e:	53 c0       	rjmp	.+166    	; 0xc6 <__bad_interrupt>
      20:	52 c0       	rjmp	.+164    	; 0xc6 <__bad_interrupt>
      22:	51 c0       	rjmp	.+162    	; 0xc6 <__bad_interrupt>
      24:	50 c0       	rjmp	.+160    	; 0xc6 <__bad_interrupt>
      26:	4f c0       	rjmp	.+158    	; 0xc6 <__bad_interrupt>
      28:	4e c0       	rjmp	.+156    	; 0xc6 <__bad_interrupt>
      2a:	4d c0       	rjmp	.+154    	; 0xc6 <__bad_interrupt>
      2c:	4c c0       	rjmp	.+152    	; 0xc6 <__bad_interrupt>
      2e:	4b c0       	rjmp	.+150    	; 0xc6 <__bad_interrupt>
      30:	4a c0       	rjmp	.+148    	; 0xc6 <__bad_interrupt>
      32:	49 c0       	rjmp	.+146    	; 0xc6 <__bad_interrupt>

00000034 <sinData>:
      34:	00 02 03 05 07 09 0a 0c 0e 10 11 13 15 16 18 1a     ................
      44:	1c 1d 1f 21 22 24 25 27 29 2a 2c 2d 2f 30 32 34     ...!"$%')*,-/024
      54:	35 36 38 39 3b 3c 3e 3f 40 42 43 44 45 47 48 49     5689;<>?@BCDEGHI
      64:	4a 4b 4d 4e 4f 50 51 52 53 54 55 56 57 57 58 59     JKMNOPQRSTUVWWXY
      74:	5a 5b 5b 5c 5d 5d 5e 5f 5f 60 60 61 61 61 62 62     Z[[\]]^__``aaabb
      84:	62 63 63 63 63 64 64 64 64 64 64 00                 bccccdddddd.

00000090 <__ctors_end>:
      90:	11 24       	eor	r1, r1
      92:	1f be       	out	0x3f, r1	; 63
      94:	cf ef       	ldi	r28, 0xFF	; 255
      96:	d4 e0       	ldi	r29, 0x04	; 4
      98:	de bf       	out	0x3e, r29	; 62
      9a:	cd bf       	out	0x3d, r28	; 61

0000009c <__do_copy_data>:
      9c:	11 e0       	ldi	r17, 0x01	; 1
      9e:	a0 e0       	ldi	r26, 0x00	; 0
      a0:	b1 e0       	ldi	r27, 0x01	; 1
      a2:	ee ee       	ldi	r30, 0xEE	; 238
      a4:	fd e1       	ldi	r31, 0x1D	; 29
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x10>
      a8:	05 90       	lpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	a2 37       	cpi	r26, 0x72	; 114
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0xc>

000000b2 <__do_clear_bss>:
      b2:	14 e0       	ldi	r17, 0x04	; 4
      b4:	a2 e7       	ldi	r26, 0x72	; 114
      b6:	b1 e0       	ldi	r27, 0x01	; 1
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	a5 34       	cpi	r26, 0x45	; 69
      be:	b1 07       	cpc	r27, r17
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	4b d5       	rcall	.+2710   	; 0xb5a <main>
      c4:	92 ce       	rjmp	.-732    	; 0xfffffdea <__eeprom_end+0xff7efbea>

000000c6 <__bad_interrupt>:
      c6:	9c cf       	rjmp	.-200    	; 0x0 <__vectors>

000000c8 <wgs84ToSec100>:
  uint8_t checksumValid;
} TGpsData;

// Convert nmea WGS84 to seconds * 100
// wgs84 = DDMM[.]MMMM
static int32_t wgs84ToSec100(int32_t wgs84) { 
      c8:	4f 92       	push	r4
      ca:	5f 92       	push	r5
      cc:	6f 92       	push	r6
      ce:	7f 92       	push	r7
      d0:	8f 92       	push	r8
      d2:	9f 92       	push	r9
      d4:	af 92       	push	r10
      d6:	bf 92       	push	r11
      d8:	cf 92       	push	r12
      da:	df 92       	push	r13
      dc:	ef 92       	push	r14
      de:	ff 92       	push	r15
      e0:	1f 93       	push	r17
      e2:	cf 93       	push	r28
      e4:	df 93       	push	r29
      e6:	00 d0       	rcall	.+0      	; 0xe8 <wgs84ToSec100+0x20>
      e8:	00 d0       	rcall	.+0      	; 0xea <wgs84ToSec100+0x22>
      ea:	cd b7       	in	r28, 0x3d	; 61
      ec:	de b7       	in	r29, 0x3e	; 62
      ee:	6b 01       	movw	r12, r22
      f0:	7c 01       	movw	r14, r24
  int8_t mult = 1;
  
  if (wgs84 < 0) {
      f2:	97 fd       	sbrc	r25, 7
      f4:	74 c0       	rjmp	.+232    	; 0x1de <wgs84ToSec100+0x116>
} TGpsData;

// Convert nmea WGS84 to seconds * 100
// wgs84 = DDMM[.]MMMM
static int32_t wgs84ToSec100(int32_t wgs84) { 
  int8_t mult = 1;
      f6:	11 e0       	ldi	r17, 0x01	; 1
  if (wgs84 < 0) {
    mult = -1;
    wgs84 = -wgs84;
  }
  
  uint8_t hour = wgs84 / 1000000; //Get hour part
      f8:	c7 01       	movw	r24, r14
      fa:	b6 01       	movw	r22, r12
      fc:	20 e4       	ldi	r18, 0x40	; 64
      fe:	32 e4       	ldi	r19, 0x42	; 66
     100:	4f e0       	ldi	r20, 0x0F	; 15
     102:	50 e0       	ldi	r21, 0x00	; 0
     104:	2a de       	rcall	.-940    	; 0xfffffd5a <__eeprom_end+0xff7efb5a>
  uint8_t min = (wgs84 - (hour * 1000000)) / 10000; //Get minute part
     106:	42 2e       	mov	r4, r18
     108:	55 24       	eor	r5, r5
     10a:	66 24       	eor	r6, r6
     10c:	77 24       	eor	r7, r7
  uint32_t minDecimal = wgs84 % 10000; //Get minute decimal part
     10e:	c7 01       	movw	r24, r14
     110:	b6 01       	movw	r22, r12
     112:	20 e1       	ldi	r18, 0x10	; 16
     114:	37 e2       	ldi	r19, 0x27	; 39
     116:	40 e0       	ldi	r20, 0x00	; 0
     118:	50 e0       	ldi	r21, 0x00	; 0
     11a:	1f de       	rcall	.-962    	; 0xfffffd5a <__eeprom_end+0xff7efb5a>
     11c:	69 83       	std	Y+1, r22	; 0x01
     11e:	7a 83       	std	Y+2, r23	; 0x02
     120:	8b 83       	std	Y+3, r24	; 0x03
     122:	9c 83       	std	Y+4, r25	; 0x04
  
  int32_t sec100 = 0;
  sec100 += hour; // Add hour part
  sec100 *= 60;
     124:	c3 01       	movw	r24, r6
     126:	b2 01       	movw	r22, r4
     128:	2c e3       	ldi	r18, 0x3C	; 60
     12a:	30 e0       	ldi	r19, 0x00	; 0
     12c:	40 e0       	ldi	r20, 0x00	; 0
     12e:	50 e0       	ldi	r21, 0x00	; 0
     130:	ac dd       	rcall	.-1192   	; 0xfffffc8a <__eeprom_end+0xff7efa8a>
     132:	4b 01       	movw	r8, r22
     134:	5c 01       	movw	r10, r24
    mult = -1;
    wgs84 = -wgs84;
  }
  
  uint8_t hour = wgs84 / 1000000; //Get hour part
  uint8_t min = (wgs84 - (hour * 1000000)) / 10000; //Get minute part
     136:	c3 01       	movw	r24, r6
     138:	b2 01       	movw	r22, r4
     13a:	20 ec       	ldi	r18, 0xC0	; 192
     13c:	3d eb       	ldi	r19, 0xBD	; 189
     13e:	40 ef       	ldi	r20, 0xF0	; 240
     140:	5f ef       	ldi	r21, 0xFF	; 255
     142:	a3 dd       	rcall	.-1210   	; 0xfffffc8a <__eeprom_end+0xff7efa8a>
     144:	6c 0d       	add	r22, r12
     146:	7d 1d       	adc	r23, r13
     148:	8e 1d       	adc	r24, r14
     14a:	9f 1d       	adc	r25, r15
     14c:	20 e1       	ldi	r18, 0x10	; 16
     14e:	37 e2       	ldi	r19, 0x27	; 39
     150:	40 e0       	ldi	r20, 0x00	; 0
     152:	50 e0       	ldi	r21, 0x00	; 0
     154:	02 de       	rcall	.-1020   	; 0xfffffd5a <__eeprom_end+0xff7efb5a>
  uint32_t minDecimal = wgs84 % 10000; //Get minute decimal part
  
  int32_t sec100 = 0;
  sec100 += hour; // Add hour part
  sec100 *= 60;
  sec100 += min; // Add minute part
     156:	82 0e       	add	r8, r18
     158:	91 1c       	adc	r9, r1
     15a:	a1 1c       	adc	r10, r1
     15c:	b1 1c       	adc	r11, r1
  sec100 *= 60;
     15e:	c5 01       	movw	r24, r10
     160:	b4 01       	movw	r22, r8
     162:	2c e3       	ldi	r18, 0x3C	; 60
     164:	30 e0       	ldi	r19, 0x00	; 0
     166:	40 e0       	ldi	r20, 0x00	; 0
     168:	50 e0       	ldi	r21, 0x00	; 0
     16a:	8f dd       	rcall	.-1250   	; 0xfffffc8a <__eeprom_end+0xff7efa8a>
     16c:	6b 01       	movw	r12, r22
     16e:	7c 01       	movw	r14, r24
  sec100 *= 100;
  minDecimal *= 60;
     170:	69 81       	ldd	r22, Y+1	; 0x01
     172:	7a 81       	ldd	r23, Y+2	; 0x02
     174:	8b 81       	ldd	r24, Y+3	; 0x03
     176:	9c 81       	ldd	r25, Y+4	; 0x04
     178:	88 dd       	rcall	.-1264   	; 0xfffffc8a <__eeprom_end+0xff7efa8a>
     17a:	4b 01       	movw	r8, r22
     17c:	5c 01       	movw	r10, r24
  int32_t sec100 = 0;
  sec100 += hour; // Add hour part
  sec100 *= 60;
  sec100 += min; // Add minute part
  sec100 *= 60;
  sec100 *= 100;
     17e:	c7 01       	movw	r24, r14
     180:	b6 01       	movw	r22, r12
     182:	24 e6       	ldi	r18, 0x64	; 100
     184:	30 e0       	ldi	r19, 0x00	; 0
     186:	40 e0       	ldi	r20, 0x00	; 0
     188:	50 e0       	ldi	r21, 0x00	; 0
     18a:	7f dd       	rcall	.-1282   	; 0xfffffc8a <__eeprom_end+0xff7efa8a>
     18c:	6b 01       	movw	r12, r22
     18e:	7c 01       	movw	r14, r24
  minDecimal *= 60;
  minDecimal /= 100;
     190:	c5 01       	movw	r24, r10
     192:	b4 01       	movw	r22, r8
     194:	c0 dd       	rcall	.-1152   	; 0xfffffd16 <__eeprom_end+0xff7efb16>
  sec100 += minDecimal; // Add minute decimal part
     196:	c2 0e       	add	r12, r18
     198:	d3 1e       	adc	r13, r19
     19a:	e4 1e       	adc	r14, r20
     19c:	f5 1e       	adc	r15, r21
  
  if (mult == -1) {
     19e:	1f 3f       	cpi	r17, 0xFF	; 255
     1a0:	41 f4       	brne	.+16     	; 0x1b2 <wgs84ToSec100+0xea>
    return -sec100;
     1a2:	f0 94       	com	r15
     1a4:	e0 94       	com	r14
     1a6:	d0 94       	com	r13
     1a8:	c0 94       	com	r12
     1aa:	c1 1c       	adc	r12, r1
     1ac:	d1 1c       	adc	r13, r1
     1ae:	e1 1c       	adc	r14, r1
     1b0:	f1 1c       	adc	r15, r1
  } else {
    return sec100;
  }
}
     1b2:	c7 01       	movw	r24, r14
     1b4:	b6 01       	movw	r22, r12
     1b6:	0f 90       	pop	r0
     1b8:	0f 90       	pop	r0
     1ba:	0f 90       	pop	r0
     1bc:	0f 90       	pop	r0
     1be:	df 91       	pop	r29
     1c0:	cf 91       	pop	r28
     1c2:	1f 91       	pop	r17
     1c4:	ff 90       	pop	r15
     1c6:	ef 90       	pop	r14
     1c8:	df 90       	pop	r13
     1ca:	cf 90       	pop	r12
     1cc:	bf 90       	pop	r11
     1ce:	af 90       	pop	r10
     1d0:	9f 90       	pop	r9
     1d2:	8f 90       	pop	r8
     1d4:	7f 90       	pop	r7
     1d6:	6f 90       	pop	r6
     1d8:	5f 90       	pop	r5
     1da:	4f 90       	pop	r4
     1dc:	08 95       	ret
static int32_t wgs84ToSec100(int32_t wgs84) { 
  int8_t mult = 1;
  
  if (wgs84 < 0) {
    mult = -1;
    wgs84 = -wgs84;
     1de:	f0 94       	com	r15
     1e0:	e0 94       	com	r14
     1e2:	d0 94       	com	r13
     1e4:	c0 94       	com	r12
     1e6:	c1 1c       	adc	r12, r1
     1e8:	d1 1c       	adc	r13, r1
     1ea:	e1 1c       	adc	r14, r1
     1ec:	f1 1c       	adc	r15, r1
// wgs84 = DDMM[.]MMMM
static int32_t wgs84ToSec100(int32_t wgs84) { 
  int8_t mult = 1;
  
  if (wgs84 < 0) {
    mult = -1;
     1ee:	1f ef       	ldi	r17, 0xFF	; 255
     1f0:	83 cf       	rjmp	.-250    	; 0xf8 <wgs84ToSec100+0x30>

000001f2 <printNumber>:
	}
	strncpy(&str[pos], str2, length);
	return length+pos;
}

static uint8_t printNumber(char* const str, uint8_t pos, int32_t number) {
     1f2:	4f 92       	push	r4
     1f4:	5f 92       	push	r5
     1f6:	6f 92       	push	r6
     1f8:	7f 92       	push	r7
     1fa:	8f 92       	push	r8
     1fc:	9f 92       	push	r9
     1fe:	af 92       	push	r10
     200:	bf 92       	push	r11
     202:	cf 92       	push	r12
     204:	df 92       	push	r13
     206:	ef 92       	push	r14
     208:	ff 92       	push	r15
     20a:	0f 93       	push	r16
     20c:	1f 93       	push	r17
     20e:	cf 93       	push	r28
     210:	df 93       	push	r29
     212:	2c 01       	movw	r4, r24
     214:	d6 2f       	mov	r29, r22
     216:	49 01       	movw	r8, r18
     218:	5a 01       	movw	r10, r20
#ifndef COMMONUTILS_H_
#define COMMONUTILS_H_

// abs seems to only support 16 bits so I had to make my own.
static uint32_t absi32(int32_t a) {
	return (a > 0) ? a : -a;
     21a:	89 01       	movw	r16, r18
     21c:	9a 01       	movw	r18, r20
     21e:	b7 fc       	sbrc	r11, 7
     220:	79 c0       	rjmp	.+242    	; 0x314 <printNumber+0x122>
	uint8_t length = 1;
	int32_t tmp = absi32(number);
	while (tmp > 9) {
     222:	c1 e0       	ldi	r28, 0x01	; 1
     224:	0a 30       	cpi	r16, 0x0A	; 10
     226:	11 05       	cpc	r17, r1
     228:	21 05       	cpc	r18, r1
     22a:	31 05       	cpc	r19, r1
     22c:	94 f0       	brlt	.+36     	; 0x252 <printNumber+0x60>
		tmp /= 10;
     22e:	9a e0       	ldi	r25, 0x0A	; 10
     230:	c9 2e       	mov	r12, r25
     232:	d1 2c       	mov	r13, r1
     234:	e1 2c       	mov	r14, r1
     236:	f1 2c       	mov	r15, r1
     238:	c9 01       	movw	r24, r18
     23a:	b8 01       	movw	r22, r16
     23c:	a7 01       	movw	r20, r14
     23e:	96 01       	movw	r18, r12
     240:	8c dd       	rcall	.-1256   	; 0xfffffd5a <__eeprom_end+0xff7efb5a>
     242:	89 01       	movw	r16, r18
     244:	9a 01       	movw	r18, r20
		++length;
     246:	cf 5f       	subi	r28, 0xFF	; 255
}

static uint8_t printNumber(char* const str, uint8_t pos, int32_t number) {
	uint8_t length = 1;
	int32_t tmp = absi32(number);
	while (tmp > 9) {
     248:	0a 30       	cpi	r16, 0x0A	; 10
     24a:	11 05       	cpc	r17, r1
     24c:	21 05       	cpc	r18, r1
     24e:	31 05       	cpc	r19, r1
     250:	9c f7       	brge	.-26     	; 0x238 <printNumber+0x46>
		tmp /= 10;
		++length;
	}
	if (number < 0) {
     252:	b7 fc       	sbrc	r11, 7
     254:	5d c0       	rjmp	.+186    	; 0x310 <printNumber+0x11e>
		++length;
	}
	if (pos + length >= TEXT_LINE_MAX_CHARS) {
     256:	8d 2f       	mov	r24, r29
     258:	90 e0       	ldi	r25, 0x00	; 0
     25a:	9c 01       	movw	r18, r24
     25c:	2c 0f       	add	r18, r28
     25e:	31 1d       	adc	r19, r1
     260:	21 32       	cpi	r18, 0x21	; 33
     262:	31 05       	cpc	r19, r1
     264:	94 f0       	brlt	.+36     	; 0x28a <printNumber+0x98>
    return TEXT_LINE_MAX_CHARS;
     266:	81 e2       	ldi	r24, 0x21	; 33
	}
	myItoa(number, &str[pos]);
	return pos+length;
}
     268:	df 91       	pop	r29
     26a:	cf 91       	pop	r28
     26c:	1f 91       	pop	r17
     26e:	0f 91       	pop	r16
     270:	ff 90       	pop	r15
     272:	ef 90       	pop	r14
     274:	df 90       	pop	r13
     276:	cf 90       	pop	r12
     278:	bf 90       	pop	r11
     27a:	af 90       	pop	r10
     27c:	9f 90       	pop	r9
     27e:	8f 90       	pop	r8
     280:	7f 90       	pop	r7
     282:	6f 90       	pop	r6
     284:	5f 90       	pop	r5
     286:	4f 90       	pop	r4
     288:	08 95       	ret
		++length;
	}
	if (pos + length >= TEXT_LINE_MAX_CHARS) {
    return TEXT_LINE_MAX_CHARS;
	}
	myItoa(number, &str[pos]);
     28a:	48 0e       	add	r4, r24
     28c:	59 1e       	adc	r5, r25
static void myItoa(int32_t n, char s[])
{
  int8_t i;
  int8_t sign = 0;
 
  if (n < 0) {  
     28e:	b7 fc       	sbrc	r11, 7
     290:	49 c0       	rjmp	.+146    	; 0x324 <printNumber+0x132>
}

static void myItoa(int32_t n, char s[])
{
  int8_t i;
  int8_t sign = 0;
     292:	10 e0       	ldi	r17, 0x00	; 0
 
  if (n < 0) {  
	  sign = -1; /* record sign */
    n = -n;          /* make n positive */
     294:	32 01       	movw	r6, r4
  }	
  i = 0;
     296:	00 e0       	ldi	r16, 0x00	; 0
  do {       /* generate digits in reverse order */
    s[i++] = n % 10 + '0';   /* get next digit */
     298:	8a e0       	ldi	r24, 0x0A	; 10
     29a:	c8 2e       	mov	r12, r24
     29c:	d1 2c       	mov	r13, r1
     29e:	e1 2c       	mov	r14, r1
     2a0:	f1 2c       	mov	r15, r1
     2a2:	01 c0       	rjmp	.+2      	; 0x2a6 <printNumber+0xb4>
     2a4:	08 2f       	mov	r16, r24
     2a6:	c5 01       	movw	r24, r10
     2a8:	b4 01       	movw	r22, r8
     2aa:	a7 01       	movw	r20, r14
     2ac:	96 01       	movw	r18, r12
     2ae:	55 dd       	rcall	.-1366   	; 0xfffffd5a <__eeprom_end+0xff7efb5a>
     2b0:	60 5d       	subi	r22, 0xD0	; 208
     2b2:	f3 01       	movw	r30, r6
     2b4:	61 93       	st	Z+, r22
     2b6:	3f 01       	movw	r6, r30
     2b8:	80 2f       	mov	r24, r16
     2ba:	8f 5f       	subi	r24, 0xFF	; 255
  } while ((n /= 10) > 0);     /* delete it */
     2bc:	49 01       	movw	r8, r18
     2be:	5a 01       	movw	r10, r20
     2c0:	12 16       	cp	r1, r18
     2c2:	13 06       	cpc	r1, r19
     2c4:	14 06       	cpc	r1, r20
     2c6:	15 06       	cpc	r1, r21
     2c8:	6c f3       	brlt	.-38     	; 0x2a4 <printNumber+0xb2>
  if (sign < 0) {
     2ca:	1f 3f       	cpi	r17, 0xFF	; 255
     2cc:	a9 f1       	breq	.+106    	; 0x338 <printNumber+0x146>
    s[i++] = '-';
  }	
  s[i] = '\0';
     2ce:	e8 2f       	mov	r30, r24
     2d0:	ff 27       	eor	r31, r31
     2d2:	e7 fd       	sbrc	r30, 7
     2d4:	f0 95       	com	r31
     2d6:	e4 0d       	add	r30, r4
     2d8:	f5 1d       	adc	r31, r5
     2da:	10 82       	st	Z, r1
}

static void myReverse(char s[], uint8_t size) {
  uint8_t i;
  char c;
  size -= 1;
     2dc:	81 50       	subi	r24, 0x01	; 1
  for (i = 0; i <= size/2; i++) {
     2de:	68 2f       	mov	r22, r24
     2e0:	66 95       	lsr	r22
     2e2:	28 2f       	mov	r18, r24
     2e4:	30 e0       	ldi	r19, 0x00	; 0
     2e6:	40 e0       	ldi	r20, 0x00	; 0
    c = s[i];
     2e8:	84 2f       	mov	r24, r20
     2ea:	90 e0       	ldi	r25, 0x00	; 0
     2ec:	f2 01       	movw	r30, r4
     2ee:	e8 0f       	add	r30, r24
     2f0:	f9 1f       	adc	r31, r25
     2f2:	50 81       	ld	r21, Z
    s[i] = s[size - i];
     2f4:	d9 01       	movw	r26, r18
     2f6:	a8 1b       	sub	r26, r24
     2f8:	b9 0b       	sbc	r27, r25
     2fa:	a4 0d       	add	r26, r4
     2fc:	b5 1d       	adc	r27, r5
     2fe:	8c 91       	ld	r24, X
     300:	80 83       	st	Z, r24
    s[size - i] = c;
     302:	5c 93       	st	X, r21

static void myReverse(char s[], uint8_t size) {
  uint8_t i;
  char c;
  size -= 1;
  for (i = 0; i <= size/2; i++) {
     304:	4f 5f       	subi	r20, 0xFF	; 255
     306:	64 17       	cp	r22, r20
     308:	78 f7       	brcc	.-34     	; 0x2e8 <printNumber+0xf6>
	return pos+length;
     30a:	8c 2f       	mov	r24, r28
     30c:	8d 0f       	add	r24, r29
     30e:	ac cf       	rjmp	.-168    	; 0x268 <printNumber+0x76>
	while (tmp > 9) {
		tmp /= 10;
		++length;
	}
	if (number < 0) {
		++length;
     310:	cf 5f       	subi	r28, 0xFF	; 255
     312:	a1 cf       	rjmp	.-190    	; 0x256 <printNumber+0x64>
#ifndef COMMONUTILS_H_
#define COMMONUTILS_H_

// abs seems to only support 16 bits so I had to make my own.
static uint32_t absi32(int32_t a) {
	return (a > 0) ? a : -a;
     314:	00 27       	eor	r16, r16
     316:	11 27       	eor	r17, r17
     318:	98 01       	movw	r18, r16
     31a:	08 19       	sub	r16, r8
     31c:	19 09       	sbc	r17, r9
     31e:	2a 09       	sbc	r18, r10
     320:	3b 09       	sbc	r19, r11
     322:	7f cf       	rjmp	.-258    	; 0x222 <printNumber+0x30>
  int8_t i;
  int8_t sign = 0;
 
  if (n < 0) {  
	  sign = -1; /* record sign */
    n = -n;          /* make n positive */
     324:	b0 94       	com	r11
     326:	a0 94       	com	r10
     328:	90 94       	com	r9
     32a:	80 94       	com	r8
     32c:	81 1c       	adc	r8, r1
     32e:	91 1c       	adc	r9, r1
     330:	a1 1c       	adc	r10, r1
     332:	b1 1c       	adc	r11, r1
{
  int8_t i;
  int8_t sign = 0;
 
  if (n < 0) {  
	  sign = -1; /* record sign */
     334:	1f ef       	ldi	r17, 0xFF	; 255
     336:	ae cf       	rjmp	.-164    	; 0x294 <printNumber+0xa2>
  i = 0;
  do {       /* generate digits in reverse order */
    s[i++] = n % 10 + '0';   /* get next digit */
  } while ((n /= 10) > 0);     /* delete it */
  if (sign < 0) {
    s[i++] = '-';
     338:	e8 2f       	mov	r30, r24
     33a:	ff 27       	eor	r31, r31
     33c:	e7 fd       	sbrc	r30, 7
     33e:	f0 95       	com	r31
     340:	e4 0d       	add	r30, r4
     342:	f5 1d       	adc	r31, r5
     344:	8d e2       	ldi	r24, 0x2D	; 45
     346:	80 83       	st	Z, r24
     348:	80 2f       	mov	r24, r16
     34a:	8e 5f       	subi	r24, 0xFE	; 254
     34c:	c0 cf       	rjmp	.-128    	; 0x2ce <printNumber+0xdc>

0000034e <printText>:
      gTextPixmap[j + (i*TEXT_LINE_MAX_CHARS)] = gTextLastCharBuffer[i];
	  }		  
	}
}

static uint8_t printText(char* const str, uint8_t pos, const char* const str2) {
     34e:	0f 93       	push	r16
     350:	1f 93       	push	r17
     352:	cf 93       	push	r28
     354:	df 93       	push	r29
     356:	8c 01       	movw	r16, r24
     358:	d6 2f       	mov	r29, r22
     35a:	fa 01       	movw	r30, r20
	uint8_t length = strlen(str2);
     35c:	da 01       	movw	r26, r20
     35e:	0d 90       	ld	r0, X+
     360:	00 20       	and	r0, r0
     362:	e9 f7       	brne	.-6      	; 0x35e <printText+0x10>
     364:	11 97       	sbiw	r26, 0x01	; 1
     366:	ca 2f       	mov	r28, r26
     368:	c4 1b       	sub	r28, r20
	if (pos + length >= TEXT_LINE_MAX_CHARS) {
     36a:	70 e0       	ldi	r23, 0x00	; 0
     36c:	8c 2f       	mov	r24, r28
     36e:	90 e0       	ldi	r25, 0x00	; 0
     370:	9b 01       	movw	r18, r22
     372:	28 0f       	add	r18, r24
     374:	39 1f       	adc	r19, r25
     376:	21 32       	cpi	r18, 0x21	; 33
     378:	31 05       	cpc	r19, r1
     37a:	7c f0       	brlt	.+30     	; 0x39a <printText+0x4c>
     37c:	41 e2       	ldi	r20, 0x21	; 33
     37e:	50 e0       	ldi	r21, 0x00	; 0
    length = TEXT_LINE_MAX_CHARS;
     380:	c1 e2       	ldi	r28, 0x21	; 33
	}
	strncpy(&str[pos], str2, length);
     382:	c8 01       	movw	r24, r16
     384:	86 0f       	add	r24, r22
     386:	97 1f       	adc	r25, r23
     388:	bf 01       	movw	r22, r30
     38a:	10 dd       	rcall	.-1504   	; 0xfffffdac <__eeprom_end+0xff7efbac>
	return length+pos;
}
     38c:	8c 2f       	mov	r24, r28
     38e:	8d 0f       	add	r24, r29
     390:	df 91       	pop	r29
     392:	cf 91       	pop	r28
     394:	1f 91       	pop	r17
     396:	0f 91       	pop	r16
     398:	08 95       	ret
	}
}

static uint8_t printText(char* const str, uint8_t pos, const char* const str2) {
	uint8_t length = strlen(str2);
	if (pos + length >= TEXT_LINE_MAX_CHARS) {
     39a:	ac 01       	movw	r20, r24
     39c:	f2 cf       	rjmp	.-28     	; 0x382 <printText+0x34>

0000039e <printNumberWithUnit>:
	}
	myItoa(number, &str[pos]);
	return pos+length;
}

static uint8_t printNumberWithUnit(char* const str, uint8_t pos, int32_t number, const char* unit) {
     39e:	0f 93       	push	r16
     3a0:	1f 93       	push	r17
     3a2:	cf 93       	push	r28
     3a4:	df 93       	push	r29
     3a6:	ec 01       	movw	r28, r24
	pos = printNumber(str, pos, number);
     3a8:	24 df       	rcall	.-440    	; 0x1f2 <printNumber>
     3aa:	68 2f       	mov	r22, r24
	return printText(str, pos, unit);
     3ac:	ce 01       	movw	r24, r28
     3ae:	a8 01       	movw	r20, r16
     3b0:	ce df       	rcall	.-100    	; 0x34e <printText>
}
     3b2:	df 91       	pop	r29
     3b4:	cf 91       	pop	r28
     3b6:	1f 91       	pop	r17
     3b8:	0f 91       	pop	r16
     3ba:	08 95       	ret

000003bc <printAdc>:
		str[pos++] = '0';
	}	
	return printNumber(str, pos, gTime.sec);
}

static uint8_t printAdc(char* const str, uint8_t pos, const uint8_t adcInput) {
     3bc:	0f 93       	push	r16
     3be:	1f 93       	push	r17
     3c0:	cf 93       	push	r28
     3c2:	df 93       	push	r29
     3c4:	ec 01       	movw	r28, r24
	uint8_t low = gAnalogInputs[adcInput].low;
     3c6:	e4 2f       	mov	r30, r20
     3c8:	f0 e0       	ldi	r31, 0x00	; 0
     3ca:	ee 0f       	add	r30, r30
     3cc:	ff 1f       	adc	r31, r31
     3ce:	e8 5c       	subi	r30, 0xC8	; 200
     3d0:	fb 4f       	sbci	r31, 0xFB	; 251
     3d2:	10 81       	ld	r17, Z
	uint8_t high = gAnalogInputs[adcInput].high;
	pos = printNumber(str, pos, high);
     3d4:	21 81       	ldd	r18, Z+1	; 0x01
     3d6:	30 e0       	ldi	r19, 0x00	; 0
     3d8:	40 e0       	ldi	r20, 0x00	; 0
     3da:	50 e0       	ldi	r21, 0x00	; 0
     3dc:	0a df       	rcall	.-492    	; 0x1f2 <printNumber>
	str[pos++] = '.';
     3de:	fe 01       	movw	r30, r28
     3e0:	e8 0f       	add	r30, r24
     3e2:	f1 1d       	adc	r31, r1
     3e4:	9e e2       	ldi	r25, 0x2E	; 46
     3e6:	90 83       	st	Z, r25
     3e8:	68 2f       	mov	r22, r24
     3ea:	6f 5f       	subi	r22, 0xFF	; 255
	if(low < 10) {
     3ec:	1a 30       	cpi	r17, 0x0A	; 10
     3ee:	30 f4       	brcc	.+12     	; 0x3fc <printAdc+0x40>
		str[pos++] = '0';
     3f0:	fe 01       	movw	r30, r28
     3f2:	e6 0f       	add	r30, r22
     3f4:	f1 1d       	adc	r31, r1
     3f6:	90 e3       	ldi	r25, 0x30	; 48
     3f8:	90 83       	st	Z, r25
     3fa:	6f 5f       	subi	r22, 0xFF	; 255
	}
	return printNumberWithUnit(str, pos, low, "V");		
     3fc:	21 2f       	mov	r18, r17
     3fe:	30 e0       	ldi	r19, 0x00	; 0
     400:	40 e0       	ldi	r20, 0x00	; 0
     402:	50 e0       	ldi	r21, 0x00	; 0
     404:	ce 01       	movw	r24, r28
     406:	00 e0       	ldi	r16, 0x00	; 0
     408:	11 e0       	ldi	r17, 0x01	; 1
     40a:	c9 df       	rcall	.-110    	; 0x39e <printNumberWithUnit>
}
     40c:	df 91       	pop	r29
     40e:	cf 91       	pop	r28
     410:	1f 91       	pop	r17
     412:	0f 91       	pop	r16
     414:	08 95       	ret

00000416 <printGpsNumber>:
/*static uint8_t printBatterLevel(char* const str, uint8_t pos, const uint8_t adcInput) {
	uint8_t batterLevel = calcBatteryLevel(adcInput);
	return printNumberWithUnit(str, pos, batterLevel, "%");
}*/

static uint8_t printGpsNumber(char* const str, uint8_t pos, int32_t number, uint8_t numberLat) {
     416:	2f 92       	push	r2
     418:	3f 92       	push	r3
     41a:	4f 92       	push	r4
     41c:	5f 92       	push	r5
     41e:	6f 92       	push	r6
     420:	7f 92       	push	r7
     422:	8f 92       	push	r8
     424:	9f 92       	push	r9
     426:	af 92       	push	r10
     428:	bf 92       	push	r11
     42a:	cf 92       	push	r12
     42c:	df 92       	push	r13
     42e:	ef 92       	push	r14
     430:	ff 92       	push	r15
     432:	0f 93       	push	r16
     434:	1f 93       	push	r17
     436:	cf 93       	push	r28
     438:	1c 01       	movw	r2, r24
     43a:	c6 2f       	mov	r28, r22
     43c:	69 01       	movw	r12, r18
     43e:	7a 01       	movw	r14, r20
	if (number == 0) {
     440:	21 15       	cp	r18, r1
     442:	31 05       	cpc	r19, r1
     444:	41 05       	cpc	r20, r1
     446:	51 05       	cpc	r21, r1
     448:	09 f4       	brne	.+2      	; 0x44c <printGpsNumber+0x36>
     44a:	56 c0       	rjmp	.+172    	; 0x4f8 <printGpsNumber+0xe2>
	  pos = printText(str, pos, "--:--.----?");
#endif
	  return pos;
  }
	
	uint8_t hour = number / 1000000;
     44c:	ca 01       	movw	r24, r20
     44e:	b9 01       	movw	r22, r18
     450:	20 e4       	ldi	r18, 0x40	; 64
     452:	32 e4       	ldi	r19, 0x42	; 66
     454:	4f e0       	ldi	r20, 0x0F	; 15
     456:	50 e0       	ldi	r21, 0x00	; 0
     458:	80 dc       	rcall	.-1792   	; 0xfffffd5a <__eeprom_end+0xff7efb5a>
#ifdef GPS_GOOGLE_FORMAT
  uint32_t min = number - (hour * 1000000);
     45a:	82 2e       	mov	r8, r18
     45c:	99 24       	eor	r9, r9
     45e:	aa 24       	eor	r10, r10
     460:	bb 24       	eor	r11, r11
     462:	c5 01       	movw	r24, r10
     464:	b4 01       	movw	r22, r8
     466:	20 ec       	ldi	r18, 0xC0	; 192
     468:	3d eb       	ldi	r19, 0xBD	; 189
     46a:	40 ef       	ldi	r20, 0xF0	; 240
     46c:	5f ef       	ldi	r21, 0xFF	; 255
     46e:	0d dc       	rcall	.-2022   	; 0xfffffc8a <__eeprom_end+0xff7efa8a>
     470:	6c 0d       	add	r22, r12
     472:	7d 1d       	adc	r23, r13
     474:	8e 1d       	adc	r24, r14
     476:	9f 1d       	adc	r25, r15
  min = (min * 100)/60;
     478:	24 e6       	ldi	r18, 0x64	; 100
     47a:	30 e0       	ldi	r19, 0x00	; 0
     47c:	40 e0       	ldi	r20, 0x00	; 0
     47e:	50 e0       	ldi	r21, 0x00	; 0
     480:	04 dc       	rcall	.-2040   	; 0xfffffc8a <__eeprom_end+0xff7efa8a>
     482:	2c e3       	ldi	r18, 0x3C	; 60
     484:	30 e0       	ldi	r19, 0x00	; 0
     486:	40 e0       	ldi	r20, 0x00	; 0
     488:	50 e0       	ldi	r21, 0x00	; 0
     48a:	45 dc       	rcall	.-1910   	; 0xfffffd16 <__eeprom_end+0xff7efb16>
     48c:	29 01       	movw	r4, r18
     48e:	3a 01       	movw	r6, r20
	uint8_t min = (number - (hour * 1000000)) / 10000; //Get minute part
  uint32_t minDecimal = number % 10000; //Get minute decimal part
#endif
  
  const char* str2;
  if (numberLat) {
     490:	00 23       	and	r16, r16
     492:	41 f5       	brne	.+80     	; 0x4e4 <printGpsNumber+0xce>
	  str2 = number > 0 ? "N" : "S";
  }
  else {
	  str2 = number > 0 ? "E" : "W";
     494:	1c 14       	cp	r1, r12
     496:	1d 04       	cpc	r1, r13
     498:	1e 04       	cpc	r1, r14
     49a:	1f 04       	cpc	r1, r15
     49c:	8c f5       	brge	.+98     	; 0x500 <__stack+0x1>
     49e:	56 e0       	ldi	r21, 0x06	; 6
     4a0:	c5 2e       	mov	r12, r21
     4a2:	51 e0       	ldi	r21, 0x01	; 1
     4a4:	d5 2e       	mov	r13, r21
  }

#ifdef GPS_GOOGLE_FORMAT
  pos = printNumberWithUnit(str, pos, hour, ".");
     4a6:	c1 01       	movw	r24, r2
     4a8:	6c 2f       	mov	r22, r28
     4aa:	a5 01       	movw	r20, r10
     4ac:	94 01       	movw	r18, r8
     4ae:	06 e1       	ldi	r16, 0x16	; 22
     4b0:	11 e0       	ldi	r17, 0x01	; 1
     4b2:	75 df       	rcall	.-278    	; 0x39e <printNumberWithUnit>
     4b4:	68 2f       	mov	r22, r24
  return printNumberWithUnit(str, pos, min, str2);
     4b6:	c1 01       	movw	r24, r2
     4b8:	a3 01       	movw	r20, r6
     4ba:	92 01       	movw	r18, r4
     4bc:	86 01       	movw	r16, r12
     4be:	6f df       	rcall	.-290    	; 0x39e <printNumberWithUnit>
#else
  pos = printNumberWithUnit(str, pos, hour, ":");
  pos = printNumberWithUnit(str, pos, min, ".");
  return printNumberWithUnit(str, pos, minDecimal, str2);
#endif
}
     4c0:	cf 91       	pop	r28
     4c2:	1f 91       	pop	r17
     4c4:	0f 91       	pop	r16
     4c6:	ff 90       	pop	r15
     4c8:	ef 90       	pop	r14
     4ca:	df 90       	pop	r13
     4cc:	cf 90       	pop	r12
     4ce:	bf 90       	pop	r11
     4d0:	af 90       	pop	r10
     4d2:	9f 90       	pop	r9
     4d4:	8f 90       	pop	r8
     4d6:	7f 90       	pop	r7
     4d8:	6f 90       	pop	r6
     4da:	5f 90       	pop	r5
     4dc:	4f 90       	pop	r4
     4de:	3f 90       	pop	r3
     4e0:	2f 90       	pop	r2
     4e2:	08 95       	ret
  uint32_t minDecimal = number % 10000; //Get minute decimal part
#endif
  
  const char* str2;
  if (numberLat) {
	  str2 = number > 0 ? "N" : "S";
     4e4:	1c 14       	cp	r1, r12
     4e6:	1d 04       	cpc	r1, r13
     4e8:	1e 04       	cpc	r1, r14
     4ea:	1f 04       	cpc	r1, r15
     4ec:	74 f4       	brge	.+28     	; 0x50a <__stack+0xb>
     4ee:	68 e0       	ldi	r22, 0x08	; 8
     4f0:	c6 2e       	mov	r12, r22
     4f2:	61 e0       	ldi	r22, 0x01	; 1
     4f4:	d6 2e       	mov	r13, r22
     4f6:	d7 cf       	rjmp	.-82     	; 0x4a6 <printGpsNumber+0x90>
}*/

static uint8_t printGpsNumber(char* const str, uint8_t pos, int32_t number, uint8_t numberLat) {
	if (number == 0) {
#ifdef GPS_GOOGLE_FORMAT
    pos = printText(str, pos, "--.-------?");
     4f8:	4a e0       	ldi	r20, 0x0A	; 10
     4fa:	51 e0       	ldi	r21, 0x01	; 1
     4fc:	28 df       	rcall	.-432    	; 0x34e <printText>
     4fe:	e0 cf       	rjmp	.-64     	; 0x4c0 <printGpsNumber+0xaa>
  const char* str2;
  if (numberLat) {
	  str2 = number > 0 ? "N" : "S";
  }
  else {
	  str2 = number > 0 ? "E" : "W";
     500:	34 e0       	ldi	r19, 0x04	; 4
     502:	c3 2e       	mov	r12, r19
     504:	31 e0       	ldi	r19, 0x01	; 1
     506:	d3 2e       	mov	r13, r19
     508:	ce cf       	rjmp	.-100    	; 0x4a6 <printGpsNumber+0x90>
  uint32_t minDecimal = number % 10000; //Get minute decimal part
#endif
  
  const char* str2;
  if (numberLat) {
	  str2 = number > 0 ? "N" : "S";
     50a:	42 e0       	ldi	r20, 0x02	; 2
     50c:	c4 2e       	mov	r12, r20
     50e:	41 e0       	ldi	r20, 0x01	; 1
     510:	d4 2e       	mov	r13, r20
     512:	c9 cf       	rjmp	.-110    	; 0x4a6 <printGpsNumber+0x90>

00000514 <parseInt.constprop.5>:
	tmp /= 1000;
	*var = tmp;
}
#endif //IMPERIAL_SYSTEM

static int32_t parseInt(const char* const text, uint8_t maxLength) {
     514:	ff 92       	push	r15
     516:	0f 93       	push	r16
     518:	1f 93       	push	r17
     51a:	cf 93       	push	r28
     51c:	df 93       	push	r29
	uint8_t i = 0;
     51e:	ff 24       	eor	r15, r15
     520:	f3 94       	inc	r15
     522:	80 91 d4 03 	lds	r24, 0x03D4
     526:	8d 32       	cpi	r24, 0x2D	; 45
     528:	09 f0       	breq	.+2      	; 0x52c <parseInt.constprop.5+0x18>
     52a:	ff 24       	eor	r15, r15
	uint8_t neg = 0;
	if (text[0] == '-') {
		++i;
		neg = 1;
	}
	while (isDigit(text[i]) && i < maxLength) {
     52c:	ef 2d       	mov	r30, r15
     52e:	f0 e0       	ldi	r31, 0x00	; 0
     530:	ec 52       	subi	r30, 0x2C	; 44
     532:	fc 4f       	sbci	r31, 0xFC	; 252
     534:	d0 81       	ld	r29, Z
  } while (c++ < 25);
  return nv;
}

inline uint8_t isDigit(char c) {
	if (c >= '0' && c <= '9') {
     536:	8d 2f       	mov	r24, r29
     538:	80 53       	subi	r24, 0x30	; 48
     53a:	8a 30       	cpi	r24, 0x0A	; 10
     53c:	90 f0       	brcs	.+36     	; 0x562 <parseInt.constprop.5+0x4e>
     53e:	00 e0       	ldi	r16, 0x00	; 0
     540:	10 e0       	ldi	r17, 0x00	; 0
     542:	98 01       	movw	r18, r16
		decimal *= 10;
		decimal += (text[i]) - '0';
		++i;		
	}
	return decimal * (neg ? -1 : 1);
     544:	ff 20       	and	r15, r15
     546:	a1 f5       	brne	.+104    	; 0x5b0 <parseInt.constprop.5+0x9c>
     548:	61 e0       	ldi	r22, 0x01	; 1
     54a:	70 e0       	ldi	r23, 0x00	; 0
     54c:	80 e0       	ldi	r24, 0x00	; 0
     54e:	90 e0       	ldi	r25, 0x00	; 0
     550:	a9 01       	movw	r20, r18
     552:	98 01       	movw	r18, r16
     554:	9a db       	rcall	.-2252   	; 0xfffffc8a <__eeprom_end+0xff7efa8a>
}
     556:	df 91       	pop	r29
     558:	cf 91       	pop	r28
     55a:	1f 91       	pop	r17
     55c:	0f 91       	pop	r16
     55e:	ff 90       	pop	r15
     560:	08 95       	ret
     562:	cf 2d       	mov	r28, r15
     564:	00 e0       	ldi	r16, 0x00	; 0
     566:	10 e0       	ldi	r17, 0x00	; 0
     568:	98 01       	movw	r18, r16
	if (text[0] == '-') {
		++i;
		neg = 1;
	}
	while (isDigit(text[i]) && i < maxLength) {
		decimal *= 10;
     56a:	c9 01       	movw	r24, r18
     56c:	b8 01       	movw	r22, r16
     56e:	2a e0       	ldi	r18, 0x0A	; 10
     570:	30 e0       	ldi	r19, 0x00	; 0
     572:	40 e0       	ldi	r20, 0x00	; 0
     574:	50 e0       	ldi	r21, 0x00	; 0
     576:	89 db       	rcall	.-2286   	; 0xfffffc8a <__eeprom_end+0xff7efa8a>
     578:	dc 01       	movw	r26, r24
     57a:	cb 01       	movw	r24, r22
		decimal += (text[i]) - '0';
     57c:	0d 2f       	mov	r16, r29
     57e:	10 e0       	ldi	r17, 0x00	; 0
     580:	00 53       	subi	r16, 0x30	; 48
     582:	10 40       	sbci	r17, 0x00	; 0
     584:	22 27       	eor	r18, r18
     586:	17 fd       	sbrc	r17, 7
     588:	20 95       	com	r18
     58a:	32 2f       	mov	r19, r18
     58c:	08 0f       	add	r16, r24
     58e:	19 1f       	adc	r17, r25
     590:	2a 1f       	adc	r18, r26
     592:	3b 1f       	adc	r19, r27
		++i;		
     594:	cf 5f       	subi	r28, 0xFF	; 255
	uint8_t neg = 0;
	if (text[0] == '-') {
		++i;
		neg = 1;
	}
	while (isDigit(text[i]) && i < maxLength) {
     596:	ec 2f       	mov	r30, r28
     598:	f0 e0       	ldi	r31, 0x00	; 0
     59a:	ec 52       	subi	r30, 0x2C	; 44
     59c:	fc 4f       	sbci	r31, 0xFC	; 252
     59e:	d0 81       	ld	r29, Z
     5a0:	8d 2f       	mov	r24, r29
     5a2:	80 53       	subi	r24, 0x30	; 48
     5a4:	8a 30       	cpi	r24, 0x0A	; 10
     5a6:	70 f6       	brcc	.-100    	; 0x544 <parseInt.constprop.5+0x30>
     5a8:	cb 30       	cpi	r28, 0x0B	; 11
     5aa:	f8 f2       	brcs	.-66     	; 0x56a <parseInt.constprop.5+0x56>
		decimal *= 10;
		decimal += (text[i]) - '0';
		++i;		
	}
	return decimal * (neg ? -1 : 1);
     5ac:	ff 20       	and	r15, r15
     5ae:	61 f2       	breq	.-104    	; 0x548 <parseInt.constprop.5+0x34>
     5b0:	6f ef       	ldi	r22, 0xFF	; 255
     5b2:	7f ef       	ldi	r23, 0xFF	; 255
     5b4:	cb 01       	movw	r24, r22
     5b6:	cc cf       	rjmp	.-104    	; 0x550 <parseInt.constprop.5+0x3c>

000005b8 <parseFloat.constprop.6>:
}

static int32_t parseFloat(const char* const text, uint8_t maxLength) {
     5b8:	ff 92       	push	r15
     5ba:	0f 93       	push	r16
     5bc:	1f 93       	push	r17
     5be:	cf 93       	push	r28
     5c0:	df 93       	push	r29
	
	uint32_t val = 0;
	uint8_t neg = 0;
     5c2:	ff 24       	eor	r15, r15
     5c4:	f3 94       	inc	r15
     5c6:	80 91 d4 03 	lds	r24, 0x03D4
     5ca:	8d 32       	cpi	r24, 0x2D	; 45
     5cc:	09 f0       	breq	.+2      	; 0x5d0 <parseFloat.constprop.6+0x18>
     5ce:	ff 24       	eor	r15, r15
     5d0:	cf 2d       	mov	r28, r15
     5d2:	00 e0       	ldi	r16, 0x00	; 0
     5d4:	10 e0       	ldi	r17, 0x00	; 0
     5d6:	98 01       	movw	r18, r16
     5d8:	18 c0       	rjmp	.+48     	; 0x60a <parseFloat.constprop.6+0x52>
		++i;
		neg = 1;
	}
	for (; i < maxLength; ++i) {
		if (isDigit(text[i])) {
			val *= 10;
     5da:	c9 01       	movw	r24, r18
     5dc:	b8 01       	movw	r22, r16
     5de:	2a e0       	ldi	r18, 0x0A	; 10
     5e0:	30 e0       	ldi	r19, 0x00	; 0
     5e2:	40 e0       	ldi	r20, 0x00	; 0
     5e4:	50 e0       	ldi	r21, 0x00	; 0
     5e6:	51 db       	rcall	.-2398   	; 0xfffffc8a <__eeprom_end+0xff7efa8a>
     5e8:	dc 01       	movw	r26, r24
     5ea:	cb 01       	movw	r24, r22
			val += (text[i]) - '0';
     5ec:	0d 2f       	mov	r16, r29
     5ee:	10 e0       	ldi	r17, 0x00	; 0
     5f0:	00 53       	subi	r16, 0x30	; 48
     5f2:	10 40       	sbci	r17, 0x00	; 0
     5f4:	22 27       	eor	r18, r18
     5f6:	17 fd       	sbrc	r17, 7
     5f8:	20 95       	com	r18
     5fa:	32 2f       	mov	r19, r18
     5fc:	08 0f       	add	r16, r24
     5fe:	19 1f       	adc	r17, r25
     600:	2a 1f       	adc	r18, r26
     602:	3b 1f       	adc	r19, r27
	uint8_t i = 0;
	if (text[0] == '-') {
		++i;
		neg = 1;
	}
	for (; i < maxLength; ++i) {
     604:	cf 5f       	subi	r28, 0xFF	; 255
     606:	cb 30       	cpi	r28, 0x0B	; 11
     608:	58 f4       	brcc	.+22     	; 0x620 <parseFloat.constprop.6+0x68>
		if (isDigit(text[i])) {
     60a:	ec 2f       	mov	r30, r28
     60c:	f0 e0       	ldi	r31, 0x00	; 0
     60e:	ec 52       	subi	r30, 0x2C	; 44
     610:	fc 4f       	sbci	r31, 0xFC	; 252
     612:	d0 81       	ld	r29, Z
     614:	8d 2f       	mov	r24, r29
     616:	80 53       	subi	r24, 0x30	; 48
     618:	8a 30       	cpi	r24, 0x0A	; 10
     61a:	f8 f2       	brcs	.-66     	; 0x5da <parseFloat.constprop.6+0x22>
			val *= 10;
			val += (text[i]) - '0';
		}
		else if (text[i] != '.') {
     61c:	de 32       	cpi	r29, 0x2E	; 46
     61e:	91 f3       	breq	.-28     	; 0x604 <parseFloat.constprop.6+0x4c>
			break;
		}			
	}
	return val * (neg ? -1 : 1);
     620:	ff 20       	and	r15, r15
     622:	69 f4       	brne	.+26     	; 0x63e <parseFloat.constprop.6+0x86>
     624:	61 e0       	ldi	r22, 0x01	; 1
     626:	70 e0       	ldi	r23, 0x00	; 0
     628:	80 e0       	ldi	r24, 0x00	; 0
     62a:	90 e0       	ldi	r25, 0x00	; 0
     62c:	a9 01       	movw	r20, r18
     62e:	98 01       	movw	r18, r16
     630:	2c db       	rcall	.-2472   	; 0xfffffc8a <__eeprom_end+0xff7efa8a>
}
     632:	df 91       	pop	r29
     634:	cf 91       	pop	r28
     636:	1f 91       	pop	r17
     638:	0f 91       	pop	r16
     63a:	ff 90       	pop	r15
     63c:	08 95       	ret
		}
		else if (text[i] != '.') {
			break;
		}			
	}
	return val * (neg ? -1 : 1);
     63e:	6f ef       	ldi	r22, 0xFF	; 255
     640:	7f ef       	ldi	r23, 0xFF	; 255
     642:	cb 01       	movw	r24, r22
     644:	f3 cf       	rjmp	.-26     	; 0x62c <parseFloat.constprop.6+0x74>

00000646 <parseGpsPart>:
	gGpsTextPartLength = strlen((const char*)gGpsText);
}
#endif //GPS_PART_TEXT

static void parseGpsPart() {
	if (gGpsTextType == GPS_TYPE_NONE) {
     646:	80 91 d2 03 	lds	r24, 0x03D2
     64a:	88 23       	and	r24, r24
     64c:	81 f1       	breq	.+96     	; 0x6ae <parseGpsPart+0x68>
			gGpsTextPartStep = GPS_GPRMC_PART_OFFSET;
			//updateParts();
		}
	}
	else if (gGpsTextType != GPS_TYPE_NONE) {
		if (gGpsTextPos != 0) {
     64e:	80 91 d1 03 	lds	r24, 0x03D1
     652:	88 23       	and	r24, r24
     654:	59 f1       	breq	.+86     	; 0x6ac <parseGpsPart+0x66>
			switch (gGpsTextPartStep) {
     656:	80 91 5e 01 	lds	r24, 0x015E
     65a:	85 36       	cpi	r24, 0x65	; 101
     65c:	89 f0       	breq	.+34     	; 0x680 <parseGpsPart+0x3a>
     65e:	86 36       	cpi	r24, 0x66	; 102
     660:	08 f0       	brcs	.+2      	; 0x664 <parseGpsPart+0x1e>
     662:	44 c0       	rjmp	.+136    	; 0x6ec <parseGpsPart+0xa6>
     664:	84 30       	cpi	r24, 0x04	; 4
     666:	09 f4       	brne	.+2      	; 0x66a <parseGpsPart+0x24>
     668:	75 c0       	rjmp	.+234    	; 0x754 <parseGpsPart+0x10e>
     66a:	85 30       	cpi	r24, 0x05	; 5
     66c:	08 f0       	brcs	.+2      	; 0x670 <parseGpsPart+0x2a>
     66e:	7e c0       	rjmp	.+252    	; 0x76c <parseGpsPart+0x126>
     670:	82 30       	cpi	r24, 0x02	; 2
     672:	09 f4       	brne	.+2      	; 0x676 <parseGpsPart+0x30>
     674:	47 c0       	rjmp	.+142    	; 0x704 <parseGpsPart+0xbe>
     676:	83 30       	cpi	r24, 0x03	; 3
     678:	08 f0       	brcs	.+2      	; 0x67c <parseGpsPart+0x36>
     67a:	21 c1       	rjmp	.+578    	; 0x8be <parseGpsPart+0x278>
     67c:	81 30       	cpi	r24, 0x01	; 1
     67e:	b1 f4       	brne	.+44     	; 0x6ac <parseGpsPart+0x66>
			case GPS_PART_GPGGA_TIME:
			case GPS_PART_GPRMC_TIME:
				gGpsLastData.gTime = parseInt(gGpsText, GPS_MAX_CHARS);
     680:	49 df       	rcall	.-366    	; 0x514 <parseInt.constprop.5>
     682:	dc 01       	movw	r26, r24
     684:	cb 01       	movw	r24, r22
     686:	80 93 83 01 	sts	0x0183, r24
     68a:	90 93 84 01 	sts	0x0184, r25
     68e:	a0 93 85 01 	sts	0x0185, r26
     692:	b0 93 86 01 	sts	0x0186, r27
     696:	08 95       	ret
}

static uint8_t parseHex(const char* const text, uint8_t maxLength) {
	uint8_t i = 0;
	uint32_t val = 0;
	while (text[i] != 0 && i < maxLength) {
     698:	80 e0       	ldi	r24, 0x00	; 0
     69a:	90 e0       	ldi	r25, 0x00	; 0
     69c:	dc 01       	movw	r26, r24
			  break;
			case GPS_PART_CHECKSUM:
				//updateParts();
				{
				uint8_t val = parseHex(gGpsText, GPS_MAX_CHARS);
				gGpsLastData.checksumValid = (val == gGpsChecksum);
     69e:	21 e0       	ldi	r18, 0x01	; 1
     6a0:	30 91 d3 03 	lds	r19, 0x03D3
     6a4:	38 13       	cpse	r19, r24
     6a6:	20 e0       	ldi	r18, 0x00	; 0
     6a8:	20 93 91 01 	sts	0x0191, r18
     6ac:	08 95       	ret
}
#endif //GPS_PART_TEXT

static void parseGpsPart() {
	if (gGpsTextType == GPS_TYPE_NONE) {
		if (!strncmp((const char*)gGpsText, "GPGGA", 5)) {
     6ae:	84 ed       	ldi	r24, 0xD4	; 212
     6b0:	93 e0       	ldi	r25, 0x03	; 3
     6b2:	68 e1       	ldi	r22, 0x18	; 24
     6b4:	71 e0       	ldi	r23, 0x01	; 1
     6b6:	45 e0       	ldi	r20, 0x05	; 5
     6b8:	50 e0       	ldi	r21, 0x00	; 0
     6ba:	6a db       	rcall	.-2348   	; 0xfffffd90 <__eeprom_end+0xff7efb90>
     6bc:	00 97       	sbiw	r24, 0x00	; 0
     6be:	81 f0       	breq	.+32     	; 0x6e0 <parseGpsPart+0x9a>
			gGpsTextType = GPS_TYPE_GPGGA;
			gGpsTextPartStep = GPS_PART_NONE;
			//updateParts();
		}
		else if (!strncmp((const char*)gGpsText, "GPRMC", 5)) {
     6c0:	84 ed       	ldi	r24, 0xD4	; 212
     6c2:	93 e0       	ldi	r25, 0x03	; 3
     6c4:	6e e1       	ldi	r22, 0x1E	; 30
     6c6:	71 e0       	ldi	r23, 0x01	; 1
     6c8:	45 e0       	ldi	r20, 0x05	; 5
     6ca:	50 e0       	ldi	r21, 0x00	; 0
     6cc:	61 db       	rcall	.-2366   	; 0xfffffd90 <__eeprom_end+0xff7efb90>
     6ce:	00 97       	sbiw	r24, 0x00	; 0
     6d0:	69 f7       	brne	.-38     	; 0x6ac <parseGpsPart+0x66>
			gGpsTextType = GPS_TYPE_GPRMC;
     6d2:	82 e0       	ldi	r24, 0x02	; 2
     6d4:	80 93 d2 03 	sts	0x03D2, r24
			gGpsTextPartStep = GPS_GPRMC_PART_OFFSET;
     6d8:	84 e6       	ldi	r24, 0x64	; 100
     6da:	80 93 5e 01 	sts	0x015E, r24
     6de:	08 95       	ret
#endif //GPS_PART_TEXT

static void parseGpsPart() {
	if (gGpsTextType == GPS_TYPE_NONE) {
		if (!strncmp((const char*)gGpsText, "GPGGA", 5)) {
			gGpsTextType = GPS_TYPE_GPGGA;
     6e0:	81 e0       	ldi	r24, 0x01	; 1
     6e2:	80 93 d2 03 	sts	0x03D2, r24
			gGpsTextPartStep = GPS_PART_NONE;
     6e6:	10 92 5e 01 	sts	0x015E, r1
     6ea:	08 95       	ret
			//updateParts();
		}
	}
	else if (gGpsTextType != GPS_TYPE_NONE) {
		if (gGpsTextPos != 0) {
			switch (gGpsTextPartStep) {
     6ec:	8a 36       	cpi	r24, 0x6A	; 106
     6ee:	b1 f0       	breq	.+44     	; 0x71c <parseGpsPart+0xd6>
     6f0:	8b 36       	cpi	r24, 0x6B	; 107
     6f2:	08 f0       	brcs	.+2      	; 0x6f6 <parseGpsPart+0xb0>
     6f4:	4e c0       	rjmp	.+156    	; 0x792 <parseGpsPart+0x14c>
     6f6:	88 36       	cpi	r24, 0x68	; 104
     6f8:	09 f4       	brne	.+2      	; 0x6fc <parseGpsPart+0xb6>
     6fa:	e1 c0       	rjmp	.+450    	; 0x8be <parseGpsPart+0x278>
     6fc:	89 36       	cpi	r24, 0x69	; 105
     6fe:	50 f5       	brcc	.+84     	; 0x754 <parseGpsPart+0x10e>
     700:	87 36       	cpi	r24, 0x67	; 103
     702:	a1 f6       	brne	.-88     	; 0x6ac <parseGpsPart+0x66>
				gGpsLastData.gTime = parseInt(gGpsText, GPS_MAX_CHARS);
				//updateParts();
				break;
			case GPS_PART_GPGGA_LAT:
			case GPS_PART_GPRMC_LAT:
				gGpsLastData.pos.latitude = parseFloat(gGpsText, GPS_MAX_CHARS);
     704:	59 df       	rcall	.-334    	; 0x5b8 <parseFloat.constprop.6>
     706:	dc 01       	movw	r26, r24
     708:	cb 01       	movw	r24, r22
     70a:	80 93 79 01 	sts	0x0179, r24
     70e:	90 93 7a 01 	sts	0x017A, r25
     712:	a0 93 7b 01 	sts	0x017B, r26
     716:	b0 93 7c 01 	sts	0x017C, r27
     71a:	08 95       	ret
				gGpsLastData.pos.longitude = parseFloat(gGpsText, GPS_MAX_CHARS);
				//updateParts();
				break;
			case GPS_PART_GPGGA_LONG_UNIT:
			case GPS_PART_GPRMC_LONG_UNIT:
				if (gGpsText[0] == 'W') {
     71c:	80 91 d4 03 	lds	r24, 0x03D4
     720:	87 35       	cpi	r24, 0x57	; 87
     722:	21 f6       	brne	.-120    	; 0x6ac <parseGpsPart+0x66>
					gGpsLastData.pos.longitude = -gGpsLastData.pos.longitude;
     724:	80 91 7d 01 	lds	r24, 0x017D
     728:	90 91 7e 01 	lds	r25, 0x017E
     72c:	a0 91 7f 01 	lds	r26, 0x017F
     730:	b0 91 80 01 	lds	r27, 0x0180
     734:	b0 95       	com	r27
     736:	a0 95       	com	r26
     738:	90 95       	com	r25
     73a:	81 95       	neg	r24
     73c:	9f 4f       	sbci	r25, 0xFF	; 255
     73e:	af 4f       	sbci	r26, 0xFF	; 255
     740:	bf 4f       	sbci	r27, 0xFF	; 255
     742:	80 93 7d 01 	sts	0x017D, r24
     746:	90 93 7e 01 	sts	0x017E, r25
     74a:	a0 93 7f 01 	sts	0x017F, r26
     74e:	b0 93 80 01 	sts	0x0180, r27
     752:	08 95       	ret
					gGpsLastData.pos.latitude = -gGpsLastData.pos.latitude;
				}
				break;
			case GPS_PART_GPGGA_LONG:
			case GPS_PART_GPRMC_LONG:
				gGpsLastData.pos.longitude = parseFloat(gGpsText, GPS_MAX_CHARS);
     754:	31 df       	rcall	.-414    	; 0x5b8 <parseFloat.constprop.6>
     756:	dc 01       	movw	r26, r24
     758:	cb 01       	movw	r24, r22
     75a:	80 93 7d 01 	sts	0x017D, r24
     75e:	90 93 7e 01 	sts	0x017E, r25
     762:	a0 93 7f 01 	sts	0x017F, r26
     766:	b0 93 80 01 	sts	0x0180, r27
     76a:	08 95       	ret
			//updateParts();
		}
	}
	else if (gGpsTextType != GPS_TYPE_NONE) {
		if (gGpsTextPos != 0) {
			switch (gGpsTextPartStep) {
     76c:	86 30       	cpi	r24, 0x06	; 6
     76e:	09 f4       	brne	.+2      	; 0x772 <parseGpsPart+0x12c>
     770:	a0 c0       	rjmp	.+320    	; 0x8b2 <parseGpsPart+0x26c>
     772:	86 30       	cpi	r24, 0x06	; 6
     774:	98 f2       	brcs	.-90     	; 0x71c <parseGpsPart+0xd6>
     776:	87 30       	cpi	r24, 0x07	; 7
     778:	09 f4       	brne	.+2      	; 0x77c <parseGpsPart+0x136>
     77a:	95 c0       	rjmp	.+298    	; 0x8a6 <parseGpsPart+0x260>
     77c:	89 30       	cpi	r24, 0x09	; 9
     77e:	09 f0       	breq	.+2      	; 0x782 <parseGpsPart+0x13c>
     780:	95 cf       	rjmp	.-214    	; 0x6ac <parseGpsPart+0x66>
				break;
			case GPS_PART_GPGGA_DILUTION:
				// Horizontal dilution of position
				break;
			case GPS_PART_GPGGA_ALTITUDE:
				gGpsLastData.pos.altitude = parseInt(gGpsText, GPS_MAX_CHARS);
     782:	c8 de       	rcall	.-624    	; 0x514 <parseInt.constprop.5>
     784:	dc 01       	movw	r26, r24
     786:	cb 01       	movw	r24, r22
     788:	90 93 82 01 	sts	0x0182, r25
     78c:	80 93 81 01 	sts	0x0181, r24
     790:	08 95       	ret
			//updateParts();
		}
	}
	else if (gGpsTextType != GPS_TYPE_NONE) {
		if (gGpsTextPos != 0) {
			switch (gGpsTextPartStep) {
     792:	8c 36       	cpi	r24, 0x6C	; 108
     794:	09 f4       	brne	.+2      	; 0x798 <parseGpsPart+0x152>
     796:	7f c0       	rjmp	.+254    	; 0x896 <parseGpsPart+0x250>
     798:	8c 36       	cpi	r24, 0x6C	; 108
     79a:	08 f4       	brcc	.+2      	; 0x79e <parseGpsPart+0x158>
     79c:	68 c0       	rjmp	.+208    	; 0x86e <parseGpsPart+0x228>
     79e:	8d 36       	cpi	r24, 0x6D	; 109
     7a0:	09 f4       	brne	.+2      	; 0x7a4 <parseGpsPart+0x15e>
     7a2:	59 c0       	rjmp	.+178    	; 0x856 <parseGpsPart+0x210>
     7a4:	88 3c       	cpi	r24, 0xC8	; 200
     7a6:	09 f0       	breq	.+2      	; 0x7aa <parseGpsPart+0x164>
     7a8:	81 cf       	rjmp	.-254    	; 0x6ac <parseGpsPart+0x66>
     7aa:	20 91 d4 03 	lds	r18, 0x03D4
     7ae:	22 23       	and	r18, r18
     7b0:	09 f4       	brne	.+2      	; 0x7b4 <parseGpsPart+0x16e>
     7b2:	72 cf       	rjmp	.-284    	; 0x698 <parseGpsPart+0x52>
				break;
			case GPS_PART_GPRMC_ANGLE:
				gGpsLastData.angle = parseInt(gGpsText, GPS_MAX_CHARS); // Only use int part
				break;
			case GPS_PART_GPRMC_DATE:
			  gGpsLastData.date = parseInt(gGpsText, GPS_MAX_CHARS);
     7b4:	e5 ed       	ldi	r30, 0xD5	; 213
     7b6:	f3 e0       	ldi	r31, 0x03	; 3
	strncpy((char*)gGpsTextPart, (char*)gGpsText, GPS_MAX_CHARS);
	gGpsTextPartLength = strlen((const char*)gGpsText);
}
#endif //GPS_PART_TEXT

static void parseGpsPart() {
     7b8:	80 e0       	ldi	r24, 0x00	; 0
     7ba:	90 e0       	ldi	r25, 0x00	; 0
     7bc:	dc 01       	movw	r26, r24
     7be:	15 c0       	rjmp	.+42     	; 0x7ea <parseGpsPart+0x1a4>
		val *= 16;
		if (text[i] >= 'A' && text[i] <= 'F') {
			val += 10 + text[i] - 'A';
     7c0:	30 e0       	ldi	r19, 0x00	; 0
     7c2:	27 53       	subi	r18, 0x37	; 55
     7c4:	30 40       	sbci	r19, 0x00	; 0
     7c6:	a9 01       	movw	r20, r18
     7c8:	66 27       	eor	r22, r22
     7ca:	57 fd       	sbrc	r21, 7
     7cc:	60 95       	com	r22
     7ce:	76 2f       	mov	r23, r22
     7d0:	84 0f       	add	r24, r20
     7d2:	95 1f       	adc	r25, r21
     7d4:	a6 1f       	adc	r26, r22
     7d6:	b7 1f       	adc	r27, r23
}

static uint8_t parseHex(const char* const text, uint8_t maxLength) {
	uint8_t i = 0;
	uint32_t val = 0;
	while (text[i] != 0 && i < maxLength) {
     7d8:	21 91       	ld	r18, Z+
     7da:	22 23       	and	r18, r18
     7dc:	09 f4       	brne	.+2      	; 0x7e0 <parseGpsPart+0x19a>
     7de:	5f cf       	rjmp	.-322    	; 0x69e <parseGpsPart+0x58>
     7e0:	33 e0       	ldi	r19, 0x03	; 3
     7e2:	e0 3e       	cpi	r30, 0xE0	; 224
     7e4:	f3 07       	cpc	r31, r19
     7e6:	09 f4       	brne	.+2      	; 0x7ea <parseGpsPart+0x1a4>
     7e8:	5a cf       	rjmp	.-332    	; 0x69e <parseGpsPart+0x58>
		val *= 16;
     7ea:	88 0f       	add	r24, r24
     7ec:	99 1f       	adc	r25, r25
     7ee:	aa 1f       	adc	r26, r26
     7f0:	bb 1f       	adc	r27, r27
     7f2:	88 0f       	add	r24, r24
     7f4:	99 1f       	adc	r25, r25
     7f6:	aa 1f       	adc	r26, r26
     7f8:	bb 1f       	adc	r27, r27
     7fa:	88 0f       	add	r24, r24
     7fc:	99 1f       	adc	r25, r25
     7fe:	aa 1f       	adc	r26, r26
     800:	bb 1f       	adc	r27, r27
     802:	88 0f       	add	r24, r24
     804:	99 1f       	adc	r25, r25
     806:	aa 1f       	adc	r26, r26
     808:	bb 1f       	adc	r27, r27
		if (text[i] >= 'A' && text[i] <= 'F') {
     80a:	32 2f       	mov	r19, r18
     80c:	31 54       	subi	r19, 0x41	; 65
     80e:	36 30       	cpi	r19, 0x06	; 6
     810:	b8 f2       	brcs	.-82     	; 0x7c0 <parseGpsPart+0x17a>
			val += 10 + text[i] - 'A';
		}
		else if (text[i] >= 'a' && text[i] <= 'f') {
     812:	32 2f       	mov	r19, r18
     814:	31 56       	subi	r19, 0x61	; 97
     816:	36 30       	cpi	r19, 0x06	; 6
     818:	68 f4       	brcc	.+26     	; 0x834 <parseGpsPart+0x1ee>
			val += 10 + text[i] - 'a';
     81a:	30 e0       	ldi	r19, 0x00	; 0
     81c:	27 55       	subi	r18, 0x57	; 87
     81e:	30 40       	sbci	r19, 0x00	; 0
     820:	a9 01       	movw	r20, r18
     822:	66 27       	eor	r22, r22
     824:	57 fd       	sbrc	r21, 7
     826:	60 95       	com	r22
     828:	76 2f       	mov	r23, r22
     82a:	84 0f       	add	r24, r20
     82c:	95 1f       	adc	r25, r21
     82e:	a6 1f       	adc	r26, r22
     830:	b7 1f       	adc	r27, r23
     832:	d2 cf       	rjmp	.-92     	; 0x7d8 <parseGpsPart+0x192>
		}
		else if (text[i] >= '0' && text[i] <= '9') {
     834:	32 2f       	mov	r19, r18
     836:	30 53       	subi	r19, 0x30	; 48
     838:	3a 30       	cpi	r19, 0x0A	; 10
     83a:	70 f6       	brcc	.-100    	; 0x7d8 <parseGpsPart+0x192>
			val += text[i] - '0';
     83c:	30 e0       	ldi	r19, 0x00	; 0
     83e:	20 53       	subi	r18, 0x30	; 48
     840:	30 40       	sbci	r19, 0x00	; 0
     842:	a9 01       	movw	r20, r18
     844:	66 27       	eor	r22, r22
     846:	57 fd       	sbrc	r21, 7
     848:	60 95       	com	r22
     84a:	76 2f       	mov	r23, r22
     84c:	84 0f       	add	r24, r20
     84e:	95 1f       	adc	r25, r21
     850:	a6 1f       	adc	r26, r22
     852:	b7 1f       	adc	r27, r23
     854:	c1 cf       	rjmp	.-126    	; 0x7d8 <parseGpsPart+0x192>
				break;
			case GPS_PART_GPRMC_ANGLE:
				gGpsLastData.angle = parseInt(gGpsText, GPS_MAX_CHARS); // Only use int part
				break;
			case GPS_PART_GPRMC_DATE:
			  gGpsLastData.date = parseInt(gGpsText, GPS_MAX_CHARS);
     856:	5e de       	rcall	.-836    	; 0x514 <parseInt.constprop.5>
     858:	dc 01       	movw	r26, r24
     85a:	cb 01       	movw	r24, r22
     85c:	80 93 8d 01 	sts	0x018D, r24
     860:	90 93 8e 01 	sts	0x018E, r25
     864:	a0 93 8f 01 	sts	0x018F, r26
     868:	b0 93 90 01 	sts	0x0190, r27
     86c:	08 95       	ret
				break;
			case GPS_PART_GPGGA_GEOID_HEIGHT_UNIT:
				// Geoid unit
				break;
			case GPS_PART_GPRMC_SPEED:
				gGpsLastData.speed = parseInt(gGpsText, GPS_MAX_CHARS); // Only use int part
     86e:	52 de       	rcall	.-860    	; 0x514 <parseInt.constprop.5>
     870:	ab 01       	movw	r20, r22
     872:	bc 01       	movw	r22, r24
#ifdef METRIC_SYSTEM
				// Convert to km/h. 1 knot = 1.852 km/h = 463/250
				gGpsLastData.speed *= 463; // Might need bigger var if you go really fast! :-)
     874:	2f ec       	ldi	r18, 0xCF	; 207
     876:	31 e0       	ldi	r19, 0x01	; 1
     878:	42 9f       	mul	r20, r18
     87a:	c0 01       	movw	r24, r0
     87c:	43 9f       	mul	r20, r19
     87e:	90 0d       	add	r25, r0
     880:	52 9f       	mul	r21, r18
     882:	90 0d       	add	r25, r0
     884:	11 24       	eor	r1, r1
				gGpsLastData.speed /= 250;
     886:	6a ef       	ldi	r22, 0xFA	; 250
     888:	70 e0       	ldi	r23, 0x00	; 0
     88a:	1e da       	rcall	.-3012   	; 0xfffffcc8 <__eeprom_end+0xff7efac8>
     88c:	70 93 8a 01 	sts	0x018A, r23
     890:	60 93 89 01 	sts	0x0189, r22
     894:	08 95       	ret
#else // IMPERIAL_SYSTEM
        knotToMph(&gGpsLastData.speed);
#endif // METRIC_SYSTEM
				break;
			case GPS_PART_GPRMC_ANGLE:
				gGpsLastData.angle = parseInt(gGpsText, GPS_MAX_CHARS); // Only use int part
     896:	3e de       	rcall	.-900    	; 0x514 <parseInt.constprop.5>
     898:	dc 01       	movw	r26, r24
     89a:	cb 01       	movw	r24, r22
     89c:	90 93 8c 01 	sts	0x018C, r25
     8a0:	80 93 8b 01 	sts	0x018B, r24
     8a4:	08 95       	ret
				break;
			case GPS_PART_GPRMC_STATUS:
				// Status
				break;
			case GPS_PART_GPGGA_SATS:
				gGpsLastData.sats = parseInt(gGpsText, GPS_MAX_CHARS);
     8a6:	36 de       	rcall	.-916    	; 0x514 <parseInt.constprop.5>
     8a8:	dc 01       	movw	r26, r24
     8aa:	cb 01       	movw	r24, r22
     8ac:	80 93 88 01 	sts	0x0188, r24
     8b0:	08 95       	ret
					gGpsLastData.pos.longitude = -gGpsLastData.pos.longitude;
				}
				//updateParts();
				break;
			case GPS_PART_GPGGA_FIX:
				gGpsLastData.fix = parseInt(gGpsText, GPS_MAX_CHARS);
     8b2:	30 de       	rcall	.-928    	; 0x514 <parseInt.constprop.5>
     8b4:	dc 01       	movw	r26, r24
     8b6:	cb 01       	movw	r24, r22
     8b8:	80 93 87 01 	sts	0x0187, r24
     8bc:	08 95       	ret
				gGpsLastData.pos.latitude = parseFloat(gGpsText, GPS_MAX_CHARS);
				//updateParts();
				break;
			case GPS_PART_GPGGA_LAT_UNIT:
			case GPS_PART_GPRMC_LAT_UNIT:
				if (gGpsText[0] == 'S') {
     8be:	80 91 d4 03 	lds	r24, 0x03D4
     8c2:	83 35       	cpi	r24, 0x53	; 83
     8c4:	09 f0       	breq	.+2      	; 0x8c8 <parseGpsPart+0x282>
     8c6:	f2 ce       	rjmp	.-540    	; 0x6ac <parseGpsPart+0x66>
					gGpsLastData.pos.latitude = -gGpsLastData.pos.latitude;
     8c8:	80 91 79 01 	lds	r24, 0x0179
     8cc:	90 91 7a 01 	lds	r25, 0x017A
     8d0:	a0 91 7b 01 	lds	r26, 0x017B
     8d4:	b0 91 7c 01 	lds	r27, 0x017C
     8d8:	b0 95       	com	r27
     8da:	a0 95       	com	r26
     8dc:	90 95       	com	r25
     8de:	81 95       	neg	r24
     8e0:	9f 4f       	sbci	r25, 0xFF	; 255
     8e2:	af 4f       	sbci	r26, 0xFF	; 255
     8e4:	bf 4f       	sbci	r27, 0xFF	; 255
     8e6:	80 93 79 01 	sts	0x0179, r24
     8ea:	90 93 7a 01 	sts	0x017A, r25
     8ee:	a0 93 7b 01 	sts	0x017B, r26
     8f2:	b0 93 7c 01 	sts	0x017C, r27
     8f6:	08 95       	ret

000008f8 <setPixel.constprop.8>:
		}		
	}
}	

inline uint8_t validPos(uint8_t x, uint8_t y) {
	if (x >= GRAPHICS_WIDTH_REAL || y >= GRAPHICS_HEIGHT) {
     8f8:	88 31       	cpi	r24, 0x18	; 24
     8fa:	10 f4       	brcc	.+4      	; 0x900 <setPixel.constprop.8+0x8>
     8fc:	68 31       	cpi	r22, 0x18	; 24
     8fe:	08 f0       	brcs	.+2      	; 0x902 <setPixel.constprop.8+0xa>
     900:	08 95       	ret
static void setPixel(uint8_t x, uint8_t y, uint8_t state) {
	if (!validPos(x, y)) {
		return;
	}
	uint8_t bitPos = 7-(x%8);
	uint8_t temp = gPixelData[x/8][y];
     902:	48 2f       	mov	r20, r24
     904:	46 95       	lsr	r20
     906:	46 95       	lsr	r20
     908:	46 95       	lsr	r20
     90a:	50 e0       	ldi	r21, 0x00	; 0

static void setPixel(uint8_t x, uint8_t y, uint8_t state) {
	if (!validPos(x, y)) {
		return;
	}
	uint8_t bitPos = 7-(x%8);
     90c:	80 95       	com	r24
     90e:	87 70       	andi	r24, 0x07	; 7
	uint8_t temp = gPixelData[x/8][y];
	if (state == 0) {
		temp &= ~(1<<bitPos);
	}
	else if (state == 1) {
		temp |= (1<<bitPos);
     910:	21 e0       	ldi	r18, 0x01	; 1
     912:	30 e0       	ldi	r19, 0x00	; 0
     914:	02 c0       	rjmp	.+4      	; 0x91a <setPixel.constprop.8+0x22>
     916:	22 0f       	add	r18, r18
     918:	33 1f       	adc	r19, r19
     91a:	8a 95       	dec	r24
     91c:	e2 f7       	brpl	.-8      	; 0x916 <setPixel.constprop.8+0x1e>
static void setPixel(uint8_t x, uint8_t y, uint8_t state) {
	if (!validPos(x, y)) {
		return;
	}
	uint8_t bitPos = 7-(x%8);
	uint8_t temp = gPixelData[x/8][y];
     91e:	fa 01       	movw	r30, r20
     920:	ee 0f       	add	r30, r30
     922:	ff 1f       	adc	r31, r31
     924:	e4 0f       	add	r30, r20
     926:	f5 1f       	adc	r31, r21
     928:	ee 0f       	add	r30, r30
     92a:	ff 1f       	adc	r31, r31
     92c:	ee 0f       	add	r30, r30
     92e:	ff 1f       	adc	r31, r31
     930:	ee 0f       	add	r30, r30
     932:	ff 1f       	adc	r31, r31
     934:	e6 0f       	add	r30, r22
     936:	f1 1d       	adc	r31, r1
     938:	e8 51       	subi	r30, 0x18	; 24
     93a:	fc 4f       	sbci	r31, 0xFC	; 252
	if (state == 0) {
		temp &= ~(1<<bitPos);
	}
	else if (state == 1) {
		temp |= (1<<bitPos);
     93c:	80 81       	ld	r24, Z
     93e:	82 2b       	or	r24, r18
	}
	else {
		temp ^= (1<<bitPos);
	}
	gPixelData[x/8][y] = temp;
     940:	80 83       	st	Z, r24
     942:	08 95       	ret

00000944 <drawLine>:
	uint8_t temp = *a;
	*a = *b;
	*b = temp;
}

static void drawLine(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
     944:	cf 92       	push	r12
     946:	df 92       	push	r13
     948:	ef 92       	push	r14
     94a:	ff 92       	push	r15
     94c:	0f 93       	push	r16
     94e:	1f 93       	push	r17
     950:	cf 93       	push	r28
     952:	df 93       	push	r29
     954:	98 2f       	mov	r25, r24
     956:	c4 2f       	mov	r28, r20
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
     958:	02 2f       	mov	r16, r18
     95a:	10 e0       	ldi	r17, 0x00	; 0
     95c:	e6 2e       	mov	r14, r22
     95e:	ff 24       	eor	r15, r15
     960:	c4 2e       	mov	r12, r20
     962:	dd 24       	eor	r13, r13
     964:	a8 2f       	mov	r26, r24
     966:	b0 e0       	ldi	r27, 0x00	; 0
     968:	a8 01       	movw	r20, r16
     96a:	4e 19       	sub	r20, r14
     96c:	5f 09       	sbc	r21, r15
     96e:	57 fd       	sbrc	r21, 7
     970:	5a c0       	rjmp	.+180    	; 0xa26 <drawLine+0xe2>
     972:	f6 01       	movw	r30, r12
     974:	ea 1b       	sub	r30, r26
     976:	fb 0b       	sbc	r31, r27
     978:	f7 fd       	sbrc	r31, 7
     97a:	5d c0       	rjmp	.+186    	; 0xa36 <drawLine+0xf2>
     97c:	d1 e0       	ldi	r29, 0x01	; 1
     97e:	e4 17       	cp	r30, r20
     980:	f5 07       	cpc	r31, r21
     982:	ec f1       	brlt	.+122    	; 0x9fe <drawLine+0xba>
     984:	d0 e0       	ldi	r29, 0x00	; 0
	if (steep) {
     986:	68 01       	movw	r12, r16
     988:	d7 01       	movw	r26, r14
		swap(&x0, &y0);
		swap(&x1, &y1);
	}		 
	if (x0 > x1) {
     98a:	c9 17       	cp	r28, r25
     98c:	08 f4       	brcc	.+2      	; 0x990 <drawLine+0x4c>
     98e:	3f c0       	rjmp	.+126    	; 0xa0e <drawLine+0xca>
     990:	ad 01       	movw	r20, r26
     992:	d6 01       	movw	r26, r12
     994:	6a 01       	movw	r12, r20
	int8_t deltax = x1 - x0;
	int8_t deltay = abs(y1 - y0);
	int8_t error = deltax / 2;
	int8_t ystep;
	int8_t y = y0;
	if (y0 < y1) { 
     996:	62 17       	cp	r22, r18
     998:	08 f4       	brcc	.+2      	; 0x99c <drawLine+0x58>
     99a:	42 c0       	rjmp	.+132    	; 0xa20 <drawLine+0xdc>
		ystep = 1; 
	}
	else {
		ystep = -1;
     99c:	ee 24       	eor	r14, r14
     99e:	ea 94       	dec	r14
	}		
	for (uint8_t x = x0; x <= x1; ++x) {
     9a0:	c9 17       	cp	r28, r25
     9a2:	20 f1       	brcs	.+72     	; 0x9ec <drawLine+0xa8>
	}		 
	if (x0 > x1) {
		swap(&x0, &x1);
		swap(&y0, &y1);
	}		 
	int8_t deltax = x1 - x0;
     9a4:	fc 2e       	mov	r15, r28
     9a6:	f9 1a       	sub	r15, r25
	int8_t deltay = abs(y1 - y0);
	int8_t error = deltax / 2;
     9a8:	1f 2d       	mov	r17, r15
     9aa:	f7 fc       	sbrc	r15, 7
     9ac:	4c c0       	rjmp	.+152    	; 0xa46 <drawLine+0x102>
     9ae:	15 95       	asr	r17
	int8_t ystep;
	int8_t y = y0;
     9b0:	06 2f       	mov	r16, r22
	if (x0 > x1) {
		swap(&x0, &x1);
		swap(&y0, &y1);
	}		 
	int8_t deltax = x1 - x0;
	int8_t deltay = abs(y1 - y0);
     9b2:	ac 19       	sub	r26, r12
     9b4:	bd 09       	sbc	r27, r13
     9b6:	b7 fd       	sbrc	r27, 7
     9b8:	42 c0       	rjmp	.+132    	; 0xa3e <drawLine+0xfa>
     9ba:	da 2e       	mov	r13, r26
     9bc:	c9 2e       	mov	r12, r25
     9be:	09 c0       	rjmp	.+18     	; 0x9d2 <drawLine+0x8e>
	else {
		ystep = -1;
	}		
	for (uint8_t x = x0; x <= x1; ++x) {
		if (steep) {
			setPixel(y, x, 1);
     9c0:	80 2f       	mov	r24, r16
     9c2:	6c 2d       	mov	r22, r12
     9c4:	99 df       	rcall	.-206    	; 0x8f8 <setPixel.constprop.8>
		}
		else { 
			setPixel(x, y, 1);
		}			
		error = error - deltay;
     9c6:	1d 19       	sub	r17, r13
		if (error < 0) {
     9c8:	17 fd       	sbrc	r17, 7
     9ca:	0b c0       	rjmp	.+22     	; 0x9e2 <drawLine+0x9e>
		ystep = 1; 
	}
	else {
		ystep = -1;
	}		
	for (uint8_t x = x0; x <= x1; ++x) {
     9cc:	c3 94       	inc	r12
     9ce:	cc 15       	cp	r28, r12
     9d0:	68 f0       	brcs	.+26     	; 0x9ec <drawLine+0xa8>
		if (steep) {
     9d2:	dd 23       	and	r29, r29
     9d4:	a9 f7       	brne	.-22     	; 0x9c0 <drawLine+0x7c>
			setPixel(y, x, 1);
		}
		else { 
			setPixel(x, y, 1);
     9d6:	8c 2d       	mov	r24, r12
     9d8:	60 2f       	mov	r22, r16
     9da:	8e df       	rcall	.-228    	; 0x8f8 <setPixel.constprop.8>
		}			
		error = error - deltay;
     9dc:	1d 19       	sub	r17, r13
		if (error < 0) {
     9de:	17 ff       	sbrs	r17, 7
     9e0:	f5 cf       	rjmp	.-22     	; 0x9cc <drawLine+0x88>
			y = y + ystep;
     9e2:	0e 0d       	add	r16, r14
			error = error + deltax;
     9e4:	1f 0d       	add	r17, r15
		ystep = 1; 
	}
	else {
		ystep = -1;
	}		
	for (uint8_t x = x0; x <= x1; ++x) {
     9e6:	c3 94       	inc	r12
     9e8:	cc 15       	cp	r28, r12
     9ea:	98 f7       	brcc	.-26     	; 0x9d2 <drawLine+0x8e>
		if (error < 0) {
			y = y + ystep;
			error = error + deltax;
		}
	}				 
}
     9ec:	df 91       	pop	r29
     9ee:	cf 91       	pop	r28
     9f0:	1f 91       	pop	r17
     9f2:	0f 91       	pop	r16
     9f4:	ff 90       	pop	r15
     9f6:	ef 90       	pop	r14
     9f8:	df 90       	pop	r13
     9fa:	cf 90       	pop	r12
     9fc:	08 95       	ret
	*b = temp;
}

static void drawLine(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep) {
     9fe:	8c 2f       	mov	r24, r28
  }
}

static void swap(uint8_t* a, uint8_t* b) {
	uint8_t temp = *a;
	*a = *b;
     a00:	c2 2f       	mov	r28, r18
	*b = temp;
     a02:	28 2f       	mov	r18, r24
}

static void drawLine(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep) {
     a04:	89 2f       	mov	r24, r25
  }
}

static void swap(uint8_t* a, uint8_t* b) {
	uint8_t temp = *a;
	*a = *b;
     a06:	96 2f       	mov	r25, r22
	*b = temp;
     a08:	68 2f       	mov	r22, r24
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep) {
		swap(&x0, &y0);
		swap(&x1, &y1);
	}		 
	if (x0 > x1) {
     a0a:	c9 17       	cp	r28, r25
     a0c:	08 f6       	brcc	.-126    	; 0x990 <drawLine+0x4c>
     a0e:	86 2f       	mov	r24, r22
  }
}

static void swap(uint8_t* a, uint8_t* b) {
	uint8_t temp = *a;
	*a = *b;
     a10:	62 2f       	mov	r22, r18
	*b = temp;
     a12:	28 2f       	mov	r18, r24
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep) {
		swap(&x0, &y0);
		swap(&x1, &y1);
	}		 
	if (x0 > x1) {
     a14:	89 2f       	mov	r24, r25
     a16:	9c 2f       	mov	r25, r28
     a18:	c8 2f       	mov	r28, r24
	int8_t deltax = x1 - x0;
	int8_t deltay = abs(y1 - y0);
	int8_t error = deltax / 2;
	int8_t ystep;
	int8_t y = y0;
	if (y0 < y1) { 
     a1a:	62 17       	cp	r22, r18
     a1c:	08 f0       	brcs	.+2      	; 0xa20 <drawLine+0xdc>
     a1e:	be cf       	rjmp	.-132    	; 0x99c <drawLine+0x58>
		ystep = 1; 
     a20:	ee 24       	eor	r14, r14
     a22:	e3 94       	inc	r14
     a24:	bd cf       	rjmp	.-134    	; 0x9a0 <drawLine+0x5c>
	*a = *b;
	*b = temp;
}

static void drawLine(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
     a26:	50 95       	com	r21
     a28:	41 95       	neg	r20
     a2a:	5f 4f       	sbci	r21, 0xFF	; 255
     a2c:	f6 01       	movw	r30, r12
     a2e:	ea 1b       	sub	r30, r26
     a30:	fb 0b       	sbc	r31, r27
     a32:	f7 ff       	sbrs	r31, 7
     a34:	a3 cf       	rjmp	.-186    	; 0x97c <drawLine+0x38>
     a36:	f0 95       	com	r31
     a38:	e1 95       	neg	r30
     a3a:	ff 4f       	sbci	r31, 0xFF	; 255
     a3c:	9f cf       	rjmp	.-194    	; 0x97c <drawLine+0x38>
	if (x0 > x1) {
		swap(&x0, &x1);
		swap(&y0, &y1);
	}		 
	int8_t deltax = x1 - x0;
	int8_t deltay = abs(y1 - y0);
     a3e:	b0 95       	com	r27
     a40:	a1 95       	neg	r26
     a42:	bf 4f       	sbci	r27, 0xFF	; 255
     a44:	ba cf       	rjmp	.-140    	; 0x9ba <drawLine+0x76>
	int8_t error = deltax / 2;
     a46:	1f 5f       	subi	r17, 0xFF	; 255
     a48:	b2 cf       	rjmp	.-156    	; 0x9ae <drawLine+0x6a>

00000a4a <drawCircle.constprop.9>:
	gPixelData[x/8][y] = temp;
}

// Credit for this one goes to wikipedia! :-)
// Some mods done by me ( name, int -> uint8 )
static void drawCircle(uint8_t x0, uint8_t y0, uint8_t radius) {
     a4a:	ff 92       	push	r15
     a4c:	0f 93       	push	r16
     a4e:	1f 93       	push	r17
     a50:	cf 93       	push	r28
     a52:	df 93       	push	r29
     a54:	00 d0       	rcall	.+0      	; 0xa56 <drawCircle.constprop.9+0xc>
     a56:	00 d0       	rcall	.+0      	; 0xa58 <drawCircle.constprop.9+0xe>
     a58:	0f 92       	push	r0
     a5a:	cd b7       	in	r28, 0x3d	; 61
     a5c:	de b7       	in	r29, 0x3e	; 62
     a5e:	18 2f       	mov	r17, r24
  volatile int8_t f = 1 - radius;
     a60:	81 e0       	ldi	r24, 0x01	; 1
     a62:	98 2f       	mov	r25, r24
     a64:	91 1b       	sub	r25, r17
     a66:	9d 83       	std	Y+5, r25	; 0x05
  volatile int8_t ddF_x = 1;
     a68:	8c 83       	std	Y+4, r24	; 0x04
  volatile int8_t ddF_y = -2 * radius;
     a6a:	81 2f       	mov	r24, r17
     a6c:	81 95       	neg	r24
     a6e:	88 0f       	add	r24, r24
     a70:	8b 83       	std	Y+3, r24	; 0x03
  volatile int8_t x = 0;
     a72:	1a 82       	std	Y+2, r1	; 0x02
  volatile int8_t y = radius;
     a74:	19 83       	std	Y+1, r17	; 0x01
 
  setPixel(x0, y0 + radius, 1);
     a76:	bb e0       	ldi	r27, 0x0B	; 11
     a78:	fb 2e       	mov	r15, r27
     a7a:	f1 0e       	add	r15, r17
     a7c:	8b e0       	ldi	r24, 0x0B	; 11
     a7e:	6f 2d       	mov	r22, r15
     a80:	3b df       	rcall	.-394    	; 0x8f8 <setPixel.constprop.8>
  setPixel(x0, y0 - radius, 1);
     a82:	0b e0       	ldi	r16, 0x0B	; 11
     a84:	01 1b       	sub	r16, r17
     a86:	8b e0       	ldi	r24, 0x0B	; 11
     a88:	60 2f       	mov	r22, r16
     a8a:	36 df       	rcall	.-404    	; 0x8f8 <setPixel.constprop.8>
  setPixel(x0 + radius, y0, 1);
     a8c:	8f 2d       	mov	r24, r15
     a8e:	6b e0       	ldi	r22, 0x0B	; 11
     a90:	33 df       	rcall	.-410    	; 0x8f8 <setPixel.constprop.8>
  setPixel(x0 - radius, y0, 1);
     a92:	80 2f       	mov	r24, r16
     a94:	6b e0       	ldi	r22, 0x0B	; 11
     a96:	30 df       	rcall	.-416    	; 0x8f8 <setPixel.constprop.8>
 
  while(x < y) {
     a98:	9a 81       	ldd	r25, Y+2	; 0x02
     a9a:	89 81       	ldd	r24, Y+1	; 0x01
     a9c:	98 17       	cp	r25, r24
     a9e:	0c f0       	brlt	.+2      	; 0xaa2 <drawCircle.constprop.9+0x58>
     aa0:	51 c0       	rjmp	.+162    	; 0xb44 <drawCircle.constprop.9+0xfa>
    }
    x++;
    ddF_x += 2;
    f += ddF_x;    
    setPixel(x0 + x, y0 + y, 1);
    setPixel(x0 - x, y0 + y, 1);
     aa2:	1b e0       	ldi	r17, 0x0B	; 11
 
  while(x < y) {
    // ddF_x == 2 * x + 1;
    // ddF_y == -2 * y;
    // f == x*x + y*y - radius*radius + 2*x - y + 1;
    if(f >= 0) {
     aa4:	8d 81       	ldd	r24, Y+5	; 0x05
     aa6:	87 fd       	sbrc	r24, 7
     aa8:	0a c0       	rjmp	.+20     	; 0xabe <drawCircle.constprop.9+0x74>
      y--;
     aaa:	89 81       	ldd	r24, Y+1	; 0x01
     aac:	81 50       	subi	r24, 0x01	; 1
     aae:	89 83       	std	Y+1, r24	; 0x01
      ddF_y += 2;
     ab0:	8b 81       	ldd	r24, Y+3	; 0x03
     ab2:	8e 5f       	subi	r24, 0xFE	; 254
     ab4:	8b 83       	std	Y+3, r24	; 0x03
      f += ddF_y;
     ab6:	9d 81       	ldd	r25, Y+5	; 0x05
     ab8:	8b 81       	ldd	r24, Y+3	; 0x03
     aba:	89 0f       	add	r24, r25
     abc:	8d 83       	std	Y+5, r24	; 0x05
    }
    x++;
     abe:	8a 81       	ldd	r24, Y+2	; 0x02
     ac0:	8f 5f       	subi	r24, 0xFF	; 255
     ac2:	8a 83       	std	Y+2, r24	; 0x02
    ddF_x += 2;
     ac4:	8c 81       	ldd	r24, Y+4	; 0x04
     ac6:	8e 5f       	subi	r24, 0xFE	; 254
     ac8:	8c 83       	std	Y+4, r24	; 0x04
    f += ddF_x;    
     aca:	9d 81       	ldd	r25, Y+5	; 0x05
     acc:	8c 81       	ldd	r24, Y+4	; 0x04
     ace:	89 0f       	add	r24, r25
     ad0:	8d 83       	std	Y+5, r24	; 0x05
    setPixel(x0 + x, y0 + y, 1);
     ad2:	8a 81       	ldd	r24, Y+2	; 0x02
     ad4:	69 81       	ldd	r22, Y+1	; 0x01
     ad6:	65 5f       	subi	r22, 0xF5	; 245
     ad8:	85 5f       	subi	r24, 0xF5	; 245
     ada:	0e df       	rcall	.-484    	; 0x8f8 <setPixel.constprop.8>
    setPixel(x0 - x, y0 + y, 1);
     adc:	8a 81       	ldd	r24, Y+2	; 0x02
     ade:	69 81       	ldd	r22, Y+1	; 0x01
     ae0:	65 5f       	subi	r22, 0xF5	; 245
     ae2:	91 2f       	mov	r25, r17
     ae4:	98 1b       	sub	r25, r24
     ae6:	89 2f       	mov	r24, r25
     ae8:	07 df       	rcall	.-498    	; 0x8f8 <setPixel.constprop.8>
    setPixel(x0 + x, y0 - y, 1);
     aea:	8a 81       	ldd	r24, Y+2	; 0x02
     aec:	99 81       	ldd	r25, Y+1	; 0x01
     aee:	61 2f       	mov	r22, r17
     af0:	69 1b       	sub	r22, r25
     af2:	85 5f       	subi	r24, 0xF5	; 245
     af4:	01 df       	rcall	.-510    	; 0x8f8 <setPixel.constprop.8>
    setPixel(x0 - x, y0 - y, 1);
     af6:	8a 81       	ldd	r24, Y+2	; 0x02
     af8:	99 81       	ldd	r25, Y+1	; 0x01
     afa:	61 2f       	mov	r22, r17
     afc:	69 1b       	sub	r22, r25
     afe:	91 2f       	mov	r25, r17
     b00:	98 1b       	sub	r25, r24
     b02:	89 2f       	mov	r24, r25
     b04:	f9 de       	rcall	.-526    	; 0x8f8 <setPixel.constprop.8>
    setPixel(x0 + y, y0 + x, 1);
     b06:	89 81       	ldd	r24, Y+1	; 0x01
     b08:	6a 81       	ldd	r22, Y+2	; 0x02
     b0a:	65 5f       	subi	r22, 0xF5	; 245
     b0c:	85 5f       	subi	r24, 0xF5	; 245
     b0e:	f4 de       	rcall	.-536    	; 0x8f8 <setPixel.constprop.8>
    setPixel(x0 - y, y0 + x, 1);
     b10:	89 81       	ldd	r24, Y+1	; 0x01
     b12:	6a 81       	ldd	r22, Y+2	; 0x02
     b14:	65 5f       	subi	r22, 0xF5	; 245
     b16:	91 2f       	mov	r25, r17
     b18:	98 1b       	sub	r25, r24
     b1a:	89 2f       	mov	r24, r25
     b1c:	ed de       	rcall	.-550    	; 0x8f8 <setPixel.constprop.8>
    setPixel(x0 + y, y0 - x, 1);
     b1e:	89 81       	ldd	r24, Y+1	; 0x01
     b20:	9a 81       	ldd	r25, Y+2	; 0x02
     b22:	61 2f       	mov	r22, r17
     b24:	69 1b       	sub	r22, r25
     b26:	85 5f       	subi	r24, 0xF5	; 245
     b28:	e7 de       	rcall	.-562    	; 0x8f8 <setPixel.constprop.8>
    setPixel(x0 - y, y0 - x, 1);
     b2a:	89 81       	ldd	r24, Y+1	; 0x01
     b2c:	9a 81       	ldd	r25, Y+2	; 0x02
     b2e:	61 2f       	mov	r22, r17
     b30:	69 1b       	sub	r22, r25
     b32:	91 2f       	mov	r25, r17
     b34:	98 1b       	sub	r25, r24
     b36:	89 2f       	mov	r24, r25
     b38:	df de       	rcall	.-578    	; 0x8f8 <setPixel.constprop.8>
  setPixel(x0, y0 + radius, 1);
  setPixel(x0, y0 - radius, 1);
  setPixel(x0 + radius, y0, 1);
  setPixel(x0 - radius, y0, 1);
 
  while(x < y) {
     b3a:	9a 81       	ldd	r25, Y+2	; 0x02
     b3c:	89 81       	ldd	r24, Y+1	; 0x01
     b3e:	98 17       	cp	r25, r24
     b40:	0c f4       	brge	.+2      	; 0xb44 <drawCircle.constprop.9+0xfa>
     b42:	b0 cf       	rjmp	.-160    	; 0xaa4 <drawCircle.constprop.9+0x5a>
    setPixel(x0 + y, y0 + x, 1);
    setPixel(x0 - y, y0 + x, 1);
    setPixel(x0 + y, y0 - x, 1);
    setPixel(x0 - y, y0 - x, 1);
  }
}
     b44:	0f 90       	pop	r0
     b46:	0f 90       	pop	r0
     b48:	0f 90       	pop	r0
     b4a:	0f 90       	pop	r0
     b4c:	0f 90       	pop	r0
     b4e:	df 91       	pop	r29
     b50:	cf 91       	pop	r28
     b52:	1f 91       	pop	r17
     b54:	0f 91       	pop	r16
     b56:	ff 90       	pop	r15
     b58:	08 95       	ret

00000b5a <main>:
#endif //GRAPICSENABLED
}

void main(void) __attribute__ ((noreturn)); // Main never returns, saves a few bytes

void main(void) {
     b5a:	cf 93       	push	r28
     b5c:	df 93       	push	r29
     b5e:	cd b7       	in	r28, 0x3d	; 61
     b60:	de b7       	in	r29, 0x3e	; 62
     b62:	66 97       	sbiw	r28, 0x16	; 22
     b64:	0f b6       	in	r0, 0x3f	; 63
     b66:	f8 94       	cli
     b68:	de bf       	out	0x3e, r29	; 62
     b6a:	0f be       	out	0x3f, r0	; 63
     b6c:	cd bf       	out	0x3d, r28	; 61
static uint8_t gKeyPressTime = 0;

static void setup(void)
{
	// Port setup
	PORTD = KEY; //key pullup & led off
     b6e:	20 e1       	ldi	r18, 0x10	; 16
     b70:	2b b9       	out	0x0b, r18	; 11
	DDRD  = LED; // led output
     b72:	88 e0       	ldi	r24, 0x08	; 8
     b74:	8a b9       	out	0x0a, r24	; 10
	PORTB &= ~OUT1;
     b76:	29 98       	cbi	0x05, 1	; 5
	DDRB  = OUT2 | SS;
     b78:	8c e0       	ldi	r24, 0x0C	; 12
     b7a:	84 b9       	out	0x04, r24	; 4
	
	TIMSK1 |= (1 << TOIE1); // Enable overflow interrupt
     b7c:	80 91 6f 00 	lds	r24, 0x006F
     b80:	81 60       	ori	r24, 0x01	; 1
     b82:	80 93 6f 00 	sts	0x006F, r24
	TCCR1B |= (1 << CS11); // Start timer at Fcpu/8
     b86:	80 91 81 00 	lds	r24, 0x0081
     b8a:	82 60       	ori	r24, 0x02	; 2
     b8c:	80 93 81 00 	sts	0x0081, r24
static uint16_t gActiveTextLastLine = 2;
static uint8_t gLineType = LINE_TYPE_UNKNOWN;

static void setupLine() {
  // Line trigger
	EICRA = (1<<ISC00) | (1<<ISC01); //set INT0 as rising edge trigger
     b90:	83 e0       	ldi	r24, 0x03	; 3
     b92:	80 93 69 00 	sts	0x0069, r24
	EIMSK = (1<<INT0); //enable INTO in global interrupt mask
     b96:	31 e0       	ldi	r19, 0x01	; 1
     b98:	3d bb       	out	0x1d, r19	; 29
	ACSR = (1<<ACD); //Comparator disabled
     b9a:	80 e8       	ldi	r24, 0x80	; 128
     b9c:	80 bf       	out	0x30, r24	; 48
	ADCSRB = 0x00;
     b9e:	10 92 7b 00 	sts	0x007B, r1

	// SPI setup
	SPDR = 0x00; // Clear spi reg or thrash will show on video
     ba2:	1e bc       	out	0x2e, r1	; 46
#ifdef TEXT_SMALL_ENABLED
	SPSR |= (1<<SPI2X); // Set dual speed
#else
	SPSR &= ~(1<<SPI2X); // Clear dual speed
     ba4:	8d b5       	in	r24, 0x2d	; 45
     ba6:	8e 7f       	andi	r24, 0xFE	; 254
     ba8:	8d bd       	out	0x2d, r24	; 45
#endif //TEXT_SMALL_ENABLED
	SPCR = (1<<SPE) | (1<<MSTR) | (1<<CPHA);
     baa:	84 e5       	ldi	r24, 0x54	; 84
     bac:	8c bd       	out	0x2c, r24	; 44
	
#ifdef TEXT_ENABLED
	gActiveTextLine = gTextLines[gActiveTextId];
     bae:	e0 91 b6 01 	lds	r30, 0x01B6
     bb2:	f0 e0       	ldi	r31, 0x00	; 0
     bb4:	ee 0f       	add	r30, r30
     bb6:	ff 1f       	adc	r31, r31
     bb8:	ee 5a       	subi	r30, 0xAE	; 174
     bba:	fe 4f       	sbci	r31, 0xFE	; 254
     bbc:	80 81       	ld	r24, Z
     bbe:	91 81       	ldd	r25, Z+1	; 0x01
     bc0:	90 93 d0 03 	sts	0x03D0, r25
     bc4:	80 93 cf 03 	sts	0x03CF, r24

#else

static void setupAdc() {
  // ADC setup
	DIDR0 = 0x00;
     bc8:	10 92 7e 00 	sts	0x007E, r1
	ADMUX |= (1<<REFS0); // Ref is AVCC
     bcc:	80 91 7c 00 	lds	r24, 0x007C
     bd0:	80 64       	ori	r24, 0x40	; 64
     bd2:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA |= (1<<ADPS2) | (1<<ADPS1); // | (1<<ADPS0); 
     bd6:	80 91 7a 00 	lds	r24, 0x007A
     bda:	86 60       	ori	r24, 0x06	; 6
     bdc:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // Free running
     be0:	10 92 7b 00 	sts	0x007B, r1
static uint8_t gGpsTextPartLength = 0;
#endif //GPS_PART_TEXT

static void setupGps() {
	// USART setup
  UBRR0H = (uint8_t)(GPS_UBRR>>8); // set baud
     be4:	30 93 c5 00 	sts	0x00C5, r19
  UBRR0L = (uint8_t)GPS_UBRR;
     be8:	87 e3       	ldi	r24, 0x37	; 55
     bea:	80 93 c4 00 	sts	0x00C4, r24
  UCSR0C = (3<<UCSZ00); // 8N1
     bee:	86 e0       	ldi	r24, 0x06	; 6
     bf0:	80 93 c2 00 	sts	0x00C2, r24
  UCSR0B = (1<<RXEN0); // Enable RX
     bf4:	20 93 c1 00 	sts	0x00C1, r18

#ifdef GPS_ENABLED
	setupGps();
#endif //GPS_ENABLED
	
	sei();
     bf8:	78 94       	sei
     bfa:	6f eb       	ldi	r22, 0xBF	; 191
     bfc:	26 2e       	mov	r2, r22
     bfe:	62 e0       	ldi	r22, 0x02	; 2
     c00:	36 2e       	mov	r3, r22
	setup();

	while(1) {
    
#ifdef GPS_ENABLED
    if(UCSR0A & (1<<RXC0)) {
     c02:	80 91 c0 00 	lds	r24, 0x00C0
     c06:	87 fd       	sbrc	r24, 7
     c08:	da c1       	rjmp	.+948    	; 0xfbe <main+0x464>
      decodeGpsData(UDR0);
    }
#endif //GPS_ENABLED
    
#ifndef DEBUG
		if((PIND & KEY) != KEY) {
     c0a:	4c 99       	sbic	0x09, 4	; 9
     c0c:	5b c1       	rjmp	.+694    	; 0xec4 <main+0x36a>
			gKeyPressed = 1;
     c0e:	81 e0       	ldi	r24, 0x01	; 1
     c10:	80 93 77 01 	sts	0x0177, r24
			if(gKeyPressTime > 50) {
     c14:	80 91 78 01 	lds	r24, 0x0178
     c18:	83 33       	cpi	r24, 0x33	; 51
     c1a:	a8 f0       	brcs	.+42     	; 0xc46 <main+0xec>
				PORTD |= LED; // long press!
     c1c:	5b 9a       	sbi	0x0b, 3	; 11
#ifdef GPS_ENABLED
#ifdef HOME_SET_WITH_BUTTON
      if (gGpsLastData.checksumValid != 0 && gGpsLastData.fix != 0) {
     c1e:	80 91 91 01 	lds	r24, 0x0191
     c22:	88 23       	and	r24, r24
     c24:	81 f0       	breq	.+32     	; 0xc46 <main+0xec>
     c26:	80 91 87 01 	lds	r24, 0x0187
     c2a:	88 23       	and	r24, r24
     c2c:	61 f0       	breq	.+24     	; 0xc46 <main+0xec>

static void setHomePos() {
#ifdef STATISTICS_ENABLED	
	resetStatistics();
#endif //STATISTICS_ENABLED
	gHomePos = gGpsLastValidData.pos;
     c2e:	a2 e9       	ldi	r26, 0x92	; 146
     c30:	b1 e0       	ldi	r27, 0x01	; 1
     c32:	ec e9       	ldi	r30, 0x9C	; 156
     c34:	f1 e0       	ldi	r31, 0x01	; 1
     c36:	8a e0       	ldi	r24, 0x0A	; 10
     c38:	01 90       	ld	r0, Z+
     c3a:	0d 92       	st	X+, r0
     c3c:	81 50       	subi	r24, 0x01	; 1
     c3e:	e1 f7       	brne	.-8      	; 0xc38 <main+0xde>
	gHomePosSet = 1;
     c40:	81 e0       	ldi	r24, 0x01	; 1
     c42:	80 93 b5 01 	sts	0x01B5, r24
#ifdef DEBUG
		gUpdateScreenData = 2;
#endif //DEBUG

#ifdef TEXT_ENABLED
    if (gUpdateScreenData == 2) {
     c46:	80 91 72 01 	lds	r24, 0x0172
     c4a:	82 30       	cpi	r24, 0x02	; 2
     c4c:	09 f4       	brne	.+2      	; 0xc50 <main+0xf6>
     c4e:	47 c1       	rjmp	.+654    	; 0xede <main+0x384>
      //DDRB |= OUT1;
      updateTextCharStartPos(gActiveTextId);
	    updateTextPixmap(gActiveTextId);
		  //DDRB &= ~OUT1;
	  }
	  else if (gUpdateScreenData == 1) {
     c50:	80 91 72 01 	lds	r24, 0x0172
     c54:	81 30       	cpi	r24, 0x01	; 1
     c56:	a9 f6       	brne	.-86     	; 0xc02 <main+0xa8>
#else
    if (gUpdateScreenData == 1) {
#endif //TEXTENABLED
			gUpdateScreenData = 0;
     c58:	10 92 72 01 	sts	0x0172, r1
#endif // ALARM_ENABLED
}
  

static void updateOnceEveryFrame() {
  if (gKeyPressed) {
     c5c:	80 91 77 01 	lds	r24, 0x0177
     c60:	88 23       	and	r24, r24
     c62:	29 f0       	breq	.+10     	; 0xc6e <main+0x114>
		++gKeyPressTime;
     c64:	80 91 78 01 	lds	r24, 0x0178
     c68:	8f 5f       	subi	r24, 0xFF	; 255
     c6a:	80 93 78 01 	sts	0x0178, r24
	}

	if (gTimeTick == 0) {
     c6e:	80 91 76 01 	lds	r24, 0x0176
     c72:	88 23       	and	r24, r24
     c74:	09 f0       	breq	.+2      	; 0xc78 <main+0x11e>
     c76:	a9 c0       	rjmp	.+338    	; 0xdca <main+0x270>

static void updateOnceEverySec() {
#ifndef GPS_ENABLED
  PORTD |= LED;
#else //GPS_ENABLED
  if (gGpsLastData.fix != 0) {
     c78:	80 91 87 01 	lds	r24, 0x0187
     c7c:	88 23       	and	r24, r24
     c7e:	09 f4       	brne	.+2      	; 0xc82 <main+0x128>
     c80:	a6 c3       	rjmp	.+1868   	; 0x13ce <main+0x874>
		PORTD |= LED;
     c82:	5b 9a       	sbi	0x0b, 3	; 11
	
#ifdef DEBUG
  //testCalcHome();
#endif // DEBUG
  
	if (gHomePosSet) {
     c84:	80 91 b5 01 	lds	r24, 0x01B5
     c88:	88 23       	and	r24, r24
     c8a:	09 f0       	breq	.+2      	; 0xc8e <main+0x134>
     c8c:	a9 c3       	rjmp	.+1874   	; 0x13e0 <main+0x886>
  distance *= mult;
#ifdef IMPERIAL_SYSTEM  
  distance *= 3281;
	distance /= 1000;
#endif //IMPERIAL_SYSTEM
  *distanceResult = distance;
     c8e:	f0 e3       	ldi	r31, 0x30	; 48
     c90:	6f 2e       	mov	r6, r31
     c92:	f4 e0       	ldi	r31, 0x04	; 4
     c94:	7f 2e       	mov	r7, r31
     c96:	a0 e6       	ldi	r26, 0x60	; 96
     c98:	4a 2e       	mov	r4, r26
     c9a:	a1 e0       	ldi	r26, 0x01	; 1
     c9c:	5a 2e       	mov	r5, r26
     c9e:	84 e6       	ldi	r24, 0x64	; 100
     ca0:	91 e0       	ldi	r25, 0x01	; 1
     ca2:	9e 83       	std	Y+6, r25	; 0x06
     ca4:	8d 83       	std	Y+5, r24	; 0x05
     ca6:	89 e3       	ldi	r24, 0x39	; 57
     ca8:	94 e0       	ldi	r25, 0x04	; 4
      if (deltaLat == 0) {
        if (deltaLong >= 0) { // Home = East
          bearing = 90; 
        } 
	      else { // Home = West
          bearing = 270;
     caa:	19 82       	std	Y+1, r1	; 0x01
	  ADCSRA &= ~(1<<ADEN) & ~(1<<ADATE); // ADC disabled & ADC auto trigger disabled
	  temp = ADCW;
#ifdef ADC_ENABLE_RAW	  
    gAnalogInputsRaw[i] = temp;
#endif
	  temp = (temp * 5 * 62) / 10;
     cac:	ba e0       	ldi	r27, 0x0A	; 10
     cae:	8b 2e       	mov	r8, r27
     cb0:	91 2c       	mov	r9, r1
     cb2:	a1 2c       	mov	r10, r1
     cb4:	b1 2c       	mov	r11, r1
     cb6:	98 8b       	std	Y+16, r25	; 0x10
     cb8:	8f 87       	std	Y+15, r24	; 0x0f
static void measureAnalog() {
  uint32_t temp = 0;
	uint8_t adcLow = 0; 
  uint8_t adcHigh = 0;
  for (uint8_t i = 0; i < ANALOG_IN_NUMBER; ++i) {
	  ADMUX &= 0xF0; // Clear mux
     cba:	80 91 7c 00 	lds	r24, 0x007C
     cbe:	80 7f       	andi	r24, 0xF0	; 240
     cc0:	80 93 7c 00 	sts	0x007C, r24
    ADMUX |= (i + ADC_OFFSET);	 //Setup adc mux
     cc4:	80 91 7c 00 	lds	r24, 0x007C
     cc8:	c9 80       	ldd	r12, Y+1	; 0x01
     cca:	8c 29       	or	r24, r12
     ccc:	80 93 7c 00 	sts	0x007C, r24
	  ADCSRA |= (1<<ADEN) | (1<<ADATE); // ADC enable & ADC auto trigger enable
     cd0:	80 91 7a 00 	lds	r24, 0x007A
     cd4:	80 6a       	ori	r24, 0xA0	; 160
     cd6:	80 93 7a 00 	sts	0x007A, r24
	  ADCSRA |= (1<<ADSC); // Start measure
     cda:	80 91 7a 00 	lds	r24, 0x007A
     cde:	80 64       	ori	r24, 0x40	; 64
     ce0:	80 93 7a 00 	sts	0x007A, r24
     ce4:	2f 85       	ldd	r18, Y+15	; 0x0f
     ce6:	38 89       	ldd	r19, Y+16	; 0x10
	  while ((ADCSRA & (1<<ADIF)) == 0); // Wait to finish
     ce8:	80 91 7a 00 	lds	r24, 0x007A
     cec:	84 ff       	sbrs	r24, 4
     cee:	fc cf       	rjmp	.-8      	; 0xce8 <main+0x18e>
     cf0:	38 8b       	std	Y+16, r19	; 0x10
     cf2:	2f 87       	std	Y+15, r18	; 0x0f
	  ADCSRA |= (1<<ADIF); // Clear ADC interrupt flag with a 1
     cf4:	80 91 7a 00 	lds	r24, 0x007A
     cf8:	80 61       	ori	r24, 0x10	; 16
     cfa:	80 93 7a 00 	sts	0x007A, r24
	  ADCSRA &= ~(1<<ADEN) & ~(1<<ADATE); // ADC disabled & ADC auto trigger disabled
     cfe:	80 91 7a 00 	lds	r24, 0x007A
     d02:	8f 75       	andi	r24, 0x5F	; 95
     d04:	80 93 7a 00 	sts	0x007A, r24
	  temp = ADCW;
     d08:	20 91 78 00 	lds	r18, 0x0078
     d0c:	30 91 79 00 	lds	r19, 0x0079
#ifdef ADC_ENABLE_RAW	  
    gAnalogInputsRaw[i] = temp;
     d10:	d3 01       	movw	r26, r6
     d12:	2d 93       	st	X+, r18
     d14:	3d 93       	st	X+, r19
     d16:	3d 01       	movw	r6, r26
#endif
	  temp = (temp * 5 * 62) / 10;
     d18:	46 e3       	ldi	r20, 0x36	; 54
     d1a:	51 e0       	ldi	r21, 0x01	; 1
     d1c:	a7 d7       	rcall	.+3918   	; 0x1c6c <__umulhisi3>
     d1e:	a5 01       	movw	r20, r10
     d20:	94 01       	movw	r18, r8
     d22:	f9 d7       	rcall	.+4082   	; 0x1d16 <__udivmodsi4>
	  temp *= gAnalogMult[i];
     d24:	f2 01       	movw	r30, r4
     d26:	61 91       	ld	r22, Z+
     d28:	2f 01       	movw	r4, r30
     d2a:	70 e0       	ldi	r23, 0x00	; 0
     d2c:	80 e0       	ldi	r24, 0x00	; 0
     d2e:	90 e0       	ldi	r25, 0x00	; 0
     d30:	ac d7       	rcall	.+3928   	; 0x1c8a <__mulsi3>
	  temp /= gAnalogDiv[i];
     d32:	ad 81       	ldd	r26, Y+5	; 0x05
     d34:	be 81       	ldd	r27, Y+6	; 0x06
     d36:	2d 91       	ld	r18, X+
     d38:	be 83       	std	Y+6, r27	; 0x06
     d3a:	ad 83       	std	Y+5, r26	; 0x05
     d3c:	30 e0       	ldi	r19, 0x00	; 0
     d3e:	40 e0       	ldi	r20, 0x00	; 0
     d40:	50 e0       	ldi	r21, 0x00	; 0
     d42:	e9 d7       	rcall	.+4050   	; 0x1d16 <__udivmodsi4>
     d44:	89 01       	movw	r16, r18
     d46:	9a 01       	movw	r18, r20
	  adcHigh = temp / 1024;
     d48:	68 01       	movw	r12, r16
     d4a:	79 01       	movw	r14, r18
     d4c:	8a e0       	ldi	r24, 0x0A	; 10
     d4e:	f6 94       	lsr	r15
     d50:	e7 94       	ror	r14
     d52:	d7 94       	ror	r13
     d54:	c7 94       	ror	r12
     d56:	8a 95       	dec	r24
     d58:	d1 f7       	brne	.-12     	; 0xd4e <main+0x1f4>
     d5a:	cb 86       	std	Y+11, r12	; 0x0b
     d5c:	dc 86       	std	Y+12, r13	; 0x0c
     d5e:	ed 86       	std	Y+13, r14	; 0x0d
     d60:	fe 86       	std	Y+14, r15	; 0x0e
#endif //GRAPICSENABLED
}

void main(void) __attribute__ ((noreturn)); // Main never returns, saves a few bytes

void main(void) {
     d62:	4f 85       	ldd	r20, Y+15	; 0x0f
     d64:	58 89       	ldd	r21, Y+16	; 0x10
     d66:	41 50       	subi	r20, 0x01	; 1
     d68:	50 40       	sbci	r21, 0x00	; 0
     d6a:	5a 87       	std	Y+10, r21	; 0x0a
     d6c:	49 87       	std	Y+9, r20	; 0x09
	  temp -= (uint16_t)(adcHigh) * 1024;
     d6e:	8c 2d       	mov	r24, r12
     d70:	90 e0       	ldi	r25, 0x00	; 0
     d72:	98 2f       	mov	r25, r24
     d74:	88 27       	eor	r24, r24
     d76:	99 0f       	add	r25, r25
     d78:	99 0f       	add	r25, r25
     d7a:	a0 e0       	ldi	r26, 0x00	; 0
     d7c:	b0 e0       	ldi	r27, 0x00	; 0
     d7e:	68 01       	movw	r12, r16
     d80:	79 01       	movw	r14, r18
     d82:	c8 1a       	sub	r12, r24
     d84:	d9 0a       	sbc	r13, r25
     d86:	ea 0a       	sbc	r14, r26
     d88:	fb 0a       	sbc	r15, r27
     d8a:	c7 01       	movw	r24, r14
     d8c:	b6 01       	movw	r22, r12
	  adcLow = (temp * 100) / 1024;
     d8e:	24 e6       	ldi	r18, 0x64	; 100
     d90:	30 e0       	ldi	r19, 0x00	; 0
     d92:	40 e0       	ldi	r20, 0x00	; 0
     d94:	50 e0       	ldi	r21, 0x00	; 0
     d96:	79 d7       	rcall	.+3826   	; 0x1c8a <__mulsi3>
     d98:	dc 01       	movw	r26, r24
     d9a:	cb 01       	movw	r24, r22
     d9c:	ea e0       	ldi	r30, 0x0A	; 10
     d9e:	b6 95       	lsr	r27
     da0:	a7 95       	ror	r26
     da2:	97 95       	ror	r25
     da4:	87 95       	ror	r24
     da6:	ea 95       	dec	r30
     da8:	d1 f7       	brne	.-12     	; 0xd9e <main+0x244>
     daa:	e9 85       	ldd	r30, Y+9	; 0x09
     dac:	fa 85       	ldd	r31, Y+10	; 0x0a
     dae:	80 83       	st	Z, r24
	
	  gAnalogInputs[i].low = adcLow;
    gAnalogInputs[i].high = adcHigh;
     db0:	eb 85       	ldd	r30, Y+11	; 0x0b
     db2:	af 85       	ldd	r26, Y+15	; 0x0f
     db4:	b8 89       	ldd	r27, Y+16	; 0x10
     db6:	ec 93       	st	X, r30

static void measureAnalog() {
  uint32_t temp = 0;
	uint8_t adcLow = 0; 
  uint8_t adcHigh = 0;
  for (uint8_t i = 0; i < ANALOG_IN_NUMBER; ++i) {
     db8:	f9 81       	ldd	r31, Y+1	; 0x01
     dba:	ff 5f       	subi	r31, 0xFF	; 255
     dbc:	f9 83       	std	Y+1, r31	; 0x01
     dbe:	12 96       	adiw	r26, 0x02	; 2
     dc0:	b8 8b       	std	Y+16, r27	; 0x10
     dc2:	af 87       	std	Y+15, r26	; 0x0f
     dc4:	f4 30       	cpi	r31, 0x04	; 4
     dc6:	09 f0       	breq	.+2      	; 0xdca <main+0x270>
     dc8:	78 cf       	rjmp	.-272    	; 0xcba <main+0x160>
static volatile uint8_t gBlink1Hz = 0;

#ifdef TIME_ENABLED

static void updateTime() {
	++gTimeTick;
     dca:	80 91 76 01 	lds	r24, 0x0176
     dce:	8f 5f       	subi	r24, 0xFF	; 255
     dd0:	80 93 76 01 	sts	0x0176, r24
	if (gTimeTick >= TIME_FRAMES_PER_SEC) {
     dd4:	80 91 76 01 	lds	r24, 0x0176
     dd8:	82 33       	cpi	r24, 0x32	; 50
     dda:	78 f0       	brcs	.+30     	; 0xdfa <main+0x2a0>
		gTimeTick = 0;
     ddc:	10 92 76 01 	sts	0x0176, r1
		gTime.sec++;
     de0:	80 91 74 01 	lds	r24, 0x0174
     de4:	8f 5f       	subi	r24, 0xFF	; 255
     de6:	80 93 74 01 	sts	0x0174, r24
		gBlink1Hz = (gBlink1Hz+1)%2;
     dea:	80 91 73 01 	lds	r24, 0x0173
     dee:	90 e0       	ldi	r25, 0x00	; 0
     df0:	01 96       	adiw	r24, 0x01	; 1
     df2:	81 70       	andi	r24, 0x01	; 1
     df4:	90 70       	andi	r25, 0x00	; 0
     df6:	80 93 73 01 	sts	0x0173, r24
	}
	if (gTime.sec >= 60) {
     dfa:	80 91 74 01 	lds	r24, 0x0174
     dfe:	8c 33       	cpi	r24, 0x3C	; 60
     e00:	38 f0       	brcs	.+14     	; 0xe10 <main+0x2b6>
		gTime.sec = 0;
     e02:	10 92 74 01 	sts	0x0174, r1
		gTime.min++;
     e06:	80 91 75 01 	lds	r24, 0x0175
     e0a:	8f 5f       	subi	r24, 0xFF	; 255
     e0c:	80 93 75 01 	sts	0x0175, r24
	}
	if (gTime.min >= 60) {
     e10:	80 91 75 01 	lds	r24, 0x0175
     e14:	8c 33       	cpi	r24, 0x3C	; 60
     e16:	10 f0       	brcs	.+4      	; 0xe1c <main+0x2c2>
		gTime.min = 0;
     e18:	10 92 75 01 	sts	0x0175, r1
static uint8_t calcGenericLevel(uint8_t adcInput, uint16_t minLevel, uint16_t maxLevel) {
	uint16_t level = ((gAnalogInputs[adcInput].high * 100) + gAnalogInputs[adcInput].low);
	if (level > maxLevel) {
		level = 100;
	}		
	else if (level > minLevel) {
     e1c:	91 e0       	ldi	r25, 0x01	; 1
     e1e:	80 e0       	ldi	r24, 0x00	; 0
     e20:	d9 2e       	mov	r13, r25
     e22:	e8 2e       	mov	r14, r24
     e24:	2e 2d       	mov	r18, r14
     e26:	30 e0       	ldi	r19, 0x00	; 0
     e28:	81 e2       	ldi	r24, 0x21	; 33
     e2a:	90 e0       	ldi	r25, 0x00	; 0
     e2c:	28 9f       	mul	r18, r24
     e2e:	f0 01       	movw	r30, r0
     e30:	29 9f       	mul	r18, r25
     e32:	f0 0d       	add	r31, r0
     e34:	38 9f       	mul	r19, r24
     e36:	f0 0d       	add	r31, r0
     e38:	11 24       	eor	r1, r1
     e3a:	e9 54       	subi	r30, 0x49	; 73
     e3c:	fe 4f       	sbci	r31, 0xFE	; 254
     e3e:	81 e2       	ldi	r24, 0x21	; 33
#endif // TEXT_INVERTED_ENABLED

// Functions
static void clearText(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
		gText[textId][j] = 0;
     e40:	11 92       	st	Z+, r1
     e42:	81 50       	subi	r24, 0x01	; 1
static uint8_t gTextInverted[TEXT_LINES][TEXT_LINE_MAX_CHARS/8];
#endif // TEXT_INVERTED_ENABLED

// Functions
static void clearText(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
     e44:	e9 f7       	brne	.-6      	; 0xe40 <main+0x2e6>
#ifdef TEXT_ENABLED
static void updateText(uint8_t textId) {
  //testPrintDebugInfo();
  uint8_t pos = 0;

	if (textId == 0) {
     e46:	ee 20       	and	r14, r14
     e48:	09 f4       	brne	.+2      	; 0xe4c <main+0x2f2>
     e4a:	e1 c0       	rjmp	.+450    	; 0x100e <main+0x4b4>
	  pos = printTime(gText[textId], TEXT_LINE_MAX_CHARS-9);
#else
    pos = printTime(gText[textId], TEXT_LINE_MAX_CHARS-6);
#endif //TIME_HOUR_ENABLED
  }
  else if (textId == 1) {
     e4c:	cc 24       	eor	r12, r12
     e4e:	c3 94       	inc	r12
     e50:	ec 14       	cp	r14, r12
     e52:	09 f4       	brne	.+2      	; 0xe56 <main+0x2fc>
     e54:	39 c2       	rjmp	.+1138   	; 0x12c8 <main+0x76e>
	    pos = printRssiLevel(gText[textId], 14, ANALOG_IN_3);
	  }
#endif //ANALOG_IN_NUMBER == 2

  }
  else if (textId == 2) {
     e56:	52 e0       	ldi	r21, 0x02	; 2
     e58:	e5 16       	cp	r14, r21
     e5a:	09 f4       	brne	.+2      	; 0xe5e <main+0x304>
     e5c:	f7 c1       	rjmp	.+1006   	; 0x124c <main+0x6f2>
	  else {
		  //printCompassArrow(gText[textId], 7, gGpsLastValidData.angle, 19);
	  }
#endif //GPS_ENABLED
  }	  
  else if (textId == 3) {
     e5e:	63 e0       	ldi	r22, 0x03	; 3
     e60:	e6 16       	cp	r14, r22
     e62:	09 f4       	brne	.+2      	; 0xe66 <main+0x30c>
     e64:	0b c2       	rjmp	.+1046   	; 0x127c <main+0x722>
	  else {
		  //printCompass(gText[textId], 7, gGpsLastValidData.angle, 19);
	  }
#endif //GPS_ENABLED
	}
	else if (textId == 4) {
     e66:	74 e0       	ldi	r23, 0x04	; 4
     e68:	e7 16       	cp	r14, r23
     e6a:	09 f4       	brne	.+2      	; 0xe6e <main+0x314>
     e6c:	74 c2       	rjmp	.+1256   	; 0x1356 <main+0x7fc>
	  }		  
#endif //GPS_ENABLED
	}
	else if (textId == 5) {
#ifdef GPS_ENABLED
		pos = printText(gText[textId], 0, "SPD");
     e6e:	8c e5       	ldi	r24, 0x5C	; 92
     e70:	92 e0       	ldi	r25, 0x02	; 2
     e72:	60 e0       	ldi	r22, 0x00	; 0
     e74:	4f e3       	ldi	r20, 0x3F	; 63
     e76:	51 e0       	ldi	r21, 0x01	; 1
     e78:	6a da       	rcall	.-2860   	; 0x34e <printText>
		pos = printText(gText[textId], 5, "LOS");
     e7a:	8c e5       	ldi	r24, 0x5C	; 92
     e7c:	92 e0       	ldi	r25, 0x02	; 2
     e7e:	65 e0       	ldi	r22, 0x05	; 5
     e80:	43 e4       	ldi	r20, 0x43	; 67
     e82:	51 e0       	ldi	r21, 0x01	; 1
     e84:	64 da       	rcall	.-2872   	; 0x34e <printText>
		
		if (gHomePosSet) {
     e86:	90 91 b5 01 	lds	r25, 0x01B5
		  pos = printText(gText[textId], pos+3, "\146");
     e8a:	68 2f       	mov	r22, r24
     e8c:	6d 5f       	subi	r22, 0xFD	; 253
	else if (textId == 5) {
#ifdef GPS_ENABLED
		pos = printText(gText[textId], 0, "SPD");
		pos = printText(gText[textId], 5, "LOS");
		
		if (gHomePosSet) {
     e8e:	99 23       	and	r25, r25
     e90:	09 f4       	brne	.+2      	; 0xe94 <main+0x33a>
     e92:	77 c3       	rjmp	.+1774   	; 0x1582 <main+0xa28>
		  pos = printText(gText[textId], pos+3, "\146");
     e94:	8c e5       	ldi	r24, 0x5C	; 92
     e96:	92 e0       	ldi	r25, 0x02	; 2
     e98:	47 e4       	ldi	r20, 0x47	; 71
     e9a:	51 e0       	ldi	r21, 0x01	; 1
     e9c:	58 da       	rcall	.-2896   	; 0x34e <printText>
		}
		else {
			pos = printText(gText[textId], pos+3, "\147");
		}
		
		pos = printText(gText[textId], TEXT_LINE_MAX_CHARS-10, "\150");
     e9e:	8c e5       	ldi	r24, 0x5C	; 92
     ea0:	92 e0       	ldi	r25, 0x02	; 2
     ea2:	67 e1       	ldi	r22, 0x17	; 23
     ea4:	4b e4       	ldi	r20, 0x4B	; 75
     ea6:	51 e0       	ldi	r21, 0x01	; 1
     ea8:	52 da       	rcall	.-2908   	; 0x34e <printText>
		pos = printText(gText[textId], TEXT_LINE_MAX_CHARS-5, "ALT");
     eaa:	8c e5       	ldi	r24, 0x5C	; 92
     eac:	92 e0       	ldi	r25, 0x02	; 2
     eae:	6c e1       	ldi	r22, 0x1C	; 28
     eb0:	4d e4       	ldi	r20, 0x4D	; 77
     eb2:	51 e0       	ldi	r21, 0x01	; 1
     eb4:	4c da       	rcall	.-2920   	; 0x34e <printText>
#ifdef TIME_ENABLED
	updateTime();
#endif //TIMEENABLED

#ifdef TEXT_ENABLED
  for (uint8_t i = 0; i < TEXT_LINES; ++i) {
     eb6:	86 e0       	ldi	r24, 0x06	; 6
     eb8:	d8 16       	cp	r13, r24
     eba:	09 f4       	brne	.+2      	; 0xebe <main+0x364>
     ebc:	e5 c0       	rjmp	.+458    	; 0x1088 <main+0x52e>
     ebe:	e3 94       	inc	r14
     ec0:	d3 94       	inc	r13
     ec2:	b0 cf       	rjmp	.-160    	; 0xe24 <main+0x2ca>
#endif //HOME_SET_WITH_BUTTON
#endif //GPS_ENABLED
			}
		}
		else {
			if (gKeyPressed) {
     ec4:	80 91 77 01 	lds	r24, 0x0177
     ec8:	81 11       	cpse	r24, r1
				PORTD &= ~LED;  // led off
     eca:	5b 98       	cbi	0x0b, 3	; 11
			}				
			gKeyPressed = 0;
     ecc:	10 92 77 01 	sts	0x0177, r1
			gKeyPressTime = 0;
     ed0:	10 92 78 01 	sts	0x0178, r1
#ifdef DEBUG
		gUpdateScreenData = 2;
#endif //DEBUG

#ifdef TEXT_ENABLED
    if (gUpdateScreenData == 2) {
     ed4:	80 91 72 01 	lds	r24, 0x0172
     ed8:	82 30       	cpi	r24, 0x02	; 2
     eda:	09 f0       	breq	.+2      	; 0xede <main+0x384>
     edc:	b9 ce       	rjmp	.-654    	; 0xc50 <main+0xf6>
		  gUpdateScreenData = 0;
     ede:	10 92 72 01 	sts	0x0172, r1
#endif //GRAPICSENABLED
}

void main(void) __attribute__ ((noreturn)); // Main never returns, saves a few bytes

void main(void) {
     ee2:	20 91 b6 01 	lds	r18, 0x01B6
     ee6:	30 e0       	ldi	r19, 0x00	; 0
     ee8:	81 e2       	ldi	r24, 0x21	; 33
     eea:	90 e0       	ldi	r25, 0x00	; 0
     eec:	28 9f       	mul	r18, r24
     eee:	d0 01       	movw	r26, r0
     ef0:	29 9f       	mul	r18, r25
     ef2:	b0 0d       	add	r27, r0
     ef4:	38 9f       	mul	r19, r24
     ef6:	b0 0d       	add	r27, r0
     ef8:	11 24       	eor	r1, r1
     efa:	a9 54       	subi	r26, 0x49	; 73
     efc:	be 4f       	sbci	r27, 0xFE	; 254
		gUpdateScreenData = 2;
#endif //DEBUG

#ifdef TEXT_ENABLED
    if (gUpdateScreenData == 2) {
		  gUpdateScreenData = 0;
     efe:	4d e7       	ldi	r20, 0x7D	; 125
     f00:	e4 2e       	mov	r14, r20
     f02:	42 e0       	ldi	r20, 0x02	; 2
     f04:	f4 2e       	mov	r15, r20
#endif //GRAPICSENABLED
}

void main(void) __attribute__ ((noreturn)); // Main never returns, saves a few bytes

void main(void) {
     f06:	f7 01       	movw	r30, r14
     f08:	80 e0       	ldi	r24, 0x00	; 0
     f0a:	90 e0       	ldi	r25, 0x00	; 0
     f0c:	13 c0       	rjmp	.+38     	; 0xf34 <main+0x3da>
		uint8_t character = gText[textId][j];
		int16_t eepromPos;
		if (character == ' ' || character == 0) {
			eepromPos = -1;
		}
		else if (character < CHAR_OFFSET + CHAR_LENGTH) {
     f0e:	2b 35       	cpi	r18, 0x5B	; 91
     f10:	08 f0       	brcs	.+2      	; 0xf14 <main+0x3ba>
     f12:	83 c1       	rjmp	.+774    	; 0x121a <main+0x6c0>
			uint16_t charPos = ((character - CHAR_OFFSET) * TEXT_CHAR_HEIGHT);
     f14:	82 2f       	mov	r24, r18
     f16:	90 e0       	ldi	r25, 0x00	; 0
     f18:	88 0f       	add	r24, r24
     f1a:	99 1f       	adc	r25, r25
     f1c:	88 0f       	add	r24, r24
     f1e:	99 1f       	adc	r25, r25
     f20:	88 0f       	add	r24, r24
     f22:	99 1f       	adc	r25, r25
			eepromPos = (int16_t)&(oem6x8[charPos]);
     f24:	88 52       	subi	r24, 0x28	; 40
     f26:	91 40       	sbci	r25, 0x01	; 1
		else if (character > CHAR_SPECIAL_OFFSET && character < CHAR_SPECIAL_OFFSET+CHAR_SPECIAL_LENGTH) {
			uint16_t charPos = ((character - CHAR_SPECIAL_OFFSET) * TEXT_CHAR_HEIGHT);
			eepromPos = (int16_t)&(specialChars[charPos]);
		}
#endif //TEXT_USE_SPECIAL_CHARS
		gTextCharEepromPos[j] = eepromPos;
     f28:	81 93       	st	Z+, r24
     f2a:	91 93       	st	Z+, r25
	return 0;
}
#endif // TEXT_INVERTED_ENABLED

static void updateTextCharStartPos(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
     f2c:	42 e0       	ldi	r20, 0x02	; 2
     f2e:	ef 3b       	cpi	r30, 0xBF	; 191
     f30:	f4 07       	cpc	r31, r20
     f32:	69 f0       	breq	.+26     	; 0xf4e <main+0x3f4>
		uint8_t character = gText[textId][j];
     f34:	2d 91       	ld	r18, X+
		int16_t eepromPos;
		if (character == ' ' || character == 0) {
     f36:	20 32       	cpi	r18, 0x20	; 32
     f38:	11 f0       	breq	.+4      	; 0xf3e <main+0x3e4>
     f3a:	22 23       	and	r18, r18
     f3c:	41 f7       	brne	.-48     	; 0xf0e <main+0x3b4>
			eepromPos = -1;
     f3e:	8f ef       	ldi	r24, 0xFF	; 255
     f40:	9f ef       	ldi	r25, 0xFF	; 255
		else if (character > CHAR_SPECIAL_OFFSET && character < CHAR_SPECIAL_OFFSET+CHAR_SPECIAL_LENGTH) {
			uint16_t charPos = ((character - CHAR_SPECIAL_OFFSET) * TEXT_CHAR_HEIGHT);
			eepromPos = (int16_t)&(specialChars[charPos]);
		}
#endif //TEXT_USE_SPECIAL_CHARS
		gTextCharEepromPos[j] = eepromPos;
     f42:	81 93       	st	Z+, r24
     f44:	91 93       	st	Z+, r25
	return 0;
}
#endif // TEXT_INVERTED_ENABLED

static void updateTextCharStartPos(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
     f46:	42 e0       	ldi	r20, 0x02	; 2
     f48:	ef 3b       	cpi	r30, 0xBF	; 191
     f4a:	f4 07       	cpc	r31, r20
     f4c:	99 f7       	brne	.-26     	; 0xf34 <main+0x3da>
     f4e:	00 e0       	ldi	r16, 0x00	; 0
     f50:	10 e0       	ldi	r17, 0x00	; 0
		  if (eepromPos != -1) {
		  eeprom_read_block((void*)gTextLastCharBuffer, (const void*)eepromPos, 8);
			  gTextLastCharEepromPos = eepromPos;
		  }
		  else {
			  memset(gTextLastCharBuffer, 0, 8);
     f52:	b8 e0       	ldi	r27, 0x08	; 8
     f54:	db 2e       	mov	r13, r27
			  gTextLastCharEepromPos = -1;
     f56:	cc 24       	eor	r12, r12
     f58:	ca 94       	dec	r12
	}		
}

static void updateTextPixmap(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
		int16_t eepromPos = gTextCharEepromPos[j];
     f5a:	d7 01       	movw	r26, r14
     f5c:	8d 90       	ld	r8, X+
     f5e:	9d 90       	ld	r9, X+
     f60:	7d 01       	movw	r14, r26
		if (gTextLastCharEepromPos != eepromPos) {
     f62:	80 91 51 01 	lds	r24, 0x0151
     f66:	99 27       	eor	r25, r25
     f68:	87 fd       	sbrc	r24, 7
     f6a:	90 95       	com	r25
     f6c:	88 16       	cp	r8, r24
     f6e:	99 06       	cpc	r9, r25
     f70:	71 f0       	breq	.+28     	; 0xf8e <main+0x434>
		  if (eepromPos != -1) {
     f72:	bf ef       	ldi	r27, 0xFF	; 255
     f74:	8b 16       	cp	r8, r27
     f76:	bf ef       	ldi	r27, 0xFF	; 255
     f78:	9b 06       	cpc	r9, r27
     f7a:	09 f4       	brne	.+2      	; 0xf7e <main+0x424>
     f7c:	5e c1       	rjmp	.+700    	; 0x123a <main+0x6e0>
		  eeprom_read_block((void*)gTextLastCharBuffer, (const void*)eepromPos, 8);
     f7e:	8f eb       	ldi	r24, 0xBF	; 191
     f80:	92 e0       	ldi	r25, 0x02	; 2
     f82:	b4 01       	movw	r22, r8
     f84:	48 e0       	ldi	r20, 0x08	; 8
     f86:	50 e0       	ldi	r21, 0x00	; 0
     f88:	20 d7       	rcall	.+3648   	; 0x1dca <__eerd_block_m88pa>
			  gTextLastCharEepromPos = eepromPos;
     f8a:	80 92 51 01 	sts	0x0151, r8
     f8e:	80 91 bf 02 	lds	r24, 0x02BF
     f92:	f8 01       	movw	r30, r16
     f94:	e9 53       	subi	r30, 0x39	; 57
     f96:	fd 4f       	sbci	r31, 0xFD	; 253
     f98:	a0 ec       	ldi	r26, 0xC0	; 192
     f9a:	b2 e0       	ldi	r27, 0x02	; 2
     f9c:	01 c0       	rjmp	.+2      	; 0xfa0 <main+0x446>
		  }
		  else {
			  memset(gTextLastCharBuffer, 0, 8);
			  gTextLastCharEepromPos = -1;
     f9e:	8d 91       	ld	r24, X+
		if (charInverted(textId, j)) {
		  gTextLastCharBuffer[i] = ~gTextLastCharBuffer[i];
		}
#endif // TEXT_INVERTED_ENABLED

      gTextPixmap[j + (i*TEXT_LINE_MAX_CHARS)] = gTextLastCharBuffer[i];
     fa0:	80 83       	st	Z, r24
     fa2:	b1 96       	adiw	r30, 0x21	; 33
			  memset(gTextLastCharBuffer, 0, 8);
			  gTextLastCharEepromPos = -1;
		  }
		}		  

	  for (uint8_t i = 0; i < TEXT_CHAR_HEIGHT; i++) {
     fa4:	32 e0       	ldi	r19, 0x02	; 2
     fa6:	a7 3c       	cpi	r26, 0xC7	; 199
     fa8:	b3 07       	cpc	r27, r19
     faa:	c9 f7       	brne	.-14     	; 0xf9e <main+0x444>
     fac:	0f 5f       	subi	r16, 0xFF	; 255
     fae:	1f 4f       	sbci	r17, 0xFF	; 255
		gTextCharEepromPos[j] = eepromPos;
	}		
}

static void updateTextPixmap(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
     fb0:	01 32       	cpi	r16, 0x21	; 33
     fb2:	11 05       	cpc	r17, r1
     fb4:	91 f6       	brne	.-92     	; 0xf5a <main+0x400>
	setup();

	while(1) {
    
#ifdef GPS_ENABLED
    if(UCSR0A & (1<<RXC0)) {
     fb6:	80 91 c0 00 	lds	r24, 0x00C0
     fba:	87 ff       	sbrs	r24, 7
     fbc:	26 ce       	rjmp	.-948    	; 0xc0a <main+0xb0>
      decodeGpsData(UDR0);
     fbe:	00 91 c6 00 	lds	r16, 0x00C6
#endif //STATISTICS_ENABLED
	}		  
}

static void decodeGpsData(char data) {
	if (gGpsTextPartStep == GPS_PART_FINISHED && data != '$') {
     fc2:	90 91 5e 01 	lds	r25, 0x015E
     fc6:	9f 3f       	cpi	r25, 0xFF	; 255
     fc8:	09 f4       	brne	.+2      	; 0xfcc <main+0x472>
     fca:	f9 c2       	rjmp	.+1522   	; 0x15be <main+0xa64>
		return;
	}
	
	switch (data) {
     fcc:	04 32       	cpi	r16, 0x24	; 36
     fce:	09 f4       	brne	.+2      	; 0xfd2 <main+0x478>
     fd0:	f9 c2       	rjmp	.+1522   	; 0x15c4 <main+0xa6a>
     fd2:	05 32       	cpi	r16, 0x25	; 37
     fd4:	08 f0       	brcs	.+2      	; 0xfd8 <main+0x47e>
     fd6:	06 c3       	rjmp	.+1548   	; 0x15e4 <main+0xa8a>
     fd8:	0a 30       	cpi	r16, 0x0A	; 10
     fda:	09 f4       	brne	.+2      	; 0xfde <main+0x484>
     fdc:	23 c3       	rjmp	.+1606   	; 0x1624 <main+0xaca>
     fde:	0d 30       	cpi	r16, 0x0D	; 13
     fe0:	09 f4       	brne	.+2      	; 0xfe4 <main+0x48a>
     fe2:	20 c3       	rjmp	.+1600   	; 0x1624 <main+0xaca>
	  gGpsTextPartStep = GPS_PART_FINISHED;
	  finishGpsDecoding();
		return;
		break;
	default:
		gGpsText[gGpsTextPos] = data;
     fe4:	80 91 d1 03 	lds	r24, 0x03D1
     fe8:	e8 2f       	mov	r30, r24
     fea:	f0 e0       	ldi	r31, 0x00	; 0
     fec:	ec 52       	subi	r30, 0x2C	; 44
     fee:	fc 4f       	sbci	r31, 0xFC	; 252
     ff0:	00 83       	st	Z, r16
		if (gGpsTextPartStep != GPS_PART_CHECKSUM) {
     ff2:	98 3c       	cpi	r25, 0xC8	; 200
     ff4:	29 f0       	breq	.+10     	; 0x1000 <main+0x4a6>
		  gGpsChecksum ^= data;
     ff6:	90 91 d3 03 	lds	r25, 0x03D3
     ffa:	90 27       	eor	r25, r16
     ffc:	90 93 d3 03 	sts	0x03D3, r25
		}
		if (gGpsTextPos < GPS_MAX_CHARS-1) {
    1000:	8a 30       	cpi	r24, 0x0A	; 10
    1002:	08 f0       	brcs	.+2      	; 0x1006 <main+0x4ac>
    1004:	02 ce       	rjmp	.-1020   	; 0xc0a <main+0xb0>
		  ++gGpsTextPos;
    1006:	8f 5f       	subi	r24, 0xFF	; 255
    1008:	80 93 d1 03 	sts	0x03D1, r24
    100c:	fe cd       	rjmp	.-1028   	; 0xc0a <main+0xb0>
static void updateText(uint8_t textId) {
  //testPrintDebugInfo();
  uint8_t pos = 0;

	if (textId == 0) {
		pos = printText(gText[textId], 0, "\1521");
    100e:	87 eb       	ldi	r24, 0xB7	; 183
    1010:	91 e0       	ldi	r25, 0x01	; 1
    1012:	60 e0       	ldi	r22, 0x00	; 0
    1014:	44 e2       	ldi	r20, 0x24	; 36
    1016:	51 e0       	ldi	r21, 0x01	; 1
    1018:	9a d9       	rcall	.-3276   	; 0x34e <printText>
#if ANALOG_IN_NUMBER == 2
    pos = printText(gText[textId], 7, "\151");
#else // ANALOG_IN_NUMBER > 2
    pos = printText(gText[textId], 7, "\1522");
    101a:	87 eb       	ldi	r24, 0xB7	; 183
    101c:	91 e0       	ldi	r25, 0x01	; 1
    101e:	67 e0       	ldi	r22, 0x07	; 7
    1020:	47 e2       	ldi	r20, 0x27	; 39
    1022:	51 e0       	ldi	r21, 0x01	; 1
    1024:	94 d9       	rcall	.-3288   	; 0x34e <printText>
	  pos = printText(gText[textId], 14, "\151");    
    1026:	87 eb       	ldi	r24, 0xB7	; 183
    1028:	91 e0       	ldi	r25, 0x01	; 1
    102a:	6e e0       	ldi	r22, 0x0E	; 14
    102c:	4a e2       	ldi	r20, 0x2A	; 42
    102e:	51 e0       	ldi	r21, 0x01	; 1
    1030:	8e d9       	rcall	.-3300   	; 0x34e <printText>
	if (gTime.hour < 10) {
		str[pos++] = '0';
	}
	pos = printNumberWithUnit(str, pos, gTime.hour, ":");
#endif //TIME_HOUR_ENABLED
	if (gTime.min < 10) {
    1032:	80 91 75 01 	lds	r24, 0x0175
    1036:	8a 30       	cpi	r24, 0x0A	; 10
    1038:	08 f0       	brcs	.+2      	; 0x103c <main+0x4e2>
    103a:	1e c1       	rjmp	.+572    	; 0x1278 <main+0x71e>
		str[pos++] = '0';
    103c:	80 e3       	ldi	r24, 0x30	; 48
    103e:	80 93 d2 01 	sts	0x01D2, r24
    1042:	6c e1       	ldi	r22, 0x1C	; 28
	}	
	pos = printNumberWithUnit(str, pos, gTime.min, ":");
    1044:	20 91 75 01 	lds	r18, 0x0175
    1048:	30 e0       	ldi	r19, 0x00	; 0
    104a:	40 e0       	ldi	r20, 0x00	; 0
    104c:	50 e0       	ldi	r21, 0x00	; 0
    104e:	87 eb       	ldi	r24, 0xB7	; 183
    1050:	91 e0       	ldi	r25, 0x01	; 1
    1052:	0c e2       	ldi	r16, 0x2C	; 44
    1054:	11 e0       	ldi	r17, 0x01	; 1
    1056:	a3 d9       	rcall	.-3258   	; 0x39e <printNumberWithUnit>
    1058:	68 2f       	mov	r22, r24
	if (gTime.sec < 10) {
    105a:	80 91 74 01 	lds	r24, 0x0174
    105e:	8a 30       	cpi	r24, 0x0A	; 10
    1060:	38 f4       	brcc	.+14     	; 0x1070 <main+0x516>
		str[pos++] = '0';
    1062:	e6 2f       	mov	r30, r22
    1064:	f0 e0       	ldi	r31, 0x00	; 0
    1066:	e9 54       	subi	r30, 0x49	; 73
    1068:	fe 4f       	sbci	r31, 0xFE	; 254
    106a:	80 e3       	ldi	r24, 0x30	; 48
    106c:	80 83       	st	Z, r24
    106e:	6f 5f       	subi	r22, 0xFF	; 255
	}	
	return printNumber(str, pos, gTime.sec);
    1070:	20 91 74 01 	lds	r18, 0x0174
    1074:	30 e0       	ldi	r19, 0x00	; 0
    1076:	40 e0       	ldi	r20, 0x00	; 0
    1078:	50 e0       	ldi	r21, 0x00	; 0
    107a:	87 eb       	ldi	r24, 0xB7	; 183
    107c:	91 e0       	ldi	r25, 0x01	; 1
    107e:	b9 d8       	rcall	.-3726   	; 0x1f2 <printNumber>
#ifdef TIME_ENABLED
	updateTime();
#endif //TIMEENABLED

#ifdef TEXT_ENABLED
  for (uint8_t i = 0; i < TEXT_LINES; ++i) {
    1080:	86 e0       	ldi	r24, 0x06	; 6
    1082:	d8 16       	cp	r13, r24
    1084:	09 f0       	breq	.+2      	; 0x1088 <main+0x52e>
    1086:	1b cf       	rjmp	.-458    	; 0xebe <main+0x364>
    1088:	80 e0       	ldi	r24, 0x00	; 0
    108a:	90 e0       	ldi	r25, 0x00	; 0
#endif //GRAPICSENABLED
}

void main(void) __attribute__ ((noreturn)); // Main never returns, saves a few bytes

void main(void) {
    108c:	fc 01       	movw	r30, r24
    108e:	ee 0f       	add	r30, r30
    1090:	ff 1f       	adc	r31, r31
    1092:	e8 0f       	add	r30, r24
    1094:	f9 1f       	adc	r31, r25
    1096:	ee 0f       	add	r30, r30
    1098:	ff 1f       	adc	r31, r31
    109a:	ee 0f       	add	r30, r30
    109c:	ff 1f       	adc	r31, r31
    109e:	ee 0f       	add	r30, r30
    10a0:	ff 1f       	adc	r31, r31
    10a2:	e8 51       	subi	r30, 0x18	; 24
    10a4:	fc 4f       	sbci	r31, 0xFC	; 252
    10a6:	20 e0       	ldi	r18, 0x00	; 0
// Functions

static void clearGraphics() {
	for (uint8_t x = 0; x < GRAPHICS_WIDTH; ++x) {
	  for (uint8_t y = 0; y < GRAPHICS_HEIGHT; ++y) {
			gPixelData[x][y] = 0x00;
    10a8:	11 92       	st	Z+, r1

// Functions

static void clearGraphics() {
	for (uint8_t x = 0; x < GRAPHICS_WIDTH; ++x) {
	  for (uint8_t y = 0; y < GRAPHICS_HEIGHT; ++y) {
    10aa:	2f 5f       	subi	r18, 0xFF	; 255
    10ac:	28 31       	cpi	r18, 0x18	; 24
    10ae:	e1 f7       	brne	.-8      	; 0x10a8 <main+0x54e>
    10b0:	01 96       	adiw	r24, 0x01	; 1
static uint8_t gPixelData[GRAPHICS_WIDTH][GRAPHICS_HEIGHT];

// Functions

static void clearGraphics() {
	for (uint8_t x = 0; x < GRAPHICS_WIDTH; ++x) {
    10b2:	83 30       	cpi	r24, 0x03	; 3
    10b4:	91 05       	cpc	r25, r1
    10b6:	51 f7       	brne	.-44     	; 0x108c <main+0x532>
}
#endif //TEXT_ENABLED

static void updateGrapics() {
#ifdef GPS_ENABLED
  drawArrow(gHomeBearing - gGpsLastValidData.angle);
    10b8:	e0 90 e6 03 	lds	r14, 0x03E6
    10bc:	f0 90 e7 03 	lds	r15, 0x03E7
    10c0:	00 91 ae 01 	lds	r16, 0x01AE
    10c4:	10 91 af 01 	lds	r17, 0x01AF
		}
	}				 
}

static void drawArrow(uint16_t angle) {
	drawCircle(GRAPHICS_MID, GRAPHICS_MID, GRAPHICS_MID);
    10c8:	8b e0       	ldi	r24, 0x0B	; 11
    10ca:	bf dc       	rcall	.-1666   	; 0xa4a <drawCircle.constprop.9>
	if (gHomeDistance < 10) {
    10cc:	80 91 e2 03 	lds	r24, 0x03E2
    10d0:	90 91 e3 03 	lds	r25, 0x03E3
    10d4:	a0 91 e4 03 	lds	r26, 0x03E4
    10d8:	b0 91 e5 03 	lds	r27, 0x03E5
    10dc:	8a 30       	cpi	r24, 0x0A	; 10
    10de:	91 05       	cpc	r25, r1
    10e0:	a1 05       	cpc	r26, r1
    10e2:	b1 05       	cpc	r27, r1
    10e4:	08 f4       	brcc	.+2      	; 0x10e8 <main+0x58e>
    10e6:	4a c2       	rjmp	.+1172   	; 0x157c <main+0xa22>
	  drawCircle(GRAPHICS_MID, GRAPHICS_MID, 2);
	  return;
	}
	if (gGpsLastValidData.speed < HOME_FIX_MIN_SPEED || gGpsLastData.fix == 0) {
    10e8:	80 91 ac 01 	lds	r24, 0x01AC
    10ec:	90 91 ad 01 	lds	r25, 0x01AD
    10f0:	8a 30       	cpi	r24, 0x0A	; 10
    10f2:	91 05       	cpc	r25, r1
    10f4:	08 f4       	brcc	.+2      	; 0x10f8 <main+0x59e>
    10f6:	24 c1       	rjmp	.+584    	; 0x1340 <main+0x7e6>
    10f8:	80 91 87 01 	lds	r24, 0x0187
    10fc:	88 23       	and	r24, r24
    10fe:	09 f4       	brne	.+2      	; 0x1102 <main+0x5a8>
    1100:	1f c1       	rjmp	.+574    	; 0x1340 <main+0x7e6>
    1102:	d7 01       	movw	r26, r14
    1104:	a0 1b       	sub	r26, r16
    1106:	b1 0b       	sbc	r27, r17
    1108:	8d 01       	movw	r16, r26
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
}

static int8_t myCos(uint16_t angle) {
	return mySin(angle + 90);
    110a:	cd 01       	movw	r24, r26
    110c:	86 5a       	subi	r24, 0xA6	; 166
    110e:	9f 4f       	sbci	r25, 0xFF	; 255
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    1110:	68 e6       	ldi	r22, 0x68	; 104
    1112:	71 e0       	ldi	r23, 0x01	; 1
    1114:	d9 d5       	rcall	.+2994   	; 0x1cc8 <__udivmodhi4>
	int8_t mult = 1;
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    1116:	84 3b       	cpi	r24, 0xB4	; 180
    1118:	91 05       	cpc	r25, r1
    111a:	08 f4       	brcc	.+2      	; 0x111e <main+0x5c4>
    111c:	3a c2       	rjmp	.+1140   	; 0x1592 <main+0xa38>
		pos = pos - 180;
    111e:	84 5b       	subi	r24, 0xB4	; 180
    1120:	90 40       	sbci	r25, 0x00	; 0
    1122:	4f ef       	ldi	r20, 0xFF	; 255
		mult = -1;
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
    1124:	8a 35       	cpi	r24, 0x5A	; 90
    1126:	91 05       	cpc	r25, r1
    1128:	30 f0       	brcs	.+12     	; 0x1136 <main+0x5dc>
		pos = 180 - pos;
    112a:	24 eb       	ldi	r18, 0xB4	; 180
    112c:	30 e0       	ldi	r19, 0x00	; 0
    112e:	f9 01       	movw	r30, r18
    1130:	e8 1b       	sub	r30, r24
    1132:	f9 0b       	sbc	r31, r25
    1134:	cf 01       	movw	r24, r30
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
    1136:	8c 5c       	subi	r24, 0xCC	; 204
    1138:	9f 4f       	sbci	r25, 0xFF	; 255
    113a:	fc 01       	movw	r30, r24
    113c:	84 91       	lpm	r24, Z
    113e:	84 9f       	mul	r24, r20
    1140:	20 2d       	mov	r18, r0
    1142:	11 24       	eor	r1, r1
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    1144:	c8 01       	movw	r24, r16
    1146:	68 e6       	ldi	r22, 0x68	; 104
    1148:	71 e0       	ldi	r23, 0x01	; 1
    114a:	be d5       	rcall	.+2940   	; 0x1cc8 <__udivmodhi4>
	int8_t mult = 1;
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    114c:	84 3b       	cpi	r24, 0xB4	; 180
    114e:	91 05       	cpc	r25, r1
    1150:	08 f4       	brcc	.+2      	; 0x1154 <main+0x5fa>
    1152:	1d c2       	rjmp	.+1082   	; 0x158e <main+0xa34>
		pos = pos - 180;
    1154:	84 5b       	subi	r24, 0xB4	; 180
    1156:	90 40       	sbci	r25, 0x00	; 0
    1158:	3f ef       	ldi	r19, 0xFF	; 255
		mult = -1;
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
    115a:	8a 35       	cpi	r24, 0x5A	; 90
    115c:	91 05       	cpc	r25, r1
    115e:	30 f0       	brcs	.+12     	; 0x116c <main+0x612>
		pos = 180 - pos;
    1160:	64 eb       	ldi	r22, 0xB4	; 180
    1162:	70 e0       	ldi	r23, 0x00	; 0
    1164:	6b 01       	movw	r12, r22
    1166:	c8 1a       	sub	r12, r24
    1168:	d9 0a       	sbc	r13, r25
    116a:	c6 01       	movw	r24, r12
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
    116c:	8c 5c       	subi	r24, 0xCC	; 204
    116e:	9f 4f       	sbci	r25, 0xFF	; 255
    1170:	fc 01       	movw	r30, r24
    1172:	84 91       	lpm	r24, Z
    1174:	83 9f       	mul	r24, r19
    1176:	40 2d       	mov	r20, r0
    1178:	11 24       	eor	r1, r1
		drawLine(GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID - (GRAPHICS_SIZE/4));
		return;
	}
	int16_t a = myCos(angle);
	int16_t b = mySin(angle);
	a = (a * (GRAPHICS_SIZE / 3)) / 100;
    117a:	82 2f       	mov	r24, r18
    117c:	99 27       	eor	r25, r25
    117e:	87 fd       	sbrc	r24, 7
    1180:	90 95       	com	r25
    1182:	88 0f       	add	r24, r24
    1184:	99 1f       	adc	r25, r25
    1186:	88 0f       	add	r24, r24
    1188:	99 1f       	adc	r25, r25
    118a:	88 0f       	add	r24, r24
    118c:	99 1f       	adc	r25, r25
    118e:	24 e6       	ldi	r18, 0x64	; 100
    1190:	30 e0       	ldi	r19, 0x00	; 0
    1192:	b9 01       	movw	r22, r18
    1194:	ad d5       	rcall	.+2906   	; 0x1cf0 <__divmodhi4>
    1196:	4b 01       	movw	r8, r22
	b = (b * (GRAPHICS_SIZE / 3)) / 100;
    1198:	84 2f       	mov	r24, r20
    119a:	99 27       	eor	r25, r25
    119c:	87 fd       	sbrc	r24, 7
    119e:	90 95       	com	r25
    11a0:	88 0f       	add	r24, r24
    11a2:	99 1f       	adc	r25, r25
    11a4:	88 0f       	add	r24, r24
    11a6:	99 1f       	adc	r25, r25
    11a8:	88 0f       	add	r24, r24
    11aa:	99 1f       	adc	r25, r25
    11ac:	b9 01       	movw	r22, r18
    11ae:	a0 d5       	rcall	.+2880   	; 0x1cf0 <__divmodhi4>
    11b0:	8b 01       	movw	r16, r22
	drawLine(GRAPHICS_MID - b, GRAPHICS_MID + a, GRAPHICS_MID + b, GRAPHICS_MID - a); //Direction line
    11b2:	68 2d       	mov	r22, r8
    11b4:	bb e0       	ldi	r27, 0x0B	; 11
    11b6:	eb 2e       	mov	r14, r27
    11b8:	e0 0e       	add	r14, r16
    11ba:	8b e0       	ldi	r24, 0x0B	; 11
    11bc:	d8 2e       	mov	r13, r24
    11be:	d8 18       	sub	r13, r8
    11c0:	65 5f       	subi	r22, 0xF5	; 245
    11c2:	80 1b       	sub	r24, r16
    11c4:	4e 2d       	mov	r20, r14
    11c6:	2d 2d       	mov	r18, r13
    11c8:	bd db       	rcall	.-2182   	; 0x944 <drawLine>
	//drawLine(GRAPHICS_MID_X + a/2, GRAPHICS_MID_X + b/2, GRAPHICS_MID_X - a/2, GRAPHICS_MID_X - b/2); //Arrow bottom line
	drawLine(GRAPHICS_MID + b, GRAPHICS_MID - a, GRAPHICS_MID - a/2, GRAPHICS_MID - b/2); // Arrow "wings"
    11ca:	c4 01       	movw	r24, r8
    11cc:	97 fc       	sbrc	r9, 7
    11ce:	7f c3       	rjmp	.+1790   	; 0x18ce <main+0xd74>
    11d0:	95 95       	asr	r25
    11d2:	87 95       	ror	r24
    11d4:	90 95       	com	r25
    11d6:	81 95       	neg	r24
    11d8:	9f 4f       	sbci	r25, 0xFF	; 255
    11da:	48 2f       	mov	r20, r24
    11dc:	45 5f       	subi	r20, 0xF5	; 245
    11de:	98 01       	movw	r18, r16
    11e0:	17 fd       	sbrc	r17, 7
    11e2:	72 c3       	rjmp	.+1764   	; 0x18c8 <main+0xd6e>
    11e4:	c9 01       	movw	r24, r18
    11e6:	95 95       	asr	r25
    11e8:	87 95       	ror	r24
    11ea:	90 95       	com	r25
    11ec:	81 95       	neg	r24
    11ee:	9f 4f       	sbci	r25, 0xFF	; 255
    11f0:	28 2f       	mov	r18, r24
    11f2:	25 5f       	subi	r18, 0xF5	; 245
    11f4:	8e 2d       	mov	r24, r14
    11f6:	6d 2d       	mov	r22, r13
    11f8:	a5 db       	rcall	.-2230   	; 0x944 <drawLine>
	drawLine(GRAPHICS_MID + b, GRAPHICS_MID - a, GRAPHICS_MID + a/2, GRAPHICS_MID + b/2);
    11fa:	97 fc       	sbrc	r9, 7
    11fc:	61 c3       	rjmp	.+1730   	; 0x18c0 <main+0xd66>
    11fe:	a4 01       	movw	r20, r8
    1200:	55 95       	asr	r21
    1202:	47 95       	ror	r20
    1204:	45 5f       	subi	r20, 0xF5	; 245
    1206:	17 fd       	sbrc	r17, 7
    1208:	58 c3       	rjmp	.+1712   	; 0x18ba <main+0xd60>
    120a:	15 95       	asr	r17
    120c:	07 95       	ror	r16
    120e:	20 2f       	mov	r18, r16
    1210:	25 5f       	subi	r18, 0xF5	; 245
    1212:	8e 2d       	mov	r24, r14
    1214:	6d 2d       	mov	r22, r13
    1216:	96 db       	rcall	.-2260   	; 0x944 <drawLine>
    1218:	f4 cc       	rjmp	.-1560   	; 0xc02 <main+0xa8>
		else if (character < CHAR_OFFSET + CHAR_LENGTH) {
			uint16_t charPos = ((character - CHAR_OFFSET) * TEXT_CHAR_HEIGHT);
			eepromPos = (int16_t)&(oem6x8[charPos]);
		}
#ifdef TEXT_USE_SPECIAL_CHARS
		else if (character > CHAR_SPECIAL_OFFSET && character < CHAR_SPECIAL_OFFSET+CHAR_SPECIAL_LENGTH) {
    121a:	32 2f       	mov	r19, r18
    121c:	35 56       	subi	r19, 0x65	; 101
    121e:	39 30       	cpi	r19, 0x09	; 9
    1220:	08 f0       	brcs	.+2      	; 0x1224 <main+0x6ca>
    1222:	82 ce       	rjmp	.-764    	; 0xf28 <main+0x3ce>
			uint16_t charPos = ((character - CHAR_SPECIAL_OFFSET) * TEXT_CHAR_HEIGHT);
    1224:	82 2f       	mov	r24, r18
    1226:	90 e0       	ldi	r25, 0x00	; 0
    1228:	88 0f       	add	r24, r24
    122a:	99 1f       	adc	r25, r25
    122c:	88 0f       	add	r24, r24
    122e:	99 1f       	adc	r25, r25
    1230:	88 0f       	add	r24, r24
    1232:	99 1f       	adc	r25, r25
			eepromPos = (int16_t)&(specialChars[charPos]);
    1234:	80 57       	subi	r24, 0x70	; 112
    1236:	91 40       	sbci	r25, 0x01	; 1
    1238:	77 ce       	rjmp	.-786    	; 0xf28 <main+0x3ce>
		  if (eepromPos != -1) {
		  eeprom_read_block((void*)gTextLastCharBuffer, (const void*)eepromPos, 8);
			  gTextLastCharEepromPos = eepromPos;
		  }
		  else {
			  memset(gTextLastCharBuffer, 0, 8);
    123a:	f1 01       	movw	r30, r2
    123c:	2d 2d       	mov	r18, r13
    123e:	11 92       	st	Z+, r1
    1240:	2a 95       	dec	r18
    1242:	e9 f7       	brne	.-6      	; 0x123e <main+0x6e4>
			  gTextLastCharEepromPos = -1;
    1244:	c0 92 51 01 	sts	0x0151, r12
    1248:	80 e0       	ldi	r24, 0x00	; 0
    124a:	a3 ce       	rjmp	.-698    	; 0xf92 <main+0x438>
#endif //ANALOG_IN_NUMBER == 2

  }
  else if (textId == 2) {
#ifdef GPS_ENABLED
	  if (gInfoShow) {
    124c:	80 91 5f 01 	lds	r24, 0x015F
    1250:	88 23       	and	r24, r24
    1252:	09 f4       	brne	.+2      	; 0x1256 <main+0x6fc>
    1254:	30 ce       	rjmp	.-928    	; 0xeb6 <main+0x35c>
	    if (gHomePosSet) {
    1256:	80 91 b5 01 	lds	r24, 0x01B5
    125a:	88 23       	and	r24, r24
    125c:	09 f0       	breq	.+2      	; 0x1260 <main+0x706>
    125e:	2b ce       	rjmp	.-938    	; 0xeb6 <main+0x35c>
#ifdef STATISTICS_ENABLED
		    pos = printText(gText[textId], 7, "LOS  SPD TRIP  ALT");
#endif //STATISTICS_ENABLED
	    }
	    else if (gBlink1Hz) {
    1260:	80 91 73 01 	lds	r24, 0x0173
    1264:	88 23       	and	r24, r24
    1266:	09 f4       	brne	.+2      	; 0x126a <main+0x710>
    1268:	2a ce       	rjmp	.-940    	; 0xebe <main+0x364>
	      pos = printText(gText[textId], 10, "NO HOME POS");
    126a:	89 ef       	ldi	r24, 0xF9	; 249
    126c:	91 e0       	ldi	r25, 0x01	; 1
    126e:	6a e0       	ldi	r22, 0x0A	; 10
    1270:	41 e3       	ldi	r20, 0x31	; 49
    1272:	51 e0       	ldi	r21, 0x01	; 1
    1274:	6c d8       	rcall	.-3880   	; 0x34e <printText>
    1276:	23 ce       	rjmp	.-954    	; 0xebe <main+0x364>
	if (gTime.hour < 10) {
		str[pos++] = '0';
	}
	pos = printNumberWithUnit(str, pos, gTime.hour, ":");
#endif //TIME_HOUR_ENABLED
	if (gTime.min < 10) {
    1278:	6b e1       	ldi	r22, 0x1B	; 27
    127a:	e4 ce       	rjmp	.-568    	; 0x1044 <main+0x4ea>
	  }
#endif //GPS_ENABLED
  }	  
  else if (textId == 3) {
#ifdef GPS_ENABLED
	  if (gInfoShow) {
    127c:	80 91 5f 01 	lds	r24, 0x015F
    1280:	88 23       	and	r24, r24
    1282:	09 f4       	brne	.+2      	; 0x1286 <main+0x72c>
    1284:	18 ce       	rjmp	.-976    	; 0xeb6 <main+0x35c>
	    if (gHomePosSet) {
    1286:	80 91 b5 01 	lds	r24, 0x01B5
    128a:	88 23       	and	r24, r24
    128c:	09 f0       	breq	.+2      	; 0x1290 <main+0x736>
    128e:	13 ce       	rjmp	.-986    	; 0xeb6 <main+0x35c>
		    printNumber(gText[textId], pos+9, gStatDistTraveled);
		    printNumber(gText[textId], pos+15, gStatMaxAltitude);
#endif //STATISTICS_ENABLED
	    }
	    else {
        pos = printGpsNumber(gText[textId], pos+4, gGpsLastValidData.pos.latitude, 1);
    1290:	20 91 9c 01 	lds	r18, 0x019C
    1294:	30 91 9d 01 	lds	r19, 0x019D
    1298:	40 91 9e 01 	lds	r20, 0x019E
    129c:	50 91 9f 01 	lds	r21, 0x019F
    12a0:	8a e1       	ldi	r24, 0x1A	; 26
    12a2:	92 e0       	ldi	r25, 0x02	; 2
    12a4:	64 e0       	ldi	r22, 0x04	; 4
    12a6:	01 e0       	ldi	r16, 0x01	; 1
    12a8:	b6 d8       	rcall	.-3732   	; 0x416 <printGpsNumber>
        pos = printGpsNumber(gText[textId], pos+2, gGpsLastValidData.pos.longitude, 0);
    12aa:	68 2f       	mov	r22, r24
    12ac:	6e 5f       	subi	r22, 0xFE	; 254
    12ae:	20 91 a0 01 	lds	r18, 0x01A0
    12b2:	30 91 a1 01 	lds	r19, 0x01A1
    12b6:	40 91 a2 01 	lds	r20, 0x01A2
    12ba:	50 91 a3 01 	lds	r21, 0x01A3
    12be:	8a e1       	ldi	r24, 0x1A	; 26
    12c0:	92 e0       	ldi	r25, 0x02	; 2
    12c2:	00 e0       	ldi	r16, 0x00	; 0
    12c4:	a8 d8       	rcall	.-3760   	; 0x416 <printGpsNumber>
    12c6:	fb cd       	rjmp	.-1034   	; 0xebe <main+0x364>
#else
    pos = printTime(gText[textId], TEXT_LINE_MAX_CHARS-6);
#endif //TIME_HOUR_ENABLED
  }
  else if (textId == 1) {
	  printText(gText[textId], TEXT_LINE_MAX_CHARS-1-strlen(TEXT_CALLSIGN), TEXT_CALLSIGN);
    12c8:	88 ed       	ldi	r24, 0xD8	; 216
    12ca:	91 e0       	ldi	r25, 0x01	; 1
    12cc:	60 e2       	ldi	r22, 0x20	; 32
    12ce:	4e e2       	ldi	r20, 0x2E	; 46
    12d0:	51 e0       	ldi	r21, 0x01	; 1
    12d2:	3d d8       	rcall	.-3974   	; 0x34e <printText>
	  if (!gAlarmBatt1 || gBlink1Hz) {
	    pos = printAdc(gText[textId], 0, ANALOG_IN_1);
    12d4:	88 ed       	ldi	r24, 0xD8	; 216
    12d6:	91 e0       	ldi	r25, 0x01	; 1
    12d8:	60 e0       	ldi	r22, 0x00	; 0
    12da:	40 e0       	ldi	r20, 0x00	; 0
    12dc:	6f d8       	rcall	.-3874   	; 0x3bc <printAdc>
    if (!gAlarmRssi || gBlink1Hz) {
      pos = printRssiLevel(gText[textId], 7, ANALOG_IN_2);
	  }	  
#else // ANALOG_IN_NUMBER > 2
    if (!gAlarmBatt2 || gBlink1Hz) {
      pos = printAdc(gText[textId], 7, ANALOG_IN_2);
    12de:	88 ed       	ldi	r24, 0xD8	; 216
    12e0:	91 e0       	ldi	r25, 0x01	; 1
    12e2:	67 e0       	ldi	r22, 0x07	; 7
    12e4:	41 e0       	ldi	r20, 0x01	; 1
    12e6:	6a d8       	rcall	.-3884   	; 0x3bc <printAdc>
    gAnalogInputs[i].high = adcHigh;
  }    
}

static uint8_t calcGenericLevel(uint8_t adcInput, uint16_t minLevel, uint16_t maxLevel) {
	uint16_t level = ((gAnalogInputs[adcInput].high * 100) + gAnalogInputs[adcInput].low);
    12e8:	20 91 3d 04 	lds	r18, 0x043D
    12ec:	84 e6       	ldi	r24, 0x64	; 100
    12ee:	28 9f       	mul	r18, r24
    12f0:	90 01       	movw	r18, r0
    12f2:	11 24       	eor	r1, r1
    12f4:	80 91 3c 04 	lds	r24, 0x043C
    12f8:	28 0f       	add	r18, r24
    12fa:	31 1d       	adc	r19, r1
	if (level > maxLevel) {
    12fc:	41 e0       	ldi	r20, 0x01	; 1
    12fe:	25 3f       	cpi	r18, 0xF5	; 245
    1300:	34 07       	cpc	r19, r20
    1302:	08 f0       	brcs	.+2      	; 0x1306 <main+0x7ac>
    1304:	48 c1       	rjmp	.+656    	; 0x1596 <main+0xa3c>
		level = 100;
	}		
	else if (level > minLevel) {
    1306:	29 37       	cpi	r18, 0x79	; 121
    1308:	31 05       	cpc	r19, r1
    130a:	08 f4       	brcc	.+2      	; 0x130e <main+0x7b4>
    130c:	a8 c2       	rjmp	.+1360   	; 0x185e <main+0xd04>
		level -= minLevel;
    130e:	28 57       	subi	r18, 0x78	; 120
    1310:	30 40       	sbci	r19, 0x00	; 0
		level *= 100;
    1312:	44 e6       	ldi	r20, 0x64	; 100
    1314:	50 e0       	ldi	r21, 0x00	; 0
    1316:	24 9f       	mul	r18, r20
    1318:	c0 01       	movw	r24, r0
    131a:	25 9f       	mul	r18, r21
    131c:	90 0d       	add	r25, r0
    131e:	34 9f       	mul	r19, r20
    1320:	90 0d       	add	r25, r0
    1322:	11 24       	eor	r1, r1
		level /= maxLevel - minLevel;
    1324:	6c e7       	ldi	r22, 0x7C	; 124
    1326:	71 e0       	ldi	r23, 0x01	; 1
    1328:	cf d4       	rcall	.+2462   	; 0x1cc8 <__udivmodhi4>
    132a:	9b 01       	movw	r18, r22
	if (level > maxLevel) {
		level = 100;
	}		
	else if (level > minLevel) {
		level -= minLevel;
		level *= 100;
    132c:	30 e0       	ldi	r19, 0x00	; 0
    132e:	40 e0       	ldi	r20, 0x00	; 0
    1330:	50 e0       	ldi	r21, 0x00	; 0
	return printNumberWithUnit(str, pos, low, "V");		
}

static uint8_t printRssiLevel(char* const str, uint8_t pos, const uint8_t adcInput) {
	uint8_t rssiLevel = calcRssiLevel(adcInput);
	return printNumberWithUnit(str, pos, rssiLevel, "%");
    1332:	88 ed       	ldi	r24, 0xD8	; 216
    1334:	91 e0       	ldi	r25, 0x01	; 1
    1336:	6e e0       	ldi	r22, 0x0E	; 14
    1338:	0f e2       	ldi	r16, 0x2F	; 47
    133a:	11 e0       	ldi	r17, 0x01	; 1
    133c:	30 d8       	rcall	.-4000   	; 0x39e <printNumberWithUnit>
    133e:	bf cd       	rjmp	.-1154   	; 0xebe <main+0x364>
	if (gHomeDistance < 10) {
	  drawCircle(GRAPHICS_MID, GRAPHICS_MID, 2);
	  return;
	}
	if (gGpsLastValidData.speed < HOME_FIX_MIN_SPEED || gGpsLastData.fix == 0) {
		drawLine(GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4));
    1340:	85 e0       	ldi	r24, 0x05	; 5
    1342:	65 e0       	ldi	r22, 0x05	; 5
    1344:	41 e1       	ldi	r20, 0x11	; 17
    1346:	21 e1       	ldi	r18, 0x11	; 17
    1348:	fd da       	rcall	.-2566   	; 0x944 <drawLine>
		drawLine(GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID - (GRAPHICS_SIZE/4));
    134a:	85 e0       	ldi	r24, 0x05	; 5
    134c:	61 e1       	ldi	r22, 0x11	; 17
    134e:	41 e1       	ldi	r20, 0x11	; 17
    1350:	25 e0       	ldi	r18, 0x05	; 5
    1352:	f8 da       	rcall	.-2576   	; 0x944 <drawLine>
    1354:	56 cc       	rjmp	.-1876   	; 0xc02 <main+0xa8>
#endif //GPS_ENABLED
	}
	else if (textId == 4) {
#ifdef GPS_ENABLED
    if (!gAlarmSpeed || gBlink1Hz) {
	    pos = printNumber(gText[textId], 0, gGpsLastValidData.speed);
    1356:	20 91 ac 01 	lds	r18, 0x01AC
    135a:	30 91 ad 01 	lds	r19, 0x01AD
    135e:	40 e0       	ldi	r20, 0x00	; 0
    1360:	50 e0       	ldi	r21, 0x00	; 0
    1362:	8b e3       	ldi	r24, 0x3B	; 59
    1364:	92 e0       	ldi	r25, 0x02	; 2
    1366:	60 e0       	ldi	r22, 0x00	; 0
    1368:	44 d7       	rcall	.+3720   	; 0x21f2 <__data_load_end+0x392>
	  }		
    if (!gHomePosSet) {
    136a:	80 91 b5 01 	lds	r24, 0x01B5
    136e:	88 23       	and	r24, r24
    1370:	09 f4       	brne	.+2      	; 0x1374 <main+0x81a>
    1372:	1e c1       	rjmp	.+572    	; 0x15b0 <main+0xa56>
		  pos = printText(gText[textId], 5, "-");
	  }
	  else {
		  if (!gAlarmDistance || gBlink1Hz) {
		    pos = printNumber(gText[textId], 5, gHomeDistance);
    1374:	20 91 e2 03 	lds	r18, 0x03E2
    1378:	30 91 e3 03 	lds	r19, 0x03E3
    137c:	40 91 e4 03 	lds	r20, 0x03E4
    1380:	50 91 e5 03 	lds	r21, 0x03E5
    1384:	8b e3       	ldi	r24, 0x3B	; 59
    1386:	92 e0       	ldi	r25, 0x02	; 2
    1388:	65 e0       	ldi	r22, 0x05	; 5
    138a:	33 d7       	rcall	.+3686   	; 0x21f2 <__data_load_end+0x392>
		  }			
	  }		  
		if (gGpsLastValidData.fix) {
    138c:	80 91 aa 01 	lds	r24, 0x01AA
    1390:	88 23       	and	r24, r24
    1392:	09 f4       	brne	.+2      	; 0x1396 <main+0x83c>
    1394:	ec c0       	rjmp	.+472    	; 0x156e <main+0xa14>
		  pos = printNumber(gText[textId], TEXT_LINE_MAX_CHARS-10, gGpsLastValidData.sats);
    1396:	20 91 ab 01 	lds	r18, 0x01AB
    139a:	30 e0       	ldi	r19, 0x00	; 0
    139c:	40 e0       	ldi	r20, 0x00	; 0
    139e:	50 e0       	ldi	r21, 0x00	; 0
    13a0:	8b e3       	ldi	r24, 0x3B	; 59
    13a2:	92 e0       	ldi	r25, 0x02	; 2
    13a4:	67 e1       	ldi	r22, 0x17	; 23
    13a6:	25 d7       	rcall	.+3658   	; 0x21f2 <__data_load_end+0x392>
		}
		else {			
		  pos = printText(gText[textId], TEXT_LINE_MAX_CHARS-10, "-");
	  }
	  if (!gAlarmAltitude || gBlink1Hz) {
		  pos = printNumber(gText[textId], TEXT_LINE_MAX_CHARS-5, gGpsLastValidData.pos.altitude - gHomePos.altitude);
    13a8:	20 91 a4 01 	lds	r18, 0x01A4
    13ac:	30 91 a5 01 	lds	r19, 0x01A5
    13b0:	80 91 9a 01 	lds	r24, 0x019A
    13b4:	90 91 9b 01 	lds	r25, 0x019B
    13b8:	28 1b       	sub	r18, r24
    13ba:	39 0b       	sbc	r19, r25
    13bc:	44 27       	eor	r20, r20
    13be:	37 fd       	sbrc	r19, 7
    13c0:	40 95       	com	r20
    13c2:	54 2f       	mov	r21, r20
    13c4:	8b e3       	ldi	r24, 0x3B	; 59
    13c6:	92 e0       	ldi	r25, 0x02	; 2
    13c8:	6c e1       	ldi	r22, 0x1C	; 28
    13ca:	13 d7       	rcall	.+3622   	; 0x21f2 <__data_load_end+0x392>
    13cc:	74 cd       	rjmp	.-1304   	; 0xeb6 <main+0x35c>
#else //GPS_ENABLED
  if (gGpsLastData.fix != 0) {
		PORTD |= LED;
	}
	else {
		PORTD ^= LED;
    13ce:	8b b1       	in	r24, 0x0b	; 11
    13d0:	98 e0       	ldi	r25, 0x08	; 8
    13d2:	89 27       	eor	r24, r25
    13d4:	8b b9       	out	0x0b, r24	; 11
	
#ifdef DEBUG
  //testCalcHome();
#endif // DEBUG
  
	if (gHomePosSet) {
    13d6:	80 91 b5 01 	lds	r24, 0x01B5
    13da:	88 23       	and	r24, r24
    13dc:	09 f4       	brne	.+2      	; 0x13e0 <main+0x886>
    13de:	57 cc       	rjmp	.-1874   	; 0xc8e <main+0x134>
	  calcHome(gGpsLastValidData.pos.latitude,
    13e0:	c0 90 9c 01 	lds	r12, 0x019C
    13e4:	d0 90 9d 01 	lds	r13, 0x019D
    13e8:	e0 90 9e 01 	lds	r14, 0x019E
    13ec:	f0 90 9f 01 	lds	r15, 0x019F
    13f0:	40 90 a0 01 	lds	r4, 0x01A0
    13f4:	50 90 a1 01 	lds	r5, 0x01A1
    13f8:	60 90 a2 01 	lds	r6, 0x01A2
    13fc:	70 90 a3 01 	lds	r7, 0x01A3
    1400:	80 90 92 01 	lds	r8, 0x0192
    1404:	90 90 93 01 	lds	r9, 0x0193
    1408:	a0 90 94 01 	lds	r10, 0x0194
    140c:	b0 90 95 01 	lds	r11, 0x0195
    1410:	40 91 96 01 	lds	r20, 0x0196
    1414:	50 91 97 01 	lds	r21, 0x0197
    1418:	60 91 98 01 	lds	r22, 0x0198
    141c:	70 91 99 01 	lds	r23, 0x0199
    1420:	49 83       	std	Y+1, r20	; 0x01
    1422:	5a 83       	std	Y+2, r21	; 0x02
    1424:	6b 83       	std	Y+3, r22	; 0x03
    1426:	7c 83       	std	Y+4, r23	; 0x04

  // considers flat earth around vehicle and reference

  // Ernani Reis, Aug 2011
  
  if (currLat == homeLat && currLong == homeLong) {
    1428:	c8 14       	cp	r12, r8
    142a:	d9 04       	cpc	r13, r9
    142c:	ea 04       	cpc	r14, r10
    142e:	fb 04       	cpc	r15, r11
    1430:	09 f4       	brne	.+2      	; 0x1434 <main+0x8da>
    1432:	4f c2       	rjmp	.+1182   	; 0x18d2 <main+0xd78>
  int32_t deltaLat; 
  int32_t deltaLong;
  uint32_t distance;
  uint16_t bearing;
      
  c = myCos(absi32(homeLat + currLat) / 2000000); // c ~ cos(lat) -> long to fix the delta
    1434:	d7 01       	movw	r26, r14
    1436:	c6 01       	movw	r24, r12
    1438:	88 0d       	add	r24, r8
    143a:	99 1d       	adc	r25, r9
    143c:	aa 1d       	adc	r26, r10
    143e:	bb 1d       	adc	r27, r11
#ifndef COMMONUTILS_H_
#define COMMONUTILS_H_

// abs seems to only support 16 bits so I had to make my own.
static uint32_t absi32(int32_t a) {
	return (a > 0) ? a : -a;
    1440:	b7 ff       	sbrs	r27, 7
    1442:	07 c0       	rjmp	.+14     	; 0x1452 <main+0x8f8>
    1444:	b0 95       	com	r27
    1446:	a0 95       	com	r26
    1448:	90 95       	com	r25
    144a:	81 95       	neg	r24
    144c:	9f 4f       	sbci	r25, 0xFF	; 255
    144e:	af 4f       	sbci	r26, 0xFF	; 255
    1450:	bf 4f       	sbci	r27, 0xFF	; 255
    1452:	bc 01       	movw	r22, r24
    1454:	cd 01       	movw	r24, r26
    1456:	20 e8       	ldi	r18, 0x80	; 128
    1458:	34 e8       	ldi	r19, 0x84	; 132
    145a:	4e e1       	ldi	r20, 0x1E	; 30
    145c:	50 e0       	ldi	r21, 0x00	; 0
    145e:	5b d4       	rcall	.+2230   	; 0x1d16 <__udivmodsi4>
}

static int8_t myCos(uint16_t angle) {
	return mySin(angle + 90);
    1460:	c9 01       	movw	r24, r18
    1462:	86 5a       	subi	r24, 0xA6	; 166
    1464:	9f 4f       	sbci	r25, 0xFF	; 255
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    1466:	68 e6       	ldi	r22, 0x68	; 104
    1468:	71 e0       	ldi	r23, 0x01	; 1
    146a:	2e d4       	rcall	.+2140   	; 0x1cc8 <__udivmodhi4>
	int8_t mult = 1;
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    146c:	84 3b       	cpi	r24, 0xB4	; 180
    146e:	91 05       	cpc	r25, r1
    1470:	08 f4       	brcc	.+2      	; 0x1474 <main+0x91a>
    1472:	f9 c1       	rjmp	.+1010   	; 0x1866 <main+0xd0c>
		pos = pos - 180;
    1474:	84 5b       	subi	r24, 0xB4	; 180
    1476:	90 40       	sbci	r25, 0x00	; 0
    1478:	5f ef       	ldi	r21, 0xFF	; 255
    147a:	5d 83       	std	Y+5, r21	; 0x05
		mult = -1;
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
    147c:	8a 35       	cpi	r24, 0x5A	; 90
    147e:	91 05       	cpc	r25, r1
    1480:	30 f0       	brcs	.+12     	; 0x148e <main+0x934>
		pos = 180 - pos;
    1482:	24 eb       	ldi	r18, 0xB4	; 180
    1484:	30 e0       	ldi	r19, 0x00	; 0
    1486:	a9 01       	movw	r20, r18
    1488:	48 1b       	sub	r20, r24
    148a:	59 0b       	sbc	r21, r25
    148c:	ca 01       	movw	r24, r20
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
    148e:	8c 5c       	subi	r24, 0xCC	; 204
    1490:	9f 4f       	sbci	r25, 0xFF	; 255
    1492:	fc 01       	movw	r30, r24
    1494:	44 91       	lpm	r20, Z

  int32_t currLatSec100 = wgs84ToSec100(currLat); // Convert wgs84 to sec * 100
    1496:	c7 01       	movw	r24, r14
    1498:	b6 01       	movw	r22, r12
    149a:	4e 8b       	std	Y+22, r20	; 0x16
    149c:	15 d6       	rcall	.+3114   	; 0x20c8 <__data_load_end+0x268>
    149e:	8b 01       	movw	r16, r22
    14a0:	9c 01       	movw	r18, r24
  int32_t homeLatSec100 = wgs84ToSec100(homeLat);
    14a2:	c5 01       	movw	r24, r10
    14a4:	b4 01       	movw	r22, r8
    14a6:	2b 8b       	std	Y+19, r18	; 0x13
    14a8:	3c 8b       	std	Y+20, r19	; 0x14
    14aa:	0e d6       	rcall	.+3100   	; 0x20c8 <__data_load_end+0x268>
    14ac:	4b 01       	movw	r8, r22
    14ae:	5c 01       	movw	r10, r24
  int32_t currLongSec100 = wgs84ToSec100(currLong);
    14b0:	c3 01       	movw	r24, r6
    14b2:	b2 01       	movw	r22, r4
    14b4:	09 d6       	rcall	.+3090   	; 0x20c8 <__data_load_end+0x268>
    14b6:	6b 01       	movw	r12, r22
    14b8:	7c 01       	movw	r14, r24
  int32_t homeLongSec100 = wgs84ToSec100(homeLong);
    14ba:	69 81       	ldd	r22, Y+1	; 0x01
    14bc:	7a 81       	ldd	r23, Y+2	; 0x02
    14be:	8b 81       	ldd	r24, Y+3	; 0x03
    14c0:	9c 81       	ldd	r25, Y+4	; 0x04
    14c2:	02 d6       	rcall	.+3076   	; 0x20c8 <__data_load_end+0x268>

  deltaLong = homeLongSec100 - currLongSec100; // Calculate deltas
    14c4:	6c 19       	sub	r22, r12
    14c6:	7d 09       	sbc	r23, r13
    14c8:	8e 09       	sbc	r24, r14
    14ca:	9f 09       	sbc	r25, r15
  deltaLat = homeLatSec100 - currLatSec100; // delta long ainda com erro (Delta still long with error?)
    14cc:	2b 89       	ldd	r18, Y+19	; 0x13
    14ce:	3c 89       	ldd	r19, Y+20	; 0x14
    14d0:	24 01       	movw	r4, r8
    14d2:	35 01       	movw	r6, r10
    14d4:	40 1a       	sub	r4, r16
    14d6:	51 0a       	sbc	r5, r17
    14d8:	62 0a       	sbc	r6, r18
    14da:	73 0a       	sbc	r7, r19
    14dc:	4e 89       	ldd	r20, Y+22	; 0x16
    14de:	cd 80       	ldd	r12, Y+5	; 0x05
    14e0:	4c 9d       	mul	r20, r12
    14e2:	20 2d       	mov	r18, r0
    14e4:	11 24       	eor	r1, r1

  deltaLong = deltaLong * c;   // corrige dla p/ lat da regio
    14e6:	33 27       	eor	r19, r19
    14e8:	27 fd       	sbrc	r18, 7
    14ea:	30 95       	com	r19
    14ec:	43 2f       	mov	r20, r19
    14ee:	53 2f       	mov	r21, r19
    14f0:	cc d3       	rcall	.+1944   	; 0x1c8a <__mulsi3>
  deltaLong = deltaLong / 100; // cosine is 0-100 so divide with 100
    14f2:	24 e6       	ldi	r18, 0x64	; 100
    14f4:	30 e0       	ldi	r19, 0x00	; 0
    14f6:	40 e0       	ldi	r20, 0x00	; 0
    14f8:	50 e0       	ldi	r21, 0x00	; 0
    14fa:	2f d4       	rcall	.+2142   	; 0x1d5a <__divmodsi4>
    14fc:	49 01       	movw	r8, r18
    14fe:	5a 01       	movw	r10, r20

  // Make sure we don't go over uin32_t when doing sqr of deltaLong & deltaLat
  uint8_t mult = 1;
  while ((absi32(deltaLong) >= 0xFFFF) 
         || (absi32(deltaLat) >= 0xFFFF)) {
	  deltaLong /= 2;
    1500:	a2 e0       	ldi	r26, 0x02	; 2
    1502:	ca 2e       	mov	r12, r26
    1504:	d1 2c       	mov	r13, r1
    1506:	e1 2c       	mov	r14, r1
    1508:	f1 2c       	mov	r15, r1
    150a:	01 e0       	ldi	r16, 0x01	; 1
    150c:	24 c0       	rjmp	.+72     	; 0x1556 <main+0x9fc>
  deltaLong = deltaLong * c;   // corrige dla p/ lat da regio
  deltaLong = deltaLong / 100; // cosine is 0-100 so divide with 100

  // Make sure we don't go over uin32_t when doing sqr of deltaLong & deltaLat
  uint8_t mult = 1;
  while ((absi32(deltaLong) >= 0xFFFF) 
    150e:	4f 3f       	cpi	r20, 0xFF	; 255
    1510:	3f ef       	ldi	r19, 0xFF	; 255
    1512:	53 07       	cpc	r21, r19
    1514:	30 e0       	ldi	r19, 0x00	; 0
    1516:	63 07       	cpc	r22, r19
    1518:	30 e0       	ldi	r19, 0x00	; 0
    151a:	73 07       	cpc	r23, r19
    151c:	68 f4       	brcc	.+26     	; 0x1538 <main+0x9de>
    151e:	d3 01       	movw	r26, r6
    1520:	c2 01       	movw	r24, r4
    1522:	77 fc       	sbrc	r7, 7
    1524:	3d c0       	rjmp	.+122    	; 0x15a0 <main+0xa46>
         || (absi32(deltaLat) >= 0xFFFF)) {
    1526:	8f 3f       	cpi	r24, 0xFF	; 255
    1528:	ef ef       	ldi	r30, 0xFF	; 255
    152a:	9e 07       	cpc	r25, r30
    152c:	e0 e0       	ldi	r30, 0x00	; 0
    152e:	ae 07       	cpc	r26, r30
    1530:	e0 e0       	ldi	r30, 0x00	; 0
    1532:	be 07       	cpc	r27, r30
    1534:	08 f4       	brcc	.+2      	; 0x1538 <main+0x9de>
    1536:	b9 c0       	rjmp	.+370    	; 0x16aa <main+0xb50>
	  deltaLong /= 2;
    1538:	c5 01       	movw	r24, r10
    153a:	b4 01       	movw	r22, r8
    153c:	a7 01       	movw	r20, r14
    153e:	96 01       	movw	r18, r12
    1540:	0c d4       	rcall	.+2072   	; 0x1d5a <__divmodsi4>
    1542:	49 01       	movw	r8, r18
    1544:	5a 01       	movw	r10, r20
	  deltaLat /= 2;
    1546:	c3 01       	movw	r24, r6
    1548:	b2 01       	movw	r22, r4
    154a:	a7 01       	movw	r20, r14
    154c:	96 01       	movw	r18, r12
    154e:	05 d4       	rcall	.+2058   	; 0x1d5a <__divmodsi4>
    1550:	29 01       	movw	r4, r18
    1552:	3a 01       	movw	r6, r20
	  mult *= 2;
    1554:	00 0f       	add	r16, r16
    1556:	b5 01       	movw	r22, r10
    1558:	a4 01       	movw	r20, r8
    155a:	b7 fe       	sbrs	r11, 7
    155c:	d8 cf       	rjmp	.-80     	; 0x150e <main+0x9b4>
    155e:	44 27       	eor	r20, r20
    1560:	55 27       	eor	r21, r21
    1562:	ba 01       	movw	r22, r20
    1564:	48 19       	sub	r20, r8
    1566:	59 09       	sbc	r21, r9
    1568:	6a 09       	sbc	r22, r10
    156a:	7b 09       	sbc	r23, r11
    156c:	d0 cf       	rjmp	.-96     	; 0x150e <main+0x9b4>
	  }		  
		if (gGpsLastValidData.fix) {
		  pos = printNumber(gText[textId], TEXT_LINE_MAX_CHARS-10, gGpsLastValidData.sats);
		}
		else {			
		  pos = printText(gText[textId], TEXT_LINE_MAX_CHARS-10, "-");
    156e:	8b e3       	ldi	r24, 0x3B	; 59
    1570:	92 e0       	ldi	r25, 0x02	; 2
    1572:	67 e1       	ldi	r22, 0x17	; 23
    1574:	4d e3       	ldi	r20, 0x3D	; 61
    1576:	51 e0       	ldi	r21, 0x01	; 1
    1578:	ea d6       	rcall	.+3540   	; 0x234e <__data_load_end+0x4ee>
    157a:	16 cf       	rjmp	.-468    	; 0x13a8 <main+0x84e>
}

static void drawArrow(uint16_t angle) {
	drawCircle(GRAPHICS_MID, GRAPHICS_MID, GRAPHICS_MID);
	if (gHomeDistance < 10) {
	  drawCircle(GRAPHICS_MID, GRAPHICS_MID, 2);
    157c:	82 e0       	ldi	r24, 0x02	; 2
    157e:	65 da       	rcall	.-2870   	; 0xa4a <drawCircle.constprop.9>
    1580:	40 cb       	rjmp	.-2432   	; 0xc02 <main+0xa8>
		
		if (gHomePosSet) {
		  pos = printText(gText[textId], pos+3, "\146");
		}
		else {
			pos = printText(gText[textId], pos+3, "\147");
    1582:	8c e5       	ldi	r24, 0x5C	; 92
    1584:	92 e0       	ldi	r25, 0x02	; 2
    1586:	49 e4       	ldi	r20, 0x49	; 73
    1588:	51 e0       	ldi	r21, 0x01	; 1
    158a:	e1 d6       	rcall	.+3522   	; 0x234e <__data_load_end+0x4ee>
    158c:	88 cc       	rjmp	.-1776   	; 0xe9e <main+0x344>
static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
	int8_t mult = 1;
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    158e:	31 e0       	ldi	r19, 0x01	; 1
    1590:	e4 cd       	rjmp	.-1080   	; 0x115a <main+0x600>
    1592:	41 e0       	ldi	r20, 0x01	; 1
    1594:	c7 cd       	rjmp	.-1138   	; 0x1124 <main+0x5ca>
  }    
}

static uint8_t calcGenericLevel(uint8_t adcInput, uint16_t minLevel, uint16_t maxLevel) {
	uint16_t level = ((gAnalogInputs[adcInput].high * 100) + gAnalogInputs[adcInput].low);
	if (level > maxLevel) {
    1596:	24 e6       	ldi	r18, 0x64	; 100
    1598:	30 e0       	ldi	r19, 0x00	; 0
    159a:	40 e0       	ldi	r20, 0x00	; 0
    159c:	50 e0       	ldi	r21, 0x00	; 0
    159e:	c9 ce       	rjmp	.-622    	; 0x1332 <main+0x7d8>
    15a0:	88 27       	eor	r24, r24
    15a2:	99 27       	eor	r25, r25
    15a4:	dc 01       	movw	r26, r24
    15a6:	84 19       	sub	r24, r4
    15a8:	95 09       	sbc	r25, r5
    15aa:	a6 09       	sbc	r26, r6
    15ac:	b7 09       	sbc	r27, r7
    15ae:	bb cf       	rjmp	.-138    	; 0x1526 <main+0x9cc>
#ifdef GPS_ENABLED
    if (!gAlarmSpeed || gBlink1Hz) {
	    pos = printNumber(gText[textId], 0, gGpsLastValidData.speed);
	  }		
    if (!gHomePosSet) {
		  pos = printText(gText[textId], 5, "-");
    15b0:	8b e3       	ldi	r24, 0x3B	; 59
    15b2:	92 e0       	ldi	r25, 0x02	; 2
    15b4:	65 e0       	ldi	r22, 0x05	; 5
    15b6:	4d e3       	ldi	r20, 0x3D	; 61
    15b8:	51 e0       	ldi	r21, 0x01	; 1
    15ba:	c9 d6       	rcall	.+3474   	; 0x234e <__data_load_end+0x4ee>
    15bc:	e7 ce       	rjmp	.-562    	; 0x138c <main+0x832>
#endif //STATISTICS_ENABLED
	}		  
}

static void decodeGpsData(char data) {
	if (gGpsTextPartStep == GPS_PART_FINISHED && data != '$') {
    15be:	04 32       	cpi	r16, 0x24	; 36
    15c0:	09 f0       	breq	.+2      	; 0x15c4 <main+0xa6a>
    15c2:	23 cb       	rjmp	.-2490   	; 0xc0a <main+0xb0>
		return;
	}
	
	switch (data) {
	case '$':
		gGpsTextPos = 0;
    15c4:	10 92 d1 03 	sts	0x03D1, r1
		gGpsTextType = GPS_TYPE_NONE;
    15c8:	10 92 d2 03 	sts	0x03D2, r1
		gGpsChecksum = 0;
    15cc:	10 92 d3 03 	sts	0x03D3, r1
		gGpsTextPartStep = 0;
    15d0:	10 92 5e 01 	sts	0x015E, r1
    15d4:	e4 ed       	ldi	r30, 0xD4	; 212
    15d6:	f3 e0       	ldi	r31, 0x03	; 3
  UCSR0B = (1<<RXEN0); // Enable RX
}

static void clearGpsText() {
	for (uint8_t i = 0; i < GPS_MAX_CHARS; ++i) {
		gGpsText[i] = 0;
    15d8:	11 92       	st	Z+, r1
  UCSR0C = (3<<UCSZ00); // 8N1
  UCSR0B = (1<<RXEN0); // Enable RX
}

static void clearGpsText() {
	for (uint8_t i = 0; i < GPS_MAX_CHARS; ++i) {
    15da:	23 e0       	ldi	r18, 0x03	; 3
    15dc:	ef 3d       	cpi	r30, 0xDF	; 223
    15de:	f2 07       	cpc	r31, r18
    15e0:	d9 f7       	brne	.-10     	; 0x15d8 <main+0xa7e>
    15e2:	13 cb       	rjmp	.-2522   	; 0xc0a <main+0xb0>
static void decodeGpsData(char data) {
	if (gGpsTextPartStep == GPS_PART_FINISHED && data != '$') {
		return;
	}
	
	switch (data) {
    15e4:	0a 32       	cpi	r16, 0x2A	; 42
    15e6:	41 f0       	breq	.+16     	; 0x15f8 <main+0xa9e>
    15e8:	0c 32       	cpi	r16, 0x2C	; 44
    15ea:	09 f0       	breq	.+2      	; 0x15ee <main+0xa94>
    15ec:	fb cc       	rjmp	.-1546   	; 0xfe4 <main+0x48a>
		clearFullGpsText();
		gGpsFullTextPos = 0;
#endif // FULLGPSTEXT
		break;
	case ',':
		gGpsChecksum ^= data;
    15ee:	80 91 d3 03 	lds	r24, 0x03D3
    15f2:	80 27       	eor	r24, r16
    15f4:	80 93 d3 03 	sts	0x03D3, r24
	case '*':
		parseGpsPart();
    15f8:	26 d8       	rcall	.-4020   	; 0x646 <parseGpsPart>
    15fa:	e4 ed       	ldi	r30, 0xD4	; 212
    15fc:	f3 e0       	ldi	r31, 0x03	; 3
  UCSR0B = (1<<RXEN0); // Enable RX
}

static void clearGpsText() {
	for (uint8_t i = 0; i < GPS_MAX_CHARS; ++i) {
		gGpsText[i] = 0;
    15fe:	11 92       	st	Z+, r1
  UCSR0C = (3<<UCSZ00); // 8N1
  UCSR0B = (1<<RXEN0); // Enable RX
}

static void clearGpsText() {
	for (uint8_t i = 0; i < GPS_MAX_CHARS; ++i) {
    1600:	33 e0       	ldi	r19, 0x03	; 3
    1602:	ef 3d       	cpi	r30, 0xDF	; 223
    1604:	f3 07       	cpc	r31, r19
    1606:	d9 f7       	brne	.-10     	; 0x15fe <main+0xaa4>
	case ',':
		gGpsChecksum ^= data;
	case '*':
		parseGpsPart();
		clearGpsText();		
		gGpsTextPos = 0;
    1608:	10 92 d1 03 	sts	0x03D1, r1
		gGpsTextPartStep++;
    160c:	80 91 5e 01 	lds	r24, 0x015E
    1610:	8f 5f       	subi	r24, 0xFF	; 255
    1612:	80 93 5e 01 	sts	0x015E, r24
		if (data =='*') {
    1616:	0a 32       	cpi	r16, 0x2A	; 42
    1618:	09 f0       	breq	.+2      	; 0x161c <main+0xac2>
    161a:	f7 ca       	rjmp	.-2578   	; 0xc0a <main+0xb0>
			gGpsTextPartStep = GPS_PART_CHECKSUM;
    161c:	88 ec       	ldi	r24, 0xC8	; 200
    161e:	80 93 5e 01 	sts	0x015E, r24
    1622:	f3 ca       	rjmp	.-2586   	; 0xc0a <main+0xb0>
		}			
		break;
	case '\r':
	case '\n':
	  parseGpsPart();
    1624:	10 d8       	rcall	.-4064   	; 0x646 <parseGpsPart>
	  gGpsTextPartStep = GPS_PART_FINISHED;
    1626:	8f ef       	ldi	r24, 0xFF	; 255
    1628:	80 93 5e 01 	sts	0x015E, r24
	}	  
}
#endif //STATISTICS_ENABLED

static void finishGpsDecoding() {
	if (gGpsLastData.checksumValid != 0) {
    162c:	80 91 91 01 	lds	r24, 0x0191
    1630:	88 23       	and	r24, r24
    1632:	09 f4       	brne	.+2      	; 0x1636 <main+0xadc>
    1634:	ea ca       	rjmp	.-2604   	; 0xc0a <main+0xb0>
#ifdef STATISTICS_ENABLED
		updateDistanceTraveled();
#endif //STATISTICS_ENABLED    
		gGpsLastValidData = gGpsLastData;
    1636:	ac e9       	ldi	r26, 0x9C	; 156
    1638:	b1 e0       	ldi	r27, 0x01	; 1
    163a:	e9 e7       	ldi	r30, 0x79	; 121
    163c:	f1 e0       	ldi	r31, 0x01	; 1
    163e:	89 e1       	ldi	r24, 0x19	; 25
    1640:	01 90       	ld	r0, Z+
    1642:	0d 92       	st	X+, r0
    1644:	81 50       	subi	r24, 0x01	; 1
    1646:	e1 f7       	brne	.-8      	; 0x1640 <main+0xae6>
		gGpsValidData = 1;
    1648:	81 e0       	ldi	r24, 0x01	; 1
    164a:	80 93 df 03 	sts	0x03DF, r24
		gLastFix = gTime;
    164e:	80 91 74 01 	lds	r24, 0x0174
    1652:	90 91 75 01 	lds	r25, 0x0175
    1656:	90 93 e1 03 	sts	0x03E1, r25
    165a:	80 93 e0 03 	sts	0x03E0, r24
		gInfoShow = gGpsLastValidData.speed < INFO_MIN_SPEED_SHOW;
    165e:	80 91 ac 01 	lds	r24, 0x01AC
    1662:	90 91 ad 01 	lds	r25, 0x01AD
    1666:	21 e0       	ldi	r18, 0x01	; 1
    1668:	83 30       	cpi	r24, 0x03	; 3
    166a:	91 05       	cpc	r25, r1
    166c:	08 f0       	brcs	.+2      	; 0x1670 <main+0xb16>
    166e:	20 e0       	ldi	r18, 0x00	; 0
    1670:	20 93 5f 01 	sts	0x015F, r18

		if (gHomePosSet == 0) {
    1674:	20 91 b5 01 	lds	r18, 0x01B5
    1678:	22 23       	and	r18, r18
    167a:	09 f0       	breq	.+2      	; 0x167e <main+0xb24>
    167c:	c6 ca       	rjmp	.-2676   	; 0xc0a <main+0xb0>
			if (gGpsLastValidData.fix != 0) {
    167e:	20 91 aa 01 	lds	r18, 0x01AA
    1682:	22 23       	and	r18, r18
    1684:	09 f4       	brne	.+2      	; 0x1688 <main+0xb2e>
    1686:	c1 ca       	rjmp	.-2686   	; 0xc0a <main+0xb0>
		    else {
			    ++gHomeFixCount;
		    }
#endif //HOME_FIRST_FIX
#ifdef HOME_AUTO_SET
        if (gGpsLastValidData.speed >= HOME_FIX_MIN_SPEED) {
    1688:	8a 30       	cpi	r24, 0x0A	; 10
    168a:	91 05       	cpc	r25, r1
    168c:	08 f4       	brcc	.+2      	; 0x1690 <main+0xb36>
    168e:	bd ca       	rjmp	.-2694   	; 0xc0a <main+0xb0>

static void setHomePos() {
#ifdef STATISTICS_ENABLED	
	resetStatistics();
#endif //STATISTICS_ENABLED
	gHomePos = gGpsLastValidData.pos;
    1690:	a2 e9       	ldi	r26, 0x92	; 146
    1692:	b1 e0       	ldi	r27, 0x01	; 1
    1694:	ec e9       	ldi	r30, 0x9C	; 156
    1696:	f1 e0       	ldi	r31, 0x01	; 1
    1698:	8a e0       	ldi	r24, 0x0A	; 10
    169a:	01 90       	ld	r0, Z+
    169c:	0d 92       	st	X+, r0
    169e:	81 50       	subi	r24, 0x01	; 1
    16a0:	e1 f7       	brne	.-8      	; 0x169a <main+0xb40>
	gHomePosSet = 1;
    16a2:	81 e0       	ldi	r24, 0x01	; 1
    16a4:	80 93 b5 01 	sts	0x01B5, r24
    16a8:	b0 ca       	rjmp	.-2720   	; 0xc0a <main+0xb0>
    16aa:	0d 8b       	std	Y+21, r16	; 0x15
    16ac:	4b 87       	std	Y+11, r20	; 0x0b
    16ae:	5c 87       	std	Y+12, r21	; 0x0c
    16b0:	6d 87       	std	Y+13, r22	; 0x0d
    16b2:	7e 87       	std	Y+14, r23	; 0x0e
    16b4:	8f 87       	std	Y+15, r24	; 0x0f
    16b6:	98 8b       	std	Y+16, r25	; 0x10
    16b8:	a9 8b       	std	Y+17, r26	; 0x11
    16ba:	ba 8b       	std	Y+18, r27	; 0x12
  }
  
  uint32_t a = (deltaLong * deltaLong);
    16bc:	c5 01       	movw	r24, r10
    16be:	b4 01       	movw	r22, r8
    16c0:	a5 01       	movw	r20, r10
    16c2:	94 01       	movw	r18, r8
    16c4:	e2 d2       	rcall	.+1476   	; 0x1c8a <__mulsi3>
    16c6:	6b 01       	movw	r12, r22
    16c8:	7c 01       	movw	r14, r24
  uint32_t b = (deltaLat * deltaLat);
    16ca:	c3 01       	movw	r24, r6
    16cc:	b2 01       	movw	r22, r4
    16ce:	a3 01       	movw	r20, r6
    16d0:	92 01       	movw	r18, r4
    16d2:	db d2       	rcall	.+1462   	; 0x1c8a <__mulsi3>
    16d4:	8b 01       	movw	r16, r22
    16d6:	9c 01       	movw	r18, r24

  // Make sure that the squared deltas don't go over uin32_t when adding them together.
  // This should only activate at long distances!
  uint8_t mult2 = 1;
  while ((a >> 24) + (b >> 24) > 0xFF) {
    16d8:	89 2f       	mov	r24, r25
    16da:	99 27       	eor	r25, r25
    16dc:	aa 27       	eor	r26, r26
    16de:	bb 27       	eor	r27, r27
    16e0:	4f 2d       	mov	r20, r15
    16e2:	55 27       	eor	r21, r21
    16e4:	66 27       	eor	r22, r22
    16e6:	77 27       	eor	r23, r23
    16e8:	84 0f       	add	r24, r20
    16ea:	95 1f       	adc	r25, r21
    16ec:	a6 1f       	adc	r26, r22
    16ee:	b7 1f       	adc	r27, r23
    16f0:	8f 3f       	cpi	r24, 0xFF	; 255
    16f2:	91 05       	cpc	r25, r1
    16f4:	a1 05       	cpc	r26, r1
    16f6:	b1 05       	cpc	r27, r1
    16f8:	09 f0       	breq	.+2      	; 0x16fc <main+0xba2>
    16fa:	08 f4       	brcc	.+2      	; 0x16fe <main+0xba4>
    16fc:	53 c1       	rjmp	.+678    	; 0x19a4 <main+0xe4a>
    a /= 4;
    16fe:	f6 94       	lsr	r15
    1700:	e7 94       	ror	r14
    1702:	d7 94       	ror	r13
    1704:	c7 94       	ror	r12
    1706:	f6 94       	lsr	r15
    1708:	e7 94       	ror	r14
    170a:	d7 94       	ror	r13
    170c:	c7 94       	ror	r12
    b /= 4;
    170e:	36 95       	lsr	r19
    1710:	27 95       	ror	r18
    1712:	17 95       	ror	r17
    1714:	07 95       	ror	r16
    1716:	36 95       	lsr	r19
    1718:	27 95       	ror	r18
    171a:	17 95       	ror	r17
    171c:	07 95       	ror	r16
    171e:	42 e0       	ldi	r20, 0x02	; 2
    1720:	50 e0       	ldi	r21, 0x00	; 0
    1722:	60 e0       	ldi	r22, 0x00	; 0
    1724:	70 e0       	ldi	r23, 0x00	; 0
    1726:	4d 83       	std	Y+5, r20	; 0x05
    1728:	5e 83       	std	Y+6, r21	; 0x06
    172a:	6f 83       	std	Y+7, r22	; 0x07
    172c:	78 87       	std	Y+8, r23	; 0x08
    mult2 *= 2;
  }
  
  distance = calcSqrt(a + b);
    172e:	d7 01       	movw	r26, r14
    1730:	c6 01       	movw	r24, r12
    1732:	80 0f       	add	r24, r16
    1734:	91 1f       	adc	r25, r17
    1736:	a2 1f       	adc	r26, r18
    1738:	b3 1f       	adc	r27, r19
    173a:	89 83       	std	Y+1, r24	; 0x01
    173c:	9a 83       	std	Y+2, r25	; 0x02
    173e:	ab 83       	std	Y+3, r26	; 0x03
    1740:	bc 83       	std	Y+4, r27	; 0x04
}

static uint32_t calcSqrt(uint32_t input)
{
  int32_t nv;
  int32_t v = input>>1;
    1742:	6c 01       	movw	r12, r24
    1744:	7d 01       	movw	r14, r26
    1746:	f6 94       	lsr	r15
    1748:	e7 94       	ror	r14
    174a:	d7 94       	ror	r13
    174c:	c7 94       	ror	r12
  int32_t c = 0;
  if (!v) {
    174e:	c1 14       	cp	r12, r1
    1750:	d1 04       	cpc	r13, r1
    1752:	e1 04       	cpc	r14, r1
    1754:	f1 04       	cpc	r15, r1
    1756:	61 f1       	breq	.+88     	; 0x17b0 <main+0xc56>
    1758:	1a 86       	std	Y+10, r1	; 0x0a
    175a:	19 86       	std	Y+9, r1	; 0x09
    175c:	0a c0       	rjmp	.+20     	; 0x1772 <main+0xc18>
    return input;
  }	
  do {
    nv = (v + input / v)>>1;
    if (absu32(v - nv) <= 1) {
    175e:	a9 85       	ldd	r26, Y+9	; 0x09
    1760:	ba 85       	ldd	r27, Y+10	; 0x0a
    1762:	11 96       	adiw	r26, 0x01	; 1
    1764:	ba 87       	std	Y+10, r27	; 0x0a
    1766:	a9 87       	std	Y+9, r26	; 0x09
      return nv;
	  }	  
    v = nv;
  } while (c++ < 25);
    1768:	aa 31       	cpi	r26, 0x1A	; 26
    176a:	b1 05       	cpc	r27, r1
    176c:	e9 f0       	breq	.+58     	; 0x17a8 <main+0xc4e>
  do {
    nv = (v + input / v)>>1;
    if (absu32(v - nv) <= 1) {
      return nv;
	  }	  
    v = nv;
    176e:	68 01       	movw	r12, r16
    1770:	79 01       	movw	r14, r18
  int32_t c = 0;
  if (!v) {
    return input;
  }	
  do {
    nv = (v + input / v)>>1;
    1772:	69 81       	ldd	r22, Y+1	; 0x01
    1774:	7a 81       	ldd	r23, Y+2	; 0x02
    1776:	8b 81       	ldd	r24, Y+3	; 0x03
    1778:	9c 81       	ldd	r25, Y+4	; 0x04
    177a:	a7 01       	movw	r20, r14
    177c:	96 01       	movw	r18, r12
    177e:	cb d2       	rcall	.+1430   	; 0x1d16 <__udivmodsi4>
    1780:	89 01       	movw	r16, r18
    1782:	9a 01       	movw	r18, r20
    1784:	0c 0d       	add	r16, r12
    1786:	1d 1d       	adc	r17, r13
    1788:	2e 1d       	adc	r18, r14
    178a:	3f 1d       	adc	r19, r15
    178c:	36 95       	lsr	r19
    178e:	27 95       	ror	r18
    1790:	17 95       	ror	r17
    1792:	07 95       	ror	r16
    if (absu32(v - nv) <= 1) {
    1794:	c0 1a       	sub	r12, r16
    1796:	d1 0a       	sbc	r13, r17
    1798:	e2 0a       	sbc	r14, r18
    179a:	f3 0a       	sbc	r15, r19
    179c:	92 e0       	ldi	r25, 0x02	; 2
    179e:	c9 16       	cp	r12, r25
    17a0:	d1 04       	cpc	r13, r1
    17a2:	e1 04       	cpc	r14, r1
    17a4:	f1 04       	cpc	r15, r1
    17a6:	d8 f6       	brcc	.-74     	; 0x175e <main+0xc04>
      return nv;
    17a8:	09 83       	std	Y+1, r16	; 0x01
    17aa:	1a 83       	std	Y+2, r17	; 0x02
    17ac:	2b 83       	std	Y+3, r18	; 0x03
    17ae:	3c 83       	std	Y+4, r19	; 0x04
  distance *= mult2;
    17b0:	69 81       	ldd	r22, Y+1	; 0x01
    17b2:	7a 81       	ldd	r23, Y+2	; 0x02
    17b4:	8b 81       	ldd	r24, Y+3	; 0x03
    17b6:	9c 81       	ldd	r25, Y+4	; 0x04
    17b8:	2d 81       	ldd	r18, Y+5	; 0x05
    17ba:	3e 81       	ldd	r19, Y+6	; 0x06
    17bc:	4f 81       	ldd	r20, Y+7	; 0x07
    17be:	58 85       	ldd	r21, Y+8	; 0x08
    17c0:	64 d2       	rcall	.+1224   	; 0x1c8a <__mulsi3>
    17c2:	6b 01       	movw	r12, r22
    17c4:	7c 01       	movw	r14, r24

  // Only calculate bearing if bearing pointer is set.
  if (bearingResult != NULL) {
    bearing = 0;
    if (distance > 0) { // Over home -> do not compute; Home forced to 0
    17c6:	61 15       	cp	r22, r1
    17c8:	71 05       	cpc	r23, r1
    17ca:	81 05       	cpc	r24, r1
    17cc:	91 05       	cpc	r25, r1
    17ce:	09 f4       	brne	.+2      	; 0x17d2 <main+0xc78>
    17d0:	4d c0       	rjmp	.+154    	; 0x186c <main+0xd12>
      if (absi32(deltaLong) >= absi32(deltaLat)) { // low angle, sine is better
    17d2:	2f 85       	ldd	r18, Y+15	; 0x0f
    17d4:	38 89       	ldd	r19, Y+16	; 0x10
    17d6:	49 89       	ldd	r20, Y+17	; 0x11
    17d8:	5a 89       	ldd	r21, Y+18	; 0x12
    17da:	6b 85       	ldd	r22, Y+11	; 0x0b
    17dc:	7c 85       	ldd	r23, Y+12	; 0x0c
    17de:	8d 85       	ldd	r24, Y+13	; 0x0d
    17e0:	9e 85       	ldd	r25, Y+14	; 0x0e
    17e2:	62 17       	cp	r22, r18
    17e4:	73 07       	cpc	r23, r19
    17e6:	84 07       	cpc	r24, r20
    17e8:	95 07       	cpc	r25, r21
    17ea:	08 f4       	brcc	.+2      	; 0x17ee <main+0xc94>
    17ec:	94 c0       	rjmp	.+296    	; 0x1916 <main+0xdbc>
        c = (absi32(deltaLat) * 100) / distance; // computes sine -> dist > 0
    17ee:	ca 01       	movw	r24, r20
    17f0:	b9 01       	movw	r22, r18
    17f2:	24 e6       	ldi	r18, 0x64	; 100
    17f4:	30 e0       	ldi	r19, 0x00	; 0
    17f6:	40 e0       	ldi	r20, 0x00	; 0
    17f8:	50 e0       	ldi	r21, 0x00	; 0
    17fa:	47 d2       	rcall	.+1166   	; 0x1c8a <__mulsi3>
    17fc:	a7 01       	movw	r20, r14
    17fe:	96 01       	movw	r18, r12
    1800:	8a d2       	rcall	.+1300   	; 0x1d16 <__udivmodsi4>
    1802:	52 2f       	mov	r21, r18
  distance = calcSqrt(a + b);
  distance *= mult2;

  // Only calculate bearing if bearing pointer is set.
  if (bearingResult != NULL) {
    bearing = 0;
    1804:	20 e0       	ldi	r18, 0x00	; 0
    1806:	30 e0       	ldi	r19, 0x00	; 0
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
	int8_t mult = 1;
    1808:	41 e0       	ldi	r20, 0x01	; 1
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    180a:	80 e0       	ldi	r24, 0x00	; 0
    180c:	90 e0       	ldi	r25, 0x00	; 0
    180e:	08 e6       	ldi	r16, 0x68	; 104
    1810:	11 e0       	ldi	r17, 0x01	; 1
    1812:	59 83       	std	Y+1, r21	; 0x01
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
		pos = 180 - pos;
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
    1814:	8c 5c       	subi	r24, 0xCC	; 204
    1816:	9f 4f       	sbci	r25, 0xFF	; 255
    1818:	fc 01       	movw	r30, r24
    181a:	84 91       	lpm	r24, Z
    181c:	84 9f       	mul	r24, r20
    181e:	40 2d       	mov	r20, r0
    1820:	11 24       	eor	r1, r1
    if (distance > 0) { // Over home -> do not compute; Home forced to 0
      if (absi32(deltaLong) >= absi32(deltaLat)) { // low angle, sine is better
        c = (absi32(deltaLat) * 100) / distance; // computes sine -> dist > 0
        while((mySin(bearing) <= c) && (bearing < 90)) {
    1822:	f9 81       	ldd	r31, Y+1	; 0x01
    1824:	f4 17       	cp	r31, r20
    1826:	0c f4       	brge	.+2      	; 0x182a <main+0xcd0>
    1828:	6b c0       	rjmp	.+214    	; 0x1900 <main+0xda6>
    182a:	2a 35       	cpi	r18, 0x5A	; 90
    182c:	31 05       	cpc	r19, r1
    182e:	09 f4       	brne	.+2      	; 0x1832 <main+0xcd8>
    1830:	67 c0       	rjmp	.+206    	; 0x1900 <main+0xda6>
          ++bearing;
    1832:	2f 5f       	subi	r18, 0xFF	; 255
    1834:	3f 4f       	sbci	r19, 0xFF	; 255
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    1836:	c9 01       	movw	r24, r18
    1838:	b8 01       	movw	r22, r16
    183a:	46 d2       	rcall	.+1164   	; 0x1cc8 <__udivmodhi4>
	int8_t mult = 1;
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    183c:	84 3b       	cpi	r24, 0xB4	; 180
    183e:	91 05       	cpc	r25, r1
    1840:	60 f0       	brcs	.+24     	; 0x185a <main+0xd00>
		pos = pos - 180;
    1842:	84 5b       	subi	r24, 0xB4	; 180
    1844:	90 40       	sbci	r25, 0x00	; 0
		mult = -1;
    1846:	4f ef       	ldi	r20, 0xFF	; 255
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
    1848:	8a 35       	cpi	r24, 0x5A	; 90
    184a:	91 05       	cpc	r25, r1
    184c:	18 f3       	brcs	.-58     	; 0x1814 <main+0xcba>
		pos = 180 - pos;
    184e:	a4 eb       	ldi	r26, 0xB4	; 180
    1850:	b0 e0       	ldi	r27, 0x00	; 0
    1852:	a8 1b       	sub	r26, r24
    1854:	b9 0b       	sbc	r27, r25
    1856:	cd 01       	movw	r24, r26
    1858:	dd cf       	rjmp	.-70     	; 0x1814 <main+0xcba>
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
	int8_t mult = 1;
    185a:	41 e0       	ldi	r20, 0x01	; 1
    185c:	f5 cf       	rjmp	.-22     	; 0x1848 <main+0xcee>
		level = 100;
	}		
	else if (level > minLevel) {
    185e:	20 e0       	ldi	r18, 0x00	; 0
    1860:	30 e0       	ldi	r19, 0x00	; 0
    1862:	a9 01       	movw	r20, r18
    1864:	66 cd       	rjmp	.-1332   	; 0x1332 <main+0x7d8>
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    1866:	21 e0       	ldi	r18, 0x01	; 1
    1868:	2d 83       	std	Y+5, r18	; 0x05
    186a:	08 ce       	rjmp	.-1008   	; 0x147c <main+0x922>
  distance = calcSqrt(a + b);
  distance *= mult2;

  // Only calculate bearing if bearing pointer is set.
  if (bearingResult != NULL) {
    bearing = 0;
    186c:	80 e0       	ldi	r24, 0x00	; 0
    186e:	90 e0       	ldi	r25, 0x00	; 0
	      else { // SW quadrant
          bearing = 270 - bearing;
        }
      }
    }
    *bearingResult = bearing;
    1870:	90 93 e7 03 	sts	0x03E7, r25
    1874:	80 93 e6 03 	sts	0x03E6, r24
	}
  distance = distance * 309; // ate aqui em segundo * 100
    1878:	c7 01       	movw	r24, r14
    187a:	b6 01       	movw	r22, r12
    187c:	25 e3       	ldi	r18, 0x35	; 53
    187e:	31 e0       	ldi	r19, 0x01	; 1
    1880:	40 e0       	ldi	r20, 0x00	; 0
    1882:	50 e0       	ldi	r21, 0x00	; 0
    1884:	02 d2       	rcall	.+1028   	; 0x1c8a <__mulsi3>
  distance = distance / 1000; // metros, agora
    1886:	28 ee       	ldi	r18, 0xE8	; 232
    1888:	33 e0       	ldi	r19, 0x03	; 3
    188a:	40 e0       	ldi	r20, 0x00	; 0
    188c:	50 e0       	ldi	r21, 0x00	; 0
    188e:	43 d2       	rcall	.+1158   	; 0x1d16 <__udivmodsi4>
    1890:	69 01       	movw	r12, r18
    1892:	7a 01       	movw	r14, r20
  distance *= mult;
    1894:	6d 89       	ldd	r22, Y+21	; 0x15
    1896:	26 2f       	mov	r18, r22
    1898:	30 e0       	ldi	r19, 0x00	; 0
    189a:	40 e0       	ldi	r20, 0x00	; 0
    189c:	50 e0       	ldi	r21, 0x00	; 0
    189e:	c7 01       	movw	r24, r14
    18a0:	b6 01       	movw	r22, r12
    18a2:	f3 d1       	rcall	.+998    	; 0x1c8a <__mulsi3>
    18a4:	dc 01       	movw	r26, r24
    18a6:	cb 01       	movw	r24, r22
#ifdef IMPERIAL_SYSTEM  
  distance *= 3281;
	distance /= 1000;
#endif //IMPERIAL_SYSTEM
  *distanceResult = distance;
    18a8:	80 93 e2 03 	sts	0x03E2, r24
    18ac:	90 93 e3 03 	sts	0x03E3, r25
    18b0:	a0 93 e4 03 	sts	0x03E4, r26
    18b4:	b0 93 e5 03 	sts	0x03E5, r27
    18b8:	ea c9       	rjmp	.-3116   	; 0xc8e <main+0x134>
	a = (a * (GRAPHICS_SIZE / 3)) / 100;
	b = (b * (GRAPHICS_SIZE / 3)) / 100;
	drawLine(GRAPHICS_MID - b, GRAPHICS_MID + a, GRAPHICS_MID + b, GRAPHICS_MID - a); //Direction line
	//drawLine(GRAPHICS_MID_X + a/2, GRAPHICS_MID_X + b/2, GRAPHICS_MID_X - a/2, GRAPHICS_MID_X - b/2); //Arrow bottom line
	drawLine(GRAPHICS_MID + b, GRAPHICS_MID - a, GRAPHICS_MID - a/2, GRAPHICS_MID - b/2); // Arrow "wings"
	drawLine(GRAPHICS_MID + b, GRAPHICS_MID - a, GRAPHICS_MID + a/2, GRAPHICS_MID + b/2);
    18ba:	0f 5f       	subi	r16, 0xFF	; 255
    18bc:	1f 4f       	sbci	r17, 0xFF	; 255
    18be:	a5 cc       	rjmp	.-1718   	; 0x120a <main+0x6b0>
    18c0:	08 94       	sec
    18c2:	81 1c       	adc	r8, r1
    18c4:	91 1c       	adc	r9, r1
    18c6:	9b cc       	rjmp	.-1738   	; 0x11fe <main+0x6a4>
	int16_t b = mySin(angle);
	a = (a * (GRAPHICS_SIZE / 3)) / 100;
	b = (b * (GRAPHICS_SIZE / 3)) / 100;
	drawLine(GRAPHICS_MID - b, GRAPHICS_MID + a, GRAPHICS_MID + b, GRAPHICS_MID - a); //Direction line
	//drawLine(GRAPHICS_MID_X + a/2, GRAPHICS_MID_X + b/2, GRAPHICS_MID_X - a/2, GRAPHICS_MID_X - b/2); //Arrow bottom line
	drawLine(GRAPHICS_MID + b, GRAPHICS_MID - a, GRAPHICS_MID - a/2, GRAPHICS_MID - b/2); // Arrow "wings"
    18c8:	2f 5f       	subi	r18, 0xFF	; 255
    18ca:	3f 4f       	sbci	r19, 0xFF	; 255
    18cc:	8b cc       	rjmp	.-1770   	; 0x11e4 <main+0x68a>
    18ce:	01 96       	adiw	r24, 0x01	; 1
    18d0:	7f cc       	rjmp	.-1794   	; 0x11d0 <main+0x676>

  // considers flat earth around vehicle and reference

  // Ernani Reis, Aug 2011
  
  if (currLat == homeLat && currLong == homeLong) {
    18d2:	44 16       	cp	r4, r20
    18d4:	55 06       	cpc	r5, r21
    18d6:	66 06       	cpc	r6, r22
    18d8:	77 06       	cpc	r7, r23
    18da:	09 f0       	breq	.+2      	; 0x18de <main+0xd84>
    18dc:	ab cd       	rjmp	.-1194   	; 0x1434 <main+0x8da>
	  *distanceResult = 0;
    18de:	10 92 e2 03 	sts	0x03E2, r1
    18e2:	10 92 e3 03 	sts	0x03E3, r1
    18e6:	10 92 e4 03 	sts	0x03E4, r1
    18ea:	10 92 e5 03 	sts	0x03E5, r1
	  *bearingResult = 0;
    18ee:	10 92 e7 03 	sts	0x03E7, r1
    18f2:	10 92 e6 03 	sts	0x03E6, r1
    18f6:	cb c9       	rjmp	.-3178   	; 0xc8e <main+0x134>
	    else { // high angle, cosine is better
        c = (absi32(deltaLong) * 100) / distance; // Computes cosine
        while((mySin(bearing) <= c) && (bearing < 90)) {
          ++bearing;
        }
        bearing = 90 - bearing;
    18f8:	2a e5       	ldi	r18, 0x5A	; 90
    18fa:	30 e0       	ldi	r19, 0x00	; 0
    18fc:	20 1b       	sub	r18, r16
    18fe:	31 0b       	sbc	r19, r17
      }
      if (deltaLat == 0) {
    1900:	41 14       	cp	r4, r1
    1902:	51 04       	cpc	r5, r1
    1904:	61 04       	cpc	r6, r1
    1906:	71 04       	cpc	r7, r1
    1908:	09 f0       	breq	.+2      	; 0x190c <main+0xdb2>
    190a:	3d c0       	rjmp	.+122    	; 0x1986 <main+0xe2c>
        if (deltaLong >= 0) { // Home = East
    190c:	b7 fc       	sbrc	r11, 7
    190e:	47 c0       	rjmp	.+142    	; 0x199e <main+0xe44>
          bearing = 90; 
    1910:	8a e5       	ldi	r24, 0x5A	; 90
    1912:	90 e0       	ldi	r25, 0x00	; 0
    1914:	ad cf       	rjmp	.-166    	; 0x1870 <main+0xd16>
        while((mySin(bearing) <= c) && (bearing < 90)) {
          ++bearing;
        }
      } 
	    else { // high angle, cosine is better
        c = (absi32(deltaLong) * 100) / distance; // Computes cosine
    1916:	6b 85       	ldd	r22, Y+11	; 0x0b
    1918:	7c 85       	ldd	r23, Y+12	; 0x0c
    191a:	8d 85       	ldd	r24, Y+13	; 0x0d
    191c:	9e 85       	ldd	r25, Y+14	; 0x0e
    191e:	24 e6       	ldi	r18, 0x64	; 100
    1920:	30 e0       	ldi	r19, 0x00	; 0
    1922:	40 e0       	ldi	r20, 0x00	; 0
    1924:	50 e0       	ldi	r21, 0x00	; 0
    1926:	b1 d1       	rcall	.+866    	; 0x1c8a <__mulsi3>
    1928:	a7 01       	movw	r20, r14
    192a:	96 01       	movw	r18, r12
    192c:	f4 d1       	rcall	.+1000   	; 0x1d16 <__udivmodsi4>
    192e:	52 2f       	mov	r21, r18
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
	int8_t mult = 1;
    1930:	41 e0       	ldi	r20, 0x01	; 1
  distance = calcSqrt(a + b);
  distance *= mult2;

  // Only calculate bearing if bearing pointer is set.
  if (bearingResult != NULL) {
    bearing = 0;
    1932:	00 e0       	ldi	r16, 0x00	; 0
    1934:	10 e0       	ldi	r17, 0x00	; 0
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    1936:	80 e0       	ldi	r24, 0x00	; 0
    1938:	90 e0       	ldi	r25, 0x00	; 0
    193a:	28 e6       	ldi	r18, 0x68	; 104
    193c:	31 e0       	ldi	r19, 0x01	; 1
    193e:	59 83       	std	Y+1, r21	; 0x01
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
		pos = 180 - pos;
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
    1940:	8c 5c       	subi	r24, 0xCC	; 204
    1942:	9f 4f       	sbci	r25, 0xFF	; 255
    1944:	fc 01       	movw	r30, r24
    1946:	84 91       	lpm	r24, Z
    1948:	84 9f       	mul	r24, r20
    194a:	40 2d       	mov	r20, r0
    194c:	11 24       	eor	r1, r1
          ++bearing;
        }
      } 
	    else { // high angle, cosine is better
        c = (absi32(deltaLong) * 100) / distance; // Computes cosine
        while((mySin(bearing) <= c) && (bearing < 90)) {
    194e:	f9 81       	ldd	r31, Y+1	; 0x01
    1950:	f4 17       	cp	r31, r20
    1952:	94 f2       	brlt	.-92     	; 0x18f8 <main+0xd9e>
    1954:	0a 35       	cpi	r16, 0x5A	; 90
    1956:	11 05       	cpc	r17, r1
    1958:	79 f2       	breq	.-98     	; 0x18f8 <main+0xd9e>
          ++bearing;
    195a:	0f 5f       	subi	r16, 0xFF	; 255
    195c:	1f 4f       	sbci	r17, 0xFF	; 255
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    195e:	c8 01       	movw	r24, r16
    1960:	b9 01       	movw	r22, r18
    1962:	b2 d1       	rcall	.+868    	; 0x1cc8 <__udivmodhi4>
	int8_t mult = 1;
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    1964:	84 3b       	cpi	r24, 0xB4	; 180
    1966:	91 05       	cpc	r25, r1
    1968:	60 f0       	brcs	.+24     	; 0x1982 <main+0xe28>
		pos = pos - 180;
    196a:	84 5b       	subi	r24, 0xB4	; 180
    196c:	90 40       	sbci	r25, 0x00	; 0
		mult = -1;
    196e:	4f ef       	ldi	r20, 0xFF	; 255
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
    1970:	8a 35       	cpi	r24, 0x5A	; 90
    1972:	91 05       	cpc	r25, r1
    1974:	28 f3       	brcs	.-54     	; 0x1940 <main+0xde6>
		pos = 180 - pos;
    1976:	64 eb       	ldi	r22, 0xB4	; 180
    1978:	70 e0       	ldi	r23, 0x00	; 0
    197a:	68 1b       	sub	r22, r24
    197c:	79 0b       	sbc	r23, r25
    197e:	cb 01       	movw	r24, r22
    1980:	df cf       	rjmp	.-66     	; 0x1940 <main+0xde6>
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
	int8_t mult = 1;
    1982:	41 e0       	ldi	r20, 0x01	; 1
    1984:	f5 cf       	rjmp	.-22     	; 0x1970 <main+0xe16>
        } 
	      else { // Home = West
          bearing = 270;
        }
      } 
      else if (deltaLat > 0) {
    1986:	14 14       	cp	r1, r4
    1988:	15 04       	cpc	r1, r5
    198a:	16 04       	cpc	r1, r6
    198c:	17 04       	cpc	r1, r7
    198e:	bc f4       	brge	.+46     	; 0x19be <main+0xe64>
        if (deltaLong >= 0) { // NE quadrant
    1990:	b7 fc       	sbrc	r11, 7
    1992:	11 c0       	rjmp	.+34     	; 0x19b6 <main+0xe5c>
          bearing = 90 - bearing;
    1994:	8a e5       	ldi	r24, 0x5A	; 90
    1996:	90 e0       	ldi	r25, 0x00	; 0
    1998:	82 1b       	sub	r24, r18
    199a:	93 0b       	sbc	r25, r19
    199c:	69 cf       	rjmp	.-302    	; 0x1870 <main+0xd16>
      if (deltaLat == 0) {
        if (deltaLong >= 0) { // Home = East
          bearing = 90; 
        } 
	      else { // Home = West
          bearing = 270;
    199e:	8e e0       	ldi	r24, 0x0E	; 14
    19a0:	91 e0       	ldi	r25, 0x01	; 1
    19a2:	66 cf       	rjmp	.-308    	; 0x1870 <main+0xd16>
  uint32_t b = (deltaLat * deltaLat);

  // Make sure that the squared deltas don't go over uin32_t when adding them together.
  // This should only activate at long distances!
  uint8_t mult2 = 1;
  while ((a >> 24) + (b >> 24) > 0xFF) {
    19a4:	61 e0       	ldi	r22, 0x01	; 1
    19a6:	70 e0       	ldi	r23, 0x00	; 0
    19a8:	80 e0       	ldi	r24, 0x00	; 0
    19aa:	90 e0       	ldi	r25, 0x00	; 0
    19ac:	6d 83       	std	Y+5, r22	; 0x05
    19ae:	7e 83       	std	Y+6, r23	; 0x06
    19b0:	8f 83       	std	Y+7, r24	; 0x07
    19b2:	98 87       	std	Y+8, r25	; 0x08
    19b4:	bc ce       	rjmp	.-648    	; 0x172e <main+0xbd4>
      else if (deltaLat > 0) {
        if (deltaLong >= 0) { // NE quadrant
          bearing = 90 - bearing;
        } 
	      else { // NW quadrant
          bearing = 270 + bearing;
    19b6:	c9 01       	movw	r24, r18
    19b8:	82 5f       	subi	r24, 0xF2	; 242
    19ba:	9e 4f       	sbci	r25, 0xFE	; 254
    19bc:	59 cf       	rjmp	.-334    	; 0x1870 <main+0xd16>
        }
      } 
	    else {
        if (deltaLong >= 0) { // SE quadrant
    19be:	b7 fc       	sbrc	r11, 7
    19c0:	04 c0       	rjmp	.+8      	; 0x19ca <main+0xe70>
          bearing = 90 + bearing;
    19c2:	c9 01       	movw	r24, r18
    19c4:	86 5a       	subi	r24, 0xA6	; 166
    19c6:	9f 4f       	sbci	r25, 0xFF	; 255
    19c8:	53 cf       	rjmp	.-346    	; 0x1870 <main+0xd16>
        } 
	      else { // SW quadrant
          bearing = 270 - bearing;
    19ca:	8e e0       	ldi	r24, 0x0E	; 14
    19cc:	91 e0       	ldi	r25, 0x01	; 1
    19ce:	82 1b       	sub	r24, r18
    19d0:	93 0b       	sbc	r25, r19
    19d2:	4e cf       	rjmp	.-356    	; 0x1870 <main+0xd16>

000019d4 <__vector_1>:
			//DDRB &= ~OUT1;
		}
	}
}

ISR(INT0_vect) {
    19d4:	1f 92       	push	r1
    19d6:	0f 92       	push	r0
    19d8:	0f b6       	in	r0, 0x3f	; 63
    19da:	0f 92       	push	r0
    19dc:	11 24       	eor	r1, r1
    19de:	2f 93       	push	r18
    19e0:	3f 93       	push	r19
    19e2:	4f 93       	push	r20
    19e4:	5f 93       	push	r21
    19e6:	6f 93       	push	r22
    19e8:	7f 93       	push	r23
    19ea:	8f 93       	push	r24
    19ec:	9f 93       	push	r25
    19ee:	af 93       	push	r26
    19f0:	bf 93       	push	r27
    19f2:	ef 93       	push	r30
    19f4:	ff 93       	push	r31
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    19f6:	88 e2       	ldi	r24, 0x28	; 40
    19f8:	8a 95       	dec	r24
    19fa:	f1 f7       	brne	.-4      	; 0x19f8 <__vector_1+0x24>
}  

static void updateLine() {
  _delay_us(5); // wait 5us to see if H or V sync

	if(!(PIND & LTRIG)) { // H sync
    19fc:	4a 99       	sbic	0x09, 2	; 9
    19fe:	81 c0       	rjmp	.+258    	; 0x1b02 <__vector_1+0x12e>
		if (gActiveLine != 0) {
    1a00:	60 91 40 04 	lds	r22, 0x0440
    1a04:	70 91 41 04 	lds	r23, 0x0441
    1a08:	61 15       	cp	r22, r1
    1a0a:	71 05       	cpc	r23, r1
    1a0c:	09 f4       	brne	.+2      	; 0x1a10 <__vector_1+0x3c>
    1a0e:	39 c0       	rjmp	.+114    	; 0x1a82 <__vector_1+0xae>
			switch(gLineType) {
    1a10:	80 91 42 04 	lds	r24, 0x0442
    1a14:	81 30       	cpi	r24, 0x01	; 1
    1a16:	09 f4       	brne	.+2      	; 0x1a1a <__vector_1+0x46>
    1a18:	92 c0       	rjmp	.+292    	; 0x1b3e <__vector_1+0x16a>
    1a1a:	82 30       	cpi	r24, 0x02	; 2
    1a1c:	09 f0       	breq	.+2      	; 0x1a20 <__vector_1+0x4c>
    1a1e:	31 c0       	rjmp	.+98     	; 0x1a82 <__vector_1+0xae>
    1a20:	e3 e1       	ldi	r30, 0x13	; 19
    1a22:	f1 e0       	ldi	r31, 0x01	; 1
    1a24:	31 97       	sbiw	r30, 0x01	; 1
    1a26:	f1 f7       	brne	.-4      	; 0x1a24 <__vector_1+0x50>
    1a28:	00 c0       	rjmp	.+0      	; 0x1a2a <__vector_1+0x56>
    1a2a:	00 00       	nop
{
#ifdef TEXT_SMALL_ENABLED
	SPSR &= ~(1<<SPI2X); // Set normal speed
#endif //TEXT_SMALL_ENABLED
  _delay_us(GRAPHICS_OFFSET);
  uint16_t currLine = gActivePixmapLine;
    1a2c:	20 91 43 04 	lds	r18, 0x0443
    1a30:	30 e0       	ldi	r19, 0x00	; 0
    1a32:	80 e0       	ldi	r24, 0x00	; 0
    1a34:	90 e0       	ldi	r25, 0x00	; 0
    1a36:	28 51       	subi	r18, 0x18	; 24
    1a38:	3c 4f       	sbci	r19, 0xFC	; 252
    1a3a:	f9 01       	movw	r30, r18
    1a3c:	e8 0f       	add	r30, r24
    1a3e:	f9 1f       	adc	r31, r25
  for (uint8_t i = 0; i < GRAPHICS_WIDTH; ++i) {
	  SPDR = gPixelData[i][currLine];
    1a40:	40 81       	ld	r20, Z
    1a42:	4e bd       	out	0x2e, r20	; 46
	  DDRB |= OUT1;
    1a44:	21 9a       	sbi	0x04, 1	; 4
	...
	  DELAY_9_NOP();
	  DELAY_9_NOP();
	  DELAY_5_NOP();
    1a72:	00 00       	nop
    1a74:	48 96       	adiw	r24, 0x18	; 24
#ifdef TEXT_SMALL_ENABLED
	SPSR &= ~(1<<SPI2X); // Set normal speed
#endif //TEXT_SMALL_ENABLED
  _delay_us(GRAPHICS_OFFSET);
  uint16_t currLine = gActivePixmapLine;
  for (uint8_t i = 0; i < GRAPHICS_WIDTH; ++i) {
    1a76:	88 34       	cpi	r24, 0x48	; 72
    1a78:	91 05       	cpc	r25, r1
    1a7a:	f9 f6       	brne	.-66     	; 0x1a3a <__vector_1+0x66>
	  DDRB |= OUT1;
	  DELAY_9_NOP();
	  DELAY_9_NOP();
	  DELAY_5_NOP();
  }
  DDRB &= ~OUT1;
    1a7c:	21 98       	cbi	0x04, 1	; 4
  DELAY_1_NOP();
    1a7e:	00 00       	nop
  SPDR = 0x00;
    1a80:	1e bc       	out	0x2e, r1	; 46
					break;
			}
		}
		
		// We save some time in beginning of line by pre-calculating next type.
		gLineType = LINE_TYPE_UNKNOWN; // Default case
    1a82:	10 92 42 04 	sts	0x0442, r1
		gActiveLine++;
    1a86:	cb 01       	movw	r24, r22
    1a88:	01 96       	adiw	r24, 0x01	; 1
    1a8a:	90 93 41 04 	sts	0x0441, r25
    1a8e:	80 93 40 04 	sts	0x0440, r24
		if (gActiveLine == UPDATE_LINE) {
    1a92:	8e 36       	cpi	r24, 0x6E	; 110
    1a94:	91 05       	cpc	r25, r1
    1a96:	09 f4       	brne	.+2      	; 0x1a9a <__vector_1+0xc6>
    1a98:	40 c0       	rjmp	.+128    	; 0x1b1a <__vector_1+0x146>
			gUpdateScreenData = 1;
		}
		if (gActiveLine == UPDATE_LINE + 1) {
    1a9a:	8f 36       	cpi	r24, 0x6F	; 111
    1a9c:	91 05       	cpc	r25, r1
    1a9e:	19 f4       	brne	.+6      	; 0x1aa6 <__vector_1+0xd2>
			gUpdateScreenData = 2;
    1aa0:	22 e0       	ldi	r18, 0x02	; 2
    1aa2:	20 93 72 01 	sts	0x0172, r18
		}			

#ifdef TEXT_ENABLED	
		if (gActiveLine >= gActiveTextLine && gActiveLine < gActiveTextLastLine) {
    1aa6:	40 91 cf 03 	lds	r20, 0x03CF
    1aaa:	50 91 d0 03 	lds	r21, 0x03D0
    1aae:	20 91 68 01 	lds	r18, 0x0168
    1ab2:	30 91 69 01 	lds	r19, 0x0169
    1ab6:	84 17       	cp	r24, r20
    1ab8:	95 07       	cpc	r25, r21
    1aba:	18 f0       	brcs	.+6      	; 0x1ac2 <__vector_1+0xee>
    1abc:	82 17       	cp	r24, r18
    1abe:	93 07       	cpc	r25, r19
    1ac0:	80 f1       	brcs	.+96     	; 0x1b22 <__vector_1+0x14e>
		  gActivePixmapLine = (gActiveLine - gActiveTextLine);
		  if (gActiveTextSize == TEXT_SIZE_LARGE_MULT) {
		    gActivePixmapLine /= TEXT_SIZE_LARGE_MULT;
		  }
		}
		else if (gActiveLine == gActiveTextLastLine) {
    1ac2:	82 17       	cp	r24, r18
    1ac4:	93 07       	cpc	r25, r19
    1ac6:	09 f4       	brne	.+2      	; 0x1aca <__vector_1+0xf6>
    1ac8:	81 c0       	rjmp	.+258    	; 0x1bcc <__vector_1+0x1f8>
			gActivePixmapLine = 1;
			return;
		}
#endif //TEXT_ENABLED		
#ifdef GRAPICSENABLED		
		else if (gActiveLine >= GRAPHICS_LINE && gActiveLine < (GRAPHICS_LINE + GRAPHICS_HEIGHT)) {
    1aca:	68 56       	subi	r22, 0x68	; 104
    1acc:	70 40       	sbci	r23, 0x00	; 0
    1ace:	68 31       	cpi	r22, 0x18	; 24
    1ad0:	71 05       	cpc	r23, r1
    1ad2:	30 f4       	brcc	.+12     	; 0x1ae0 <__vector_1+0x10c>
			gLineType = LINE_TYPE_GRAPHICS;
    1ad4:	92 e0       	ldi	r25, 0x02	; 2
    1ad6:	90 93 42 04 	sts	0x0442, r25
			gActivePixmapLine = (gActiveLine - GRAPHICS_LINE);
    1ada:	89 56       	subi	r24, 0x69	; 105
    1adc:	80 93 43 04 	sts	0x0443, r24
	updateLine();
}
    1ae0:	ff 91       	pop	r31
    1ae2:	ef 91       	pop	r30
    1ae4:	bf 91       	pop	r27
    1ae6:	af 91       	pop	r26
    1ae8:	9f 91       	pop	r25
    1aea:	8f 91       	pop	r24
    1aec:	7f 91       	pop	r23
    1aee:	6f 91       	pop	r22
    1af0:	5f 91       	pop	r21
    1af2:	4f 91       	pop	r20
    1af4:	3f 91       	pop	r19
    1af6:	2f 91       	pop	r18
    1af8:	0f 90       	pop	r0
    1afa:	0f be       	out	0x3f, r0	; 63
    1afc:	0f 90       	pop	r0
    1afe:	1f 90       	pop	r1
    1b00:	18 95       	reti
		}
#endif //GRAPICSENABLED
	}
	else { // V sync
		if(gActiveLine > 200) {
    1b02:	80 91 40 04 	lds	r24, 0x0440
    1b06:	90 91 41 04 	lds	r25, 0x0441
    1b0a:	89 3c       	cpi	r24, 0xC9	; 201
    1b0c:	91 05       	cpc	r25, r1
    1b0e:	40 f3       	brcs	.-48     	; 0x1ae0 <__vector_1+0x10c>
			gActiveLine = 0;
    1b10:	10 92 41 04 	sts	0x0441, r1
    1b14:	10 92 40 04 	sts	0x0440, r1
    1b18:	e3 cf       	rjmp	.-58     	; 0x1ae0 <__vector_1+0x10c>
		
		// We save some time in beginning of line by pre-calculating next type.
		gLineType = LINE_TYPE_UNKNOWN; // Default case
		gActiveLine++;
		if (gActiveLine == UPDATE_LINE) {
			gUpdateScreenData = 1;
    1b1a:	21 e0       	ldi	r18, 0x01	; 1
    1b1c:	20 93 72 01 	sts	0x0172, r18
    1b20:	c2 cf       	rjmp	.-124    	; 0x1aa6 <__vector_1+0xd2>
			gUpdateScreenData = 2;
		}			

#ifdef TEXT_ENABLED	
		if (gActiveLine >= gActiveTextLine && gActiveLine < gActiveTextLastLine) {
	    gLineType = LINE_TYPE_TEXT;
    1b22:	91 e0       	ldi	r25, 0x01	; 1
    1b24:	90 93 42 04 	sts	0x0442, r25
		  gActivePixmapLine = (gActiveLine - gActiveTextLine);
    1b28:	84 1b       	sub	r24, r20
    1b2a:	80 93 43 04 	sts	0x0443, r24
		  if (gActiveTextSize == TEXT_SIZE_LARGE_MULT) {
    1b2e:	90 91 6a 01 	lds	r25, 0x016A
    1b32:	92 30       	cpi	r25, 0x02	; 2
    1b34:	a9 f6       	brne	.-86     	; 0x1ae0 <__vector_1+0x10c>
		    gActivePixmapLine /= TEXT_SIZE_LARGE_MULT;
    1b36:	86 95       	lsr	r24
    1b38:	80 93 43 04 	sts	0x0443, r24
    1b3c:	d1 cf       	rjmp	.-94     	; 0x1ae0 <__vector_1+0x10c>
	if(!(PIND & LTRIG)) { // H sync
		if (gActiveLine != 0) {
			switch(gLineType) {
				case LINE_TYPE_TEXT:
#ifdef TEXT_ENABLED				
					drawTextLine(gActiveTextId);
    1b3e:	20 91 b6 01 	lds	r18, 0x01B6
    1b42:	98 e1       	ldi	r25, 0x18	; 24
    1b44:	9a 95       	dec	r25
    1b46:	f1 f7       	brne	.-4      	; 0x1b44 <__vector_1+0x170>
} */ 

static void drawTextLine(uint8_t textId)
{
	_delay_us(3);
	uint8_t currLine = gActivePixmapLine;
    1b48:	a0 91 43 04 	lds	r26, 0x0443
			//DDRB &= ~OUT1;
		}
	}
}

ISR(INT0_vect) {
    1b4c:	30 e0       	ldi	r19, 0x00	; 0
    1b4e:	81 e2       	ldi	r24, 0x21	; 33
    1b50:	90 e0       	ldi	r25, 0x00	; 0
    1b52:	28 9f       	mul	r18, r24
    1b54:	f0 01       	movw	r30, r0
    1b56:	29 9f       	mul	r18, r25
    1b58:	f0 0d       	add	r31, r0
    1b5a:	38 9f       	mul	r19, r24
    1b5c:	f0 0d       	add	r31, r0
    1b5e:	11 24       	eor	r1, r1
    1b60:	e9 54       	subi	r30, 0x49	; 73
    1b62:	fe 4f       	sbci	r31, 0xFE	; 254
    1b64:	81 e2       	ldi	r24, 0x21	; 33
    1b66:	a8 9f       	mul	r26, r24
    1b68:	d0 01       	movw	r26, r0
    1b6a:	11 24       	eor	r1, r1
    1b6c:	a9 53       	subi	r26, 0x39	; 57
    1b6e:	bd 4f       	sbci	r27, 0xFD	; 253
	for (uint8_t i = 0; i < TEXT_LINE_MAX_CHARS; ++i) {
    1b70:	80 e0       	ldi	r24, 0x00	; 0
    1b72:	17 c0       	rjmp	.+46     	; 0x1ba2 <__vector_1+0x1ce>
		if (gText[textId][i] != ' ' && gText[textId][i] != 0) {
			DDRB |= OUT1;
    1b74:	21 9a       	sbi	0x04, 1	; 4
		}
		else {
			DDRB &= ~OUT1;
			DELAY_1_NOP();
		}
		SPDR = gTextPixmap[(uint16_t)(currLine)*TEXT_LINE_MAX_CHARS + i];
    1b76:	9d 91       	ld	r25, X+
    1b78:	9e bd       	out	0x2e, r25	; 46
	...
		DELAY_4_NOP();
#ifndef TEXT_SMALL_ENABLED
		DELAY_6_NOP();
		DELAY_7_NOP();
    1b9a:	00 00       	nop

static void drawTextLine(uint8_t textId)
{
	_delay_us(3);
	uint8_t currLine = gActivePixmapLine;
	for (uint8_t i = 0; i < TEXT_LINE_MAX_CHARS; ++i) {
    1b9c:	8f 5f       	subi	r24, 0xFF	; 255
    1b9e:	81 32       	cpi	r24, 0x21	; 33
    1ba0:	41 f0       	breq	.+16     	; 0x1bb2 <__vector_1+0x1de>
		if (gText[textId][i] != ' ' && gText[textId][i] != 0) {
    1ba2:	91 91       	ld	r25, Z+
    1ba4:	90 32       	cpi	r25, 0x20	; 32
    1ba6:	11 f0       	breq	.+4      	; 0x1bac <__vector_1+0x1d8>
    1ba8:	99 23       	and	r25, r25
    1baa:	21 f7       	brne	.-56     	; 0x1b74 <__vector_1+0x1a0>
			DDRB |= OUT1;
		}
		else {
			DDRB &= ~OUT1;
    1bac:	21 98       	cbi	0x04, 1	; 4
			DELAY_1_NOP();
    1bae:	00 00       	nop
    1bb0:	e2 cf       	rjmp	.-60     	; 0x1b76 <__vector_1+0x1a2>
	...
		DELAY_6_NOP();
		DELAY_7_NOP();
#endif //TEXT_SMALL_ENABLED	
	}
	DELAY_10_NOP();
	SPDR = 0x00;
    1bc6:	1e bc       	out	0x2e, r1	; 46
	DDRB &= ~OUT1;
    1bc8:	21 98       	cbi	0x04, 1	; 4
    1bca:	5b cf       	rjmp	.-330    	; 0x1a82 <__vector_1+0xae>
		  if (gActiveTextSize == TEXT_SIZE_LARGE_MULT) {
		    gActivePixmapLine /= TEXT_SIZE_LARGE_MULT;
		  }
		}
		else if (gActiveLine == gActiveTextLastLine) {
		  gUpdateScreenData = 2;
    1bcc:	82 e0       	ldi	r24, 0x02	; 2
    1bce:	80 93 72 01 	sts	0x0172, r24
			gActiveTextId = (gActiveTextId+1) % TEXT_LINES;
    1bd2:	80 91 b6 01 	lds	r24, 0x01B6
    1bd6:	90 e0       	ldi	r25, 0x00	; 0
    1bd8:	01 96       	adiw	r24, 0x01	; 1
    1bda:	66 e0       	ldi	r22, 0x06	; 6
    1bdc:	70 e0       	ldi	r23, 0x00	; 0
    1bde:	88 d0       	rcall	.+272    	; 0x1cf0 <__divmodhi4>
    1be0:	80 93 b6 01 	sts	0x01B6, r24
			gActiveTextLine = gTextLines[gActiveTextId];
    1be4:	fc 01       	movw	r30, r24
    1be6:	ee 0f       	add	r30, r30
    1be8:	ff 1f       	adc	r31, r31
    1bea:	ee 5a       	subi	r30, 0xAE	; 174
    1bec:	fe 4f       	sbci	r31, 0xFE	; 254
    1bee:	20 81       	ld	r18, Z
    1bf0:	31 81       	ldd	r19, Z+1	; 0x01
    1bf2:	30 93 d0 03 	sts	0x03D0, r19
    1bf6:	20 93 cf 03 	sts	0x03CF, r18
			gActiveTextSize = gTextLineSizes[gActiveTextId];
    1bfa:	85 59       	subi	r24, 0x95	; 149
    1bfc:	9e 4f       	sbci	r25, 0xFE	; 254
    1bfe:	fc 01       	movw	r30, r24
    1c00:	80 81       	ld	r24, Z
    1c02:	80 93 6a 01 	sts	0x016A, r24
			gActiveTextLastLine = gActiveTextLine + TEXT_CHAR_HEIGHT * gActiveTextSize;
    1c06:	90 e0       	ldi	r25, 0x00	; 0
    1c08:	88 0f       	add	r24, r24
    1c0a:	99 1f       	adc	r25, r25
    1c0c:	88 0f       	add	r24, r24
    1c0e:	99 1f       	adc	r25, r25
    1c10:	88 0f       	add	r24, r24
    1c12:	99 1f       	adc	r25, r25
    1c14:	82 0f       	add	r24, r18
    1c16:	93 1f       	adc	r25, r19
    1c18:	90 93 69 01 	sts	0x0169, r25
    1c1c:	80 93 68 01 	sts	0x0168, r24
			gActivePixmapLine = 1;
    1c20:	81 e0       	ldi	r24, 0x01	; 1
    1c22:	80 93 43 04 	sts	0x0443, r24
    1c26:	5c cf       	rjmp	.-328    	; 0x1ae0 <__vector_1+0x10c>

00001c28 <__vector_13>:
	updateLine();
}

ISR(TIMER1_OVF_vect)
{
    1c28:	1f 92       	push	r1
    1c2a:	0f 92       	push	r0
    1c2c:	0f b6       	in	r0, 0x3f	; 63
    1c2e:	0f 92       	push	r0
    1c30:	11 24       	eor	r1, r1
    1c32:	2f 93       	push	r18
    1c34:	3f 93       	push	r19
    1c36:	8f 93       	push	r24
    1c38:	9f 93       	push	r25
	static uint8_t lastLine = 0;
	if (lastLine == gActiveLine) {
    1c3a:	80 91 40 04 	lds	r24, 0x0440
    1c3e:	90 91 41 04 	lds	r25, 0x0441
    1c42:	20 91 44 04 	lds	r18, 0x0444
    1c46:	30 e0       	ldi	r19, 0x00	; 0
    1c48:	28 17       	cp	r18, r24
    1c4a:	39 07       	cpc	r19, r25
    1c4c:	21 f4       	brne	.+8      	; 0x1c56 <__vector_13+0x2e>
    PORTD ^= LED; // Toggle the LED
    1c4e:	2b b1       	in	r18, 0x0b	; 11
    1c50:	38 e0       	ldi	r19, 0x08	; 8
    1c52:	23 27       	eor	r18, r19
    1c54:	2b b9       	out	0x0b, r18	; 11
	}
	lastLine = gActiveLine;
    1c56:	80 93 44 04 	sts	0x0444, r24
}
    1c5a:	9f 91       	pop	r25
    1c5c:	8f 91       	pop	r24
    1c5e:	3f 91       	pop	r19
    1c60:	2f 91       	pop	r18
    1c62:	0f 90       	pop	r0
    1c64:	0f be       	out	0x3f, r0	; 63
    1c66:	0f 90       	pop	r0
    1c68:	1f 90       	pop	r1
    1c6a:	18 95       	reti

00001c6c <__umulhisi3>:
    1c6c:	53 9f       	mul	r21, r19
    1c6e:	c0 01       	movw	r24, r0
    1c70:	42 9f       	mul	r20, r18
    1c72:	b0 01       	movw	r22, r0
    1c74:	52 9f       	mul	r21, r18
    1c76:	70 0d       	add	r23, r0
    1c78:	81 1d       	adc	r24, r1
    1c7a:	11 24       	eor	r1, r1
    1c7c:	91 1d       	adc	r25, r1
    1c7e:	34 9f       	mul	r19, r20
    1c80:	70 0d       	add	r23, r0
    1c82:	81 1d       	adc	r24, r1
    1c84:	11 24       	eor	r1, r1
    1c86:	91 1d       	adc	r25, r1
    1c88:	08 95       	ret

00001c8a <__mulsi3>:
    1c8a:	62 9f       	mul	r22, r18
    1c8c:	d0 01       	movw	r26, r0
    1c8e:	73 9f       	mul	r23, r19
    1c90:	f0 01       	movw	r30, r0
    1c92:	82 9f       	mul	r24, r18
    1c94:	e0 0d       	add	r30, r0
    1c96:	f1 1d       	adc	r31, r1
    1c98:	64 9f       	mul	r22, r20
    1c9a:	e0 0d       	add	r30, r0
    1c9c:	f1 1d       	adc	r31, r1
    1c9e:	92 9f       	mul	r25, r18
    1ca0:	f0 0d       	add	r31, r0
    1ca2:	83 9f       	mul	r24, r19
    1ca4:	f0 0d       	add	r31, r0
    1ca6:	74 9f       	mul	r23, r20
    1ca8:	f0 0d       	add	r31, r0
    1caa:	65 9f       	mul	r22, r21
    1cac:	f0 0d       	add	r31, r0
    1cae:	99 27       	eor	r25, r25
    1cb0:	72 9f       	mul	r23, r18
    1cb2:	b0 0d       	add	r27, r0
    1cb4:	e1 1d       	adc	r30, r1
    1cb6:	f9 1f       	adc	r31, r25
    1cb8:	63 9f       	mul	r22, r19
    1cba:	b0 0d       	add	r27, r0
    1cbc:	e1 1d       	adc	r30, r1
    1cbe:	f9 1f       	adc	r31, r25
    1cc0:	bd 01       	movw	r22, r26
    1cc2:	cf 01       	movw	r24, r30
    1cc4:	11 24       	eor	r1, r1
    1cc6:	08 95       	ret

00001cc8 <__udivmodhi4>:
    1cc8:	aa 1b       	sub	r26, r26
    1cca:	bb 1b       	sub	r27, r27
    1ccc:	51 e1       	ldi	r21, 0x11	; 17
    1cce:	07 c0       	rjmp	.+14     	; 0x1cde <__udivmodhi4_ep>

00001cd0 <__udivmodhi4_loop>:
    1cd0:	aa 1f       	adc	r26, r26
    1cd2:	bb 1f       	adc	r27, r27
    1cd4:	a6 17       	cp	r26, r22
    1cd6:	b7 07       	cpc	r27, r23
    1cd8:	10 f0       	brcs	.+4      	; 0x1cde <__udivmodhi4_ep>
    1cda:	a6 1b       	sub	r26, r22
    1cdc:	b7 0b       	sbc	r27, r23

00001cde <__udivmodhi4_ep>:
    1cde:	88 1f       	adc	r24, r24
    1ce0:	99 1f       	adc	r25, r25
    1ce2:	5a 95       	dec	r21
    1ce4:	a9 f7       	brne	.-22     	; 0x1cd0 <__udivmodhi4_loop>
    1ce6:	80 95       	com	r24
    1ce8:	90 95       	com	r25
    1cea:	bc 01       	movw	r22, r24
    1cec:	cd 01       	movw	r24, r26
    1cee:	08 95       	ret

00001cf0 <__divmodhi4>:
    1cf0:	97 fb       	bst	r25, 7
    1cf2:	09 2e       	mov	r0, r25
    1cf4:	07 26       	eor	r0, r23
    1cf6:	0a d0       	rcall	.+20     	; 0x1d0c <__divmodhi4_neg1>
    1cf8:	77 fd       	sbrc	r23, 7
    1cfa:	04 d0       	rcall	.+8      	; 0x1d04 <__divmodhi4_neg2>
    1cfc:	e5 df       	rcall	.-54     	; 0x1cc8 <__udivmodhi4>
    1cfe:	06 d0       	rcall	.+12     	; 0x1d0c <__divmodhi4_neg1>
    1d00:	00 20       	and	r0, r0
    1d02:	1a f4       	brpl	.+6      	; 0x1d0a <__divmodhi4_exit>

00001d04 <__divmodhi4_neg2>:
    1d04:	70 95       	com	r23
    1d06:	61 95       	neg	r22
    1d08:	7f 4f       	sbci	r23, 0xFF	; 255

00001d0a <__divmodhi4_exit>:
    1d0a:	08 95       	ret

00001d0c <__divmodhi4_neg1>:
    1d0c:	f6 f7       	brtc	.-4      	; 0x1d0a <__divmodhi4_exit>
    1d0e:	90 95       	com	r25
    1d10:	81 95       	neg	r24
    1d12:	9f 4f       	sbci	r25, 0xFF	; 255
    1d14:	08 95       	ret

00001d16 <__udivmodsi4>:
    1d16:	a1 e2       	ldi	r26, 0x21	; 33
    1d18:	1a 2e       	mov	r1, r26
    1d1a:	aa 1b       	sub	r26, r26
    1d1c:	bb 1b       	sub	r27, r27
    1d1e:	fd 01       	movw	r30, r26
    1d20:	0d c0       	rjmp	.+26     	; 0x1d3c <__udivmodsi4_ep>

00001d22 <__udivmodsi4_loop>:
    1d22:	aa 1f       	adc	r26, r26
    1d24:	bb 1f       	adc	r27, r27
    1d26:	ee 1f       	adc	r30, r30
    1d28:	ff 1f       	adc	r31, r31
    1d2a:	a2 17       	cp	r26, r18
    1d2c:	b3 07       	cpc	r27, r19
    1d2e:	e4 07       	cpc	r30, r20
    1d30:	f5 07       	cpc	r31, r21
    1d32:	20 f0       	brcs	.+8      	; 0x1d3c <__udivmodsi4_ep>
    1d34:	a2 1b       	sub	r26, r18
    1d36:	b3 0b       	sbc	r27, r19
    1d38:	e4 0b       	sbc	r30, r20
    1d3a:	f5 0b       	sbc	r31, r21

00001d3c <__udivmodsi4_ep>:
    1d3c:	66 1f       	adc	r22, r22
    1d3e:	77 1f       	adc	r23, r23
    1d40:	88 1f       	adc	r24, r24
    1d42:	99 1f       	adc	r25, r25
    1d44:	1a 94       	dec	r1
    1d46:	69 f7       	brne	.-38     	; 0x1d22 <__udivmodsi4_loop>
    1d48:	60 95       	com	r22
    1d4a:	70 95       	com	r23
    1d4c:	80 95       	com	r24
    1d4e:	90 95       	com	r25
    1d50:	9b 01       	movw	r18, r22
    1d52:	ac 01       	movw	r20, r24
    1d54:	bd 01       	movw	r22, r26
    1d56:	cf 01       	movw	r24, r30
    1d58:	08 95       	ret

00001d5a <__divmodsi4>:
    1d5a:	97 fb       	bst	r25, 7
    1d5c:	09 2e       	mov	r0, r25
    1d5e:	05 26       	eor	r0, r21
    1d60:	0e d0       	rcall	.+28     	; 0x1d7e <__divmodsi4_neg1>
    1d62:	57 fd       	sbrc	r21, 7
    1d64:	04 d0       	rcall	.+8      	; 0x1d6e <__divmodsi4_neg2>
    1d66:	d7 df       	rcall	.-82     	; 0x1d16 <__udivmodsi4>
    1d68:	0a d0       	rcall	.+20     	; 0x1d7e <__divmodsi4_neg1>
    1d6a:	00 1c       	adc	r0, r0
    1d6c:	38 f4       	brcc	.+14     	; 0x1d7c <__divmodsi4_exit>

00001d6e <__divmodsi4_neg2>:
    1d6e:	50 95       	com	r21
    1d70:	40 95       	com	r20
    1d72:	30 95       	com	r19
    1d74:	21 95       	neg	r18
    1d76:	3f 4f       	sbci	r19, 0xFF	; 255
    1d78:	4f 4f       	sbci	r20, 0xFF	; 255
    1d7a:	5f 4f       	sbci	r21, 0xFF	; 255

00001d7c <__divmodsi4_exit>:
    1d7c:	08 95       	ret

00001d7e <__divmodsi4_neg1>:
    1d7e:	f6 f7       	brtc	.-4      	; 0x1d7c <__divmodsi4_exit>
    1d80:	90 95       	com	r25
    1d82:	80 95       	com	r24
    1d84:	70 95       	com	r23
    1d86:	61 95       	neg	r22
    1d88:	7f 4f       	sbci	r23, 0xFF	; 255
    1d8a:	8f 4f       	sbci	r24, 0xFF	; 255
    1d8c:	9f 4f       	sbci	r25, 0xFF	; 255
    1d8e:	08 95       	ret

00001d90 <strncmp>:
    1d90:	fb 01       	movw	r30, r22
    1d92:	dc 01       	movw	r26, r24
    1d94:	41 50       	subi	r20, 0x01	; 1
    1d96:	50 40       	sbci	r21, 0x00	; 0
    1d98:	30 f0       	brcs	.+12     	; 0x1da6 <strncmp+0x16>
    1d9a:	8d 91       	ld	r24, X+
    1d9c:	01 90       	ld	r0, Z+
    1d9e:	80 19       	sub	r24, r0
    1da0:	19 f4       	brne	.+6      	; 0x1da8 <strncmp+0x18>
    1da2:	00 20       	and	r0, r0
    1da4:	b9 f7       	brne	.-18     	; 0x1d94 <strncmp+0x4>
    1da6:	88 1b       	sub	r24, r24
    1da8:	99 0b       	sbc	r25, r25
    1daa:	08 95       	ret

00001dac <strncpy>:
    1dac:	fb 01       	movw	r30, r22
    1dae:	dc 01       	movw	r26, r24
    1db0:	41 50       	subi	r20, 0x01	; 1
    1db2:	50 40       	sbci	r21, 0x00	; 0
    1db4:	48 f0       	brcs	.+18     	; 0x1dc8 <strncpy+0x1c>
    1db6:	01 90       	ld	r0, Z+
    1db8:	0d 92       	st	X+, r0
    1dba:	00 20       	and	r0, r0
    1dbc:	c9 f7       	brne	.-14     	; 0x1db0 <strncpy+0x4>
    1dbe:	01 c0       	rjmp	.+2      	; 0x1dc2 <strncpy+0x16>
    1dc0:	1d 92       	st	X+, r1
    1dc2:	41 50       	subi	r20, 0x01	; 1
    1dc4:	50 40       	sbci	r21, 0x00	; 0
    1dc6:	e0 f7       	brcc	.-8      	; 0x1dc0 <strncpy+0x14>
    1dc8:	08 95       	ret

00001dca <__eerd_block_m88pa>:
    1dca:	dc 01       	movw	r26, r24
    1dcc:	cb 01       	movw	r24, r22

00001dce <__eerd_blraw_m88pa>:
    1dce:	fc 01       	movw	r30, r24
    1dd0:	f9 99       	sbic	0x1f, 1	; 31
    1dd2:	fe cf       	rjmp	.-4      	; 0x1dd0 <__eerd_blraw_m88pa+0x2>
    1dd4:	06 c0       	rjmp	.+12     	; 0x1de2 <__eerd_blraw_m88pa+0x14>
    1dd6:	f2 bd       	out	0x22, r31	; 34
    1dd8:	e1 bd       	out	0x21, r30	; 33
    1dda:	f8 9a       	sbi	0x1f, 0	; 31
    1ddc:	31 96       	adiw	r30, 0x01	; 1
    1dde:	00 b4       	in	r0, 0x20	; 32
    1de0:	0d 92       	st	X+, r0
    1de2:	41 50       	subi	r20, 0x01	; 1
    1de4:	50 40       	sbci	r21, 0x00	; 0
    1de6:	b8 f7       	brcc	.-18     	; 0x1dd6 <__eerd_blraw_m88pa+0x8>
    1de8:	08 95       	ret

00001dea <_exit>:
    1dea:	f8 94       	cli

00001dec <__stop_program>:
    1dec:	ff cf       	rjmp	.-2      	; 0x1dec <__stop_program>
