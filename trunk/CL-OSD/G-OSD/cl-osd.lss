
cl-osd.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000072  00800100  00001ff6  000020aa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001ff6  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000002db  00800172  00800172  0000211c  2**0
                  ALLOC
  3 .eeprom       00000200  00810000  00810000  0000211c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .stab         00000960  00000000  00000000  0000231c  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      000001db  00000000  00000000  00002c7c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000090  00000000  00000000  00002e57  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 0000003a  00000000  00000000  00002ee7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   00001d03  00000000  00000000  00002f21  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 0000037a  00000000  00000000  00004c24  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00001c13  00000000  00000000  00004f9e  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00000100  00000000  00000000  00006bb4  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    0000088d  00000000  00000000  00006cb4  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    0000286e  00000000  00000000  00007541  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_macinfo 0000bc2a  00000000  00000000  00009daf  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_pubtypes 0000008f  00000000  00000000  000159d9  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 000007d8  00000000  00000000  00015a68  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	47 c0       	rjmp	.+142    	; 0x90 <__ctors_end>
       2:	d7 cd       	rjmp	.-1106   	; 0xfffffbb2 <__eeprom_end+0xff7ef9b2>
       4:	60 c0       	rjmp	.+192    	; 0xc6 <__bad_interrupt>
       6:	5f c0       	rjmp	.+190    	; 0xc6 <__bad_interrupt>
       8:	5e c0       	rjmp	.+188    	; 0xc6 <__bad_interrupt>
       a:	5d c0       	rjmp	.+186    	; 0xc6 <__bad_interrupt>
       c:	5c c0       	rjmp	.+184    	; 0xc6 <__bad_interrupt>
       e:	5b c0       	rjmp	.+182    	; 0xc6 <__bad_interrupt>
      10:	5a c0       	rjmp	.+180    	; 0xc6 <__bad_interrupt>
      12:	59 c0       	rjmp	.+178    	; 0xc6 <__bad_interrupt>
      14:	58 c0       	rjmp	.+176    	; 0xc6 <__bad_interrupt>
      16:	57 c0       	rjmp	.+174    	; 0xc6 <__bad_interrupt>
      18:	56 c0       	rjmp	.+172    	; 0xc6 <__bad_interrupt>
      1a:	fe ce       	rjmp	.-516    	; 0xfffffe18 <__eeprom_end+0xff7efc18>
      1c:	54 c0       	rjmp	.+168    	; 0xc6 <__bad_interrupt>
      1e:	53 c0       	rjmp	.+166    	; 0xc6 <__bad_interrupt>
      20:	52 c0       	rjmp	.+164    	; 0xc6 <__bad_interrupt>
      22:	51 c0       	rjmp	.+162    	; 0xc6 <__bad_interrupt>
      24:	50 c0       	rjmp	.+160    	; 0xc6 <__bad_interrupt>
      26:	4f c0       	rjmp	.+158    	; 0xc6 <__bad_interrupt>
      28:	4e c0       	rjmp	.+156    	; 0xc6 <__bad_interrupt>
      2a:	4d c0       	rjmp	.+154    	; 0xc6 <__bad_interrupt>
      2c:	4c c0       	rjmp	.+152    	; 0xc6 <__bad_interrupt>
      2e:	4b c0       	rjmp	.+150    	; 0xc6 <__bad_interrupt>
      30:	4a c0       	rjmp	.+148    	; 0xc6 <__bad_interrupt>
      32:	49 c0       	rjmp	.+146    	; 0xc6 <__bad_interrupt>

00000034 <sinData>:
      34:	00 02 03 05 07 09 0a 0c 0e 10 11 13 15 16 18 1a     ................
      44:	1c 1d 1f 21 22 24 25 27 29 2a 2c 2d 2f 30 32 34     ...!"$%')*,-/024
      54:	35 36 38 39 3b 3c 3e 3f 40 42 43 44 45 47 48 49     5689;<>?@BCDEGHI
      64:	4a 4b 4d 4e 4f 50 51 52 53 54 55 56 57 57 58 59     JKMNOPQRSTUVWWXY
      74:	5a 5b 5b 5c 5d 5d 5e 5f 5f 60 60 61 61 61 62 62     Z[[\]]^__``aaabb
      84:	62 63 63 63 63 64 64 64 64 64 64 00                 bccccdddddd.

00000090 <__ctors_end>:
      90:	11 24       	eor	r1, r1
      92:	1f be       	out	0x3f, r1	; 63
      94:	cf ef       	ldi	r28, 0xFF	; 255
      96:	d4 e0       	ldi	r29, 0x04	; 4
      98:	de bf       	out	0x3e, r29	; 62
      9a:	cd bf       	out	0x3d, r28	; 61

0000009c <__do_copy_data>:
      9c:	11 e0       	ldi	r17, 0x01	; 1
      9e:	a0 e0       	ldi	r26, 0x00	; 0
      a0:	b1 e0       	ldi	r27, 0x01	; 1
      a2:	e6 ef       	ldi	r30, 0xF6	; 246
      a4:	ff e1       	ldi	r31, 0x1F	; 31
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x10>
      a8:	05 90       	lpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	a2 37       	cpi	r26, 0x72	; 114
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0xc>

000000b2 <__do_clear_bss>:
      b2:	14 e0       	ldi	r17, 0x04	; 4
      b4:	a2 e7       	ldi	r26, 0x72	; 114
      b6:	b1 e0       	ldi	r27, 0x01	; 1
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	ad 34       	cpi	r26, 0x4D	; 77
      be:	b1 07       	cpc	r27, r17
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	c0 d5       	rcall	.+2944   	; 0xc44 <main>
      c4:	96 cf       	rjmp	.-212    	; 0xfffffff2 <__eeprom_end+0xff7efdf2>

000000c6 <__bad_interrupt>:
      c6:	9c cf       	rjmp	.-200    	; 0x0 <__vectors>

000000c8 <wgs84ToSec100>:
  uint8_t checksumValid;
} TGpsData;

// Convert nmea WGS84 to seconds * 100
// wgs84 = DDMM[.]MMMM
static int32_t wgs84ToSec100(int32_t wgs84) { 
      c8:	2f 92       	push	r2
      ca:	3f 92       	push	r3
      cc:	4f 92       	push	r4
      ce:	5f 92       	push	r5
      d0:	6f 92       	push	r6
      d2:	7f 92       	push	r7
      d4:	8f 92       	push	r8
      d6:	9f 92       	push	r9
      d8:	af 92       	push	r10
      da:	bf 92       	push	r11
      dc:	cf 92       	push	r12
      de:	df 92       	push	r13
      e0:	ef 92       	push	r14
      e2:	ff 92       	push	r15
      e4:	0f 93       	push	r16
      e6:	1f 93       	push	r17
      e8:	df 93       	push	r29
      ea:	cf 93       	push	r28
      ec:	00 d0       	rcall	.+0      	; 0xee <wgs84ToSec100+0x26>
      ee:	00 d0       	rcall	.+0      	; 0xf0 <wgs84ToSec100+0x28>
      f0:	0f 92       	push	r0
      f2:	cd b7       	in	r28, 0x3d	; 61
      f4:	de b7       	in	r29, 0x3e	; 62
      f6:	7b 01       	movw	r14, r22
      f8:	8c 01       	movw	r16, r24
  int8_t mult = 1;
  
  if (wgs84 < 0) {
      fa:	97 fd       	sbrc	r25, 7
      fc:	7b c0       	rjmp	.+246    	; 0x1f4 <wgs84ToSec100+0x12c>
} TGpsData;

// Convert nmea WGS84 to seconds * 100
// wgs84 = DDMM[.]MMMM
static int32_t wgs84ToSec100(int32_t wgs84) { 
  int8_t mult = 1;
      fe:	e1 e0       	ldi	r30, 0x01	; 1
     100:	e9 83       	std	Y+1, r30	; 0x01
  if (wgs84 < 0) {
    mult = -1;
    wgs84 = -wgs84;
  }
  
  uint8_t hour = wgs84 / 1000000; //Get hour part
     102:	c8 01       	movw	r24, r16
     104:	b7 01       	movw	r22, r14
     106:	20 e4       	ldi	r18, 0x40	; 64
     108:	32 e4       	ldi	r19, 0x42	; 66
     10a:	4f e0       	ldi	r20, 0x0F	; 15
     10c:	50 e0       	ldi	r21, 0x00	; 0
     10e:	29 df       	rcall	.-430    	; 0xffffff62 <__eeprom_end+0xff7efd62>
  uint8_t min = (wgs84 - (hour * 1000000)) / 10000; //Get minute part
     110:	a2 2e       	mov	r10, r18
     112:	bb 24       	eor	r11, r11
     114:	cc 24       	eor	r12, r12
     116:	dd 24       	eor	r13, r13
  uint32_t minDecimal = wgs84 % 10000; //Get minute decimal part
     118:	80 e1       	ldi	r24, 0x10	; 16
     11a:	68 2e       	mov	r6, r24
     11c:	87 e2       	ldi	r24, 0x27	; 39
     11e:	78 2e       	mov	r7, r24
     120:	81 2c       	mov	r8, r1
     122:	91 2c       	mov	r9, r1
     124:	c8 01       	movw	r24, r16
     126:	b7 01       	movw	r22, r14
     128:	a4 01       	movw	r20, r8
     12a:	93 01       	movw	r18, r6
     12c:	1a df       	rcall	.-460    	; 0xffffff62 <__eeprom_end+0xff7efd62>
     12e:	6a 83       	std	Y+2, r22	; 0x02
     130:	7b 83       	std	Y+3, r23	; 0x03
     132:	8c 83       	std	Y+4, r24	; 0x04
     134:	9d 83       	std	Y+5, r25	; 0x05
  
  int32_t sec100 = 0;
  sec100 += hour; // Add hour part
  sec100 *= 60;
     136:	c6 01       	movw	r24, r12
     138:	b5 01       	movw	r22, r10
     13a:	2c e3       	ldi	r18, 0x3C	; 60
     13c:	30 e0       	ldi	r19, 0x00	; 0
     13e:	40 e0       	ldi	r20, 0x00	; 0
     140:	50 e0       	ldi	r21, 0x00	; 0
     142:	9b de       	rcall	.-714    	; 0xfffffe7a <__eeprom_end+0xff7efc7a>
     144:	1b 01       	movw	r2, r22
     146:	2c 01       	movw	r4, r24
    mult = -1;
    wgs84 = -wgs84;
  }
  
  uint8_t hour = wgs84 / 1000000; //Get hour part
  uint8_t min = (wgs84 - (hour * 1000000)) / 10000; //Get minute part
     148:	c6 01       	movw	r24, r12
     14a:	b5 01       	movw	r22, r10
     14c:	20 ec       	ldi	r18, 0xC0	; 192
     14e:	3d eb       	ldi	r19, 0xBD	; 189
     150:	40 ef       	ldi	r20, 0xF0	; 240
     152:	5f ef       	ldi	r21, 0xFF	; 255
     154:	92 de       	rcall	.-732    	; 0xfffffe7a <__eeprom_end+0xff7efc7a>
     156:	6e 0d       	add	r22, r14
     158:	7f 1d       	adc	r23, r15
     15a:	80 1f       	adc	r24, r16
     15c:	91 1f       	adc	r25, r17
     15e:	a4 01       	movw	r20, r8
     160:	93 01       	movw	r18, r6
     162:	ff de       	rcall	.-514    	; 0xffffff62 <__eeprom_end+0xff7efd62>
  uint32_t minDecimal = wgs84 % 10000; //Get minute decimal part
  
  int32_t sec100 = 0;
  sec100 += hour; // Add hour part
  sec100 *= 60;
  sec100 += min; // Add minute part
     164:	22 0e       	add	r2, r18
     166:	31 1c       	adc	r3, r1
     168:	41 1c       	adc	r4, r1
     16a:	51 1c       	adc	r5, r1
  sec100 *= 60;
  sec100 *= 100;
  minDecimal *= 60;
     16c:	6a 81       	ldd	r22, Y+2	; 0x02
     16e:	7b 81       	ldd	r23, Y+3	; 0x03
     170:	8c 81       	ldd	r24, Y+4	; 0x04
     172:	9d 81       	ldd	r25, Y+5	; 0x05
     174:	2c e3       	ldi	r18, 0x3C	; 60
     176:	30 e0       	ldi	r19, 0x00	; 0
     178:	40 e0       	ldi	r20, 0x00	; 0
     17a:	50 e0       	ldi	r21, 0x00	; 0
     17c:	7e de       	rcall	.-772    	; 0xfffffe7a <__eeprom_end+0xff7efc7a>
     17e:	5b 01       	movw	r10, r22
     180:	6c 01       	movw	r12, r24
  int32_t sec100 = 0;
  sec100 += hour; // Add hour part
  sec100 *= 60;
  sec100 += min; // Add minute part
  sec100 *= 60;
  sec100 *= 100;
     182:	c2 01       	movw	r24, r4
     184:	b1 01       	movw	r22, r2
     186:	20 e7       	ldi	r18, 0x70	; 112
     188:	37 e1       	ldi	r19, 0x17	; 23
     18a:	40 e0       	ldi	r20, 0x00	; 0
     18c:	50 e0       	ldi	r21, 0x00	; 0
     18e:	75 de       	rcall	.-790    	; 0xfffffe7a <__eeprom_end+0xff7efc7a>
     190:	7b 01       	movw	r14, r22
     192:	8c 01       	movw	r16, r24
  minDecimal *= 60;
  minDecimal /= 100;
     194:	c6 01       	movw	r24, r12
     196:	b5 01       	movw	r22, r10
     198:	24 e6       	ldi	r18, 0x64	; 100
     19a:	30 e0       	ldi	r19, 0x00	; 0
     19c:	40 e0       	ldi	r20, 0x00	; 0
     19e:	50 e0       	ldi	r21, 0x00	; 0
     1a0:	be de       	rcall	.-644    	; 0xffffff1e <__eeprom_end+0xff7efd1e>
  sec100 += minDecimal; // Add minute decimal part
     1a2:	e2 0e       	add	r14, r18
     1a4:	f3 1e       	adc	r15, r19
     1a6:	04 1f       	adc	r16, r20
     1a8:	15 1f       	adc	r17, r21
  
  if (mult == -1) {
     1aa:	f9 81       	ldd	r31, Y+1	; 0x01
     1ac:	ff 3f       	cpi	r31, 0xFF	; 255
     1ae:	41 f4       	brne	.+16     	; 0x1c0 <wgs84ToSec100+0xf8>
    return -sec100;
     1b0:	10 95       	com	r17
     1b2:	00 95       	com	r16
     1b4:	f0 94       	com	r15
     1b6:	e0 94       	com	r14
     1b8:	e1 1c       	adc	r14, r1
     1ba:	f1 1c       	adc	r15, r1
     1bc:	01 1d       	adc	r16, r1
     1be:	11 1d       	adc	r17, r1
  } else {
    return sec100;
  }
}
     1c0:	c8 01       	movw	r24, r16
     1c2:	b7 01       	movw	r22, r14
     1c4:	0f 90       	pop	r0
     1c6:	0f 90       	pop	r0
     1c8:	0f 90       	pop	r0
     1ca:	0f 90       	pop	r0
     1cc:	0f 90       	pop	r0
     1ce:	cf 91       	pop	r28
     1d0:	df 91       	pop	r29
     1d2:	1f 91       	pop	r17
     1d4:	0f 91       	pop	r16
     1d6:	ff 90       	pop	r15
     1d8:	ef 90       	pop	r14
     1da:	df 90       	pop	r13
     1dc:	cf 90       	pop	r12
     1de:	bf 90       	pop	r11
     1e0:	af 90       	pop	r10
     1e2:	9f 90       	pop	r9
     1e4:	8f 90       	pop	r8
     1e6:	7f 90       	pop	r7
     1e8:	6f 90       	pop	r6
     1ea:	5f 90       	pop	r5
     1ec:	4f 90       	pop	r4
     1ee:	3f 90       	pop	r3
     1f0:	2f 90       	pop	r2
     1f2:	08 95       	ret
static int32_t wgs84ToSec100(int32_t wgs84) { 
  int8_t mult = 1;
  
  if (wgs84 < 0) {
    mult = -1;
    wgs84 = -wgs84;
     1f4:	10 95       	com	r17
     1f6:	00 95       	com	r16
     1f8:	f0 94       	com	r15
     1fa:	e0 94       	com	r14
     1fc:	e1 1c       	adc	r14, r1
     1fe:	f1 1c       	adc	r15, r1
     200:	01 1d       	adc	r16, r1
     202:	11 1d       	adc	r17, r1
// wgs84 = DDMM[.]MMMM
static int32_t wgs84ToSec100(int32_t wgs84) { 
  int8_t mult = 1;
  
  if (wgs84 < 0) {
    mult = -1;
     204:	8f ef       	ldi	r24, 0xFF	; 255
     206:	89 83       	std	Y+1, r24	; 0x01
     208:	7c cf       	rjmp	.-264    	; 0x102 <wgs84ToSec100+0x3a>

0000020a <printNumber>:
	}
	strncpy(&str[pos], str2, length);
	return length+pos;
}

static uint8_t printNumber(char* const str, uint8_t pos, int32_t number) {
     20a:	4f 92       	push	r4
     20c:	5f 92       	push	r5
     20e:	6f 92       	push	r6
     210:	7f 92       	push	r7
     212:	8f 92       	push	r8
     214:	9f 92       	push	r9
     216:	af 92       	push	r10
     218:	bf 92       	push	r11
     21a:	cf 92       	push	r12
     21c:	df 92       	push	r13
     21e:	ef 92       	push	r14
     220:	ff 92       	push	r15
     222:	0f 93       	push	r16
     224:	1f 93       	push	r17
     226:	df 93       	push	r29
     228:	cf 93       	push	r28
     22a:	0f 92       	push	r0
     22c:	cd b7       	in	r28, 0x3d	; 61
     22e:	de b7       	in	r29, 0x3e	; 62
     230:	2c 01       	movw	r4, r24
     232:	c6 2e       	mov	r12, r22
     234:	79 01       	movw	r14, r18
     236:	8a 01       	movw	r16, r20
#ifndef COMMONUTILS_H_
#define COMMONUTILS_H_

// abs seems to only support 16 bits so I had to make my own.
static uint32_t absi32(int32_t a) {
	return (a > 0) ? a : -a;
     238:	17 fd       	sbrc	r17, 7
     23a:	7a c0       	rjmp	.+244    	; 0x330 <printNumber+0x126>
	uint8_t length = 1;
	int32_t tmp = absi32(number);
	while (tmp > 9) {
     23c:	2a 30       	cpi	r18, 0x0A	; 10
     23e:	31 05       	cpc	r19, r1
     240:	41 05       	cpc	r20, r1
     242:	51 05       	cpc	r21, r1
     244:	0c f4       	brge	.+2      	; 0x248 <printNumber+0x3e>
     246:	91 c0       	rjmp	.+290    	; 0x36a <printNumber+0x160>
     248:	dd 24       	eor	r13, r13
     24a:	d3 94       	inc	r13
		tmp /= 10;
     24c:	6a e0       	ldi	r22, 0x0A	; 10
     24e:	86 2e       	mov	r8, r22
     250:	91 2c       	mov	r9, r1
     252:	a1 2c       	mov	r10, r1
     254:	b1 2c       	mov	r11, r1
     256:	ca 01       	movw	r24, r20
     258:	b9 01       	movw	r22, r18
     25a:	a5 01       	movw	r20, r10
     25c:	94 01       	movw	r18, r8
     25e:	81 de       	rcall	.-766    	; 0xffffff62 <__eeprom_end+0xff7efd62>
		++length;
     260:	d3 94       	inc	r13
}

static uint8_t printNumber(char* const str, uint8_t pos, int32_t number) {
	uint8_t length = 1;
	int32_t tmp = absi32(number);
	while (tmp > 9) {
     262:	2a 30       	cpi	r18, 0x0A	; 10
     264:	31 05       	cpc	r19, r1
     266:	41 05       	cpc	r20, r1
     268:	51 05       	cpc	r21, r1
     26a:	ac f7       	brge	.-22     	; 0x256 <printNumber+0x4c>
		tmp /= 10;
		++length;
	}
	if (number < 0) {
     26c:	17 fd       	sbrc	r17, 7
     26e:	5e c0       	rjmp	.+188    	; 0x32c <printNumber+0x122>
		++length;
	}
	if (pos + length >= TEXT_LINE_MAX_CHARS) {
     270:	8c 2d       	mov	r24, r12
     272:	90 e0       	ldi	r25, 0x00	; 0
     274:	9c 01       	movw	r18, r24
     276:	2d 0d       	add	r18, r13
     278:	31 1d       	adc	r19, r1
     27a:	21 32       	cpi	r18, 0x21	; 33
     27c:	31 05       	cpc	r19, r1
     27e:	0c f0       	brlt	.+2      	; 0x282 <printNumber+0x78>
     280:	53 c0       	rjmp	.+166    	; 0x328 <printNumber+0x11e>
    return TEXT_LINE_MAX_CHARS;
	}
	myItoa(number, &str[pos]);
     282:	48 0e       	add	r4, r24
     284:	59 1e       	adc	r5, r25
static void myItoa(int32_t n, char s[])
{
  int8_t i;
  int8_t sign = 0;
 
  if (n < 0) {  
     286:	17 fd       	sbrc	r17, 7
     288:	5b c0       	rjmp	.+182    	; 0x340 <printNumber+0x136>
}

static void myItoa(int32_t n, char s[])
{
  int8_t i;
  int8_t sign = 0;
     28a:	19 82       	std	Y+1, r1	; 0x01
 
  if (n < 0) {  
	  sign = -1; /* record sign */
     28c:	52 01       	movw	r10, r4
    n = -n;          /* make n positive */
  }	
  i = 0;
  do {       /* generate digits in reverse order */
    s[i++] = n % 10 + '0';   /* get next digit */
     28e:	9a e0       	ldi	r25, 0x0A	; 10
     290:	69 2e       	mov	r6, r25
     292:	71 2c       	mov	r7, r1
     294:	81 2c       	mov	r8, r1
     296:	91 2c       	mov	r9, r1
     298:	c8 01       	movw	r24, r16
     29a:	b7 01       	movw	r22, r14
     29c:	a4 01       	movw	r20, r8
     29e:	93 01       	movw	r18, r6
     2a0:	60 de       	rcall	.-832    	; 0xffffff62 <__eeprom_end+0xff7efd62>
     2a2:	60 5d       	subi	r22, 0xD0	; 208
     2a4:	f5 01       	movw	r30, r10
     2a6:	61 93       	st	Z+, r22
     2a8:	5f 01       	movw	r10, r30
	}
	strncpy(&str[pos], str2, length);
	return length+pos;
}

static uint8_t printNumber(char* const str, uint8_t pos, int32_t number) {
     2aa:	8e 2f       	mov	r24, r30
     2ac:	84 19       	sub	r24, r4
  } while ((n /= 10) > 0);     /* delete it */
     2ae:	79 01       	movw	r14, r18
     2b0:	8a 01       	movw	r16, r20
     2b2:	12 16       	cp	r1, r18
     2b4:	13 06       	cpc	r1, r19
     2b6:	14 06       	cpc	r1, r20
     2b8:	15 06       	cpc	r1, r21
     2ba:	74 f3       	brlt	.-36     	; 0x298 <printNumber+0x8e>
  if (sign < 0) {
     2bc:	f9 81       	ldd	r31, Y+1	; 0x01
     2be:	ff 3f       	cpi	r31, 0xFF	; 255
     2c0:	09 f4       	brne	.+2      	; 0x2c4 <printNumber+0xba>
     2c2:	49 c0       	rjmp	.+146    	; 0x356 <printNumber+0x14c>
    s[i++] = '-';
  }	
  s[i] = '\0';
     2c4:	e8 2f       	mov	r30, r24
     2c6:	ff 27       	eor	r31, r31
     2c8:	e7 fd       	sbrc	r30, 7
     2ca:	f0 95       	com	r31
     2cc:	e4 0d       	add	r30, r4
     2ce:	f5 1d       	adc	r31, r5
     2d0:	10 82       	st	Z, r1
}

static void myReverse(char s[], uint8_t size) {
  uint8_t i;
  char c;
  size -= 1;
     2d2:	81 50       	subi	r24, 0x01	; 1
  for (i = 0; i <= size/2; i++) {
     2d4:	68 2f       	mov	r22, r24
     2d6:	66 95       	lsr	r22
     2d8:	28 2f       	mov	r18, r24
     2da:	30 e0       	ldi	r19, 0x00	; 0
     2dc:	40 e0       	ldi	r20, 0x00	; 0
    c = s[i];
     2de:	84 2f       	mov	r24, r20
     2e0:	90 e0       	ldi	r25, 0x00	; 0
     2e2:	d2 01       	movw	r26, r4
     2e4:	a8 0f       	add	r26, r24
     2e6:	b9 1f       	adc	r27, r25
     2e8:	5c 91       	ld	r21, X
    s[i] = s[size - i];
     2ea:	f9 01       	movw	r30, r18
     2ec:	e8 1b       	sub	r30, r24
     2ee:	f9 0b       	sbc	r31, r25
     2f0:	e4 0d       	add	r30, r4
     2f2:	f5 1d       	adc	r31, r5
     2f4:	80 81       	ld	r24, Z
     2f6:	8c 93       	st	X, r24
    s[size - i] = c;
     2f8:	50 83       	st	Z, r21

static void myReverse(char s[], uint8_t size) {
  uint8_t i;
  char c;
  size -= 1;
  for (i = 0; i <= size/2; i++) {
     2fa:	4f 5f       	subi	r20, 0xFF	; 255
     2fc:	64 17       	cp	r22, r20
     2fe:	78 f7       	brcc	.-34     	; 0x2de <printNumber+0xd4>
	}
	if (pos + length >= TEXT_LINE_MAX_CHARS) {
    return TEXT_LINE_MAX_CHARS;
	}
	myItoa(number, &str[pos]);
	return pos+length;
     300:	8d 2d       	mov	r24, r13
     302:	8c 0d       	add	r24, r12
}
     304:	0f 90       	pop	r0
     306:	cf 91       	pop	r28
     308:	df 91       	pop	r29
     30a:	1f 91       	pop	r17
     30c:	0f 91       	pop	r16
     30e:	ff 90       	pop	r15
     310:	ef 90       	pop	r14
     312:	df 90       	pop	r13
     314:	cf 90       	pop	r12
     316:	bf 90       	pop	r11
     318:	af 90       	pop	r10
     31a:	9f 90       	pop	r9
     31c:	8f 90       	pop	r8
     31e:	7f 90       	pop	r7
     320:	6f 90       	pop	r6
     322:	5f 90       	pop	r5
     324:	4f 90       	pop	r4
     326:	08 95       	ret
	}
	if (number < 0) {
		++length;
	}
	if (pos + length >= TEXT_LINE_MAX_CHARS) {
    return TEXT_LINE_MAX_CHARS;
     328:	81 e2       	ldi	r24, 0x21	; 33
     32a:	ec cf       	rjmp	.-40     	; 0x304 <printNumber+0xfa>
	while (tmp > 9) {
		tmp /= 10;
		++length;
	}
	if (number < 0) {
		++length;
     32c:	d3 94       	inc	r13
     32e:	a0 cf       	rjmp	.-192    	; 0x270 <printNumber+0x66>
#ifndef COMMONUTILS_H_
#define COMMONUTILS_H_

// abs seems to only support 16 bits so I had to make my own.
static uint32_t absi32(int32_t a) {
	return (a > 0) ? a : -a;
     330:	22 27       	eor	r18, r18
     332:	33 27       	eor	r19, r19
     334:	a9 01       	movw	r20, r18
     336:	2e 19       	sub	r18, r14
     338:	3f 09       	sbc	r19, r15
     33a:	40 0b       	sbc	r20, r16
     33c:	51 0b       	sbc	r21, r17
     33e:	7e cf       	rjmp	.-260    	; 0x23c <printNumber+0x32>
  int8_t i;
  int8_t sign = 0;
 
  if (n < 0) {  
	  sign = -1; /* record sign */
    n = -n;          /* make n positive */
     340:	10 95       	com	r17
     342:	00 95       	com	r16
     344:	f0 94       	com	r15
     346:	e0 94       	com	r14
     348:	e1 1c       	adc	r14, r1
     34a:	f1 1c       	adc	r15, r1
     34c:	01 1d       	adc	r16, r1
     34e:	11 1d       	adc	r17, r1
{
  int8_t i;
  int8_t sign = 0;
 
  if (n < 0) {  
	  sign = -1; /* record sign */
     350:	6f ef       	ldi	r22, 0xFF	; 255
     352:	69 83       	std	Y+1, r22	; 0x01
     354:	9b cf       	rjmp	.-202    	; 0x28c <printNumber+0x82>
  i = 0;
  do {       /* generate digits in reverse order */
    s[i++] = n % 10 + '0';   /* get next digit */
  } while ((n /= 10) > 0);     /* delete it */
  if (sign < 0) {
    s[i++] = '-';
     356:	e8 2f       	mov	r30, r24
     358:	ff 27       	eor	r31, r31
     35a:	e7 fd       	sbrc	r30, 7
     35c:	f0 95       	com	r31
     35e:	e4 0d       	add	r30, r4
     360:	f5 1d       	adc	r31, r5
     362:	9d e2       	ldi	r25, 0x2D	; 45
     364:	90 83       	st	Z, r25
     366:	8f 5f       	subi	r24, 0xFF	; 255
     368:	ad cf       	rjmp	.-166    	; 0x2c4 <printNumber+0xba>
	strncpy(&str[pos], str2, length);
	return length+pos;
}

static uint8_t printNumber(char* const str, uint8_t pos, int32_t number) {
	uint8_t length = 1;
     36a:	dd 24       	eor	r13, r13
     36c:	d3 94       	inc	r13
     36e:	7e cf       	rjmp	.-260    	; 0x26c <printNumber+0x62>

00000370 <printText>:
      gTextPixmap[j + (i*TEXT_LINE_MAX_CHARS)] = gTextLastCharBuffer[i];
	  }		  
	}
}

static uint8_t printText(char* const str, uint8_t pos, const char* const str2) {
     370:	0f 93       	push	r16
     372:	1f 93       	push	r17
     374:	9c 01       	movw	r18, r24
     376:	16 2f       	mov	r17, r22
     378:	fa 01       	movw	r30, r20
	uint8_t length = strlen(str2);
     37a:	da 01       	movw	r26, r20
     37c:	0d 90       	ld	r0, X+
     37e:	00 20       	and	r0, r0
     380:	e9 f7       	brne	.-6      	; 0x37c <printText+0xc>
     382:	11 97       	sbiw	r26, 0x01	; 1
     384:	0a 2f       	mov	r16, r26
     386:	04 1b       	sub	r16, r20
	if (pos + length >= TEXT_LINE_MAX_CHARS) {
     388:	40 2f       	mov	r20, r16
     38a:	50 e0       	ldi	r21, 0x00	; 0
     38c:	86 2f       	mov	r24, r22
     38e:	90 e0       	ldi	r25, 0x00	; 0
     390:	ba 01       	movw	r22, r20
     392:	68 0f       	add	r22, r24
     394:	79 1f       	adc	r23, r25
     396:	61 32       	cpi	r22, 0x21	; 33
     398:	71 05       	cpc	r23, r1
     39a:	1c f0       	brlt	.+6      	; 0x3a2 <printText+0x32>
     39c:	41 e2       	ldi	r20, 0x21	; 33
     39e:	50 e0       	ldi	r21, 0x00	; 0
    length = TEXT_LINE_MAX_CHARS;
     3a0:	01 e2       	ldi	r16, 0x21	; 33
	}
	strncpy(&str[pos], str2, length);
     3a2:	82 0f       	add	r24, r18
     3a4:	93 1f       	adc	r25, r19
     3a6:	bf 01       	movw	r22, r30
     3a8:	05 de       	rcall	.-1014   	; 0xffffffb4 <__eeprom_end+0xff7efdb4>
	return length+pos;
}
     3aa:	80 2f       	mov	r24, r16
     3ac:	81 0f       	add	r24, r17
     3ae:	1f 91       	pop	r17
     3b0:	0f 91       	pop	r16
     3b2:	08 95       	ret

000003b4 <printNumberWithUnit>:
		str[pos++] = '0';
	}
	return printNumber(str, pos, numberLow);
}

static uint8_t printNumberWithUnit(char* const str, uint8_t pos, int32_t number, const char* unit) {
     3b4:	0f 93       	push	r16
     3b6:	1f 93       	push	r17
     3b8:	cf 93       	push	r28
     3ba:	df 93       	push	r29
     3bc:	ec 01       	movw	r28, r24
	pos = printNumber(str, pos, number);
     3be:	25 df       	rcall	.-438    	; 0x20a <printNumber>
     3c0:	68 2f       	mov	r22, r24
	return printText(str, pos, unit);
     3c2:	ce 01       	movw	r24, r28
     3c4:	a8 01       	movw	r20, r16
     3c6:	d4 df       	rcall	.-88     	; 0x370 <printText>
}
     3c8:	df 91       	pop	r29
     3ca:	cf 91       	pop	r28
     3cc:	1f 91       	pop	r17
     3ce:	0f 91       	pop	r16
     3d0:	08 95       	ret

000003d2 <printGpsNumber>:
/*static uint8_t printBatterLevel(char* const str, uint8_t pos, const uint8_t adcInput) {
	uint8_t batterLevel = gSensorBatteryPercentage;
	return printNumberWithUnit(str, pos, batterLevel, "%");
}*/

static uint8_t printGpsNumber(char* const str, uint8_t pos, int32_t number, uint8_t numberLat) {
     3d2:	2f 92       	push	r2
     3d4:	3f 92       	push	r3
     3d6:	4f 92       	push	r4
     3d8:	5f 92       	push	r5
     3da:	6f 92       	push	r6
     3dc:	7f 92       	push	r7
     3de:	8f 92       	push	r8
     3e0:	9f 92       	push	r9
     3e2:	af 92       	push	r10
     3e4:	bf 92       	push	r11
     3e6:	cf 92       	push	r12
     3e8:	df 92       	push	r13
     3ea:	ef 92       	push	r14
     3ec:	ff 92       	push	r15
     3ee:	0f 93       	push	r16
     3f0:	1f 93       	push	r17
     3f2:	cf 93       	push	r28
     3f4:	df 93       	push	r29
     3f6:	ec 01       	movw	r28, r24
     3f8:	16 2f       	mov	r17, r22
	if (number == 0) {
     3fa:	21 15       	cp	r18, r1
     3fc:	31 05       	cpc	r19, r1
     3fe:	41 05       	cpc	r20, r1
     400:	51 05       	cpc	r21, r1
     402:	09 f4       	brne	.+2      	; 0x406 <printGpsNumber+0x34>
     404:	b8 c0       	rjmp	.+368    	; 0x576 <__stack+0x77>
#endif
	  return pos;
  }
  
  const char* str2;
  if (numberLat) {
     406:	00 23       	and	r16, r16
     408:	09 f0       	breq	.+2      	; 0x40c <printGpsNumber+0x3a>
     40a:	7d c0       	rjmp	.+250    	; 0x506 <__stack+0x7>
	  str2 = number > 0 ? "N" : "S";
  }
  else {
	  str2 = number > 0 ? "E" : "W";
     40c:	12 16       	cp	r1, r18
     40e:	13 06       	cpc	r1, r19
     410:	14 06       	cpc	r1, r20
     412:	15 06       	cpc	r1, r21
     414:	0c f0       	brlt	.+2      	; 0x418 <printGpsNumber+0x46>
     416:	b3 c0       	rjmp	.+358    	; 0x57e <__stack+0x7f>
     418:	e4 e0       	ldi	r30, 0x04	; 4
     41a:	2e 2e       	mov	r2, r30
     41c:	e1 e0       	ldi	r30, 0x01	; 1
     41e:	3e 2e       	mov	r3, r30
#ifndef COMMONUTILS_H_
#define COMMONUTILS_H_

// abs seems to only support 16 bits so I had to make my own.
static uint32_t absi32(int32_t a) {
	return (a > 0) ? a : -a;
     420:	69 01       	movw	r12, r18
     422:	7a 01       	movw	r14, r20
     424:	57 fd       	sbrc	r21, 7
     426:	be c0       	rjmp	.+380    	; 0x5a4 <__stack+0xa5>
  }
  
  number = absi32(number);
 
	
	uint8_t hour = number / 1000000;
     428:	c7 01       	movw	r24, r14
     42a:	b6 01       	movw	r22, r12
     42c:	20 e4       	ldi	r18, 0x40	; 64
     42e:	32 e4       	ldi	r19, 0x42	; 66
     430:	4f e0       	ldi	r20, 0x0F	; 15
     432:	50 e0       	ldi	r21, 0x00	; 0
     434:	96 dd       	rcall	.-1236   	; 0xffffff62 <__eeprom_end+0xff7efd62>
#ifdef GPS_GOOGLE_FORMAT
  uint32_t min = number - (hour * 1000000);
     436:	42 2e       	mov	r4, r18
     438:	55 24       	eor	r5, r5
     43a:	66 24       	eor	r6, r6
     43c:	77 24       	eor	r7, r7
     43e:	c3 01       	movw	r24, r6
     440:	b2 01       	movw	r22, r4
     442:	20 ec       	ldi	r18, 0xC0	; 192
     444:	3d eb       	ldi	r19, 0xBD	; 189
     446:	40 ef       	ldi	r20, 0xF0	; 240
     448:	5f ef       	ldi	r21, 0xFF	; 255
     44a:	17 dd       	rcall	.-1490   	; 0xfffffe7a <__eeprom_end+0xff7efc7a>
     44c:	6c 0d       	add	r22, r12
     44e:	7d 1d       	adc	r23, r13
     450:	8e 1d       	adc	r24, r14
     452:	9f 1d       	adc	r25, r15
  min = (min * 100)/60;
     454:	24 e6       	ldi	r18, 0x64	; 100
     456:	30 e0       	ldi	r19, 0x00	; 0
     458:	40 e0       	ldi	r20, 0x00	; 0
     45a:	50 e0       	ldi	r21, 0x00	; 0
     45c:	0e dd       	rcall	.-1508   	; 0xfffffe7a <__eeprom_end+0xff7efc7a>
     45e:	2c e3       	ldi	r18, 0x3C	; 60
     460:	30 e0       	ldi	r19, 0x00	; 0
     462:	40 e0       	ldi	r20, 0x00	; 0
     464:	50 e0       	ldi	r21, 0x00	; 0
     466:	5b dd       	rcall	.-1354   	; 0xffffff1e <__eeprom_end+0xff7efd1e>
     468:	49 01       	movw	r8, r18
     46a:	5a 01       	movw	r10, r20
  //Calibrate Google GPS Coords
  if (numberLat) {
	  min = min + FUDGE_GOOGLE_LAT;    //Local calibration of Google GPS Lat (Truglodite)
  }
  else {
	  min = min + FUDGE_GOOGLE_LON;    //Local calibration of Google GPS Long (Truglodite)
     46c:	80 e3       	ldi	r24, 0x30	; 48
     46e:	92 ee       	ldi	r25, 0xE2	; 226
     470:	af ef       	ldi	r26, 0xFF	; 255
     472:	bf ef       	ldi	r27, 0xFF	; 255
     474:	88 0e       	add	r8, r24
     476:	99 1e       	adc	r9, r25
     478:	aa 1e       	adc	r10, r26
     47a:	bb 1e       	adc	r11, r27
	uint8_t min = (number - (hour * 1000000)) / 10000; //Get minute part
  uint32_t minDecimal = number % 10000; //Get minute decimal part
#endif

#ifdef GPS_GOOGLE_FORMAT
  pos = printNumberWithUnit(str, pos, hour, ".");
     47c:	ce 01       	movw	r24, r28
     47e:	61 2f       	mov	r22, r17
     480:	a3 01       	movw	r20, r6
     482:	92 01       	movw	r18, r4
     484:	04 e1       	ldi	r16, 0x14	; 20
     486:	11 e0       	ldi	r17, 0x01	; 1
     488:	95 df       	rcall	.-214    	; 0x3b4 <printNumberWithUnit>
     48a:	18 2f       	mov	r17, r24
  if (min < 10000) { // Added with inspiration from Joern
     48c:	90 e1       	ldi	r25, 0x10	; 16
     48e:	89 16       	cp	r8, r25
     490:	97 e2       	ldi	r25, 0x27	; 39
     492:	99 06       	cpc	r9, r25
     494:	90 e0       	ldi	r25, 0x00	; 0
     496:	a9 06       	cpc	r10, r25
     498:	90 e0       	ldi	r25, 0x00	; 0
     49a:	b9 06       	cpc	r11, r25
     49c:	d8 f4       	brcc	.+54     	; 0x4d4 <printGpsNumber+0x102>
     49e:	75 01       	movw	r14, r10
     4a0:	64 01       	movw	r12, r8
	  uint32_t temp = min;
		while (temp < 10000) {
			temp *= 10;
     4a2:	c7 01       	movw	r24, r14
     4a4:	b6 01       	movw	r22, r12
     4a6:	2a e0       	ldi	r18, 0x0A	; 10
     4a8:	30 e0       	ldi	r19, 0x00	; 0
     4aa:	40 e0       	ldi	r20, 0x00	; 0
     4ac:	50 e0       	ldi	r21, 0x00	; 0
     4ae:	e5 dc       	rcall	.-1590   	; 0xfffffe7a <__eeprom_end+0xff7efc7a>
     4b0:	6b 01       	movw	r12, r22
     4b2:	7c 01       	movw	r14, r24
			pos = printNumber(str, pos, 0);
     4b4:	ce 01       	movw	r24, r28
     4b6:	61 2f       	mov	r22, r17
     4b8:	20 e0       	ldi	r18, 0x00	; 0
     4ba:	30 e0       	ldi	r19, 0x00	; 0
     4bc:	a9 01       	movw	r20, r18
     4be:	a5 de       	rcall	.-694    	; 0x20a <printNumber>
     4c0:	18 2f       	mov	r17, r24

#ifdef GPS_GOOGLE_FORMAT
  pos = printNumberWithUnit(str, pos, hour, ".");
  if (min < 10000) { // Added with inspiration from Joern
	  uint32_t temp = min;
		while (temp < 10000) {
     4c2:	a0 e1       	ldi	r26, 0x10	; 16
     4c4:	ca 16       	cp	r12, r26
     4c6:	a7 e2       	ldi	r26, 0x27	; 39
     4c8:	da 06       	cpc	r13, r26
     4ca:	a0 e0       	ldi	r26, 0x00	; 0
     4cc:	ea 06       	cpc	r14, r26
     4ce:	a0 e0       	ldi	r26, 0x00	; 0
     4d0:	fa 06       	cpc	r15, r26
     4d2:	38 f3       	brcs	.-50     	; 0x4a2 <printGpsNumber+0xd0>
			temp *= 10;
			pos = printNumber(str, pos, 0);
		}
  }
  return printNumberWithUnit(str, pos, min, str2);
     4d4:	ce 01       	movw	r24, r28
     4d6:	61 2f       	mov	r22, r17
     4d8:	a5 01       	movw	r20, r10
     4da:	94 01       	movw	r18, r8
     4dc:	81 01       	movw	r16, r2
     4de:	6a df       	rcall	.-300    	; 0x3b4 <printNumberWithUnit>
			pos = printNumber(str, pos, 0);
		}
  }
  return printNumberWithUnit(str, pos, minDecimal, str2);
#endif
}
     4e0:	df 91       	pop	r29
     4e2:	cf 91       	pop	r28
     4e4:	1f 91       	pop	r17
     4e6:	0f 91       	pop	r16
     4e8:	ff 90       	pop	r15
     4ea:	ef 90       	pop	r14
     4ec:	df 90       	pop	r13
     4ee:	cf 90       	pop	r12
     4f0:	bf 90       	pop	r11
     4f2:	af 90       	pop	r10
     4f4:	9f 90       	pop	r9
     4f6:	8f 90       	pop	r8
     4f8:	7f 90       	pop	r7
     4fa:	6f 90       	pop	r6
     4fc:	5f 90       	pop	r5
     4fe:	4f 90       	pop	r4
     500:	3f 90       	pop	r3
     502:	2f 90       	pop	r2
     504:	08 95       	ret
	  return pos;
  }
  
  const char* str2;
  if (numberLat) {
	  str2 = number > 0 ? "N" : "S";
     506:	12 16       	cp	r1, r18
     508:	13 06       	cpc	r1, r19
     50a:	14 06       	cpc	r1, r20
     50c:	15 06       	cpc	r1, r21
     50e:	e4 f5       	brge	.+120    	; 0x588 <__stack+0x89>
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	2a 2e       	mov	r2, r26
     514:	a1 e0       	ldi	r26, 0x01	; 1
     516:	3a 2e       	mov	r3, r26
     518:	69 01       	movw	r12, r18
     51a:	7a 01       	movw	r14, r20
     51c:	57 fd       	sbrc	r21, 7
     51e:	39 c0       	rjmp	.+114    	; 0x592 <__stack+0x93>
  }
  
  number = absi32(number);
 
	
	uint8_t hour = number / 1000000;
     520:	c7 01       	movw	r24, r14
     522:	b6 01       	movw	r22, r12
     524:	20 e4       	ldi	r18, 0x40	; 64
     526:	32 e4       	ldi	r19, 0x42	; 66
     528:	4f e0       	ldi	r20, 0x0F	; 15
     52a:	50 e0       	ldi	r21, 0x00	; 0
     52c:	1a dd       	rcall	.-1484   	; 0xffffff62 <__eeprom_end+0xff7efd62>
#ifdef GPS_GOOGLE_FORMAT
  uint32_t min = number - (hour * 1000000);
     52e:	42 2e       	mov	r4, r18
     530:	55 24       	eor	r5, r5
     532:	66 24       	eor	r6, r6
     534:	77 24       	eor	r7, r7
     536:	c3 01       	movw	r24, r6
     538:	b2 01       	movw	r22, r4
     53a:	20 ec       	ldi	r18, 0xC0	; 192
     53c:	3d eb       	ldi	r19, 0xBD	; 189
     53e:	40 ef       	ldi	r20, 0xF0	; 240
     540:	5f ef       	ldi	r21, 0xFF	; 255
     542:	9b dc       	rcall	.-1738   	; 0xfffffe7a <__eeprom_end+0xff7efc7a>
     544:	6c 0d       	add	r22, r12
     546:	7d 1d       	adc	r23, r13
     548:	8e 1d       	adc	r24, r14
     54a:	9f 1d       	adc	r25, r15
  min = (min * 100)/60;
     54c:	24 e6       	ldi	r18, 0x64	; 100
     54e:	30 e0       	ldi	r19, 0x00	; 0
     550:	40 e0       	ldi	r20, 0x00	; 0
     552:	50 e0       	ldi	r21, 0x00	; 0
     554:	92 dc       	rcall	.-1756   	; 0xfffffe7a <__eeprom_end+0xff7efc7a>
     556:	2c e3       	ldi	r18, 0x3C	; 60
     558:	30 e0       	ldi	r19, 0x00	; 0
     55a:	40 e0       	ldi	r20, 0x00	; 0
     55c:	50 e0       	ldi	r21, 0x00	; 0
     55e:	df dc       	rcall	.-1602   	; 0xffffff1e <__eeprom_end+0xff7efd1e>
     560:	49 01       	movw	r8, r18
     562:	5a 01       	movw	r10, r20
  //Calibrate Google GPS Coords
  if (numberLat) {
	  min = min + FUDGE_GOOGLE_LAT;    //Local calibration of Google GPS Lat (Truglodite)
     564:	83 eb       	ldi	r24, 0xB3	; 179
     566:	9b ee       	ldi	r25, 0xEB	; 235
     568:	af ef       	ldi	r26, 0xFF	; 255
     56a:	bf ef       	ldi	r27, 0xFF	; 255
     56c:	88 0e       	add	r8, r24
     56e:	99 1e       	adc	r9, r25
     570:	aa 1e       	adc	r10, r26
     572:	bb 1e       	adc	r11, r27
     574:	83 cf       	rjmp	.-250    	; 0x47c <printGpsNumber+0xaa>
}*/

static uint8_t printGpsNumber(char* const str, uint8_t pos, int32_t number, uint8_t numberLat) {
	if (number == 0) {
#ifdef GPS_GOOGLE_FORMAT
    pos = printText(str, pos, "--.-------?");
     576:	48 e0       	ldi	r20, 0x08	; 8
     578:	51 e0       	ldi	r21, 0x01	; 1
     57a:	fa de       	rcall	.-524    	; 0x370 <printText>
#else
	  pos = printText(str, pos, "--:--.----?");
#endif
	  return pos;
     57c:	b1 cf       	rjmp	.-158    	; 0x4e0 <printGpsNumber+0x10e>
  const char* str2;
  if (numberLat) {
	  str2 = number > 0 ? "N" : "S";
  }
  else {
	  str2 = number > 0 ? "E" : "W";
     57e:	76 e0       	ldi	r23, 0x06	; 6
     580:	27 2e       	mov	r2, r23
     582:	71 e0       	ldi	r23, 0x01	; 1
     584:	37 2e       	mov	r3, r23
     586:	4c cf       	rjmp	.-360    	; 0x420 <printGpsNumber+0x4e>
	  return pos;
  }
  
  const char* str2;
  if (numberLat) {
	  str2 = number > 0 ? "N" : "S";
     588:	f2 e0       	ldi	r31, 0x02	; 2
     58a:	2f 2e       	mov	r2, r31
     58c:	f1 e0       	ldi	r31, 0x01	; 1
     58e:	3f 2e       	mov	r3, r31
     590:	c3 cf       	rjmp	.-122    	; 0x518 <__stack+0x19>
     592:	f0 94       	com	r15
     594:	e0 94       	com	r14
     596:	d0 94       	com	r13
     598:	c0 94       	com	r12
     59a:	c1 1c       	adc	r12, r1
     59c:	d1 1c       	adc	r13, r1
     59e:	e1 1c       	adc	r14, r1
     5a0:	f1 1c       	adc	r15, r1
     5a2:	be cf       	rjmp	.-132    	; 0x520 <__stack+0x21>
     5a4:	f0 94       	com	r15
     5a6:	e0 94       	com	r14
     5a8:	d0 94       	com	r13
     5aa:	c0 94       	com	r12
     5ac:	c1 1c       	adc	r12, r1
     5ae:	d1 1c       	adc	r13, r1
     5b0:	e1 1c       	adc	r14, r1
     5b2:	f1 1c       	adc	r15, r1
     5b4:	39 cf       	rjmp	.-398    	; 0x428 <printGpsNumber+0x56>

000005b6 <parseInt.clone.3>:
	tmp /= 1000;
	*var = tmp;
}
#endif //IMPERIAL_SYSTEM

static int32_t parseInt(const char* const text, uint8_t maxLength) {
     5b6:	ff 92       	push	r15
     5b8:	0f 93       	push	r16
     5ba:	1f 93       	push	r17
	uint8_t i = 0;
     5bc:	ff 24       	eor	r15, r15
     5be:	f3 94       	inc	r15
     5c0:	80 91 af 03 	lds	r24, 0x03AF
     5c4:	8d 32       	cpi	r24, 0x2D	; 45
     5c6:	09 f0       	breq	.+2      	; 0x5ca <parseInt.clone.3+0x14>
     5c8:	ff 24       	eor	r15, r15
	uint8_t neg = 0;
	if (text[0] == '-') {
		++i;
		neg = 1;
	}
	while (isDigit(text[i]) && i < maxLength) {
     5ca:	ef 2d       	mov	r30, r15
     5cc:	f0 e0       	ldi	r31, 0x00	; 0
     5ce:	e1 55       	subi	r30, 0x51	; 81
     5d0:	fc 4f       	sbci	r31, 0xFC	; 252
     5d2:	00 81       	ld	r16, Z
  } while (c++ < 25);
  return nv;
}

inline uint8_t isDigit(char c) {
	if (c >= '0' && c <= '9') {
     5d4:	80 2f       	mov	r24, r16
     5d6:	80 53       	subi	r24, 0x30	; 48
     5d8:	8a 30       	cpi	r24, 0x0A	; 10
     5da:	70 f0       	brcs	.+28     	; 0x5f8 <parseInt.clone.3+0x42>
     5dc:	20 e0       	ldi	r18, 0x00	; 0
     5de:	30 e0       	ldi	r19, 0x00	; 0
     5e0:	a9 01       	movw	r20, r18
		decimal *= 10;
		decimal += (text[i]) - '0';
		++i;		
	}
	return decimal * (neg ? -1 : 1);
     5e2:	ff 20       	and	r15, r15
     5e4:	71 f5       	brne	.+92     	; 0x642 <parseInt.clone.3+0x8c>
     5e6:	61 e0       	ldi	r22, 0x01	; 1
     5e8:	70 e0       	ldi	r23, 0x00	; 0
     5ea:	80 e0       	ldi	r24, 0x00	; 0
     5ec:	90 e0       	ldi	r25, 0x00	; 0
     5ee:	45 dc       	rcall	.-1910   	; 0xfffffe7a <__eeprom_end+0xff7efc7a>
}
     5f0:	1f 91       	pop	r17
     5f2:	0f 91       	pop	r16
     5f4:	ff 90       	pop	r15
     5f6:	08 95       	ret
     5f8:	1f 2d       	mov	r17, r15
     5fa:	20 e0       	ldi	r18, 0x00	; 0
     5fc:	30 e0       	ldi	r19, 0x00	; 0
     5fe:	a9 01       	movw	r20, r18
	if (text[0] == '-') {
		++i;
		neg = 1;
	}
	while (isDigit(text[i]) && i < maxLength) {
		decimal *= 10;
     600:	ca 01       	movw	r24, r20
     602:	b9 01       	movw	r22, r18
     604:	2a e0       	ldi	r18, 0x0A	; 10
     606:	30 e0       	ldi	r19, 0x00	; 0
     608:	40 e0       	ldi	r20, 0x00	; 0
     60a:	50 e0       	ldi	r21, 0x00	; 0
     60c:	36 dc       	rcall	.-1940   	; 0xfffffe7a <__eeprom_end+0xff7efc7a>
		decimal += (text[i]) - '0';
     60e:	20 2f       	mov	r18, r16
     610:	30 e0       	ldi	r19, 0x00	; 0
     612:	20 53       	subi	r18, 0x30	; 48
     614:	30 40       	sbci	r19, 0x00	; 0
     616:	44 27       	eor	r20, r20
     618:	37 fd       	sbrc	r19, 7
     61a:	40 95       	com	r20
     61c:	54 2f       	mov	r21, r20
     61e:	26 0f       	add	r18, r22
     620:	37 1f       	adc	r19, r23
     622:	48 1f       	adc	r20, r24
     624:	59 1f       	adc	r21, r25
		++i;		
     626:	1f 5f       	subi	r17, 0xFF	; 255
	uint8_t neg = 0;
	if (text[0] == '-') {
		++i;
		neg = 1;
	}
	while (isDigit(text[i]) && i < maxLength) {
     628:	e1 2f       	mov	r30, r17
     62a:	f0 e0       	ldi	r31, 0x00	; 0
     62c:	e1 55       	subi	r30, 0x51	; 81
     62e:	fc 4f       	sbci	r31, 0xFC	; 252
     630:	00 81       	ld	r16, Z
     632:	80 2f       	mov	r24, r16
     634:	80 53       	subi	r24, 0x30	; 48
     636:	8a 30       	cpi	r24, 0x0A	; 10
     638:	a0 f6       	brcc	.-88     	; 0x5e2 <parseInt.clone.3+0x2c>
     63a:	1b 30       	cpi	r17, 0x0B	; 11
     63c:	08 f3       	brcs	.-62     	; 0x600 <parseInt.clone.3+0x4a>
		decimal *= 10;
		decimal += (text[i]) - '0';
		++i;		
	}
	return decimal * (neg ? -1 : 1);
     63e:	ff 20       	and	r15, r15
     640:	91 f2       	breq	.-92     	; 0x5e6 <parseInt.clone.3+0x30>
     642:	6f ef       	ldi	r22, 0xFF	; 255
     644:	7f ef       	ldi	r23, 0xFF	; 255
     646:	cb 01       	movw	r24, r22
     648:	18 dc       	rcall	.-2000   	; 0xfffffe7a <__eeprom_end+0xff7efc7a>
}
     64a:	1f 91       	pop	r17
     64c:	0f 91       	pop	r16
     64e:	ff 90       	pop	r15
     650:	08 95       	ret

00000652 <setPixel.clone.4>:
		}		
	}
}	

inline uint8_t validPos(uint8_t x, uint8_t y) {
	if (x >= GRAPHICS_WIDTH_REAL || y >= GRAPHICS_HEIGHT) {
     652:	88 31       	cpi	r24, 0x18	; 24
     654:	10 f4       	brcc	.+4      	; 0x65a <setPixel.clone.4+0x8>
     656:	68 31       	cpi	r22, 0x18	; 24
     658:	08 f0       	brcs	.+2      	; 0x65c <setPixel.clone.4+0xa>
     65a:	08 95       	ret
static void setPixel(uint8_t x, uint8_t y, uint8_t state) {
	if (!validPos(x, y)) {
		return;
	}
	uint8_t bitPos = 7-(x%8);
	uint8_t temp = gPixelData[x/8][y];
     65c:	48 2f       	mov	r20, r24
     65e:	46 95       	lsr	r20
     660:	46 95       	lsr	r20
     662:	46 95       	lsr	r20
     664:	50 e0       	ldi	r21, 0x00	; 0

static void setPixel(uint8_t x, uint8_t y, uint8_t state) {
	if (!validPos(x, y)) {
		return;
	}
	uint8_t bitPos = 7-(x%8);
     666:	80 95       	com	r24
     668:	87 70       	andi	r24, 0x07	; 7
	uint8_t temp = gPixelData[x/8][y];
	if (state == 0) {
		temp &= ~(1<<bitPos);
	}
	else if (state == 1) {
		temp |= (1<<bitPos);
     66a:	21 e0       	ldi	r18, 0x01	; 1
     66c:	30 e0       	ldi	r19, 0x00	; 0
     66e:	02 c0       	rjmp	.+4      	; 0x674 <setPixel.clone.4+0x22>
     670:	22 0f       	add	r18, r18
     672:	33 1f       	adc	r19, r19
     674:	8a 95       	dec	r24
     676:	e2 f7       	brpl	.-8      	; 0x670 <setPixel.clone.4+0x1e>
static void setPixel(uint8_t x, uint8_t y, uint8_t state) {
	if (!validPos(x, y)) {
		return;
	}
	uint8_t bitPos = 7-(x%8);
	uint8_t temp = gPixelData[x/8][y];
     678:	fa 01       	movw	r30, r20
     67a:	ee 0f       	add	r30, r30
     67c:	ff 1f       	adc	r31, r31
     67e:	e4 0f       	add	r30, r20
     680:	f5 1f       	adc	r31, r21
     682:	ee 0f       	add	r30, r30
     684:	ff 1f       	adc	r31, r31
     686:	ee 0f       	add	r30, r30
     688:	ff 1f       	adc	r31, r31
     68a:	ee 0f       	add	r30, r30
     68c:	ff 1f       	adc	r31, r31
     68e:	e6 0f       	add	r30, r22
     690:	f1 1d       	adc	r31, r1
     692:	e7 5b       	subi	r30, 0xB7	; 183
     694:	fc 4f       	sbci	r31, 0xFC	; 252
	if (state == 0) {
		temp &= ~(1<<bitPos);
	}
	else if (state == 1) {
		temp |= (1<<bitPos);
     696:	80 81       	ld	r24, Z
     698:	82 2b       	or	r24, r18
	}
	else {
		temp ^= (1<<bitPos);
	}
	gPixelData[x/8][y] = temp;
     69a:	80 83       	st	Z, r24
     69c:	08 95       	ret

0000069e <drawCircle.clone.2>:
}

// Credit for this one goes to wikipedia! :-)
// Some mods done by me ( name, int -> uint8 )
static void drawCircle(uint8_t x0, uint8_t y0, uint8_t radius) {
     69e:	ff 92       	push	r15
     6a0:	0f 93       	push	r16
     6a2:	1f 93       	push	r17
     6a4:	df 93       	push	r29
     6a6:	cf 93       	push	r28
     6a8:	00 d0       	rcall	.+0      	; 0x6aa <drawCircle.clone.2+0xc>
     6aa:	00 d0       	rcall	.+0      	; 0x6ac <drawCircle.clone.2+0xe>
     6ac:	0f 92       	push	r0
     6ae:	cd b7       	in	r28, 0x3d	; 61
     6b0:	de b7       	in	r29, 0x3e	; 62
     6b2:	18 2f       	mov	r17, r24
  volatile int8_t f = 1 - radius;
     6b4:	81 e0       	ldi	r24, 0x01	; 1
     6b6:	98 2f       	mov	r25, r24
     6b8:	91 1b       	sub	r25, r17
     6ba:	99 83       	std	Y+1, r25	; 0x01
  volatile int8_t ddF_x = 1;
     6bc:	8a 83       	std	Y+2, r24	; 0x02
  volatile int8_t ddF_y = -2 * radius;
     6be:	81 2f       	mov	r24, r17
     6c0:	81 95       	neg	r24
     6c2:	88 0f       	add	r24, r24
     6c4:	8b 83       	std	Y+3, r24	; 0x03
  volatile int8_t x = 0;
     6c6:	1c 82       	std	Y+4, r1	; 0x04
  volatile int8_t y = radius;
     6c8:	1d 83       	std	Y+5, r17	; 0x05
 
  setPixel(x0, y0 + radius, 1);
     6ca:	9b e0       	ldi	r25, 0x0B	; 11
     6cc:	f9 2e       	mov	r15, r25
     6ce:	f1 0e       	add	r15, r17
     6d0:	8b e0       	ldi	r24, 0x0B	; 11
     6d2:	6f 2d       	mov	r22, r15
     6d4:	be df       	rcall	.-132    	; 0x652 <setPixel.clone.4>
  setPixel(x0, y0 - radius, 1);
     6d6:	0b e0       	ldi	r16, 0x0B	; 11
     6d8:	01 1b       	sub	r16, r17
     6da:	8b e0       	ldi	r24, 0x0B	; 11
     6dc:	60 2f       	mov	r22, r16
     6de:	b9 df       	rcall	.-142    	; 0x652 <setPixel.clone.4>
  setPixel(x0 + radius, y0, 1);
     6e0:	8f 2d       	mov	r24, r15
     6e2:	6b e0       	ldi	r22, 0x0B	; 11
     6e4:	b6 df       	rcall	.-148    	; 0x652 <setPixel.clone.4>
  setPixel(x0 - radius, y0, 1);
     6e6:	80 2f       	mov	r24, r16
     6e8:	6b e0       	ldi	r22, 0x0B	; 11
     6ea:	b3 df       	rcall	.-154    	; 0x652 <setPixel.clone.4>
 
  while(x < y) {
     6ec:	9c 81       	ldd	r25, Y+4	; 0x04
     6ee:	8d 81       	ldd	r24, Y+5	; 0x05
     6f0:	98 17       	cp	r25, r24
     6f2:	0c f0       	brlt	.+2      	; 0x6f6 <drawCircle.clone.2+0x58>
     6f4:	51 c0       	rjmp	.+162    	; 0x798 <drawCircle.clone.2+0xfa>
    }
    x++;
    ddF_x += 2;
    f += ddF_x;    
    setPixel(x0 + x, y0 + y, 1);
    setPixel(x0 - x, y0 + y, 1);
     6f6:	1b e0       	ldi	r17, 0x0B	; 11
 
  while(x < y) {
    // ddF_x == 2 * x + 1;
    // ddF_y == -2 * y;
    // f == x*x + y*y - radius*radius + 2*x - y + 1;
    if(f >= 0) {
     6f8:	89 81       	ldd	r24, Y+1	; 0x01
     6fa:	87 fd       	sbrc	r24, 7
     6fc:	0a c0       	rjmp	.+20     	; 0x712 <drawCircle.clone.2+0x74>
      y--;
     6fe:	8d 81       	ldd	r24, Y+5	; 0x05
     700:	81 50       	subi	r24, 0x01	; 1
     702:	8d 83       	std	Y+5, r24	; 0x05
      ddF_y += 2;
     704:	8b 81       	ldd	r24, Y+3	; 0x03
     706:	8e 5f       	subi	r24, 0xFE	; 254
     708:	8b 83       	std	Y+3, r24	; 0x03
      f += ddF_y;
     70a:	99 81       	ldd	r25, Y+1	; 0x01
     70c:	8b 81       	ldd	r24, Y+3	; 0x03
     70e:	89 0f       	add	r24, r25
     710:	89 83       	std	Y+1, r24	; 0x01
    }
    x++;
     712:	8c 81       	ldd	r24, Y+4	; 0x04
     714:	8f 5f       	subi	r24, 0xFF	; 255
     716:	8c 83       	std	Y+4, r24	; 0x04
    ddF_x += 2;
     718:	8a 81       	ldd	r24, Y+2	; 0x02
     71a:	8e 5f       	subi	r24, 0xFE	; 254
     71c:	8a 83       	std	Y+2, r24	; 0x02
    f += ddF_x;    
     71e:	99 81       	ldd	r25, Y+1	; 0x01
     720:	8a 81       	ldd	r24, Y+2	; 0x02
     722:	89 0f       	add	r24, r25
     724:	89 83       	std	Y+1, r24	; 0x01
    setPixel(x0 + x, y0 + y, 1);
     726:	8c 81       	ldd	r24, Y+4	; 0x04
     728:	6d 81       	ldd	r22, Y+5	; 0x05
     72a:	65 5f       	subi	r22, 0xF5	; 245
     72c:	85 5f       	subi	r24, 0xF5	; 245
     72e:	91 df       	rcall	.-222    	; 0x652 <setPixel.clone.4>
    setPixel(x0 - x, y0 + y, 1);
     730:	8c 81       	ldd	r24, Y+4	; 0x04
     732:	6d 81       	ldd	r22, Y+5	; 0x05
     734:	65 5f       	subi	r22, 0xF5	; 245
     736:	91 2f       	mov	r25, r17
     738:	98 1b       	sub	r25, r24
     73a:	89 2f       	mov	r24, r25
     73c:	8a df       	rcall	.-236    	; 0x652 <setPixel.clone.4>
    setPixel(x0 + x, y0 - y, 1);
     73e:	8c 81       	ldd	r24, Y+4	; 0x04
     740:	9d 81       	ldd	r25, Y+5	; 0x05
     742:	61 2f       	mov	r22, r17
     744:	69 1b       	sub	r22, r25
     746:	85 5f       	subi	r24, 0xF5	; 245
     748:	84 df       	rcall	.-248    	; 0x652 <setPixel.clone.4>
    setPixel(x0 - x, y0 - y, 1);
     74a:	8c 81       	ldd	r24, Y+4	; 0x04
     74c:	9d 81       	ldd	r25, Y+5	; 0x05
     74e:	61 2f       	mov	r22, r17
     750:	69 1b       	sub	r22, r25
     752:	91 2f       	mov	r25, r17
     754:	98 1b       	sub	r25, r24
     756:	89 2f       	mov	r24, r25
     758:	7c df       	rcall	.-264    	; 0x652 <setPixel.clone.4>
    setPixel(x0 + y, y0 + x, 1);
     75a:	8d 81       	ldd	r24, Y+5	; 0x05
     75c:	6c 81       	ldd	r22, Y+4	; 0x04
     75e:	65 5f       	subi	r22, 0xF5	; 245
     760:	85 5f       	subi	r24, 0xF5	; 245
     762:	77 df       	rcall	.-274    	; 0x652 <setPixel.clone.4>
    setPixel(x0 - y, y0 + x, 1);
     764:	8d 81       	ldd	r24, Y+5	; 0x05
     766:	6c 81       	ldd	r22, Y+4	; 0x04
     768:	65 5f       	subi	r22, 0xF5	; 245
     76a:	91 2f       	mov	r25, r17
     76c:	98 1b       	sub	r25, r24
     76e:	89 2f       	mov	r24, r25
     770:	70 df       	rcall	.-288    	; 0x652 <setPixel.clone.4>
    setPixel(x0 + y, y0 - x, 1);
     772:	8d 81       	ldd	r24, Y+5	; 0x05
     774:	9c 81       	ldd	r25, Y+4	; 0x04
     776:	61 2f       	mov	r22, r17
     778:	69 1b       	sub	r22, r25
     77a:	85 5f       	subi	r24, 0xF5	; 245
     77c:	6a df       	rcall	.-300    	; 0x652 <setPixel.clone.4>
    setPixel(x0 - y, y0 - x, 1);
     77e:	8d 81       	ldd	r24, Y+5	; 0x05
     780:	9c 81       	ldd	r25, Y+4	; 0x04
     782:	61 2f       	mov	r22, r17
     784:	69 1b       	sub	r22, r25
     786:	91 2f       	mov	r25, r17
     788:	98 1b       	sub	r25, r24
     78a:	89 2f       	mov	r24, r25
     78c:	62 df       	rcall	.-316    	; 0x652 <setPixel.clone.4>
  setPixel(x0, y0 + radius, 1);
  setPixel(x0, y0 - radius, 1);
  setPixel(x0 + radius, y0, 1);
  setPixel(x0 - radius, y0, 1);
 
  while(x < y) {
     78e:	9c 81       	ldd	r25, Y+4	; 0x04
     790:	8d 81       	ldd	r24, Y+5	; 0x05
     792:	98 17       	cp	r25, r24
     794:	0c f4       	brge	.+2      	; 0x798 <drawCircle.clone.2+0xfa>
     796:	b0 cf       	rjmp	.-160    	; 0x6f8 <drawCircle.clone.2+0x5a>
    setPixel(x0 + y, y0 + x, 1);
    setPixel(x0 - y, y0 + x, 1);
    setPixel(x0 + y, y0 - x, 1);
    setPixel(x0 - y, y0 - x, 1);
  }
}
     798:	0f 90       	pop	r0
     79a:	0f 90       	pop	r0
     79c:	0f 90       	pop	r0
     79e:	0f 90       	pop	r0
     7a0:	0f 90       	pop	r0
     7a2:	cf 91       	pop	r28
     7a4:	df 91       	pop	r29
     7a6:	1f 91       	pop	r17
     7a8:	0f 91       	pop	r16
     7aa:	ff 90       	pop	r15
     7ac:	08 95       	ret

000007ae <drawLine>:
	uint8_t temp = *a;
	*a = *b;
	*b = temp;
}

static void drawLine(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
     7ae:	af 92       	push	r10
     7b0:	bf 92       	push	r11
     7b2:	cf 92       	push	r12
     7b4:	df 92       	push	r13
     7b6:	ef 92       	push	r14
     7b8:	ff 92       	push	r15
     7ba:	0f 93       	push	r16
     7bc:	1f 93       	push	r17
     7be:	cf 93       	push	r28
     7c0:	df 93       	push	r29
     7c2:	d4 2e       	mov	r13, r20
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
     7c4:	42 2f       	mov	r20, r18
     7c6:	50 e0       	ldi	r21, 0x00	; 0
     7c8:	e6 2e       	mov	r14, r22
     7ca:	ff 24       	eor	r15, r15
     7cc:	ed 2d       	mov	r30, r13
     7ce:	f0 e0       	ldi	r31, 0x00	; 0
     7d0:	a8 2f       	mov	r26, r24
     7d2:	b0 e0       	ldi	r27, 0x00	; 0
     7d4:	8a 01       	movw	r16, r20
     7d6:	0e 19       	sub	r16, r14
     7d8:	1f 09       	sbc	r17, r15
     7da:	17 fd       	sbrc	r17, 7
     7dc:	5f c0       	rjmp	.+190    	; 0x89c <drawLine+0xee>
     7de:	ef 01       	movw	r28, r30
     7e0:	ca 1b       	sub	r28, r26
     7e2:	db 0b       	sbc	r29, r27
     7e4:	d7 fd       	sbrc	r29, 7
     7e6:	62 c0       	rjmp	.+196    	; 0x8ac <drawLine+0xfe>
     7e8:	cc 24       	eor	r12, r12
     7ea:	c3 94       	inc	r12
     7ec:	c0 17       	cp	r28, r16
     7ee:	d1 07       	cpc	r29, r17
     7f0:	0c f4       	brge	.+2      	; 0x7f4 <drawLine+0x46>
     7f2:	3f c0       	rjmp	.+126    	; 0x872 <drawLine+0xc4>
     7f4:	cc 24       	eor	r12, r12
	if (steep) {
     7f6:	fa 01       	movw	r30, r20
     7f8:	d7 01       	movw	r26, r14
		swap(&x0, &y0);
		swap(&x1, &y1);
	}		 
	if (x0 > x1) {
     7fa:	d8 16       	cp	r13, r24
     7fc:	08 f4       	brcc	.+2      	; 0x800 <drawLine+0x52>
     7fe:	42 c0       	rjmp	.+132    	; 0x884 <drawLine+0xd6>
     800:	ad 01       	movw	r20, r26
     802:	df 01       	movw	r26, r30
     804:	fa 01       	movw	r30, r20
	int8_t deltax = x1 - x0;
	int8_t deltay = abs(y1 - y0);
	int8_t error = deltax / 2;
	int8_t ystep;
	int8_t y = y0;
	if (y0 < y1) { 
     806:	62 17       	cp	r22, r18
     808:	08 f4       	brcc	.+2      	; 0x80c <drawLine+0x5e>
     80a:	45 c0       	rjmp	.+138    	; 0x896 <drawLine+0xe8>
		ystep = 1; 
	}
	else {
		ystep = -1;
     80c:	aa 24       	eor	r10, r10
     80e:	aa 94       	dec	r10
	}		
	for (uint8_t x = x0; x <= x1; ++x) {
     810:	d8 16       	cp	r13, r24
     812:	20 f1       	brcs	.+72     	; 0x85c <drawLine+0xae>
	}		 
	if (x0 > x1) {
		swap(&x0, &x1);
		swap(&y0, &y1);
	}		 
	int8_t deltax = x1 - x0;
     814:	bd 2c       	mov	r11, r13
     816:	b8 1a       	sub	r11, r24
	int8_t deltay = abs(y1 - y0);
	int8_t error = deltax / 2;
     818:	eb 2c       	mov	r14, r11
     81a:	b7 fc       	sbrc	r11, 7
     81c:	4f c0       	rjmp	.+158    	; 0x8bc <drawLine+0x10e>
     81e:	e5 94       	asr	r14
	int8_t ystep;
	int8_t y = y0;
     820:	16 2f       	mov	r17, r22
	if (x0 > x1) {
		swap(&x0, &x1);
		swap(&y0, &y1);
	}		 
	int8_t deltax = x1 - x0;
	int8_t deltay = abs(y1 - y0);
     822:	ae 1b       	sub	r26, r30
     824:	bf 0b       	sbc	r27, r31
     826:	b7 fd       	sbrc	r27, 7
     828:	45 c0       	rjmp	.+138    	; 0x8b4 <drawLine+0x106>
     82a:	fa 2e       	mov	r15, r26
     82c:	08 2f       	mov	r16, r24
     82e:	09 c0       	rjmp	.+18     	; 0x842 <drawLine+0x94>
	else {
		ystep = -1;
	}		
	for (uint8_t x = x0; x <= x1; ++x) {
		if (steep) {
			setPixel(y, x, 1);
     830:	81 2f       	mov	r24, r17
     832:	60 2f       	mov	r22, r16
     834:	0e df       	rcall	.-484    	; 0x652 <setPixel.clone.4>
		}
		else { 
			setPixel(x, y, 1);
		}			
		error = error - deltay;
     836:	ef 18       	sub	r14, r15
		if (error < 0) {
     838:	e7 fc       	sbrc	r14, 7
     83a:	0b c0       	rjmp	.+22     	; 0x852 <drawLine+0xa4>
		ystep = 1; 
	}
	else {
		ystep = -1;
	}		
	for (uint8_t x = x0; x <= x1; ++x) {
     83c:	0f 5f       	subi	r16, 0xFF	; 255
     83e:	d0 16       	cp	r13, r16
     840:	68 f0       	brcs	.+26     	; 0x85c <drawLine+0xae>
		if (steep) {
     842:	cc 20       	and	r12, r12
     844:	a9 f7       	brne	.-22     	; 0x830 <drawLine+0x82>
			setPixel(y, x, 1);
		}
		else { 
			setPixel(x, y, 1);
     846:	80 2f       	mov	r24, r16
     848:	61 2f       	mov	r22, r17
     84a:	03 df       	rcall	.-506    	; 0x652 <setPixel.clone.4>
		}			
		error = error - deltay;
     84c:	ef 18       	sub	r14, r15
		if (error < 0) {
     84e:	e7 fe       	sbrs	r14, 7
     850:	f5 cf       	rjmp	.-22     	; 0x83c <drawLine+0x8e>
			y = y + ystep;
     852:	1a 0d       	add	r17, r10
			error = error + deltax;
     854:	eb 0c       	add	r14, r11
		ystep = 1; 
	}
	else {
		ystep = -1;
	}		
	for (uint8_t x = x0; x <= x1; ++x) {
     856:	0f 5f       	subi	r16, 0xFF	; 255
     858:	d0 16       	cp	r13, r16
     85a:	98 f7       	brcc	.-26     	; 0x842 <drawLine+0x94>
		if (error < 0) {
			y = y + ystep;
			error = error + deltax;
		}
	}				 
}
     85c:	df 91       	pop	r29
     85e:	cf 91       	pop	r28
     860:	1f 91       	pop	r17
     862:	0f 91       	pop	r16
     864:	ff 90       	pop	r15
     866:	ef 90       	pop	r14
     868:	df 90       	pop	r13
     86a:	cf 90       	pop	r12
     86c:	bf 90       	pop	r11
     86e:	af 90       	pop	r10
     870:	08 95       	ret
	*b = temp;
}

static void drawLine(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep) {
     872:	9d 2d       	mov	r25, r13
  }
}

static void swap(uint8_t* a, uint8_t* b) {
	uint8_t temp = *a;
	*a = *b;
     874:	d2 2e       	mov	r13, r18
	*b = temp;
     876:	29 2f       	mov	r18, r25
}

static void drawLine(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep) {
     878:	98 2f       	mov	r25, r24
  }
}

static void swap(uint8_t* a, uint8_t* b) {
	uint8_t temp = *a;
	*a = *b;
     87a:	86 2f       	mov	r24, r22
	*b = temp;
     87c:	69 2f       	mov	r22, r25
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep) {
		swap(&x0, &y0);
		swap(&x1, &y1);
	}		 
	if (x0 > x1) {
     87e:	d8 16       	cp	r13, r24
     880:	08 f0       	brcs	.+2      	; 0x884 <drawLine+0xd6>
     882:	be cf       	rjmp	.-132    	; 0x800 <drawLine+0x52>
     884:	96 2f       	mov	r25, r22
  }
}

static void swap(uint8_t* a, uint8_t* b) {
	uint8_t temp = *a;
	*a = *b;
     886:	62 2f       	mov	r22, r18
	*b = temp;
     888:	29 2f       	mov	r18, r25
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep) {
		swap(&x0, &y0);
		swap(&x1, &y1);
	}		 
	if (x0 > x1) {
     88a:	98 2f       	mov	r25, r24
     88c:	8d 2d       	mov	r24, r13
     88e:	d9 2e       	mov	r13, r25
	int8_t deltax = x1 - x0;
	int8_t deltay = abs(y1 - y0);
	int8_t error = deltax / 2;
	int8_t ystep;
	int8_t y = y0;
	if (y0 < y1) { 
     890:	62 17       	cp	r22, r18
     892:	08 f0       	brcs	.+2      	; 0x896 <drawLine+0xe8>
     894:	bb cf       	rjmp	.-138    	; 0x80c <drawLine+0x5e>
		ystep = 1; 
     896:	aa 24       	eor	r10, r10
     898:	a3 94       	inc	r10
     89a:	ba cf       	rjmp	.-140    	; 0x810 <drawLine+0x62>
	*a = *b;
	*b = temp;
}

static void drawLine(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
     89c:	10 95       	com	r17
     89e:	01 95       	neg	r16
     8a0:	1f 4f       	sbci	r17, 0xFF	; 255
     8a2:	ef 01       	movw	r28, r30
     8a4:	ca 1b       	sub	r28, r26
     8a6:	db 0b       	sbc	r29, r27
     8a8:	d7 ff       	sbrs	r29, 7
     8aa:	9e cf       	rjmp	.-196    	; 0x7e8 <drawLine+0x3a>
     8ac:	d0 95       	com	r29
     8ae:	c1 95       	neg	r28
     8b0:	df 4f       	sbci	r29, 0xFF	; 255
     8b2:	9a cf       	rjmp	.-204    	; 0x7e8 <drawLine+0x3a>
	if (x0 > x1) {
		swap(&x0, &x1);
		swap(&y0, &y1);
	}		 
	int8_t deltax = x1 - x0;
	int8_t deltay = abs(y1 - y0);
     8b4:	b0 95       	com	r27
     8b6:	a1 95       	neg	r26
     8b8:	bf 4f       	sbci	r27, 0xFF	; 255
     8ba:	b7 cf       	rjmp	.-146    	; 0x82a <drawLine+0x7c>
	int8_t error = deltax / 2;
     8bc:	e3 94       	inc	r14
     8be:	af cf       	rjmp	.-162    	; 0x81e <drawLine+0x70>

000008c0 <parseFloat.clone.5>:

static int32_t parseFloat(const char* const text, uint8_t maxLength) {
     8c0:	ff 92       	push	r15
     8c2:	0f 93       	push	r16
     8c4:	1f 93       	push	r17
	
	uint32_t val = 0;
	uint8_t neg = 0;
     8c6:	ff 24       	eor	r15, r15
     8c8:	f3 94       	inc	r15
     8ca:	80 91 af 03 	lds	r24, 0x03AF
     8ce:	8d 32       	cpi	r24, 0x2D	; 45
     8d0:	09 f0       	breq	.+2      	; 0x8d4 <parseFloat.clone.5+0x14>
     8d2:	ff 24       	eor	r15, r15
     8d4:	1f 2d       	mov	r17, r15
     8d6:	20 e0       	ldi	r18, 0x00	; 0
     8d8:	30 e0       	ldi	r19, 0x00	; 0
     8da:	a9 01       	movw	r20, r18
     8dc:	16 c0       	rjmp	.+44     	; 0x90a <parseFloat.clone.5+0x4a>
		++i;
		neg = 1;
	}
	for (; i < maxLength; ++i) {
		if (isDigit(text[i])) {
			val *= 10;
     8de:	ca 01       	movw	r24, r20
     8e0:	b9 01       	movw	r22, r18
     8e2:	2a e0       	ldi	r18, 0x0A	; 10
     8e4:	30 e0       	ldi	r19, 0x00	; 0
     8e6:	40 e0       	ldi	r20, 0x00	; 0
     8e8:	50 e0       	ldi	r21, 0x00	; 0
     8ea:	c7 da       	rcall	.-2674   	; 0xfffffe7a <__eeprom_end+0xff7efc7a>
			val += (text[i]) - '0';
     8ec:	20 2f       	mov	r18, r16
     8ee:	30 e0       	ldi	r19, 0x00	; 0
     8f0:	20 53       	subi	r18, 0x30	; 48
     8f2:	30 40       	sbci	r19, 0x00	; 0
     8f4:	44 27       	eor	r20, r20
     8f6:	37 fd       	sbrc	r19, 7
     8f8:	40 95       	com	r20
     8fa:	54 2f       	mov	r21, r20
     8fc:	26 0f       	add	r18, r22
     8fe:	37 1f       	adc	r19, r23
     900:	48 1f       	adc	r20, r24
     902:	59 1f       	adc	r21, r25
	uint8_t i = 0;
	if (text[0] == '-') {
		++i;
		neg = 1;
	}
	for (; i < maxLength; ++i) {
     904:	1f 5f       	subi	r17, 0xFF	; 255
     906:	1b 30       	cpi	r17, 0x0B	; 11
     908:	58 f4       	brcc	.+22     	; 0x920 <parseFloat.clone.5+0x60>
		if (isDigit(text[i])) {
     90a:	e1 2f       	mov	r30, r17
     90c:	f0 e0       	ldi	r31, 0x00	; 0
     90e:	e1 55       	subi	r30, 0x51	; 81
     910:	fc 4f       	sbci	r31, 0xFC	; 252
     912:	00 81       	ld	r16, Z
     914:	80 2f       	mov	r24, r16
     916:	80 53       	subi	r24, 0x30	; 48
     918:	8a 30       	cpi	r24, 0x0A	; 10
     91a:	08 f3       	brcs	.-62     	; 0x8de <parseFloat.clone.5+0x1e>
			val *= 10;
			val += (text[i]) - '0';
		}
		else if (text[i] != '.') {
     91c:	0e 32       	cpi	r16, 0x2E	; 46
     91e:	91 f3       	breq	.-28     	; 0x904 <parseFloat.clone.5+0x44>
			break;
		}			
	}
	return val * (neg ? -1 : 1);
     920:	ff 20       	and	r15, r15
     922:	49 f4       	brne	.+18     	; 0x936 <parseFloat.clone.5+0x76>
     924:	61 e0       	ldi	r22, 0x01	; 1
     926:	70 e0       	ldi	r23, 0x00	; 0
     928:	80 e0       	ldi	r24, 0x00	; 0
     92a:	90 e0       	ldi	r25, 0x00	; 0
     92c:	a6 da       	rcall	.-2740   	; 0xfffffe7a <__eeprom_end+0xff7efc7a>
}
     92e:	1f 91       	pop	r17
     930:	0f 91       	pop	r16
     932:	ff 90       	pop	r15
     934:	08 95       	ret
		}
		else if (text[i] != '.') {
			break;
		}			
	}
	return val * (neg ? -1 : 1);
     936:	6f ef       	ldi	r22, 0xFF	; 255
     938:	7f ef       	ldi	r23, 0xFF	; 255
     93a:	cb 01       	movw	r24, r22
     93c:	9e da       	rcall	.-2756   	; 0xfffffe7a <__eeprom_end+0xff7efc7a>
}
     93e:	1f 91       	pop	r17
     940:	0f 91       	pop	r16
     942:	ff 90       	pop	r15
     944:	08 95       	ret

00000946 <parseGpsPart>:
	gGpsTextPartLength = strlen((const char*)gGpsText);
}
#endif //GPS_PART_TEXT

static void parseGpsPart() {
	if (gGpsTextType == GPS_TYPE_NONE) {
     946:	80 91 ad 03 	lds	r24, 0x03AD
     94a:	88 23       	and	r24, r24
     94c:	71 f1       	breq	.+92     	; 0x9aa <parseGpsPart+0x64>
			gGpsTextPartStep = GPS_GPRMC_PART_OFFSET;
			//updateParts();
		}
	}
	else if (gGpsTextType != GPS_TYPE_NONE) {
		if (gGpsTextPos != 0) {
     94e:	80 91 ac 03 	lds	r24, 0x03AC
     952:	88 23       	and	r24, r24
     954:	49 f1       	breq	.+82     	; 0x9a8 <parseGpsPart+0x62>
			switch (gGpsTextPartStep) {
     956:	80 91 67 01 	lds	r24, 0x0167
     95a:	85 36       	cpi	r24, 0x65	; 101
     95c:	89 f0       	breq	.+34     	; 0x980 <parseGpsPart+0x3a>
     95e:	86 36       	cpi	r24, 0x66	; 102
     960:	08 f0       	brcs	.+2      	; 0x964 <parseGpsPart+0x1e>
     962:	42 c0       	rjmp	.+132    	; 0x9e8 <parseGpsPart+0xa2>
     964:	84 30       	cpi	r24, 0x04	; 4
     966:	09 f4       	brne	.+2      	; 0x96a <parseGpsPart+0x24>
     968:	71 c0       	rjmp	.+226    	; 0xa4c <parseGpsPart+0x106>
     96a:	85 30       	cpi	r24, 0x05	; 5
     96c:	08 f0       	brcs	.+2      	; 0x970 <parseGpsPart+0x2a>
     96e:	78 c0       	rjmp	.+240    	; 0xa60 <parseGpsPart+0x11a>
     970:	82 30       	cpi	r24, 0x02	; 2
     972:	09 f4       	brne	.+2      	; 0x976 <parseGpsPart+0x30>
     974:	45 c0       	rjmp	.+138    	; 0xa00 <parseGpsPart+0xba>
     976:	83 30       	cpi	r24, 0x03	; 3
     978:	08 f0       	brcs	.+2      	; 0x97c <parseGpsPart+0x36>
     97a:	0d c1       	rjmp	.+538    	; 0xb96 <parseGpsPart+0x250>
     97c:	81 30       	cpi	r24, 0x01	; 1
     97e:	a1 f4       	brne	.+40     	; 0x9a8 <parseGpsPart+0x62>
			case GPS_PART_GPGGA_TIME:
			case GPS_PART_GPRMC_TIME:
				gGpsLastData.gTime = parseInt(gGpsText, GPS_MAX_CHARS);
     980:	1a de       	rcall	.-972    	; 0x5b6 <parseInt.clone.3>
     982:	60 93 9d 03 	sts	0x039D, r22
     986:	70 93 9e 03 	sts	0x039E, r23
     98a:	80 93 9f 03 	sts	0x039F, r24
     98e:	90 93 a0 03 	sts	0x03A0, r25
				//updateParts();
				break;
     992:	08 95       	ret

static uint8_t parseHex(const char* const text, uint8_t maxLength) {
	uint8_t i = 0;
	uint32_t val = 0;
	while (text[i] != 0 && i < maxLength) {
     994:	80 e0       	ldi	r24, 0x00	; 0
     996:	90 e0       	ldi	r25, 0x00	; 0
     998:	dc 01       	movw	r26, r24
			  break;
			case GPS_PART_CHECKSUM:
				//updateParts();
				{
				uint8_t val = parseHex(gGpsText, GPS_MAX_CHARS);
				gGpsLastData.checksumValid = (val == gGpsChecksum);
     99a:	21 e0       	ldi	r18, 0x01	; 1
     99c:	30 91 ae 03 	lds	r19, 0x03AE
     9a0:	38 13       	cpse	r19, r24
     9a2:	20 e0       	ldi	r18, 0x00	; 0
     9a4:	20 93 ab 03 	sts	0x03AB, r18
     9a8:	08 95       	ret
}
#endif //GPS_PART_TEXT

static void parseGpsPart() {
	if (gGpsTextType == GPS_TYPE_NONE) {
		if (!strncmp((const char*)gGpsText, "GPGGA", 5)) {
     9aa:	8f ea       	ldi	r24, 0xAF	; 175
     9ac:	93 e0       	ldi	r25, 0x03	; 3
     9ae:	66 e1       	ldi	r22, 0x16	; 22
     9b0:	71 e0       	ldi	r23, 0x01	; 1
     9b2:	45 e0       	ldi	r20, 0x05	; 5
     9b4:	50 e0       	ldi	r21, 0x00	; 0
     9b6:	f0 da       	rcall	.-2592   	; 0xffffff98 <__eeprom_end+0xff7efd98>
     9b8:	00 97       	sbiw	r24, 0x00	; 0
     9ba:	81 f0       	breq	.+32     	; 0x9dc <parseGpsPart+0x96>
			gGpsTextType = GPS_TYPE_GPGGA;
			gGpsTextPartStep = GPS_PART_NONE;
			//updateParts();
		}
		else if (!strncmp((const char*)gGpsText, "GPRMC", 5)) {
     9bc:	8f ea       	ldi	r24, 0xAF	; 175
     9be:	93 e0       	ldi	r25, 0x03	; 3
     9c0:	6c e1       	ldi	r22, 0x1C	; 28
     9c2:	71 e0       	ldi	r23, 0x01	; 1
     9c4:	45 e0       	ldi	r20, 0x05	; 5
     9c6:	50 e0       	ldi	r21, 0x00	; 0
     9c8:	e7 da       	rcall	.-2610   	; 0xffffff98 <__eeprom_end+0xff7efd98>
     9ca:	00 97       	sbiw	r24, 0x00	; 0
     9cc:	69 f7       	brne	.-38     	; 0x9a8 <parseGpsPart+0x62>
			gGpsTextType = GPS_TYPE_GPRMC;
     9ce:	82 e0       	ldi	r24, 0x02	; 2
     9d0:	80 93 ad 03 	sts	0x03AD, r24
			gGpsTextPartStep = GPS_GPRMC_PART_OFFSET;
     9d4:	84 e6       	ldi	r24, 0x64	; 100
     9d6:	80 93 67 01 	sts	0x0167, r24
     9da:	08 95       	ret
#endif //GPS_PART_TEXT

static void parseGpsPart() {
	if (gGpsTextType == GPS_TYPE_NONE) {
		if (!strncmp((const char*)gGpsText, "GPGGA", 5)) {
			gGpsTextType = GPS_TYPE_GPGGA;
     9dc:	81 e0       	ldi	r24, 0x01	; 1
     9de:	80 93 ad 03 	sts	0x03AD, r24
			gGpsTextPartStep = GPS_PART_NONE;
     9e2:	10 92 67 01 	sts	0x0167, r1
     9e6:	08 95       	ret
			//updateParts();
		}
	}
	else if (gGpsTextType != GPS_TYPE_NONE) {
		if (gGpsTextPos != 0) {
			switch (gGpsTextPartStep) {
     9e8:	8a 36       	cpi	r24, 0x6A	; 106
     9ea:	a1 f0       	breq	.+40     	; 0xa14 <parseGpsPart+0xce>
     9ec:	8b 36       	cpi	r24, 0x6B	; 107
     9ee:	08 f0       	brcs	.+2      	; 0x9f2 <parseGpsPart+0xac>
     9f0:	48 c0       	rjmp	.+144    	; 0xa82 <parseGpsPart+0x13c>
     9f2:	88 36       	cpi	r24, 0x68	; 104
     9f4:	09 f4       	brne	.+2      	; 0x9f8 <parseGpsPart+0xb2>
     9f6:	cf c0       	rjmp	.+414    	; 0xb96 <parseGpsPart+0x250>
     9f8:	89 36       	cpi	r24, 0x69	; 105
     9fa:	40 f5       	brcc	.+80     	; 0xa4c <parseGpsPart+0x106>
     9fc:	87 36       	cpi	r24, 0x67	; 103
     9fe:	a1 f6       	brne	.-88     	; 0x9a8 <parseGpsPart+0x62>
				gGpsLastData.gTime = parseInt(gGpsText, GPS_MAX_CHARS);
				//updateParts();
				break;
			case GPS_PART_GPGGA_LAT:
			case GPS_PART_GPRMC_LAT:
				gGpsLastData.pos.latitude = parseFloat(gGpsText, GPS_MAX_CHARS);
     a00:	5f df       	rcall	.-322    	; 0x8c0 <parseFloat.clone.5>
     a02:	60 93 93 03 	sts	0x0393, r22
     a06:	70 93 94 03 	sts	0x0394, r23
     a0a:	80 93 95 03 	sts	0x0395, r24
     a0e:	90 93 96 03 	sts	0x0396, r25
				//updateParts();
				break;
     a12:	08 95       	ret
				gGpsLastData.pos.longitude = parseFloat(gGpsText, GPS_MAX_CHARS);
				//updateParts();
				break;
			case GPS_PART_GPGGA_LONG_UNIT:
			case GPS_PART_GPRMC_LONG_UNIT:
				if (gGpsText[0] == 'W') {
     a14:	80 91 af 03 	lds	r24, 0x03AF
     a18:	87 35       	cpi	r24, 0x57	; 87
     a1a:	31 f6       	brne	.-116    	; 0x9a8 <parseGpsPart+0x62>
					gGpsLastData.pos.longitude = -gGpsLastData.pos.longitude;
     a1c:	80 91 97 03 	lds	r24, 0x0397
     a20:	90 91 98 03 	lds	r25, 0x0398
     a24:	a0 91 99 03 	lds	r26, 0x0399
     a28:	b0 91 9a 03 	lds	r27, 0x039A
     a2c:	b0 95       	com	r27
     a2e:	a0 95       	com	r26
     a30:	90 95       	com	r25
     a32:	81 95       	neg	r24
     a34:	9f 4f       	sbci	r25, 0xFF	; 255
     a36:	af 4f       	sbci	r26, 0xFF	; 255
     a38:	bf 4f       	sbci	r27, 0xFF	; 255
     a3a:	80 93 97 03 	sts	0x0397, r24
     a3e:	90 93 98 03 	sts	0x0398, r25
     a42:	a0 93 99 03 	sts	0x0399, r26
     a46:	b0 93 9a 03 	sts	0x039A, r27
     a4a:	08 95       	ret
					gGpsLastData.pos.latitude = -gGpsLastData.pos.latitude;
				}
				break;
			case GPS_PART_GPGGA_LONG:
			case GPS_PART_GPRMC_LONG:
				gGpsLastData.pos.longitude = parseFloat(gGpsText, GPS_MAX_CHARS);
     a4c:	39 df       	rcall	.-398    	; 0x8c0 <parseFloat.clone.5>
     a4e:	60 93 97 03 	sts	0x0397, r22
     a52:	70 93 98 03 	sts	0x0398, r23
     a56:	80 93 99 03 	sts	0x0399, r24
     a5a:	90 93 9a 03 	sts	0x039A, r25
				//updateParts();
				break;
     a5e:	08 95       	ret
			//updateParts();
		}
	}
	else if (gGpsTextType != GPS_TYPE_NONE) {
		if (gGpsTextPos != 0) {
			switch (gGpsTextPartStep) {
     a60:	86 30       	cpi	r24, 0x06	; 6
     a62:	09 f4       	brne	.+2      	; 0xa66 <parseGpsPart+0x120>
     a64:	94 c0       	rjmp	.+296    	; 0xb8e <parseGpsPart+0x248>
     a66:	86 30       	cpi	r24, 0x06	; 6
     a68:	a8 f2       	brcs	.-86     	; 0xa14 <parseGpsPart+0xce>
     a6a:	87 30       	cpi	r24, 0x07	; 7
     a6c:	09 f4       	brne	.+2      	; 0xa70 <parseGpsPart+0x12a>
     a6e:	8b c0       	rjmp	.+278    	; 0xb86 <parseGpsPart+0x240>
     a70:	89 30       	cpi	r24, 0x09	; 9
     a72:	09 f0       	breq	.+2      	; 0xa76 <parseGpsPart+0x130>
     a74:	99 cf       	rjmp	.-206    	; 0x9a8 <parseGpsPart+0x62>
				break;
			case GPS_PART_GPGGA_DILUTION:
				// Horizontal dilution of position
				break;
			case GPS_PART_GPGGA_ALTITUDE:
				gGpsLastData.pos.altitude = parseInt(gGpsText, GPS_MAX_CHARS);
     a76:	9f dd       	rcall	.-1218   	; 0x5b6 <parseInt.clone.3>
     a78:	70 93 9c 03 	sts	0x039C, r23
     a7c:	60 93 9b 03 	sts	0x039B, r22
#ifdef IMPERIAL_SYSTEM
        meterToFeet(&gGpsLastData.pos.altitude);
#endif // IMPERIAL_SYSTEM
				//updateParts();
				break;
     a80:	08 95       	ret
			//updateParts();
		}
	}
	else if (gGpsTextType != GPS_TYPE_NONE) {
		if (gGpsTextPos != 0) {
			switch (gGpsTextPartStep) {
     a82:	8c 36       	cpi	r24, 0x6C	; 108
     a84:	09 f4       	brne	.+2      	; 0xa88 <parseGpsPart+0x142>
     a86:	79 c0       	rjmp	.+242    	; 0xb7a <parseGpsPart+0x234>
     a88:	8c 36       	cpi	r24, 0x6C	; 108
     a8a:	08 f4       	brcc	.+2      	; 0xa8e <parseGpsPart+0x148>
     a8c:	63 c0       	rjmp	.+198    	; 0xb54 <parseGpsPart+0x20e>
     a8e:	8d 36       	cpi	r24, 0x6D	; 109
     a90:	09 f4       	brne	.+2      	; 0xa94 <parseGpsPart+0x14e>
     a92:	56 c0       	rjmp	.+172    	; 0xb40 <parseGpsPart+0x1fa>
     a94:	88 3c       	cpi	r24, 0xC8	; 200
     a96:	09 f0       	breq	.+2      	; 0xa9a <parseGpsPart+0x154>
     a98:	87 cf       	rjmp	.-242    	; 0x9a8 <parseGpsPart+0x62>
     a9a:	20 91 af 03 	lds	r18, 0x03AF
     a9e:	22 23       	and	r18, r18
     aa0:	09 f4       	brne	.+2      	; 0xaa4 <parseGpsPart+0x15e>
     aa2:	78 cf       	rjmp	.-272    	; 0x994 <parseGpsPart+0x4e>
			case GPS_PART_GPRMC_ANGLE:
				gGpsLastData.angle = parseInt(gGpsText, GPS_MAX_CHARS); // Only use int part
				break;
			case GPS_PART_GPRMC_DATE:
			  gGpsLastData.date = parseInt(gGpsText, GPS_MAX_CHARS);
			  break;
     aa4:	e0 eb       	ldi	r30, 0xB0	; 176
     aa6:	f3 e0       	ldi	r31, 0x03	; 3
	strncpy((char*)gGpsTextPart, (char*)gGpsText, GPS_MAX_CHARS);
	gGpsTextPartLength = strlen((const char*)gGpsText);
}
#endif //GPS_PART_TEXT

static void parseGpsPart() {
     aa8:	80 e0       	ldi	r24, 0x00	; 0
     aaa:	90 e0       	ldi	r25, 0x00	; 0
     aac:	dc 01       	movw	r26, r24
     aae:	14 c0       	rjmp	.+40     	; 0xad8 <parseGpsPart+0x192>
		val *= 16;
		if (text[i] >= 'A' && text[i] <= 'F') {
			val += 10 + text[i] - 'A';
     ab0:	30 e0       	ldi	r19, 0x00	; 0
     ab2:	27 53       	subi	r18, 0x37	; 55
     ab4:	30 40       	sbci	r19, 0x00	; 0
     ab6:	44 27       	eor	r20, r20
     ab8:	37 fd       	sbrc	r19, 7
     aba:	40 95       	com	r20
     abc:	54 2f       	mov	r21, r20
     abe:	82 0f       	add	r24, r18
     ac0:	93 1f       	adc	r25, r19
     ac2:	a4 1f       	adc	r26, r20
     ac4:	b5 1f       	adc	r27, r21
}

static uint8_t parseHex(const char* const text, uint8_t maxLength) {
	uint8_t i = 0;
	uint32_t val = 0;
	while (text[i] != 0 && i < maxLength) {
     ac6:	21 91       	ld	r18, Z+
     ac8:	22 23       	and	r18, r18
     aca:	09 f4       	brne	.+2      	; 0xace <parseGpsPart+0x188>
     acc:	66 cf       	rjmp	.-308    	; 0x99a <parseGpsPart+0x54>
     ace:	33 e0       	ldi	r19, 0x03	; 3
     ad0:	eb 3b       	cpi	r30, 0xBB	; 187
     ad2:	f3 07       	cpc	r31, r19
     ad4:	09 f4       	brne	.+2      	; 0xad8 <parseGpsPart+0x192>
     ad6:	61 cf       	rjmp	.-318    	; 0x99a <parseGpsPart+0x54>
		val *= 16;
     ad8:	88 0f       	add	r24, r24
     ada:	99 1f       	adc	r25, r25
     adc:	aa 1f       	adc	r26, r26
     ade:	bb 1f       	adc	r27, r27
     ae0:	88 0f       	add	r24, r24
     ae2:	99 1f       	adc	r25, r25
     ae4:	aa 1f       	adc	r26, r26
     ae6:	bb 1f       	adc	r27, r27
     ae8:	88 0f       	add	r24, r24
     aea:	99 1f       	adc	r25, r25
     aec:	aa 1f       	adc	r26, r26
     aee:	bb 1f       	adc	r27, r27
     af0:	88 0f       	add	r24, r24
     af2:	99 1f       	adc	r25, r25
     af4:	aa 1f       	adc	r26, r26
     af6:	bb 1f       	adc	r27, r27
		if (text[i] >= 'A' && text[i] <= 'F') {
     af8:	32 2f       	mov	r19, r18
     afa:	31 54       	subi	r19, 0x41	; 65
     afc:	36 30       	cpi	r19, 0x06	; 6
     afe:	c0 f2       	brcs	.-80     	; 0xab0 <parseGpsPart+0x16a>
			val += 10 + text[i] - 'A';
		}
		else if (text[i] >= 'a' && text[i] <= 'f') {
     b00:	32 2f       	mov	r19, r18
     b02:	31 56       	subi	r19, 0x61	; 97
     b04:	36 30       	cpi	r19, 0x06	; 6
     b06:	60 f4       	brcc	.+24     	; 0xb20 <parseGpsPart+0x1da>
			val += 10 + text[i] - 'a';
     b08:	30 e0       	ldi	r19, 0x00	; 0
     b0a:	27 55       	subi	r18, 0x57	; 87
     b0c:	30 40       	sbci	r19, 0x00	; 0
     b0e:	44 27       	eor	r20, r20
     b10:	37 fd       	sbrc	r19, 7
     b12:	40 95       	com	r20
     b14:	54 2f       	mov	r21, r20
     b16:	82 0f       	add	r24, r18
     b18:	93 1f       	adc	r25, r19
     b1a:	a4 1f       	adc	r26, r20
     b1c:	b5 1f       	adc	r27, r21
     b1e:	d3 cf       	rjmp	.-90     	; 0xac6 <parseGpsPart+0x180>
		}
		else if (text[i] >= '0' && text[i] <= '9') {
     b20:	32 2f       	mov	r19, r18
     b22:	30 53       	subi	r19, 0x30	; 48
     b24:	3a 30       	cpi	r19, 0x0A	; 10
     b26:	78 f6       	brcc	.-98     	; 0xac6 <parseGpsPart+0x180>
			val += text[i] - '0';
     b28:	30 e0       	ldi	r19, 0x00	; 0
     b2a:	20 53       	subi	r18, 0x30	; 48
     b2c:	30 40       	sbci	r19, 0x00	; 0
     b2e:	44 27       	eor	r20, r20
     b30:	37 fd       	sbrc	r19, 7
     b32:	40 95       	com	r20
     b34:	54 2f       	mov	r21, r20
     b36:	82 0f       	add	r24, r18
     b38:	93 1f       	adc	r25, r19
     b3a:	a4 1f       	adc	r26, r20
     b3c:	b5 1f       	adc	r27, r21
     b3e:	c3 cf       	rjmp	.-122    	; 0xac6 <parseGpsPart+0x180>
				break;
			case GPS_PART_GPRMC_ANGLE:
				gGpsLastData.angle = parseInt(gGpsText, GPS_MAX_CHARS); // Only use int part
				break;
			case GPS_PART_GPRMC_DATE:
			  gGpsLastData.date = parseInt(gGpsText, GPS_MAX_CHARS);
     b40:	3a dd       	rcall	.-1420   	; 0x5b6 <parseInt.clone.3>
     b42:	60 93 a7 03 	sts	0x03A7, r22
     b46:	70 93 a8 03 	sts	0x03A8, r23
     b4a:	80 93 a9 03 	sts	0x03A9, r24
     b4e:	90 93 aa 03 	sts	0x03AA, r25
			  break;
     b52:	08 95       	ret
				break;
			case GPS_PART_GPGGA_GEOID_HEIGHT_UNIT:
				// Geoid unit
				break;
			case GPS_PART_GPRMC_SPEED:
				gGpsLastData.speed = parseInt(gGpsText, GPS_MAX_CHARS); // Only use int part
     b54:	30 dd       	rcall	.-1440   	; 0x5b6 <parseInt.clone.3>
#ifdef METRIC_SYSTEM
#ifndef GOSDII_GPS_SPEED_BUGFIX
				// Convert to km/h. 1 knot = 1.852 km/h = 463/250
				gGpsLastData.speed *= 463; // Might need bigger var if you go really fast! :-)
     b56:	4f ec       	ldi	r20, 0xCF	; 207
     b58:	51 e0       	ldi	r21, 0x01	; 1
     b5a:	64 9f       	mul	r22, r20
     b5c:	90 01       	movw	r18, r0
     b5e:	65 9f       	mul	r22, r21
     b60:	30 0d       	add	r19, r0
     b62:	74 9f       	mul	r23, r20
     b64:	30 0d       	add	r19, r0
     b66:	11 24       	eor	r1, r1
				gGpsLastData.speed /= 250;
     b68:	c9 01       	movw	r24, r18
     b6a:	6a ef       	ldi	r22, 0xFA	; 250
     b6c:	70 e0       	ldi	r23, 0x00	; 0
     b6e:	b0 d9       	rcall	.-3232   	; 0xfffffed0 <__eeprom_end+0xff7efcd0>
     b70:	70 93 a4 03 	sts	0x03A4, r23
     b74:	60 93 a3 03 	sts	0x03A3, r22
        knotToMph(&gGpsLastData.speed);
#else
		    kmphToMph(&gGpsLastData.speed);
#endif
#endif // METRIC_SYSTEM
				break;
     b78:	08 95       	ret
			case GPS_PART_GPRMC_ANGLE:
				gGpsLastData.angle = parseInt(gGpsText, GPS_MAX_CHARS); // Only use int part
     b7a:	1d dd       	rcall	.-1478   	; 0x5b6 <parseInt.clone.3>
     b7c:	70 93 a6 03 	sts	0x03A6, r23
     b80:	60 93 a5 03 	sts	0x03A5, r22
				break;
     b84:	08 95       	ret
				break;
			case GPS_PART_GPRMC_STATUS:
				// Status
				break;
			case GPS_PART_GPGGA_SATS:
				gGpsLastData.sats = parseInt(gGpsText, GPS_MAX_CHARS);
     b86:	17 dd       	rcall	.-1490   	; 0x5b6 <parseInt.clone.3>
     b88:	60 93 a2 03 	sts	0x03A2, r22
				//updateParts();
				break;
     b8c:	08 95       	ret
					gGpsLastData.pos.longitude = -gGpsLastData.pos.longitude;
				}
				//updateParts();
				break;
			case GPS_PART_GPGGA_FIX:
				gGpsLastData.fix = parseInt(gGpsText, GPS_MAX_CHARS);
     b8e:	13 dd       	rcall	.-1498   	; 0x5b6 <parseInt.clone.3>
     b90:	60 93 a1 03 	sts	0x03A1, r22
				//updateParts();
				break;
     b94:	08 95       	ret
				gGpsLastData.pos.latitude = parseFloat(gGpsText, GPS_MAX_CHARS);
				//updateParts();
				break;
			case GPS_PART_GPGGA_LAT_UNIT:
			case GPS_PART_GPRMC_LAT_UNIT:
				if (gGpsText[0] == 'S') {
     b96:	80 91 af 03 	lds	r24, 0x03AF
     b9a:	83 35       	cpi	r24, 0x53	; 83
     b9c:	09 f0       	breq	.+2      	; 0xba0 <parseGpsPart+0x25a>
     b9e:	04 cf       	rjmp	.-504    	; 0x9a8 <parseGpsPart+0x62>
					gGpsLastData.pos.latitude = -gGpsLastData.pos.latitude;
     ba0:	80 91 93 03 	lds	r24, 0x0393
     ba4:	90 91 94 03 	lds	r25, 0x0394
     ba8:	a0 91 95 03 	lds	r26, 0x0395
     bac:	b0 91 96 03 	lds	r27, 0x0396
     bb0:	b0 95       	com	r27
     bb2:	a0 95       	com	r26
     bb4:	90 95       	com	r25
     bb6:	81 95       	neg	r24
     bb8:	9f 4f       	sbci	r25, 0xFF	; 255
     bba:	af 4f       	sbci	r26, 0xFF	; 255
     bbc:	bf 4f       	sbci	r27, 0xFF	; 255
     bbe:	80 93 93 03 	sts	0x0393, r24
     bc2:	90 93 94 03 	sts	0x0394, r25
     bc6:	a0 93 95 03 	sts	0x0395, r26
     bca:	b0 93 96 03 	sts	0x0396, r27
     bce:	08 95       	ret

00000bd0 <printAdc.clone.6>:
		str[pos++] = '0';
	}	
	return printNumber(str, pos, gTime.sec);
}

static uint8_t printAdc(char* const str, uint8_t pos, const uint8_t adcInput) {
     bd0:	ef 92       	push	r14
     bd2:	ff 92       	push	r15
     bd4:	0f 93       	push	r16
     bd6:	1f 93       	push	r17
     bd8:	cf 93       	push	r28
     bda:	df 93       	push	r29
     bdc:	ec 01       	movw	r28, r24
	uint8_t low = gAnalogInputs[adcInput].low;
     bde:	e6 2f       	mov	r30, r22
     be0:	f0 e0       	ldi	r31, 0x00	; 0
     be2:	ee 0f       	add	r30, r30
     be4:	ff 1f       	adc	r31, r31
     be6:	e3 5c       	subi	r30, 0xC3	; 195
     be8:	fb 4f       	sbci	r31, 0xFB	; 251
	uint8_t high = gAnalogInputs[adcInput].high;
	return printFloatNumberWithUnit(str, pos, low, high, "V");		
     bea:	e0 80       	ld	r14, Z
     bec:	ff 24       	eor	r15, r15
     bee:	00 e0       	ldi	r16, 0x00	; 0
     bf0:	10 e0       	ldi	r17, 0x00	; 0
     bf2:	21 81       	ldd	r18, Z+1	; 0x01
     bf4:	30 e0       	ldi	r19, 0x00	; 0
     bf6:	40 e0       	ldi	r20, 0x00	; 0
     bf8:	50 e0       	ldi	r21, 0x00	; 0
	myItoa(number, &str[pos]);
	return pos+length;
}

static uint8_t printFloatNumber(char* const str, uint8_t pos, int32_t numberLow, int32_t numberHigh) {
	pos = printNumber(str, pos, numberHigh);
     bfa:	64 e0       	ldi	r22, 0x04	; 4
     bfc:	06 db       	rcall	.-2548   	; 0x20a <printNumber>
	str[pos++] = '.';
     bfe:	fe 01       	movw	r30, r28
     c00:	e8 0f       	add	r30, r24
     c02:	f1 1d       	adc	r31, r1
     c04:	9e e2       	ldi	r25, 0x2E	; 46
     c06:	90 83       	st	Z, r25
     c08:	68 2f       	mov	r22, r24
     c0a:	6f 5f       	subi	r22, 0xFF	; 255
	if(numberLow < 10) {
     c0c:	8a e0       	ldi	r24, 0x0A	; 10
     c0e:	e8 16       	cp	r14, r24
     c10:	f1 04       	cpc	r15, r1
     c12:	01 05       	cpc	r16, r1
     c14:	11 05       	cpc	r17, r1
     c16:	34 f4       	brge	.+12     	; 0xc24 <printAdc.clone.6+0x54>
		str[pos++] = '0';
     c18:	fe 01       	movw	r30, r28
     c1a:	e6 0f       	add	r30, r22
     c1c:	f1 1d       	adc	r31, r1
     c1e:	80 e3       	ldi	r24, 0x30	; 48
     c20:	80 83       	st	Z, r24
     c22:	6f 5f       	subi	r22, 0xFF	; 255
	}
	return printNumber(str, pos, numberLow);
     c24:	ce 01       	movw	r24, r28
     c26:	a8 01       	movw	r20, r16
     c28:	97 01       	movw	r18, r14
     c2a:	ef da       	rcall	.-2594   	; 0x20a <printNumber>
     c2c:	68 2f       	mov	r22, r24
	return printText(str, pos, unit);
}

static uint8_t printFloatNumberWithUnit(char* const str, uint8_t pos, int32_t numberLow, int32_t numberHigh, const char* unit) {
	pos = printFloatNumber(str, pos, numberLow, numberHigh);
	return printText(str, pos, unit);
     c2e:	ce 01       	movw	r24, r28
     c30:	42 e2       	ldi	r20, 0x22	; 34
     c32:	51 e0       	ldi	r21, 0x01	; 1
     c34:	9d db       	rcall	.-2246   	; 0x370 <printText>

static uint8_t printAdc(char* const str, uint8_t pos, const uint8_t adcInput) {
	uint8_t low = gAnalogInputs[adcInput].low;
	uint8_t high = gAnalogInputs[adcInput].high;
	return printFloatNumberWithUnit(str, pos, low, high, "V");		
}
     c36:	df 91       	pop	r29
     c38:	cf 91       	pop	r28
     c3a:	1f 91       	pop	r17
     c3c:	0f 91       	pop	r16
     c3e:	ff 90       	pop	r15
     c40:	ef 90       	pop	r14
     c42:	08 95       	ret

00000c44 <main>:
#endif //GRAPICSENABLED
}

void main(void) __attribute__ ((noreturn)); // Main never returns, saves a few bytes

void main(void) {
     c44:	df 93       	push	r29
     c46:	cf 93       	push	r28
     c48:	cd b7       	in	r28, 0x3d	; 61
     c4a:	de b7       	in	r29, 0x3e	; 62
     c4c:	64 97       	sbiw	r28, 0x14	; 20
     c4e:	0f b6       	in	r0, 0x3f	; 63
     c50:	f8 94       	cli
     c52:	de bf       	out	0x3e, r29	; 62
     c54:	0f be       	out	0x3f, r0	; 63
     c56:	cd bf       	out	0x3d, r28	; 61
static uint8_t gKeyPressTime = 0;

static void setup(void)
{
	// Port setup
	PORTD = KEY; //key pullup & led off
     c58:	20 e1       	ldi	r18, 0x10	; 16
     c5a:	2b b9       	out	0x0b, r18	; 11
	DDRD  = LED; // led output
     c5c:	88 e0       	ldi	r24, 0x08	; 8
     c5e:	8a b9       	out	0x0a, r24	; 10
	PORTB &= ~OUT1;
     c60:	29 98       	cbi	0x05, 1	; 5
	DDRB  = OUT2 | SS;
     c62:	8c e0       	ldi	r24, 0x0C	; 12
     c64:	84 b9       	out	0x04, r24	; 4
	
	TIMSK1 |= (1 << TOIE1); // Enable overflow interrupt
     c66:	80 91 6f 00 	lds	r24, 0x006F
     c6a:	81 60       	ori	r24, 0x01	; 1
     c6c:	80 93 6f 00 	sts	0x006F, r24
	TCCR1B |= (1 << CS11); // Start timer at Fcpu/8
     c70:	80 91 81 00 	lds	r24, 0x0081
     c74:	82 60       	ori	r24, 0x02	; 2
     c76:	80 93 81 00 	sts	0x0081, r24
static uint16_t gActiveTextLastLine = 2;
static uint8_t gLineType = LINE_TYPE_UNKNOWN;

static void setupLine() {
  // Line trigger
	EICRA = (1<<ISC00) | (1<<ISC01); //set INT0 as rising edge trigger
     c7a:	83 e0       	ldi	r24, 0x03	; 3
     c7c:	80 93 69 00 	sts	0x0069, r24
	EIMSK = (1<<INT0); //enable INTO in global interrupt mask
     c80:	31 e0       	ldi	r19, 0x01	; 1
     c82:	3d bb       	out	0x1d, r19	; 29
	ACSR = (1<<ACD); //Comparator disabled
     c84:	80 e8       	ldi	r24, 0x80	; 128
     c86:	80 bf       	out	0x30, r24	; 48
	ADCSRB = 0x00;
     c88:	10 92 7b 00 	sts	0x007B, r1

	// SPI setup
	SPDR = 0x00; // Clear spi reg or thrash will show on video
     c8c:	1e bc       	out	0x2e, r1	; 46
#ifdef TEXT_SMALL_ENABLED
	SPSR |= (1<<SPI2X); // Set dual speed
#else
	SPSR &= ~(1<<SPI2X); // Clear dual speed
     c8e:	8d b5       	in	r24, 0x2d	; 45
     c90:	8e 7f       	andi	r24, 0xFE	; 254
     c92:	8d bd       	out	0x2d, r24	; 45
#endif //TEXT_SMALL_ENABLED
	SPCR = (1<<SPE) | (1<<MSTR) | (1<<CPHA);
     c94:	84 e5       	ldi	r24, 0x54	; 84
     c96:	8c bd       	out	0x2c, r24	; 44
	
#ifdef TEXT_ENABLED
	gActiveTextLine = gTextLines[gActiveTextId];
     c98:	e0 91 76 01 	lds	r30, 0x0176
     c9c:	f0 e0       	ldi	r31, 0x00	; 0
     c9e:	ee 0f       	add	r30, r30
     ca0:	ff 1f       	adc	r31, r31
     ca2:	eb 5a       	subi	r30, 0xAB	; 171
     ca4:	fe 4f       	sbci	r31, 0xFE	; 254
     ca6:	80 81       	ld	r24, Z
     ca8:	91 81       	ldd	r25, Z+1	; 0x01
     caa:	90 93 79 01 	sts	0x0179, r25
     cae:	80 93 78 01 	sts	0x0178, r24

#ifdef ADC_ENABLED

static void setupAdc() {
  // ADC setup
	DIDR0 = 0x00;
     cb2:	10 92 7e 00 	sts	0x007E, r1
	ADMUX |= (1<<REFS0); // Ref is AVCC
     cb6:	80 91 7c 00 	lds	r24, 0x007C
     cba:	80 64       	ori	r24, 0x40	; 64
     cbc:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA |= (1<<ADPS2) | (1<<ADPS1); // | (1<<ADPS0); 
     cc0:	80 91 7a 00 	lds	r24, 0x007A
     cc4:	86 60       	ori	r24, 0x06	; 6
     cc6:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // Free running
     cca:	10 92 7b 00 	sts	0x007B, r1
static TGpsData gGpsLastData = {};
static TTime gLastFix = {};

static void setupGps() {
	// USART setup
	UBRR0H = (uint8_t)(GPS_UBRR>>8); // set baud
     cce:	30 93 c5 00 	sts	0x00C5, r19
	UBRR0L = (uint8_t)GPS_UBRR;
     cd2:	87 e3       	ldi	r24, 0x37	; 55
     cd4:	80 93 c4 00 	sts	0x00C4, r24
	UCSR0C = (3<<UCSZ00); // 8N1
     cd8:	86 e0       	ldi	r24, 0x06	; 6
     cda:	80 93 c2 00 	sts	0x00C2, r24
	UCSR0B = (1<<RXEN0); // Enable RX
     cde:	20 93 c1 00 	sts	0x00C1, r18

#ifdef GPS_ENABLED
	setupGps();
#endif //GPS_ENABLED
	
	sei();
     ce2:	78 94       	sei
     ce4:	e7 e2       	ldi	r30, 0x27	; 39
     ce6:	4e 2e       	mov	r4, r30
     ce8:	e4 e0       	ldi	r30, 0x04	; 4
     cea:	5e 2e       	mov	r5, r30
	setup();

	while(1) {
    
#ifdef GPS_ENABLED
    if(UCSR0A & (1<<RXC0)) {
     cec:	80 91 c0 00 	lds	r24, 0x00C0
     cf0:	87 fd       	sbrc	r24, 7
     cf2:	1d c1       	rjmp	.+570    	; 0xf2e <main+0x2ea>
      decodeGpsData(UDR0);
    }
#endif //GPS_ENABLED
    
#ifndef DEBUG
		if((PIND & KEY) != KEY) {
     cf4:	4c 99       	sbic	0x09, 4	; 9
     cf6:	9c c0       	rjmp	.+312    	; 0xe30 <main+0x1ec>
			gKeyPressed = 1;
     cf8:	81 e0       	ldi	r24, 0x01	; 1
     cfa:	80 93 91 03 	sts	0x0391, r24
			if(gKeyPressTime > 50) {
     cfe:	80 91 92 03 	lds	r24, 0x0392
     d02:	83 33       	cpi	r24, 0x33	; 51
     d04:	e8 f0       	brcs	.+58     	; 0xd40 <main+0xfc>
				gKeyPressTime = 0;
     d06:	10 92 92 03 	sts	0x0392, r1
				PORTD |= LED; // long press!
     d0a:	5b 9a       	sbi	0x0b, 3	; 11
#ifdef GPS_ENABLED
#ifdef HOME_SET_WITH_BUTTON
      if (gGpsLastData.checksumValid != 0 && gGpsLastData.fix != 0) { // (Improved thanks to Yury Smirnov)
     d0c:	80 91 ab 03 	lds	r24, 0x03AB
     d10:	88 23       	and	r24, r24
     d12:	b1 f0       	breq	.+44     	; 0xd40 <main+0xfc>
     d14:	80 91 a1 03 	lds	r24, 0x03A1
     d18:	88 23       	and	r24, r24
     d1a:	91 f0       	breq	.+36     	; 0xd40 <main+0xfc>
}

static void setHomePos() {

	gHomePos = gGpsLastValidData.pos;
     d1c:	aa ed       	ldi	r26, 0xDA	; 218
     d1e:	b3 e0       	ldi	r27, 0x03	; 3
     d20:	ea eb       	ldi	r30, 0xBA	; 186
     d22:	f3 e0       	ldi	r31, 0x03	; 3
     d24:	8a e0       	ldi	r24, 0x0A	; 10
     d26:	01 90       	ld	r0, Z+
     d28:	0d 92       	st	X+, r0
     d2a:	81 50       	subi	r24, 0x01	; 1
     d2c:	e1 f7       	brne	.-8      	; 0xd26 <main+0xe2>
	gHomePosSet = 1;
     d2e:	81 e0       	ldi	r24, 0x01	; 1
     d30:	80 93 d9 03 	sts	0x03D9, r24
	}
#endif //TIME_HOUR_ENABLED
}

static void resetTime() {
	gTimeTick = 0;
     d34:	10 92 e4 03 	sts	0x03E4, r1
	gTime.sec = 0;
     d38:	10 92 d5 03 	sts	0x03D5, r1
	gTime.min = 0;
     d3c:	10 92 d6 03 	sts	0x03D6, r1
#ifdef DEBUG
		gUpdateScreenData = 2;
#endif //DEBUG

#ifdef TEXT_ENABLED
    if (gUpdateScreenData == 2) {
     d40:	80 91 77 01 	lds	r24, 0x0177
     d44:	82 30       	cpi	r24, 0x02	; 2
     d46:	09 f4       	brne	.+2      	; 0xd4a <main+0x106>
     d48:	80 c0       	rjmp	.+256    	; 0xe4a <main+0x206>
      //DDRB |= OUT1;
      updateTextCharStartPos(gActiveTextId);
	    updateTextPixmap(gActiveTextId);
		  //DDRB &= ~OUT1;
	  }
	  else if (gUpdateScreenData == 1) {
     d4a:	80 91 77 01 	lds	r24, 0x0177
     d4e:	81 30       	cpi	r24, 0x01	; 1
     d50:	69 f6       	brne	.-102    	; 0xcec <main+0xa8>
#else
    if (gUpdateScreenData == 1) {
#endif //TEXTENABLED
			gUpdateScreenData = 0;
     d52:	10 92 77 01 	sts	0x0177, r1
#endif // ALARM_ENABLED

}  

static void updateOnceEveryFrame() {
  if (gKeyPressed) {
     d56:	80 91 91 03 	lds	r24, 0x0391
     d5a:	88 23       	and	r24, r24
     d5c:	29 f0       	breq	.+10     	; 0xd68 <main+0x124>
		++gKeyPressTime;
     d5e:	80 91 92 03 	lds	r24, 0x0392
     d62:	8f 5f       	subi	r24, 0xFF	; 255
     d64:	80 93 92 03 	sts	0x0392, r24
	}

	if ((gTimeTick%(TIME_FRAMES_PER_SEC/SCREEN_AND_SENSOR_UPDATES_PER_SEC) == 0)) {
     d68:	80 91 e4 03 	lds	r24, 0x03E4
     d6c:	69 e1       	ldi	r22, 0x19	; 25
     d6e:	a4 d8       	rcall	.-3768   	; 0xfffffeb8 <__eeprom_end+0xff7efcb8>
     d70:	99 23       	and	r25, r25
     d72:	09 f4       	brne	.+2      	; 0xd76 <main+0x132>
     d74:	ac c2       	rjmp	.+1368   	; 0x12ce <main+0x68a>
static volatile uint8_t gBlink1Hz = 0;

#ifdef TIME_ENABLED

static void updateTime() {
	++gTimeTick;
     d76:	80 91 e4 03 	lds	r24, 0x03E4
     d7a:	8f 5f       	subi	r24, 0xFF	; 255
     d7c:	80 93 e4 03 	sts	0x03E4, r24
	if (gTimeTick >= TIME_FRAMES_PER_SEC) {
     d80:	80 91 e4 03 	lds	r24, 0x03E4
     d84:	82 33       	cpi	r24, 0x32	; 50
     d86:	78 f0       	brcs	.+30     	; 0xda6 <main+0x162>
		gTimeTick = 0;
     d88:	10 92 e4 03 	sts	0x03E4, r1
		gTime.sec++;
     d8c:	80 91 d5 03 	lds	r24, 0x03D5
     d90:	8f 5f       	subi	r24, 0xFF	; 255
     d92:	80 93 d5 03 	sts	0x03D5, r24
		gBlink1Hz = (gBlink1Hz+1)%2;
     d96:	80 91 4c 04 	lds	r24, 0x044C
     d9a:	90 e0       	ldi	r25, 0x00	; 0
     d9c:	01 96       	adiw	r24, 0x01	; 1
     d9e:	81 70       	andi	r24, 0x01	; 1
     da0:	90 70       	andi	r25, 0x00	; 0
     da2:	80 93 4c 04 	sts	0x044C, r24
	}
	if (gTime.sec >= 60) {
     da6:	80 91 d5 03 	lds	r24, 0x03D5
     daa:	8c 33       	cpi	r24, 0x3C	; 60
     dac:	38 f0       	brcs	.+14     	; 0xdbc <main+0x178>
		gTime.sec = 0;
     dae:	10 92 d5 03 	sts	0x03D5, r1
		gTime.min++;
     db2:	80 91 d6 03 	lds	r24, 0x03D6
     db6:	8f 5f       	subi	r24, 0xFF	; 255
     db8:	80 93 d6 03 	sts	0x03D6, r24
	}
	if (gTime.min >= 60) {
     dbc:	80 91 d6 03 	lds	r24, 0x03D6
     dc0:	8c 33       	cpi	r24, 0x3C	; 60
     dc2:	10 f0       	brcs	.+4      	; 0xdc8 <main+0x184>
		gTime.min = 0;
     dc4:	10 92 d6 03 	sts	0x03D6, r1
		str[pos++] = '0';
	}
	pos = printNumberWithUnit(str, pos, gTime.hour, ":");
#endif //TIME_HOUR_ENABLED
	if (gTime.min < 10) {
		str[pos++] = '0';
     dc8:	ee 24       	eor	r14, r14
     dca:	e3 94       	inc	r14
     dcc:	80 e0       	ldi	r24, 0x00	; 0
     dce:	90 e0       	ldi	r25, 0x00	; 0
#endif //GRAPICSENABLED
}

void main(void) __attribute__ ((noreturn)); // Main never returns, saves a few bytes

void main(void) {
     dd0:	51 e2       	ldi	r21, 0x21	; 33
     dd2:	a5 2e       	mov	r10, r21
     dd4:	b1 2c       	mov	r11, r1
	}	
	pos = printNumberWithUnit(str, pos, gTime.min, ":");
	if (gTime.sec < 10) {
		str[pos++] = '0';
     dd6:	40 e3       	ldi	r20, 0x30	; 48
     dd8:	64 2e       	mov	r6, r20
  }
  // --------------- TEXT LINE 2 (From top) -----------------------
  else if (textId == 1) {
	  
#ifdef SENSOR_VOLTAGE_2_ENABLED
		if(((gSensorVoltage2.high * 100) + gSensorVoltage2.low) > 0) {
     dda:	34 e6       	ldi	r19, 0x64	; 100
     ddc:	83 2e       	mov	r8, r19
     dde:	1c 01       	movw	r2, r24
#ifdef TIME_ENABLED
	updateTime();
#endif //TIMEENABLED

#ifdef TEXT_ENABLED
  for (uint8_t i = 0; i < TEXT_LINES; ++i) {
     de0:	22 2d       	mov	r18, r2
#endif //GRAPICSENABLED
}

void main(void) __attribute__ ((noreturn)); // Main never returns, saves a few bytes

void main(void) {
     de2:	82 2d       	mov	r24, r2
     de4:	90 e0       	ldi	r25, 0x00	; 0
     de6:	8a 9d       	mul	r24, r10
     de8:	f0 01       	movw	r30, r0
     dea:	8b 9d       	mul	r24, r11
     dec:	f0 0d       	add	r31, r0
     dee:	9a 9d       	mul	r25, r10
     df0:	f0 0d       	add	r31, r0
     df2:	11 24       	eor	r1, r1
     df4:	e5 58       	subi	r30, 0x85	; 133
     df6:	fe 4f       	sbci	r31, 0xFE	; 254
     df8:	81 e2       	ldi	r24, 0x21	; 33
#endif // TEXT_INVERTED_ENABLED

// Functions
static void clearText(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
		gText[textId][j] = 0;
     dfa:	11 92       	st	Z+, r1
     dfc:	81 50       	subi	r24, 0x01	; 1
static uint8_t gTextInverted[TEXT_LINES][TEXT_LINE_MAX_CHARS/8];
#endif // TEXT_INVERTED_ENABLED

// Functions
static void clearText(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
     dfe:	e9 f7       	brne	.-6      	; 0xdfa <main+0x1b6>
static void updateText(uint8_t textId) {
  //testPrintDebugInfo();
  uint8_t pos = 0;

  // --------------- TEXT LINE 1 (From top) -----------------------
	if (textId == 0) {
     e00:	22 23       	and	r18, r18
     e02:	09 f4       	brne	.+2      	; 0xe06 <main+0x1c2>
     e04:	bc c0       	rjmp	.+376    	; 0xf7e <main+0x33a>
#ifdef SHOW_GPS_IN_FLIGHT
	 printGpsNumber(gText[textId], pos, gGpsLastValidData.pos.latitude, 1); 
#endif	
  }
  // --------------- TEXT LINE 2 (From top) -----------------------
  else if (textId == 1) {
     e06:	21 30       	cpi	r18, 0x01	; 1
     e08:	09 f4       	brne	.+2      	; 0xe0c <main+0x1c8>
     e0a:	c5 c1       	rjmp	.+906    	; 0x1196 <main+0x552>
#ifdef SHOW_GPS_IN_FLIGHT
	 printGpsNumber(gText[textId], pos, gGpsLastValidData.pos.longitude, 0); 
#endif	
  }
  // --------------- TEXT LINE 3 (From top) -----------------------
  else if (textId == 2) {
     e0c:	22 30       	cpi	r18, 0x02	; 2
     e0e:	09 f4       	brne	.+2      	; 0xe12 <main+0x1ce>
     e10:	0c c2       	rjmp	.+1048   	; 0x122a <main+0x5e6>
	
	
#endif //GPS_ENABLED
  }
  // --------------- TEXT LINE 4 (From top) -----------------------
  else if (textId == 3) {
     e12:	23 30       	cpi	r18, 0x03	; 3
     e14:	09 f4       	brne	.+2      	; 0xe18 <main+0x1d4>
     e16:	62 c3       	rjmp	.+1732   	; 0x14dc <main+0x898>
		  pos = printNumber(gText[textId], TEXT_LINE_MAX_CHARS-4, gGpsLastValidData.angle);
		 
#endif //GPS_ENABLED	  
	}
	// --------------- TEXT LINE 5 (From top) -----------------------
	else if (textId == 4) {
     e18:	24 30       	cpi	r18, 0x04	; 4
     e1a:	09 f4       	brne	.+2      	; 0xe1e <main+0x1da>
     e1c:	1e c2       	rjmp	.+1084   	; 0x125a <main+0x616>
#ifdef TIME_ENABLED
	updateTime();
#endif //TIMEENABLED

#ifdef TEXT_ENABLED
  for (uint8_t i = 0; i < TEXT_LINES; ++i) {
     e1e:	6e 2d       	mov	r22, r14
     e20:	66 30       	cpi	r22, 0x06	; 6
     e22:	08 f0       	brcs	.+2      	; 0xe26 <main+0x1e2>
     e24:	e0 c0       	rjmp	.+448    	; 0xfe6 <main+0x3a2>
     e26:	08 94       	sec
     e28:	21 1c       	adc	r2, r1
     e2a:	31 1c       	adc	r3, r1
     e2c:	e3 94       	inc	r14
     e2e:	d8 cf       	rjmp	.-80     	; 0xde0 <main+0x19c>
#endif //HOME_SET_WITH_BUTTON
#endif //GPS_ENABLED
			}
		}
		else {
			if (gKeyPressed) {
     e30:	80 91 91 03 	lds	r24, 0x0391
     e34:	81 11       	cpse	r24, r1
				PORTD &= ~LED;  // led off
     e36:	5b 98       	cbi	0x0b, 3	; 11
			}				
			gKeyPressed = 0;
     e38:	10 92 91 03 	sts	0x0391, r1
			gKeyPressTime = 0;
     e3c:	10 92 92 03 	sts	0x0392, r1
#ifdef DEBUG
		gUpdateScreenData = 2;
#endif //DEBUG

#ifdef TEXT_ENABLED
    if (gUpdateScreenData == 2) {
     e40:	80 91 77 01 	lds	r24, 0x0177
     e44:	82 30       	cpi	r24, 0x02	; 2
     e46:	09 f0       	breq	.+2      	; 0xe4a <main+0x206>
     e48:	80 cf       	rjmp	.-256    	; 0xd4a <main+0x106>
		  gUpdateScreenData = 0;
     e4a:	10 92 77 01 	sts	0x0177, r1
#endif //GRAPICSENABLED
}

void main(void) __attribute__ ((noreturn)); // Main never returns, saves a few bytes

void main(void) {
     e4e:	20 91 76 01 	lds	r18, 0x0176
     e52:	30 e0       	ldi	r19, 0x00	; 0
     e54:	81 e2       	ldi	r24, 0x21	; 33
     e56:	90 e0       	ldi	r25, 0x00	; 0
     e58:	28 9f       	mul	r18, r24
     e5a:	d0 01       	movw	r26, r0
     e5c:	29 9f       	mul	r18, r25
     e5e:	b0 0d       	add	r27, r0
     e60:	38 9f       	mul	r19, r24
     e62:	b0 0d       	add	r27, r0
     e64:	11 24       	eor	r1, r1
     e66:	a5 58       	subi	r26, 0x85	; 133
     e68:	be 4f       	sbci	r27, 0xFE	; 254
		gUpdateScreenData = 2;
#endif //DEBUG

#ifdef TEXT_ENABLED
    if (gUpdateScreenData == 2) {
		  gUpdateScreenData = 0;
     e6a:	75 ee       	ldi	r23, 0xE5	; 229
     e6c:	e7 2e       	mov	r14, r23
     e6e:	73 e0       	ldi	r23, 0x03	; 3
     e70:	f7 2e       	mov	r15, r23
#endif //GRAPICSENABLED
}

void main(void) __attribute__ ((noreturn)); // Main never returns, saves a few bytes

void main(void) {
     e72:	f7 01       	movw	r30, r14
     e74:	80 e0       	ldi	r24, 0x00	; 0
     e76:	90 e0       	ldi	r25, 0x00	; 0
     e78:	13 c0       	rjmp	.+38     	; 0xea0 <main+0x25c>
		uint8_t character = gText[textId][j];
		int16_t eepromPos;
		if (character == ' ' || character == 0) {
			eepromPos = -1;
		}
		else if (character < CHAR_OFFSET + CHAR_LENGTH) {
     e7a:	2b 35       	cpi	r18, 0x5B	; 91
     e7c:	08 f0       	brcs	.+2      	; 0xe80 <main+0x23c>
     e7e:	72 c1       	rjmp	.+740    	; 0x1164 <main+0x520>
			uint16_t charPos = ((character - CHAR_OFFSET) * TEXT_CHAR_HEIGHT);
     e80:	82 2f       	mov	r24, r18
     e82:	90 e0       	ldi	r25, 0x00	; 0
     e84:	88 0f       	add	r24, r24
     e86:	99 1f       	adc	r25, r25
     e88:	88 0f       	add	r24, r24
     e8a:	99 1f       	adc	r25, r25
     e8c:	88 0f       	add	r24, r24
     e8e:	99 1f       	adc	r25, r25
			eepromPos = (int16_t)&(oem6x8[charPos]);
     e90:	88 52       	subi	r24, 0x28	; 40
     e92:	91 40       	sbci	r25, 0x01	; 1
		else if (character > CHAR_SPECIAL_OFFSET && character < CHAR_SPECIAL_OFFSET+CHAR_SPECIAL_LENGTH) {
			uint16_t charPos = ((character - CHAR_SPECIAL_OFFSET) * TEXT_CHAR_HEIGHT);
			eepromPos = (int16_t)&(specialChars[charPos]);
		}
#endif //TEXT_USE_SPECIAL_CHARS
		gTextCharEepromPos[j] = eepromPos;
     e94:	81 93       	st	Z+, r24
     e96:	91 93       	st	Z+, r25
	return 0;
}
#endif // TEXT_INVERTED_ENABLED

static void updateTextCharStartPos(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
     e98:	24 e0       	ldi	r18, 0x04	; 4
     e9a:	e7 32       	cpi	r30, 0x27	; 39
     e9c:	f2 07       	cpc	r31, r18
     e9e:	69 f0       	breq	.+26     	; 0xeba <main+0x276>
		uint8_t character = gText[textId][j];
     ea0:	2d 91       	ld	r18, X+
		int16_t eepromPos;
		if (character == ' ' || character == 0) {
     ea2:	20 32       	cpi	r18, 0x20	; 32
     ea4:	11 f0       	breq	.+4      	; 0xeaa <main+0x266>
     ea6:	22 23       	and	r18, r18
     ea8:	41 f7       	brne	.-48     	; 0xe7a <main+0x236>
			eepromPos = -1;
     eaa:	8f ef       	ldi	r24, 0xFF	; 255
     eac:	9f ef       	ldi	r25, 0xFF	; 255
		else if (character > CHAR_SPECIAL_OFFSET && character < CHAR_SPECIAL_OFFSET+CHAR_SPECIAL_LENGTH) {
			uint16_t charPos = ((character - CHAR_SPECIAL_OFFSET) * TEXT_CHAR_HEIGHT);
			eepromPos = (int16_t)&(specialChars[charPos]);
		}
#endif //TEXT_USE_SPECIAL_CHARS
		gTextCharEepromPos[j] = eepromPos;
     eae:	81 93       	st	Z+, r24
     eb0:	91 93       	st	Z+, r25
	return 0;
}
#endif // TEXT_INVERTED_ENABLED

static void updateTextCharStartPos(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
     eb2:	24 e0       	ldi	r18, 0x04	; 4
     eb4:	e7 32       	cpi	r30, 0x27	; 39
     eb6:	f2 07       	cpc	r31, r18
     eb8:	99 f7       	brne	.-26     	; 0xea0 <main+0x25c>
     eba:	80 e0       	ldi	r24, 0x00	; 0
     ebc:	90 e0       	ldi	r25, 0x00	; 0
		  if (eepromPos != -1) {
		  eeprom_read_block((void*)gTextLastCharBuffer, (const void*)eepromPos, 8);
			  gTextLastCharEepromPos = eepromPos;
		  }
		  else {
			  memset(gTextLastCharBuffer, 0, 8);
     ebe:	48 e0       	ldi	r20, 0x08	; 8
     ec0:	a4 2e       	mov	r10, r20
			  gTextLastCharEepromPos = -1;
     ec2:	88 24       	eor	r8, r8
     ec4:	8a 94       	dec	r8
     ec6:	3c 01       	movw	r6, r24
	}		
}

static void updateTextPixmap(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
		int16_t eepromPos = gTextCharEepromPos[j];
     ec8:	d7 01       	movw	r26, r14
     eca:	0d 91       	ld	r16, X+
     ecc:	1d 91       	ld	r17, X+
     ece:	7d 01       	movw	r14, r26
		if (gTextLastCharEepromPos != eepromPos) {
     ed0:	80 91 68 01 	lds	r24, 0x0168
     ed4:	99 27       	eor	r25, r25
     ed6:	87 fd       	sbrc	r24, 7
     ed8:	90 95       	com	r25
     eda:	08 17       	cp	r16, r24
     edc:	19 07       	cpc	r17, r25
     ede:	69 f0       	breq	.+26     	; 0xefa <main+0x2b6>
		  if (eepromPos != -1) {
     ee0:	bf ef       	ldi	r27, 0xFF	; 255
     ee2:	0f 3f       	cpi	r16, 0xFF	; 255
     ee4:	1b 07       	cpc	r17, r27
     ee6:	09 f4       	brne	.+2      	; 0xeea <main+0x2a6>
     ee8:	4d c1       	rjmp	.+666    	; 0x1184 <main+0x540>
		  eeprom_read_block((void*)gTextLastCharBuffer, (const void*)eepromPos, 8);
     eea:	87 e2       	ldi	r24, 0x27	; 39
     eec:	94 e0       	ldi	r25, 0x04	; 4
     eee:	b8 01       	movw	r22, r16
     ef0:	48 e0       	ldi	r20, 0x08	; 8
     ef2:	50 e0       	ldi	r21, 0x00	; 0
     ef4:	6e d8       	rcall	.-3876   	; 0xffffffd2 <__eeprom_end+0xff7efdd2>
			  gTextLastCharEepromPos = eepromPos;
     ef6:	00 93 68 01 	sts	0x0168, r16
     efa:	80 91 27 04 	lds	r24, 0x0427
     efe:	f3 01       	movw	r30, r6
     f00:	ef 5b       	subi	r30, 0xBF	; 191
     f02:	fd 4f       	sbci	r31, 0xFD	; 253
     f04:	a8 e2       	ldi	r26, 0x28	; 40
     f06:	b4 e0       	ldi	r27, 0x04	; 4
     f08:	01 c0       	rjmp	.+2      	; 0xf0c <main+0x2c8>
		  }
		  else {
			  memset(gTextLastCharBuffer, 0, 8);
			  gTextLastCharEepromPos = -1;
     f0a:	8d 91       	ld	r24, X+
		if (charInverted(textId, j)) {
		  gTextLastCharBuffer[i] = ~gTextLastCharBuffer[i];
		}
#endif // TEXT_INVERTED_ENABLED

      gTextPixmap[j + (i*TEXT_LINE_MAX_CHARS)] = gTextLastCharBuffer[i];
     f0c:	80 83       	st	Z, r24
     f0e:	b1 96       	adiw	r30, 0x21	; 33
			  memset(gTextLastCharBuffer, 0, 8);
			  gTextLastCharEepromPos = -1;
		  }
		}		  

	  for (uint8_t i = 0; i < TEXT_CHAR_HEIGHT; i++) {
     f10:	04 e0       	ldi	r16, 0x04	; 4
     f12:	af 32       	cpi	r26, 0x2F	; 47
     f14:	b0 07       	cpc	r27, r16
     f16:	c9 f7       	brne	.-14     	; 0xf0a <main+0x2c6>
     f18:	08 94       	sec
     f1a:	61 1c       	adc	r6, r1
     f1c:	71 1c       	adc	r7, r1
		gTextCharEepromPos[j] = eepromPos;
	}		
}

static void updateTextPixmap(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
     f1e:	11 e2       	ldi	r17, 0x21	; 33
     f20:	61 16       	cp	r6, r17
     f22:	71 04       	cpc	r7, r1
     f24:	89 f6       	brne	.-94     	; 0xec8 <main+0x284>
	setup();

	while(1) {
    
#ifdef GPS_ENABLED
    if(UCSR0A & (1<<RXC0)) {
     f26:	80 91 c0 00 	lds	r24, 0x00C0
     f2a:	87 ff       	sbrs	r24, 7
     f2c:	e3 ce       	rjmp	.-570    	; 0xcf4 <main+0xb0>
      decodeGpsData(UDR0);
     f2e:	00 91 c6 00 	lds	r16, 0x00C6
		}			
	}
}

static void decodeGpsData(char data) {
	if (gGpsTextPartStep == GPS_PART_FINISHED && data != '$') {
     f32:	90 91 67 01 	lds	r25, 0x0167
     f36:	9f 3f       	cpi	r25, 0xFF	; 255
     f38:	09 f4       	brne	.+2      	; 0xf3c <main+0x2f8>
     f3a:	24 c3       	rjmp	.+1608   	; 0x1584 <main+0x940>
		return;
	}
	
	switch (data) {
     f3c:	04 32       	cpi	r16, 0x24	; 36
     f3e:	09 f4       	brne	.+2      	; 0xf42 <main+0x2fe>
     f40:	24 c3       	rjmp	.+1608   	; 0x158a <main+0x946>
     f42:	05 32       	cpi	r16, 0x25	; 37
     f44:	08 f0       	brcs	.+2      	; 0xf48 <main+0x304>
     f46:	31 c3       	rjmp	.+1634   	; 0x15aa <main+0x966>
     f48:	0a 30       	cpi	r16, 0x0A	; 10
     f4a:	09 f4       	brne	.+2      	; 0xf4e <main+0x30a>
     f4c:	4e c3       	rjmp	.+1692   	; 0x15ea <main+0x9a6>
     f4e:	0d 30       	cpi	r16, 0x0D	; 13
     f50:	09 f4       	brne	.+2      	; 0xf54 <main+0x310>
     f52:	4b c3       	rjmp	.+1686   	; 0x15ea <main+0x9a6>
	  gGpsTextPartStep = GPS_PART_FINISHED;
	  finishGpsDecoding();
		return;
		break;
	default:
		gGpsText[gGpsTextPos] = data;
     f54:	80 91 ac 03 	lds	r24, 0x03AC
     f58:	e8 2f       	mov	r30, r24
     f5a:	f0 e0       	ldi	r31, 0x00	; 0
     f5c:	e1 55       	subi	r30, 0x51	; 81
     f5e:	fc 4f       	sbci	r31, 0xFC	; 252
     f60:	00 83       	st	Z, r16
		if (gGpsTextPartStep != GPS_PART_CHECKSUM) {
     f62:	98 3c       	cpi	r25, 0xC8	; 200
     f64:	29 f0       	breq	.+10     	; 0xf70 <main+0x32c>
		  gGpsChecksum ^= data;
     f66:	90 91 ae 03 	lds	r25, 0x03AE
     f6a:	90 27       	eor	r25, r16
     f6c:	90 93 ae 03 	sts	0x03AE, r25
		}
		if (gGpsTextPos < GPS_MAX_CHARS-1) {
     f70:	8a 30       	cpi	r24, 0x0A	; 10
     f72:	08 f0       	brcs	.+2      	; 0xf76 <main+0x332>
     f74:	bf ce       	rjmp	.-642    	; 0xcf4 <main+0xb0>
		  ++gGpsTextPos;
     f76:	8f 5f       	subi	r24, 0xFF	; 255
     f78:	80 93 ac 03 	sts	0x03AC, r24
     f7c:	bb ce       	rjmp	.-650    	; 0xcf4 <main+0xb0>
  uint8_t pos = 0;

  // --------------- TEXT LINE 1 (From top) -----------------------
	if (textId == 0) {
#ifdef SENSOR_VOLTAGE_1_ENABLED
		printText(gText[textId], pos+ 1, "\1521"); //Battery symbol + '1'
     f7e:	8b e7       	ldi	r24, 0x7B	; 123
     f80:	91 e0       	ldi	r25, 0x01	; 1
     f82:	61 e0       	ldi	r22, 0x01	; 1
     f84:	44 e2       	ldi	r20, 0x24	; 36
     f86:	51 e0       	ldi	r21, 0x01	; 1
     f88:	f3 d9       	rcall	.-3098   	; 0x370 <printText>
#endif
		pos += 4 ;

#ifdef SENSOR_VOLTAGE_1_ENABLED
		 if (!gAlarmBatt1 || gBlink1Hz) {
     f8a:	80 91 4a 04 	lds	r24, 0x044A
     f8e:	88 23       	and	r24, r24
     f90:	21 f0       	breq	.+8      	; 0xf9a <main+0x356>
     f92:	80 91 4c 04 	lds	r24, 0x044C
     f96:	88 23       	and	r24, r24
     f98:	21 f0       	breq	.+8      	; 0xfa2 <main+0x35e>
			 printAdc(gText[textId], pos , ANALOG_IN_1); // Voltage 1
     f9a:	8b e7       	ldi	r24, 0x7B	; 123
     f9c:	91 e0       	ldi	r25, 0x01	; 1
     f9e:	60 e0       	ldi	r22, 0x00	; 0
     fa0:	17 de       	rcall	.-978    	; 0xbd0 <printAdc.clone.6>
		 }
#endif
		 pos += 8;

#ifdef SENSOR_RSSI_ENABLED
     if (gSensorRssi > 0) {
     fa2:	80 91 49 04 	lds	r24, 0x0449
     fa6:	88 23       	and	r24, r24
     fa8:	31 f0       	breq	.+12     	; 0xfb6 <main+0x372>
	  printText(gText[textId], pos, "\151"); //Antenna symbol (RSSI)
     faa:	8b e7       	ldi	r24, 0x7B	; 123
     fac:	91 e0       	ldi	r25, 0x01	; 1
     fae:	6c e0       	ldi	r22, 0x0C	; 12
     fb0:	47 e2       	ldi	r20, 0x27	; 39
     fb2:	51 e0       	ldi	r21, 0x01	; 1
     fb4:	dd d9       	rcall	.-3142   	; 0x370 <printText>
#endif
         pos += 6 ;
		 
#ifdef GPS_ENABLED

  		  pos = printText(gText[textId], pos, "\150"); // Satellites symbol
     fb6:	8b e7       	ldi	r24, 0x7B	; 123
     fb8:	91 e0       	ldi	r25, 0x01	; 1
     fba:	62 e1       	ldi	r22, 0x12	; 18
     fbc:	49 e2       	ldi	r20, 0x29	; 41
     fbe:	51 e0       	ldi	r21, 0x01	; 1
     fc0:	d7 d9       	rcall	.-3154   	; 0x370 <printText>
		
	#endif
	  pos += 2 ;	  
     fc2:	68 2f       	mov	r22, r24
     fc4:	6e 5f       	subi	r22, 0xFE	; 254
	  

#ifdef SHOW_GPS_IN_FLIGHT
	 printGpsNumber(gText[textId], pos, gGpsLastValidData.pos.latitude, 1); 
     fc6:	20 91 ba 03 	lds	r18, 0x03BA
     fca:	30 91 bb 03 	lds	r19, 0x03BB
     fce:	40 91 bc 03 	lds	r20, 0x03BC
     fd2:	50 91 bd 03 	lds	r21, 0x03BD
     fd6:	8b e7       	ldi	r24, 0x7B	; 123
     fd8:	91 e0       	ldi	r25, 0x01	; 1
     fda:	01 e0       	ldi	r16, 0x01	; 1
     fdc:	fa d9       	rcall	.-3084   	; 0x3d2 <printGpsNumber>
#ifdef TIME_ENABLED
	updateTime();
#endif //TIMEENABLED

#ifdef TEXT_ENABLED
  for (uint8_t i = 0; i < TEXT_LINES; ++i) {
     fde:	6e 2d       	mov	r22, r14
     fe0:	66 30       	cpi	r22, 0x06	; 6
     fe2:	08 f4       	brcc	.+2      	; 0xfe6 <main+0x3a2>
     fe4:	20 cf       	rjmp	.-448    	; 0xe26 <main+0x1e2>
     fe6:	80 e0       	ldi	r24, 0x00	; 0
     fe8:	90 e0       	ldi	r25, 0x00	; 0
#endif //GRAPICSENABLED
}

void main(void) __attribute__ ((noreturn)); // Main never returns, saves a few bytes

void main(void) {
     fea:	fc 01       	movw	r30, r24
     fec:	ee 0f       	add	r30, r30
     fee:	ff 1f       	adc	r31, r31
     ff0:	e8 0f       	add	r30, r24
     ff2:	f9 1f       	adc	r31, r25
     ff4:	ee 0f       	add	r30, r30
     ff6:	ff 1f       	adc	r31, r31
     ff8:	ee 0f       	add	r30, r30
     ffa:	ff 1f       	adc	r31, r31
     ffc:	ee 0f       	add	r30, r30
     ffe:	ff 1f       	adc	r31, r31
    1000:	e7 5b       	subi	r30, 0xB7	; 183
    1002:	fc 4f       	sbci	r31, 0xFC	; 252
    1004:	20 e0       	ldi	r18, 0x00	; 0
// Functions

static void clearGraphics() {
	for (uint8_t x = 0; x < GRAPHICS_WIDTH; ++x) {
	  for (uint8_t y = 0; y < GRAPHICS_HEIGHT; ++y) {
			gPixelData[x][y] = 0x00;
    1006:	11 92       	st	Z+, r1

// Functions

static void clearGraphics() {
	for (uint8_t x = 0; x < GRAPHICS_WIDTH; ++x) {
	  for (uint8_t y = 0; y < GRAPHICS_HEIGHT; ++y) {
    1008:	2f 5f       	subi	r18, 0xFF	; 255
    100a:	28 31       	cpi	r18, 0x18	; 24
    100c:	e1 f7       	brne	.-8      	; 0x1006 <main+0x3c2>
    100e:	01 96       	adiw	r24, 0x01	; 1
static uint8_t gPixelData[GRAPHICS_WIDTH][GRAPHICS_HEIGHT];

// Functions

static void clearGraphics() {
	for (uint8_t x = 0; x < GRAPHICS_WIDTH; ++x) {
    1010:	83 30       	cpi	r24, 0x03	; 3
    1012:	91 05       	cpc	r25, r1
    1014:	51 f7       	brne	.-44     	; 0xfea <main+0x3a6>
}
#endif //TEXT_ENABLED

static void updateGrapics() {
#ifdef GPS_ENABLED
  drawArrow(gHomeBearing - gGpsLastValidData.angle);
    1016:	00 91 33 04 	lds	r16, 0x0433
    101a:	10 91 34 04 	lds	r17, 0x0434
    101e:	e0 90 cc 03 	lds	r14, 0x03CC
    1022:	f0 90 cd 03 	lds	r15, 0x03CD
		}
	}				 
}

static void drawArrow(uint16_t angle) {
	drawCircle(GRAPHICS_MID, GRAPHICS_MID, GRAPHICS_MID);
    1026:	8b e0       	ldi	r24, 0x0B	; 11
    1028:	3a db       	rcall	.-2444   	; 0x69e <drawCircle.clone.2>
	if (gHomeDistance < 10) {
    102a:	80 91 2f 04 	lds	r24, 0x042F
    102e:	90 91 30 04 	lds	r25, 0x0430
    1032:	a0 91 31 04 	lds	r26, 0x0431
    1036:	b0 91 32 04 	lds	r27, 0x0432
    103a:	8a 30       	cpi	r24, 0x0A	; 10
    103c:	91 05       	cpc	r25, r1
    103e:	a1 05       	cpc	r26, r1
    1040:	b1 05       	cpc	r27, r1
    1042:	08 f4       	brcc	.+2      	; 0x1046 <main+0x402>
    1044:	48 c2       	rjmp	.+1168   	; 0x14d6 <main+0x892>
	  drawCircle(GRAPHICS_MID, GRAPHICS_MID, 2);
	  return;
	}
	if (gGpsLastData.fix == 0) {
    1046:	80 91 a1 03 	lds	r24, 0x03A1
    104a:	88 23       	and	r24, r24
    104c:	09 f4       	brne	.+2      	; 0x1050 <main+0x40c>
    104e:	8f c2       	rjmp	.+1310   	; 0x156e <main+0x92a>
    1050:	98 01       	movw	r18, r16
    1052:	2e 19       	sub	r18, r14
    1054:	3f 09       	sbc	r19, r15
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
}

static int8_t myCos(uint16_t angle) {
	return mySin(angle + 90);
    1056:	c9 01       	movw	r24, r18
    1058:	86 5a       	subi	r24, 0xA6	; 166
    105a:	9f 4f       	sbci	r25, 0xFF	; 255
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    105c:	68 e6       	ldi	r22, 0x68	; 104
    105e:	71 e0       	ldi	r23, 0x01	; 1
    1060:	37 d7       	rcall	.+3694   	; 0x1ed0 <__udivmodhi4>
	int8_t mult = 1;
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    1062:	84 3b       	cpi	r24, 0xB4	; 180
    1064:	91 05       	cpc	r25, r1
    1066:	08 f4       	brcc	.+2      	; 0x106a <main+0x426>
    1068:	2e c1       	rjmp	.+604    	; 0x12c6 <main+0x682>
		pos = pos - 180;
    106a:	84 5b       	subi	r24, 0xB4	; 180
    106c:	90 40       	sbci	r25, 0x00	; 0
		mult = -1;
    106e:	6f ef       	ldi	r22, 0xFF	; 255
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
    1070:	8a 35       	cpi	r24, 0x5A	; 90
    1072:	91 05       	cpc	r25, r1
    1074:	30 f0       	brcs	.+12     	; 0x1082 <main+0x43e>
		pos = 180 - pos;
    1076:	44 eb       	ldi	r20, 0xB4	; 180
    1078:	50 e0       	ldi	r21, 0x00	; 0
    107a:	da 01       	movw	r26, r20
    107c:	a8 1b       	sub	r26, r24
    107e:	b9 0b       	sbc	r27, r25
    1080:	cd 01       	movw	r24, r26
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
    1082:	8c 5c       	subi	r24, 0xCC	; 204
    1084:	9f 4f       	sbci	r25, 0xFF	; 255
    1086:	fc 01       	movw	r30, r24
    1088:	84 91       	lpm	r24, Z+
    108a:	86 9f       	mul	r24, r22
    108c:	60 2d       	mov	r22, r0
    108e:	11 24       	eor	r1, r1
		drawLine(GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4));
		drawLine(GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID - (GRAPHICS_SIZE/4));
		return;
	}
	int16_t a = myCos(angle);
    1090:	06 2f       	mov	r16, r22
    1092:	11 27       	eor	r17, r17
    1094:	07 fd       	sbrc	r16, 7
    1096:	10 95       	com	r17
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    1098:	c9 01       	movw	r24, r18
    109a:	68 e6       	ldi	r22, 0x68	; 104
    109c:	71 e0       	ldi	r23, 0x01	; 1
    109e:	18 d7       	rcall	.+3632   	; 0x1ed0 <__udivmodhi4>
	int8_t mult = 1;
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    10a0:	84 3b       	cpi	r24, 0xB4	; 180
    10a2:	91 05       	cpc	r25, r1
    10a4:	08 f4       	brcc	.+2      	; 0x10a8 <main+0x464>
    10a6:	11 c1       	rjmp	.+546    	; 0x12ca <main+0x686>
		pos = pos - 180;
    10a8:	84 5b       	subi	r24, 0xB4	; 180
    10aa:	90 40       	sbci	r25, 0x00	; 0
		mult = -1;
    10ac:	4f ef       	ldi	r20, 0xFF	; 255
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
    10ae:	8a 35       	cpi	r24, 0x5A	; 90
    10b0:	91 05       	cpc	r25, r1
    10b2:	30 f0       	brcs	.+12     	; 0x10c0 <main+0x47c>
		pos = 180 - pos;
    10b4:	24 eb       	ldi	r18, 0xB4	; 180
    10b6:	30 e0       	ldi	r19, 0x00	; 0
    10b8:	59 01       	movw	r10, r18
    10ba:	a8 1a       	sub	r10, r24
    10bc:	b9 0a       	sbc	r11, r25
    10be:	c5 01       	movw	r24, r10
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
    10c0:	8c 5c       	subi	r24, 0xCC	; 204
    10c2:	9f 4f       	sbci	r25, 0xFF	; 255
    10c4:	fc 01       	movw	r30, r24
    10c6:	e4 90       	lpm	r14, Z+
	int16_t b = mySin(angle);
	a = (a * (GRAPHICS_SIZE / 3)) / 100;
    10c8:	c8 01       	movw	r24, r16
    10ca:	88 0f       	add	r24, r24
    10cc:	99 1f       	adc	r25, r25
    10ce:	88 0f       	add	r24, r24
    10d0:	99 1f       	adc	r25, r25
    10d2:	88 0f       	add	r24, r24
    10d4:	99 1f       	adc	r25, r25
    10d6:	24 e6       	ldi	r18, 0x64	; 100
    10d8:	30 e0       	ldi	r19, 0x00	; 0
    10da:	b9 01       	movw	r22, r18
    10dc:	0d d7       	rcall	.+3610   	; 0x1ef8 <__divmodhi4>
    10de:	4b 01       	movw	r8, r22
    10e0:	e4 9e       	mul	r14, r20
    10e2:	80 2d       	mov	r24, r0
    10e4:	11 24       	eor	r1, r1
		drawLine(GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4));
		drawLine(GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID - (GRAPHICS_SIZE/4));
		return;
	}
	int16_t a = myCos(angle);
	int16_t b = mySin(angle);
    10e6:	99 27       	eor	r25, r25
    10e8:	87 fd       	sbrc	r24, 7
    10ea:	90 95       	com	r25
	a = (a * (GRAPHICS_SIZE / 3)) / 100;
	b = (b * (GRAPHICS_SIZE / 3)) / 100;
    10ec:	88 0f       	add	r24, r24
    10ee:	99 1f       	adc	r25, r25
    10f0:	88 0f       	add	r24, r24
    10f2:	99 1f       	adc	r25, r25
    10f4:	88 0f       	add	r24, r24
    10f6:	99 1f       	adc	r25, r25
    10f8:	b9 01       	movw	r22, r18
    10fa:	fe d6       	rcall	.+3580   	; 0x1ef8 <__divmodhi4>
    10fc:	8b 01       	movw	r16, r22
	drawLine(GRAPHICS_MID - b, GRAPHICS_MID + a, GRAPHICS_MID + b, GRAPHICS_MID - a); //Direction line
    10fe:	68 2d       	mov	r22, r8
    1100:	ab e0       	ldi	r26, 0x0B	; 11
    1102:	aa 2e       	mov	r10, r26
    1104:	a0 0e       	add	r10, r16
    1106:	8b e0       	ldi	r24, 0x0B	; 11
    1108:	e8 2e       	mov	r14, r24
    110a:	e8 18       	sub	r14, r8
    110c:	65 5f       	subi	r22, 0xF5	; 245
    110e:	80 1b       	sub	r24, r16
    1110:	4a 2d       	mov	r20, r10
    1112:	2e 2d       	mov	r18, r14
    1114:	4c db       	rcall	.-2408   	; 0x7ae <drawLine>
	//drawLine(GRAPHICS_MID_X + a/2, GRAPHICS_MID_X + b/2, GRAPHICS_MID_X - a/2, GRAPHICS_MID_X - b/2); //Arrow bottom line
	drawLine(GRAPHICS_MID + b, GRAPHICS_MID - a, GRAPHICS_MID - a/2, GRAPHICS_MID - b/2); // Arrow "wings"
    1116:	c4 01       	movw	r24, r8
    1118:	97 fc       	sbrc	r9, 7
    111a:	a0 c2       	rjmp	.+1344   	; 0x165c <main+0xa18>
    111c:	95 95       	asr	r25
    111e:	87 95       	ror	r24
    1120:	90 95       	com	r25
    1122:	81 95       	neg	r24
    1124:	9f 4f       	sbci	r25, 0xFF	; 255
    1126:	48 2f       	mov	r20, r24
    1128:	45 5f       	subi	r20, 0xF5	; 245
    112a:	c8 01       	movw	r24, r16
    112c:	17 fd       	sbrc	r17, 7
    112e:	94 c2       	rjmp	.+1320   	; 0x1658 <main+0xa14>
    1130:	95 95       	asr	r25
    1132:	87 95       	ror	r24
    1134:	90 95       	com	r25
    1136:	81 95       	neg	r24
    1138:	9f 4f       	sbci	r25, 0xFF	; 255
    113a:	28 2f       	mov	r18, r24
    113c:	25 5f       	subi	r18, 0xF5	; 245
    113e:	8a 2d       	mov	r24, r10
    1140:	6e 2d       	mov	r22, r14
    1142:	35 db       	rcall	.-2454   	; 0x7ae <drawLine>
	drawLine(GRAPHICS_MID + b, GRAPHICS_MID - a, GRAPHICS_MID + a/2, GRAPHICS_MID + b/2);
    1144:	97 fc       	sbrc	r9, 7
    1146:	84 c2       	rjmp	.+1288   	; 0x1650 <main+0xa0c>
    1148:	a4 01       	movw	r20, r8
    114a:	55 95       	asr	r21
    114c:	47 95       	ror	r20
    114e:	45 5f       	subi	r20, 0xF5	; 245
    1150:	17 fd       	sbrc	r17, 7
    1152:	7b c2       	rjmp	.+1270   	; 0x164a <main+0xa06>
    1154:	15 95       	asr	r17
    1156:	07 95       	ror	r16
    1158:	20 2f       	mov	r18, r16
    115a:	25 5f       	subi	r18, 0xF5	; 245
    115c:	8a 2d       	mov	r24, r10
    115e:	6e 2d       	mov	r22, r14
    1160:	26 db       	rcall	.-2484   	; 0x7ae <drawLine>
    1162:	c4 cd       	rjmp	.-1144   	; 0xcec <main+0xa8>
		else if (character < CHAR_OFFSET + CHAR_LENGTH) {
			uint16_t charPos = ((character - CHAR_OFFSET) * TEXT_CHAR_HEIGHT);
			eepromPos = (int16_t)&(oem6x8[charPos]);
		}
#ifdef TEXT_USE_SPECIAL_CHARS
		else if (character > CHAR_SPECIAL_OFFSET && character < CHAR_SPECIAL_OFFSET+CHAR_SPECIAL_LENGTH) {
    1164:	32 2f       	mov	r19, r18
    1166:	35 56       	subi	r19, 0x65	; 101
    1168:	39 30       	cpi	r19, 0x09	; 9
    116a:	08 f0       	brcs	.+2      	; 0x116e <main+0x52a>
    116c:	93 ce       	rjmp	.-730    	; 0xe94 <main+0x250>
			uint16_t charPos = ((character - CHAR_SPECIAL_OFFSET) * TEXT_CHAR_HEIGHT);
    116e:	82 2f       	mov	r24, r18
    1170:	90 e0       	ldi	r25, 0x00	; 0
    1172:	88 0f       	add	r24, r24
    1174:	99 1f       	adc	r25, r25
    1176:	88 0f       	add	r24, r24
    1178:	99 1f       	adc	r25, r25
    117a:	88 0f       	add	r24, r24
    117c:	99 1f       	adc	r25, r25
			eepromPos = (int16_t)&(specialChars[charPos]);
    117e:	80 57       	subi	r24, 0x70	; 112
    1180:	91 40       	sbci	r25, 0x01	; 1
    1182:	88 ce       	rjmp	.-752    	; 0xe94 <main+0x250>
		  if (eepromPos != -1) {
		  eeprom_read_block((void*)gTextLastCharBuffer, (const void*)eepromPos, 8);
			  gTextLastCharEepromPos = eepromPos;
		  }
		  else {
			  memset(gTextLastCharBuffer, 0, 8);
    1184:	f2 01       	movw	r30, r4
    1186:	ba 2c       	mov	r11, r10
    1188:	11 92       	st	Z+, r1
    118a:	ba 94       	dec	r11
    118c:	e9 f7       	brne	.-6      	; 0x1188 <main+0x544>
			  gTextLastCharEepromPos = -1;
    118e:	80 92 68 01 	sts	0x0168, r8
    1192:	80 e0       	ldi	r24, 0x00	; 0
    1194:	b4 ce       	rjmp	.-664    	; 0xefe <main+0x2ba>
  }
  // --------------- TEXT LINE 2 (From top) -----------------------
  else if (textId == 1) {
	  
#ifdef SENSOR_VOLTAGE_2_ENABLED
		if(((gSensorVoltage2.high * 100) + gSensorVoltage2.low) > 0) {
    1196:	80 91 48 04 	lds	r24, 0x0448
    119a:	48 2d       	mov	r20, r8
    119c:	84 9f       	mul	r24, r20
    119e:	c0 01       	movw	r24, r0
    11a0:	11 24       	eor	r1, r1
    11a2:	20 91 47 04 	lds	r18, 0x0447
    11a6:	82 0f       	add	r24, r18
    11a8:	91 1d       	adc	r25, r1
    11aa:	00 97       	sbiw	r24, 0x00	; 0
    11ac:	f1 f0       	breq	.+60     	; 0x11ea <main+0x5a6>
		printText(gText[textId], pos+ 1, "\1522"); //Battery symbol + '2'
    11ae:	8c e9       	ldi	r24, 0x9C	; 156
    11b0:	91 e0       	ldi	r25, 0x01	; 1
    11b2:	61 e0       	ldi	r22, 0x01	; 1
    11b4:	4b e2       	ldi	r20, 0x2B	; 43
    11b6:	51 e0       	ldi	r21, 0x01	; 1
    11b8:	db d8       	rcall	.-3658   	; 0x370 <printText>
		}
#endif		
		pos += 4 ;
#ifdef SENSOR_VOLTAGE_2_ENABLED
		 if(((gSensorVoltage2.high * 100) + gSensorVoltage2.low) > 0) {
    11ba:	80 91 48 04 	lds	r24, 0x0448
    11be:	58 2d       	mov	r21, r8
    11c0:	85 9f       	mul	r24, r21
    11c2:	c0 01       	movw	r24, r0
    11c4:	11 24       	eor	r1, r1
    11c6:	20 91 47 04 	lds	r18, 0x0447
    11ca:	82 0f       	add	r24, r18
    11cc:	91 1d       	adc	r25, r1
    11ce:	00 97       	sbiw	r24, 0x00	; 0
    11d0:	61 f0       	breq	.+24     	; 0x11ea <main+0x5a6>
     if (!gAlarmBatt2 || gBlink1Hz) {
    11d2:	80 91 4b 04 	lds	r24, 0x044B
    11d6:	88 23       	and	r24, r24
    11d8:	21 f0       	breq	.+8      	; 0x11e2 <main+0x59e>
    11da:	80 91 4c 04 	lds	r24, 0x044C
    11de:	88 23       	and	r24, r24
    11e0:	21 f0       	breq	.+8      	; 0x11ea <main+0x5a6>
			 printAdc(gText[textId], pos , ANALOG_IN_2); // Voltage 2
    11e2:	8c e9       	ldi	r24, 0x9C	; 156
    11e4:	91 e0       	ldi	r25, 0x01	; 1
    11e6:	61 e0       	ldi	r22, 0x01	; 1
    11e8:	f3 dc       	rcall	.-1562   	; 0xbd0 <printAdc.clone.6>
		  }
#endif
		 pos += 8;

#ifdef SENSOR_RSSI_ENABLED
      if ((!gAlarmRssi || gBlink1Hz ) && gSensorRssi > 0)
    11ea:	20 91 49 04 	lds	r18, 0x0449
    11ee:	22 23       	and	r18, r18
    11f0:	09 f0       	breq	.+2      	; 0x11f4 <main+0x5b0>
    11f2:	67 c1       	rjmp	.+718    	; 0x14c2 <main+0x87e>
#endif
	  pos += 6 ;


#ifdef GPS_ENABLED
    if (gGpsLastValidData.fix) {
    11f4:	80 91 c8 03 	lds	r24, 0x03C8
    11f8:	88 23       	and	r24, r24
    11fa:	41 f1       	breq	.+80     	; 0x124c <main+0x608>
		printNumber(gText[textId], pos, gGpsLastValidData.sats); 
    11fc:	20 91 c9 03 	lds	r18, 0x03C9
    1200:	30 e0       	ldi	r19, 0x00	; 0
    1202:	40 e0       	ldi	r20, 0x00	; 0
    1204:	50 e0       	ldi	r21, 0x00	; 0
    1206:	8c e9       	ldi	r24, 0x9C	; 156
    1208:	91 e0       	ldi	r25, 0x01	; 1
    120a:	62 e1       	ldi	r22, 0x12	; 18
    120c:	fe d7       	rcall	.+4092   	; 0x220a <__data_load_end+0x1a2>
	  }
#endif
	  pos += 3 ;	  
	  
#ifdef SHOW_GPS_IN_FLIGHT
	 printGpsNumber(gText[textId], pos, gGpsLastValidData.pos.longitude, 0); 
    120e:	20 91 be 03 	lds	r18, 0x03BE
    1212:	30 91 bf 03 	lds	r19, 0x03BF
    1216:	40 91 c0 03 	lds	r20, 0x03C0
    121a:	50 91 c1 03 	lds	r21, 0x03C1
    121e:	8c e9       	ldi	r24, 0x9C	; 156
    1220:	91 e0       	ldi	r25, 0x01	; 1
    1222:	65 e1       	ldi	r22, 0x15	; 21
    1224:	00 e0       	ldi	r16, 0x00	; 0
    1226:	d5 d8       	rcall	.-3670   	; 0x3d2 <printGpsNumber>
    1228:	fa cd       	rjmp	.-1036   	; 0xe1e <main+0x1da>
  }
  // --------------- TEXT LINE 3 (From top) -----------------------
  else if (textId == 2) {
	 
#ifdef GPS_ENABLED
	  if (gHomePosSet) {
    122a:	80 91 d9 03 	lds	r24, 0x03D9
    122e:	88 23       	and	r24, r24
    1230:	09 f0       	breq	.+2      	; 0x1234 <main+0x5f0>
    1232:	84 c1       	rjmp	.+776    	; 0x153c <main+0x8f8>
			 pos = printText(gText[textId], pos, "\146");
			 pos = printText(gText[textId], 2, "MT");
			 pos = printNumber(gText[textId], 5 , gHomeDistance);
		}
	    else if (gBlink1Hz) {
    1234:	80 91 4c 04 	lds	r24, 0x044C
    1238:	88 23       	and	r24, r24
    123a:	09 f4       	brne	.+2      	; 0x123e <main+0x5fa>
    123c:	f0 cd       	rjmp	.-1056   	; 0xe1e <main+0x1da>
	      pos = printText(gText[textId], 10, "NO HOME POS");
    123e:	8d eb       	ldi	r24, 0xBD	; 189
    1240:	91 e0       	ldi	r25, 0x01	; 1
    1242:	6a e0       	ldi	r22, 0x0A	; 10
    1244:	47 e3       	ldi	r20, 0x37	; 55
    1246:	51 e0       	ldi	r21, 0x01	; 1
    1248:	93 d8       	rcall	.-3802   	; 0x370 <printText>
    124a:	e9 cd       	rjmp	.-1070   	; 0xe1e <main+0x1da>
#ifdef GPS_ENABLED
    if (gGpsLastValidData.fix) {
		printNumber(gText[textId], pos, gGpsLastValidData.sats); 
		}
		else {			
		printText(gText[textId], pos, "-");
    124c:	8c e9       	ldi	r24, 0x9C	; 156
    124e:	91 e0       	ldi	r25, 0x01	; 1
    1250:	62 e1       	ldi	r22, 0x12	; 18
    1252:	40 e3       	ldi	r20, 0x30	; 48
    1254:	51 e0       	ldi	r21, 0x01	; 1
    1256:	8c d8       	rcall	.-3816   	; 0x370 <printText>
    1258:	da cf       	rjmp	.-76     	; 0x120e <main+0x5ca>
	}
	// --------------- TEXT LINE 5 (From top) -----------------------
	else if (textId == 4) {
#ifdef GPS_ENABLED

	    pos = printNumber(gText[textId], 0, gGpsLastValidData.speed); // Speed
    125a:	20 91 ca 03 	lds	r18, 0x03CA
    125e:	30 91 cb 03 	lds	r19, 0x03CB
    1262:	40 e0       	ldi	r20, 0x00	; 0
    1264:	50 e0       	ldi	r21, 0x00	; 0
    1266:	8f ef       	ldi	r24, 0xFF	; 255
    1268:	91 e0       	ldi	r25, 0x01	; 1
    126a:	60 e0       	ldi	r22, 0x00	; 0
    126c:	ce d7       	rcall	.+3996   	; 0x220a <__data_load_end+0x1a2>
			
        pos = printText(gText[textId],5 , "KM/H");
    126e:	8f ef       	ldi	r24, 0xFF	; 255
    1270:	91 e0       	ldi	r25, 0x01	; 1
    1272:	65 e0       	ldi	r22, 0x05	; 5
    1274:	4b e4       	ldi	r20, 0x4B	; 75
    1276:	51 e0       	ldi	r21, 0x01	; 1
    1278:	7b d8       	rcall	.-3850   	; 0x370 <printText>
	if (gTime.hour < 10) {
		str[pos++] = '0';
	}
	pos = printNumberWithUnit(str, pos, gTime.hour, ":");
#endif //TIME_HOUR_ENABLED
	if (gTime.min < 10) {
    127a:	80 91 d6 03 	lds	r24, 0x03D6
    127e:	8a 30       	cpi	r24, 0x0A	; 10
    1280:	08 f0       	brcs	.+2      	; 0x1284 <main+0x640>
    1282:	55 c1       	rjmp	.+682    	; 0x152e <main+0x8ea>
		str[pos++] = '0';
    1284:	60 92 1a 02 	sts	0x021A, r6
    1288:	6c e1       	ldi	r22, 0x1C	; 28
	}	
	pos = printNumberWithUnit(str, pos, gTime.min, ":");
    128a:	20 91 d6 03 	lds	r18, 0x03D6
    128e:	30 e0       	ldi	r19, 0x00	; 0
    1290:	40 e0       	ldi	r20, 0x00	; 0
    1292:	50 e0       	ldi	r21, 0x00	; 0
    1294:	8f ef       	ldi	r24, 0xFF	; 255
    1296:	91 e0       	ldi	r25, 0x01	; 1
    1298:	00 e5       	ldi	r16, 0x50	; 80
    129a:	11 e0       	ldi	r17, 0x01	; 1
    129c:	8b d8       	rcall	.-3818   	; 0x3b4 <printNumberWithUnit>
    129e:	68 2f       	mov	r22, r24
	if (gTime.sec < 10) {
    12a0:	80 91 d5 03 	lds	r24, 0x03D5
    12a4:	8a 30       	cpi	r24, 0x0A	; 10
    12a6:	30 f4       	brcc	.+12     	; 0x12b4 <main+0x670>
		str[pos++] = '0';
    12a8:	e6 2f       	mov	r30, r22
    12aa:	f0 e0       	ldi	r31, 0x00	; 0
    12ac:	e1 50       	subi	r30, 0x01	; 1
    12ae:	fe 4f       	sbci	r31, 0xFE	; 254
    12b0:	60 82       	st	Z, r6
    12b2:	6f 5f       	subi	r22, 0xFF	; 255
	}	
	return printNumber(str, pos, gTime.sec);
    12b4:	20 91 d5 03 	lds	r18, 0x03D5
    12b8:	30 e0       	ldi	r19, 0x00	; 0
    12ba:	40 e0       	ldi	r20, 0x00	; 0
    12bc:	50 e0       	ldi	r21, 0x00	; 0
    12be:	8f ef       	ldi	r24, 0xFF	; 255
    12c0:	91 e0       	ldi	r25, 0x01	; 1
    12c2:	a3 d7       	rcall	.+3910   	; 0x220a <__data_load_end+0x1a2>
    12c4:	ac cd       	rjmp	.-1192   	; 0xe1e <main+0x1da>
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
	int8_t mult = 1;
    12c6:	61 e0       	ldi	r22, 0x01	; 1
    12c8:	d3 ce       	rjmp	.-602    	; 0x1070 <main+0x42c>
    12ca:	41 e0       	ldi	r20, 0x01	; 1
    12cc:	f0 ce       	rjmp	.-544    	; 0x10ae <main+0x46a>

static void updateSensorsAndScreen() {
#ifndef GPS_ENABLED
  PORTD |= LED;
#else //GPS_ENABLED
  if (gGpsLastData.fix != 0) {
    12ce:	80 91 a1 03 	lds	r24, 0x03A1
    12d2:	88 23       	and	r24, r24
    12d4:	09 f4       	brne	.+2      	; 0x12d8 <main+0x694>
    12d6:	2d c1       	rjmp	.+602    	; 0x1532 <main+0x8ee>
		PORTD |= LED;
    12d8:	5b 9a       	sbi	0x0b, 3	; 11
	
#ifdef DEBUG
  //testCalcHome();
#endif // DEBUG
  
	if (gHomePosSet) {
    12da:	80 91 d9 03 	lds	r24, 0x03D9
    12de:	88 23       	and	r24, r24
    12e0:	09 f0       	breq	.+2      	; 0x12e4 <main+0x6a0>
    12e2:	be c1       	rjmp	.+892    	; 0x1660 <main+0xa1c>
  distance *= mult;
#ifdef IMPERIAL_SYSTEM  
  distance *= 3281;
	distance /= 1000;
#endif //IMPERIAL_SYSTEM
  *distanceResult = distance;
    12e4:	85 e3       	ldi	r24, 0x35	; 53
    12e6:	88 2e       	mov	r8, r24
    12e8:	84 e0       	ldi	r24, 0x04	; 4
    12ea:	98 2e       	mov	r9, r24
    12ec:	09 e6       	ldi	r16, 0x69	; 105
    12ee:	60 2e       	mov	r6, r16
    12f0:	01 e0       	ldi	r16, 0x01	; 1
    12f2:	70 2e       	mov	r7, r16
    12f4:	1d e6       	ldi	r17, 0x6D	; 109
    12f6:	21 2e       	mov	r2, r17
    12f8:	11 e0       	ldi	r17, 0x01	; 1
    12fa:	31 2e       	mov	r3, r17
    12fc:	8d e3       	ldi	r24, 0x3D	; 61
    12fe:	94 e0       	ldi	r25, 0x04	; 4
      if (deltaLat == 0) {
        if (deltaLong >= 0) { // Home = East
          bearing = 90; 
        } 
	      else { // Home = West
          bearing = 270;
    1300:	19 82       	std	Y+1, r1	; 0x01
	  ADCSRA &= ~(1<<ADEN) & ~(1<<ADATE); // ADC disabled & ADC auto trigger disabled
	  temp = ADCW;
#ifdef ADC_ENABLE_RAW	  
    gAnalogInputsRaw[i] = temp;
#endif
	  temp = (temp * 5 * 62) / 10;
    1302:	ba e0       	ldi	r27, 0x0A	; 10
    1304:	ab 2e       	mov	r10, r27
    1306:	b1 2c       	mov	r11, r1
    1308:	c1 2c       	mov	r12, r1
    130a:	d1 2c       	mov	r13, r1
    130c:	9a 87       	std	Y+10, r25	; 0x0a
    130e:	89 87       	std	Y+9, r24	; 0x09
static void measureAnalog() {
  uint32_t temp = 0;
	uint8_t adcLow = 0; 
  uint8_t adcHigh = 0;
  for (uint8_t i = 0; i < ANALOG_IN_NUMBER; ++i) {
	  ADMUX &= 0xF0; // Clear mux
    1310:	80 91 7c 00 	lds	r24, 0x007C
    1314:	80 7f       	andi	r24, 0xF0	; 240
    1316:	80 93 7c 00 	sts	0x007C, r24
    ADMUX |= (i + ADC_OFFSET);	 //Setup adc mux
    131a:	80 91 7c 00 	lds	r24, 0x007C
    131e:	59 81       	ldd	r21, Y+1	; 0x01
    1320:	85 2b       	or	r24, r21
    1322:	80 93 7c 00 	sts	0x007C, r24
	  ADCSRA |= (1<<ADEN) | (1<<ADATE); // ADC enable & ADC auto trigger enable
    1326:	80 91 7a 00 	lds	r24, 0x007A
    132a:	80 6a       	ori	r24, 0xA0	; 160
    132c:	80 93 7a 00 	sts	0x007A, r24
	  ADCSRA |= (1<<ADSC); // Start measure
    1330:	80 91 7a 00 	lds	r24, 0x007A
    1334:	80 64       	ori	r24, 0x40	; 64
    1336:	80 93 7a 00 	sts	0x007A, r24
    133a:	29 85       	ldd	r18, Y+9	; 0x09
    133c:	3a 85       	ldd	r19, Y+10	; 0x0a
	  while ((ADCSRA & (1<<ADIF)) == 0); // Wait to finish
    133e:	80 91 7a 00 	lds	r24, 0x007A
    1342:	84 ff       	sbrs	r24, 4
    1344:	fc cf       	rjmp	.-8      	; 0x133e <main+0x6fa>
    1346:	3a 87       	std	Y+10, r19	; 0x0a
    1348:	29 87       	std	Y+9, r18	; 0x09
	  ADCSRA |= (1<<ADIF); // Clear ADC interrupt flag with a 1
    134a:	80 91 7a 00 	lds	r24, 0x007A
    134e:	80 61       	ori	r24, 0x10	; 16
    1350:	80 93 7a 00 	sts	0x007A, r24
	  ADCSRA &= ~(1<<ADEN) & ~(1<<ADATE); // ADC disabled & ADC auto trigger disabled
    1354:	80 91 7a 00 	lds	r24, 0x007A
    1358:	8f 75       	andi	r24, 0x5F	; 95
    135a:	80 93 7a 00 	sts	0x007A, r24
	  temp = ADCW;
    135e:	20 91 78 00 	lds	r18, 0x0078
    1362:	30 91 79 00 	lds	r19, 0x0079
#ifdef ADC_ENABLE_RAW	  
    gAnalogInputsRaw[i] = temp;
    1366:	d4 01       	movw	r26, r8
    1368:	2d 93       	st	X+, r18
    136a:	3d 93       	st	X+, r19
    136c:	4d 01       	movw	r8, r26
#endif
	  temp = (temp * 5 * 62) / 10;
    136e:	46 e3       	ldi	r20, 0x36	; 54
    1370:	51 e0       	ldi	r21, 0x01	; 1
    1372:	74 d5       	rcall	.+2792   	; 0x1e5c <__umulhisi3>
    1374:	a6 01       	movw	r20, r12
    1376:	95 01       	movw	r18, r10
    1378:	d2 d5       	rcall	.+2980   	; 0x1f1e <__udivmodsi4>
    137a:	79 01       	movw	r14, r18
    137c:	8a 01       	movw	r16, r20
	  temp *= gAnalogMult[i];
    137e:	f3 01       	movw	r30, r6
    1380:	21 91       	ld	r18, Z+
    1382:	3f 01       	movw	r6, r30
    1384:	30 e0       	ldi	r19, 0x00	; 0
    1386:	40 e0       	ldi	r20, 0x00	; 0
    1388:	50 e0       	ldi	r21, 0x00	; 0
    138a:	c8 01       	movw	r24, r16
    138c:	b7 01       	movw	r22, r14
    138e:	75 d5       	rcall	.+2794   	; 0x1e7a <__mulsi3>
	  temp /= gAnalogDiv[i];
    1390:	d1 01       	movw	r26, r2
    1392:	2d 91       	ld	r18, X+
    1394:	1d 01       	movw	r2, r26
    1396:	30 e0       	ldi	r19, 0x00	; 0
    1398:	40 e0       	ldi	r20, 0x00	; 0
    139a:	50 e0       	ldi	r21, 0x00	; 0
    139c:	c0 d5       	rcall	.+2944   	; 0x1f1e <__udivmodsi4>
	  adcHigh = temp / 1024;
    139e:	79 01       	movw	r14, r18
    13a0:	8a 01       	movw	r16, r20
    13a2:	aa e0       	ldi	r26, 0x0A	; 10
    13a4:	16 95       	lsr	r17
    13a6:	07 95       	ror	r16
    13a8:	f7 94       	ror	r15
    13aa:	e7 94       	ror	r14
    13ac:	aa 95       	dec	r26
    13ae:	d1 f7       	brne	.-12     	; 0x13a4 <main+0x760>
    13b0:	ed 82       	std	Y+5, r14	; 0x05
    13b2:	fe 82       	std	Y+6, r15	; 0x06
    13b4:	0f 83       	std	Y+7, r16	; 0x07
    13b6:	18 87       	std	Y+8, r17	; 0x08
	  temp -= (uint16_t)(adcHigh) * 1024;
    13b8:	8e 2d       	mov	r24, r14
    13ba:	90 e0       	ldi	r25, 0x00	; 0
    13bc:	98 2f       	mov	r25, r24
    13be:	88 27       	eor	r24, r24
    13c0:	99 0f       	add	r25, r25
    13c2:	99 0f       	add	r25, r25
    13c4:	a0 e0       	ldi	r26, 0x00	; 0
    13c6:	b0 e0       	ldi	r27, 0x00	; 0
    13c8:	79 01       	movw	r14, r18
    13ca:	8a 01       	movw	r16, r20
    13cc:	e8 1a       	sub	r14, r24
    13ce:	f9 0a       	sbc	r15, r25
    13d0:	0a 0b       	sbc	r16, r26
    13d2:	1b 0b       	sbc	r17, r27
    13d4:	c8 01       	movw	r24, r16
    13d6:	b7 01       	movw	r22, r14
	  adcLow = (temp * 100) / 1024;
    13d8:	24 e6       	ldi	r18, 0x64	; 100
    13da:	30 e0       	ldi	r19, 0x00	; 0
    13dc:	40 e0       	ldi	r20, 0x00	; 0
    13de:	50 e0       	ldi	r21, 0x00	; 0
    13e0:	4c d5       	rcall	.+2712   	; 0x1e7a <__mulsi3>
    13e2:	ea e0       	ldi	r30, 0x0A	; 10
    13e4:	96 95       	lsr	r25
    13e6:	87 95       	ror	r24
    13e8:	77 95       	ror	r23
    13ea:	67 95       	ror	r22
    13ec:	ea 95       	dec	r30
    13ee:	d1 f7       	brne	.-12     	; 0x13e4 <main+0x7a0>
    13f0:	a9 85       	ldd	r26, Y+9	; 0x09
    13f2:	ba 85       	ldd	r27, Y+10	; 0x0a
    13f4:	6c 93       	st	X, r22
	
	  gAnalogInputs[i].low = adcLow;
    gAnalogInputs[i].high = adcHigh;
    13f6:	ed 81       	ldd	r30, Y+5	; 0x05
    13f8:	11 96       	adiw	r26, 0x01	; 1
    13fa:	ec 93       	st	X, r30
    13fc:	11 97       	sbiw	r26, 0x01	; 1

static void measureAnalog() {
  uint32_t temp = 0;
	uint8_t adcLow = 0; 
  uint8_t adcHigh = 0;
  for (uint8_t i = 0; i < ANALOG_IN_NUMBER; ++i) {
    13fe:	f9 81       	ldd	r31, Y+1	; 0x01
    1400:	ff 5f       	subi	r31, 0xFF	; 255
    1402:	f9 83       	std	Y+1, r31	; 0x01
    1404:	12 96       	adiw	r26, 0x02	; 2
    1406:	ba 87       	std	Y+10, r27	; 0x0a
    1408:	a9 87       	std	Y+9, r26	; 0x09
    140a:	f4 30       	cpi	r31, 0x04	; 4
    140c:	09 f0       	breq	.+2      	; 0x1410 <main+0x7cc>
    140e:	80 cf       	rjmp	.-256    	; 0x1310 <main+0x6cc>
	return outMax - value + outMin;
}*/

static void updateSensors() {
#ifdef SENSOR_VOLTAGE_1_ENABLED
    gSensorVoltage1 = gAnalogInputs[ANALOG_IN_1];
    1410:	80 91 3d 04 	lds	r24, 0x043D
    1414:	90 91 3e 04 	lds	r25, 0x043E
    1418:	90 93 46 04 	sts	0x0446, r25
    141c:	80 93 45 04 	sts	0x0445, r24
#endif
#ifdef SENSOR_VOLTAGE_2_ENABLED
    gSensorVoltage2 = gAnalogInputs[ANALOG_IN_2];
    1420:	80 91 3f 04 	lds	r24, 0x043F
    1424:	90 91 40 04 	lds	r25, 0x0440
    1428:	90 93 48 04 	sts	0x0448, r25
    142c:	80 93 47 04 	sts	0x0447, r24
static void updateSensors() { DUMMY_FUNC }

#else //ADC_ENABLED

static uint8_t calcGenericVoltageLevel(uint8_t adcInput, uint16_t inMin, uint16_t inMax, uint16_t outMin, uint16_t outMax) {
	uint16_t level = ((gAnalogInputs[adcInput].high * 100) + gAnalogInputs[adcInput].low);
    1430:	90 91 42 04 	lds	r25, 0x0442
    1434:	84 e6       	ldi	r24, 0x64	; 100
    1436:	98 9f       	mul	r25, r24
    1438:	c0 01       	movw	r24, r0
    143a:	11 24       	eor	r1, r1
    143c:	20 91 41 04 	lds	r18, 0x0441
    1440:	82 0f       	add	r24, r18
    1442:	91 1d       	adc	r25, r1
	if (level > inMax) {
    1444:	01 e0       	ldi	r16, 0x01	; 1
    1446:	85 3f       	cpi	r24, 0xF5	; 245
    1448:	90 07       	cpc	r25, r16
    144a:	08 f0       	brcs	.+2      	; 0x144e <main+0x80a>
    144c:	fb c0       	rjmp	.+502    	; 0x1644 <main+0xa00>
		level = outMax;
	}		
	else if (level > inMin) {
    144e:	89 37       	cpi	r24, 0x79	; 121
    1450:	91 05       	cpc	r25, r1
    1452:	08 f4       	brcc	.+2      	; 0x1456 <main+0x812>
    1454:	e7 c2       	rjmp	.+1486   	; 0x1a24 <main+0xde0>
		level -= inMin;
    1456:	ac 01       	movw	r20, r24
    1458:	48 57       	subi	r20, 0x78	; 120
    145a:	50 40       	sbci	r21, 0x00	; 0
		level *= outMax - outMin;
    145c:	24 e6       	ldi	r18, 0x64	; 100
    145e:	30 e0       	ldi	r19, 0x00	; 0
    1460:	42 9f       	mul	r20, r18
    1462:	c0 01       	movw	r24, r0
    1464:	43 9f       	mul	r20, r19
    1466:	90 0d       	add	r25, r0
    1468:	52 9f       	mul	r21, r18
    146a:	90 0d       	add	r25, r0
    146c:	11 24       	eor	r1, r1
		level /= inMax - inMin;
    146e:	6c e7       	ldi	r22, 0x7C	; 124
    1470:	71 e0       	ldi	r23, 0x01	; 1
    1472:	2e d5       	rcall	.+2652   	; 0x1ed0 <__udivmodhi4>
		level += outMin;
	}
	else {
		level = outMin;
	}
	return level;
    1474:	60 93 49 04 	sts	0x0449, r22
	gAlarmDistance = (gHomeDistance > ALARM_DISTANCE_HIGH);
#endif
#endif //GPS_ENABLED

#ifdef ALARM_BATT1_LOW_INT
	gAlarmBatt1 = ((gSensorVoltage1.high * 100) + gSensorVoltage1.low) < ALARM_BATT1_LOW_INT;
    1478:	90 91 46 04 	lds	r25, 0x0446
    147c:	84 e6       	ldi	r24, 0x64	; 100
    147e:	98 9f       	mul	r25, r24
    1480:	c0 01       	movw	r24, r0
    1482:	11 24       	eor	r1, r1
    1484:	20 91 45 04 	lds	r18, 0x0445
    1488:	82 0f       	add	r24, r18
    148a:	91 1d       	adc	r25, r1
    148c:	21 e0       	ldi	r18, 0x01	; 1
    148e:	13 e0       	ldi	r17, 0x03	; 3
    1490:	88 3e       	cpi	r24, 0xE8	; 232
    1492:	91 07       	cpc	r25, r17
    1494:	08 f0       	brcs	.+2      	; 0x1498 <main+0x854>
    1496:	20 e0       	ldi	r18, 0x00	; 0
    1498:	20 93 4a 04 	sts	0x044A, r18
#ifdef ALARM_POWER_USAGE_HIGH
  gAlarmPowerUsage = (gSensorPowerUsage/1000) < ALARM_POWER_USAGE_HIGH;
#endif
#else // ANALOG_IN_NUMBER > 2
#ifdef ALARM_BATT2_LOW_INT
	gAlarmBatt2 = ((gSensorVoltage2.high * 100) + gSensorVoltage2.low) < ALARM_BATT2_LOW_INT; //Bugfix thanks to Benson
    149c:	90 91 48 04 	lds	r25, 0x0448
    14a0:	84 e6       	ldi	r24, 0x64	; 100
    14a2:	98 9f       	mul	r25, r24
    14a4:	c0 01       	movw	r24, r0
    14a6:	11 24       	eor	r1, r1
    14a8:	20 91 47 04 	lds	r18, 0x0447
    14ac:	82 0f       	add	r24, r18
    14ae:	91 1d       	adc	r25, r1
    14b0:	21 e0       	ldi	r18, 0x01	; 1
    14b2:	33 e0       	ldi	r19, 0x03	; 3
    14b4:	88 3e       	cpi	r24, 0xE8	; 232
    14b6:	93 07       	cpc	r25, r19
    14b8:	08 f0       	brcs	.+2      	; 0x14bc <main+0x878>
    14ba:	20 e0       	ldi	r18, 0x00	; 0
    14bc:	20 93 4b 04 	sts	0x044B, r18
    14c0:	5a cc       	rjmp	.-1868   	; 0xd76 <main+0x132>
	return printFloatNumberWithUnit(str, pos, low, high, "V");		
}

static uint8_t printRssiLevel(char* const str, uint8_t pos, const uint8_t adcInput) {
	uint8_t rssiLevel = gSensorRssi;
	return printNumberWithUnit(str, pos, rssiLevel, "%");
    14c2:	30 e0       	ldi	r19, 0x00	; 0
    14c4:	40 e0       	ldi	r20, 0x00	; 0
    14c6:	50 e0       	ldi	r21, 0x00	; 0
    14c8:	8c e9       	ldi	r24, 0x9C	; 156
    14ca:	91 e0       	ldi	r25, 0x01	; 1
    14cc:	6c e0       	ldi	r22, 0x0C	; 12
    14ce:	0e e2       	ldi	r16, 0x2E	; 46
    14d0:	11 e0       	ldi	r17, 0x01	; 1
    14d2:	70 d7       	rcall	.+3808   	; 0x23b4 <__data_load_end+0x34c>
    14d4:	8f ce       	rjmp	.-738    	; 0x11f4 <main+0x5b0>
}

static void drawArrow(uint16_t angle) {
	drawCircle(GRAPHICS_MID, GRAPHICS_MID, GRAPHICS_MID);
	if (gHomeDistance < 10) {
	  drawCircle(GRAPHICS_MID, GRAPHICS_MID, 2);
    14d6:	82 e0       	ldi	r24, 0x02	; 2
    14d8:	e2 d8       	rcall	.-3644   	; 0x69e <drawCircle.clone.2>
    14da:	08 cc       	rjmp	.-2032   	; 0xcec <main+0xa8>
#endif //GPS_ENABLED
  }
  // --------------- TEXT LINE 4 (From top) -----------------------
  else if (textId == 3) {
#ifdef GPS_ENABLED
        printText(gText[textId], pos, "ALT"); //ALTITUDE
    14dc:	8e ed       	ldi	r24, 0xDE	; 222
    14de:	91 e0       	ldi	r25, 0x01	; 1
    14e0:	60 e0       	ldi	r22, 0x00	; 0
    14e2:	43 e4       	ldi	r20, 0x43	; 67
    14e4:	51 e0       	ldi	r21, 0x01	; 1
    14e6:	44 d7       	rcall	.+3720   	; 0x2370 <__data_load_end+0x308>
     else if (altitudeArrow == -1) 
	      pos = printText(gText[textId], 5, "\155");
		  
	 else pos = printText(gText[textId], 5, "=");*/
	
		 pos = printNumber(gText[textId], 7 , gGpsLastValidData.pos.altitude - gHomePos.altitude); // Altitude
    14e8:	20 91 c2 03 	lds	r18, 0x03C2
    14ec:	30 91 c3 03 	lds	r19, 0x03C3
    14f0:	80 91 e2 03 	lds	r24, 0x03E2
    14f4:	90 91 e3 03 	lds	r25, 0x03E3
    14f8:	28 1b       	sub	r18, r24
    14fa:	39 0b       	sbc	r19, r25
    14fc:	44 27       	eor	r20, r20
    14fe:	37 fd       	sbrc	r19, 7
    1500:	40 95       	com	r20
    1502:	54 2f       	mov	r21, r20
    1504:	8e ed       	ldi	r24, 0xDE	; 222
    1506:	91 e0       	ldi	r25, 0x01	; 1
    1508:	67 e0       	ldi	r22, 0x07	; 7
    150a:	7f d6       	rcall	.+3326   	; 0x220a <__data_load_end+0x1a2>
	   		
	  
          pos = printText(gText[textId],TEXT_LINE_MAX_CHARS-8 , "HDG");
    150c:	8e ed       	ldi	r24, 0xDE	; 222
    150e:	91 e0       	ldi	r25, 0x01	; 1
    1510:	69 e1       	ldi	r22, 0x19	; 25
    1512:	47 e4       	ldi	r20, 0x47	; 71
    1514:	51 e0       	ldi	r21, 0x01	; 1
    1516:	2c d7       	rcall	.+3672   	; 0x2370 <__data_load_end+0x308>
		  pos = printNumber(gText[textId], TEXT_LINE_MAX_CHARS-4, gGpsLastValidData.angle);
    1518:	20 91 cc 03 	lds	r18, 0x03CC
    151c:	30 91 cd 03 	lds	r19, 0x03CD
    1520:	40 e0       	ldi	r20, 0x00	; 0
    1522:	50 e0       	ldi	r21, 0x00	; 0
    1524:	8e ed       	ldi	r24, 0xDE	; 222
    1526:	91 e0       	ldi	r25, 0x01	; 1
    1528:	6d e1       	ldi	r22, 0x1D	; 29
    152a:	6f d6       	rcall	.+3294   	; 0x220a <__data_load_end+0x1a2>
    152c:	7c cc       	rjmp	.-1800   	; 0xe26 <main+0x1e2>
	if (gTime.hour < 10) {
		str[pos++] = '0';
	}
	pos = printNumberWithUnit(str, pos, gTime.hour, ":");
#endif //TIME_HOUR_ENABLED
	if (gTime.min < 10) {
    152e:	6b e1       	ldi	r22, 0x1B	; 27
    1530:	ac ce       	rjmp	.-680    	; 0x128a <main+0x646>
#else //GPS_ENABLED
  if (gGpsLastData.fix != 0) {
		PORTD |= LED;
	}
	else {
		PORTD ^= LED;
    1532:	8b b1       	in	r24, 0x0b	; 11
    1534:	98 e0       	ldi	r25, 0x08	; 8
    1536:	89 27       	eor	r24, r25
    1538:	8b b9       	out	0x0b, r24	; 11
    153a:	cf ce       	rjmp	.-610    	; 0x12da <main+0x696>
  // --------------- TEXT LINE 3 (From top) -----------------------
  else if (textId == 2) {
	 
#ifdef GPS_ENABLED
	  if (gHomePosSet) {
			 pos = printText(gText[textId], pos, "\146");
    153c:	8d eb       	ldi	r24, 0xBD	; 189
    153e:	91 e0       	ldi	r25, 0x01	; 1
    1540:	60 e0       	ldi	r22, 0x00	; 0
    1542:	42 e3       	ldi	r20, 0x32	; 50
    1544:	51 e0       	ldi	r21, 0x01	; 1
    1546:	14 d7       	rcall	.+3624   	; 0x2370 <__data_load_end+0x308>
			 pos = printText(gText[textId], 2, "MT");
    1548:	8d eb       	ldi	r24, 0xBD	; 189
    154a:	91 e0       	ldi	r25, 0x01	; 1
    154c:	62 e0       	ldi	r22, 0x02	; 2
    154e:	44 e3       	ldi	r20, 0x34	; 52
    1550:	51 e0       	ldi	r21, 0x01	; 1
    1552:	0e d7       	rcall	.+3612   	; 0x2370 <__data_load_end+0x308>
			 pos = printNumber(gText[textId], 5 , gHomeDistance);
    1554:	20 91 2f 04 	lds	r18, 0x042F
    1558:	30 91 30 04 	lds	r19, 0x0430
    155c:	40 91 31 04 	lds	r20, 0x0431
    1560:	50 91 32 04 	lds	r21, 0x0432
    1564:	8d eb       	ldi	r24, 0xBD	; 189
    1566:	91 e0       	ldi	r25, 0x01	; 1
    1568:	65 e0       	ldi	r22, 0x05	; 5
    156a:	4f d6       	rcall	.+3230   	; 0x220a <__data_load_end+0x1a2>
    156c:	5c cc       	rjmp	.-1864   	; 0xe26 <main+0x1e2>
	  return;
	}
	if (gGpsLastData.fix == 0) {
		drawLine(GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4));
    156e:	85 e0       	ldi	r24, 0x05	; 5
    1570:	65 e0       	ldi	r22, 0x05	; 5
    1572:	41 e1       	ldi	r20, 0x11	; 17
    1574:	21 e1       	ldi	r18, 0x11	; 17
    1576:	1b d9       	rcall	.-3530   	; 0x7ae <drawLine>
		drawLine(GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID - (GRAPHICS_SIZE/4));
    1578:	85 e0       	ldi	r24, 0x05	; 5
    157a:	61 e1       	ldi	r22, 0x11	; 17
    157c:	41 e1       	ldi	r20, 0x11	; 17
    157e:	25 e0       	ldi	r18, 0x05	; 5
    1580:	16 d9       	rcall	.-3540   	; 0x7ae <drawLine>
    1582:	b4 cb       	rjmp	.-2200   	; 0xcec <main+0xa8>
		}			
	}
}

static void decodeGpsData(char data) {
	if (gGpsTextPartStep == GPS_PART_FINISHED && data != '$') {
    1584:	04 32       	cpi	r16, 0x24	; 36
    1586:	09 f0       	breq	.+2      	; 0x158a <main+0x946>
    1588:	b5 cb       	rjmp	.-2198   	; 0xcf4 <main+0xb0>
		return;
	}
	
	switch (data) {
	case '$':
		gGpsTextPos = 0;
    158a:	10 92 ac 03 	sts	0x03AC, r1
		gGpsTextType = GPS_TYPE_NONE;
    158e:	10 92 ad 03 	sts	0x03AD, r1
		gGpsChecksum = 0;
    1592:	10 92 ae 03 	sts	0x03AE, r1
		gGpsTextPartStep = 0;
    1596:	10 92 67 01 	sts	0x0167, r1
    159a:	ef ea       	ldi	r30, 0xAF	; 175
    159c:	f3 e0       	ldi	r31, 0x03	; 3
static uint8_t gGpsTextPartLength = 0;
#endif //GPS_PART_TEXT

static void clearGpsText() {
	for (uint8_t i = 0; i < GPS_MAX_CHARS; ++i) {
		gGpsText[i] = 0;
    159e:	11 92       	st	Z+, r1
static char gGpsTextPart[GPS_MAX_CHARS];
static uint8_t gGpsTextPartLength = 0;
#endif //GPS_PART_TEXT

static void clearGpsText() {
	for (uint8_t i = 0; i < GPS_MAX_CHARS; ++i) {
    15a0:	03 e0       	ldi	r16, 0x03	; 3
    15a2:	ea 3b       	cpi	r30, 0xBA	; 186
    15a4:	f0 07       	cpc	r31, r16
    15a6:	d9 f7       	brne	.-10     	; 0x159e <main+0x95a>
    15a8:	a5 cb       	rjmp	.-2230   	; 0xcf4 <main+0xb0>
static void decodeGpsData(char data) {
	if (gGpsTextPartStep == GPS_PART_FINISHED && data != '$') {
		return;
	}
	
	switch (data) {
    15aa:	0a 32       	cpi	r16, 0x2A	; 42
    15ac:	41 f0       	breq	.+16     	; 0x15be <main+0x97a>
    15ae:	0c 32       	cpi	r16, 0x2C	; 44
    15b0:	09 f0       	breq	.+2      	; 0x15b4 <main+0x970>
    15b2:	d0 cc       	rjmp	.-1632   	; 0xf54 <main+0x310>
		clearFullGpsText();
		gGpsFullTextPos = 0;
#endif // FULLGPSTEXT
		break;
	case ',':
		gGpsChecksum ^= data;
    15b4:	80 91 ae 03 	lds	r24, 0x03AE
    15b8:	80 27       	eor	r24, r16
    15ba:	80 93 ae 03 	sts	0x03AE, r24
	case '*':
		parseGpsPart();
    15be:	c3 d9       	rcall	.-3194   	; 0x946 <parseGpsPart>
    15c0:	ef ea       	ldi	r30, 0xAF	; 175
    15c2:	f3 e0       	ldi	r31, 0x03	; 3
static uint8_t gGpsTextPartLength = 0;
#endif //GPS_PART_TEXT

static void clearGpsText() {
	for (uint8_t i = 0; i < GPS_MAX_CHARS; ++i) {
		gGpsText[i] = 0;
    15c4:	11 92       	st	Z+, r1
static char gGpsTextPart[GPS_MAX_CHARS];
static uint8_t gGpsTextPartLength = 0;
#endif //GPS_PART_TEXT

static void clearGpsText() {
	for (uint8_t i = 0; i < GPS_MAX_CHARS; ++i) {
    15c6:	13 e0       	ldi	r17, 0x03	; 3
    15c8:	ea 3b       	cpi	r30, 0xBA	; 186
    15ca:	f1 07       	cpc	r31, r17
    15cc:	d9 f7       	brne	.-10     	; 0x15c4 <main+0x980>
	case ',':
		gGpsChecksum ^= data;
	case '*':
		parseGpsPart();
		clearGpsText();		
		gGpsTextPos = 0;
    15ce:	10 92 ac 03 	sts	0x03AC, r1
		gGpsTextPartStep++;
    15d2:	80 91 67 01 	lds	r24, 0x0167
    15d6:	8f 5f       	subi	r24, 0xFF	; 255
    15d8:	80 93 67 01 	sts	0x0167, r24
		if (data =='*') {
    15dc:	0a 32       	cpi	r16, 0x2A	; 42
    15de:	09 f0       	breq	.+2      	; 0x15e2 <main+0x99e>
    15e0:	89 cb       	rjmp	.-2286   	; 0xcf4 <main+0xb0>
			gGpsTextPartStep = GPS_PART_CHECKSUM;
    15e2:	88 ec       	ldi	r24, 0xC8	; 200
    15e4:	80 93 67 01 	sts	0x0167, r24
    15e8:	85 cb       	rjmp	.-2294   	; 0xcf4 <main+0xb0>
		}			
		break;
	case '\r':
	case '\n':
	  parseGpsPart();
    15ea:	ad d9       	rcall	.-3238   	; 0x946 <parseGpsPart>
	  gGpsTextPartStep = GPS_PART_FINISHED;
    15ec:	4f ef       	ldi	r20, 0xFF	; 255
    15ee:	40 93 67 01 	sts	0x0167, r20



static void finishGpsDecoding() {
	
if (gGpsLastData.pos.altitude > gGpsLastValidData.pos.altitude) 
    15f2:	20 91 9b 03 	lds	r18, 0x039B
    15f6:	30 91 9c 03 	lds	r19, 0x039C
    15fa:	80 91 c2 03 	lds	r24, 0x03C2
    15fe:	90 91 c3 03 	lds	r25, 0x03C3
    1602:	82 17       	cp	r24, r18
    1604:	93 07       	cpc	r25, r19
    1606:	0c f0       	brlt	.+2      	; 0x160a <main+0x9c6>
    1608:	5f c2       	rjmp	.+1214   	; 0x1ac8 <main+0xe84>
altitudeArrow = 1;
    160a:	81 e0       	ldi	r24, 0x01	; 1
    160c:	80 93 d3 03 	sts	0x03D3, r24
		
else if (gGpsLastData.pos.altitude < gGpsLastValidData.pos.altitude)
altitudeArrow = -1;


	if (gGpsLastData.checksumValid != 0) {
    1610:	80 91 ab 03 	lds	r24, 0x03AB
    1614:	88 23       	and	r24, r24
    1616:	09 f4       	brne	.+2      	; 0x161a <main+0x9d6>
    1618:	6d cb       	rjmp	.-2342   	; 0xcf4 <main+0xb0>

		gGpsLastValidData = gGpsLastData;
    161a:	aa eb       	ldi	r26, 0xBA	; 186
    161c:	b3 e0       	ldi	r27, 0x03	; 3
    161e:	e3 e9       	ldi	r30, 0x93	; 147
    1620:	f3 e0       	ldi	r31, 0x03	; 3
    1622:	89 e1       	ldi	r24, 0x19	; 25
    1624:	01 90       	ld	r0, Z+
    1626:	0d 92       	st	X+, r0
    1628:	81 50       	subi	r24, 0x01	; 1
    162a:	e1 f7       	brne	.-8      	; 0x1624 <main+0x9e0>
		gGpsValidData = 1;
    162c:	81 e0       	ldi	r24, 0x01	; 1
    162e:	80 93 d4 03 	sts	0x03D4, r24
		gLastFix = gTime;
    1632:	80 91 d5 03 	lds	r24, 0x03D5
    1636:	90 91 d6 03 	lds	r25, 0x03D6
    163a:	90 93 d8 03 	sts	0x03D8, r25
    163e:	80 93 d7 03 	sts	0x03D7, r24
    1642:	58 cb       	rjmp	.-2384   	; 0xcf4 <main+0xb0>
#else //ADC_ENABLED

static uint8_t calcGenericVoltageLevel(uint8_t adcInput, uint16_t inMin, uint16_t inMax, uint16_t outMin, uint16_t outMax) {
	uint16_t level = ((gAnalogInputs[adcInput].high * 100) + gAnalogInputs[adcInput].low);
	if (level > inMax) {
		level = outMax;
    1644:	64 e6       	ldi	r22, 0x64	; 100
    1646:	70 e0       	ldi	r23, 0x00	; 0
    1648:	15 cf       	rjmp	.-470    	; 0x1474 <main+0x830>
	a = (a * (GRAPHICS_SIZE / 3)) / 100;
	b = (b * (GRAPHICS_SIZE / 3)) / 100;
	drawLine(GRAPHICS_MID - b, GRAPHICS_MID + a, GRAPHICS_MID + b, GRAPHICS_MID - a); //Direction line
	//drawLine(GRAPHICS_MID_X + a/2, GRAPHICS_MID_X + b/2, GRAPHICS_MID_X - a/2, GRAPHICS_MID_X - b/2); //Arrow bottom line
	drawLine(GRAPHICS_MID + b, GRAPHICS_MID - a, GRAPHICS_MID - a/2, GRAPHICS_MID - b/2); // Arrow "wings"
	drawLine(GRAPHICS_MID + b, GRAPHICS_MID - a, GRAPHICS_MID + a/2, GRAPHICS_MID + b/2);
    164a:	0f 5f       	subi	r16, 0xFF	; 255
    164c:	1f 4f       	sbci	r17, 0xFF	; 255
    164e:	82 cd       	rjmp	.-1276   	; 0x1154 <main+0x510>
    1650:	08 94       	sec
    1652:	81 1c       	adc	r8, r1
    1654:	91 1c       	adc	r9, r1
    1656:	78 cd       	rjmp	.-1296   	; 0x1148 <main+0x504>
	int16_t b = mySin(angle);
	a = (a * (GRAPHICS_SIZE / 3)) / 100;
	b = (b * (GRAPHICS_SIZE / 3)) / 100;
	drawLine(GRAPHICS_MID - b, GRAPHICS_MID + a, GRAPHICS_MID + b, GRAPHICS_MID - a); //Direction line
	//drawLine(GRAPHICS_MID_X + a/2, GRAPHICS_MID_X + b/2, GRAPHICS_MID_X - a/2, GRAPHICS_MID_X - b/2); //Arrow bottom line
	drawLine(GRAPHICS_MID + b, GRAPHICS_MID - a, GRAPHICS_MID - a/2, GRAPHICS_MID - b/2); // Arrow "wings"
    1658:	01 96       	adiw	r24, 0x01	; 1
    165a:	6a cd       	rjmp	.-1324   	; 0x1130 <main+0x4ec>
    165c:	01 96       	adiw	r24, 0x01	; 1
    165e:	5e cd       	rjmp	.-1348   	; 0x111c <main+0x4d8>
#ifdef DEBUG
  //testCalcHome();
#endif // DEBUG
  
	if (gHomePosSet) {
	  calcHome(gGpsLastValidData.pos.latitude,
    1660:	e0 90 ba 03 	lds	r14, 0x03BA
    1664:	f0 90 bb 03 	lds	r15, 0x03BB
    1668:	00 91 bc 03 	lds	r16, 0x03BC
    166c:	10 91 bd 03 	lds	r17, 0x03BD
    1670:	60 90 be 03 	lds	r6, 0x03BE
    1674:	70 90 bf 03 	lds	r7, 0x03BF
    1678:	80 90 c0 03 	lds	r8, 0x03C0
    167c:	90 90 c1 03 	lds	r9, 0x03C1
    1680:	a0 90 da 03 	lds	r10, 0x03DA
    1684:	b0 90 db 03 	lds	r11, 0x03DB
    1688:	c0 90 dc 03 	lds	r12, 0x03DC
    168c:	d0 90 dd 03 	lds	r13, 0x03DD
    1690:	20 91 de 03 	lds	r18, 0x03DE
    1694:	30 91 df 03 	lds	r19, 0x03DF
    1698:	40 91 e0 03 	lds	r20, 0x03E0
    169c:	50 91 e1 03 	lds	r21, 0x03E1
    16a0:	29 83       	std	Y+1, r18	; 0x01
    16a2:	3a 83       	std	Y+2, r19	; 0x02
    16a4:	4b 83       	std	Y+3, r20	; 0x03
    16a6:	5c 83       	std	Y+4, r21	; 0x04

  // considers flat earth around vehicle and reference

  // Ernani Reis, Aug 2011
  
  if (currLat == homeLat && currLong == homeLong) {
    16a8:	ea 14       	cp	r14, r10
    16aa:	fb 04       	cpc	r15, r11
    16ac:	0c 05       	cpc	r16, r12
    16ae:	1d 05       	cpc	r17, r13
    16b0:	09 f4       	brne	.+2      	; 0x16b4 <main+0xa70>
    16b2:	f2 c1       	rjmp	.+996    	; 0x1a98 <main+0xe54>
  int32_t deltaLat; 
  int32_t deltaLong;
  uint32_t distance;
  uint16_t bearing;
      
  c = myCos(absi32(homeLat + currLat) / 2000000); // c ~ cos(lat) -> long to fix the delta
    16b4:	c6 01       	movw	r24, r12
    16b6:	b5 01       	movw	r22, r10
    16b8:	6e 0d       	add	r22, r14
    16ba:	7f 1d       	adc	r23, r15
    16bc:	80 1f       	adc	r24, r16
    16be:	91 1f       	adc	r25, r17
#ifndef COMMONUTILS_H_
#define COMMONUTILS_H_

// abs seems to only support 16 bits so I had to make my own.
static uint32_t absi32(int32_t a) {
	return (a > 0) ? a : -a;
    16c0:	97 fd       	sbrc	r25, 7
    16c2:	0c c2       	rjmp	.+1048   	; 0x1adc <main+0xe98>
    16c4:	20 e8       	ldi	r18, 0x80	; 128
    16c6:	34 e8       	ldi	r19, 0x84	; 132
    16c8:	4e e1       	ldi	r20, 0x1E	; 30
    16ca:	50 e0       	ldi	r21, 0x00	; 0
    16cc:	28 d4       	rcall	.+2128   	; 0x1f1e <__udivmodsi4>
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
}

static int8_t myCos(uint16_t angle) {
	return mySin(angle + 90);
    16ce:	c9 01       	movw	r24, r18
    16d0:	86 5a       	subi	r24, 0xA6	; 166
    16d2:	9f 4f       	sbci	r25, 0xFF	; 255
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    16d4:	68 e6       	ldi	r22, 0x68	; 104
    16d6:	71 e0       	ldi	r23, 0x01	; 1
    16d8:	fb d3       	rcall	.+2038   	; 0x1ed0 <__udivmodhi4>
	int8_t mult = 1;
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    16da:	84 3b       	cpi	r24, 0xB4	; 180
    16dc:	91 05       	cpc	r25, r1
    16de:	08 f4       	brcc	.+2      	; 0x16e2 <main+0xa9e>
    16e0:	fa c1       	rjmp	.+1012   	; 0x1ad6 <main+0xe92>
		pos = pos - 180;
    16e2:	84 5b       	subi	r24, 0xB4	; 180
    16e4:	90 40       	sbci	r25, 0x00	; 0
		mult = -1;
    16e6:	33 24       	eor	r3, r3
    16e8:	3a 94       	dec	r3
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
    16ea:	8a 35       	cpi	r24, 0x5A	; 90
    16ec:	91 05       	cpc	r25, r1
    16ee:	30 f0       	brcs	.+12     	; 0x16fc <main+0xab8>
		pos = 180 - pos;
    16f0:	24 eb       	ldi	r18, 0xB4	; 180
    16f2:	30 e0       	ldi	r19, 0x00	; 0
    16f4:	a9 01       	movw	r20, r18
    16f6:	48 1b       	sub	r20, r24
    16f8:	59 0b       	sbc	r21, r25
    16fa:	ca 01       	movw	r24, r20
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
    16fc:	8c 5c       	subi	r24, 0xCC	; 204
    16fe:	9f 4f       	sbci	r25, 0xFF	; 255
    1700:	fc 01       	movw	r30, r24
    1702:	24 90       	lpm	r2, Z+

  int32_t currLatSec100 = wgs84ToSec100(currLat); // Convert wgs84 to sec * 100
    1704:	c8 01       	movw	r24, r16
    1706:	b7 01       	movw	r22, r14
    1708:	df d4       	rcall	.+2494   	; 0x20c8 <__data_load_end+0x60>
    170a:	6d 83       	std	Y+5, r22	; 0x05
    170c:	7e 83       	std	Y+6, r23	; 0x06
    170e:	8f 83       	std	Y+7, r24	; 0x07
    1710:	98 87       	std	Y+8, r25	; 0x08
  int32_t homeLatSec100 = wgs84ToSec100(homeLat);
    1712:	c6 01       	movw	r24, r12
    1714:	b5 01       	movw	r22, r10
    1716:	d8 d4       	rcall	.+2480   	; 0x20c8 <__data_load_end+0x60>
    1718:	5b 01       	movw	r10, r22
    171a:	6c 01       	movw	r12, r24
  int32_t currLongSec100 = wgs84ToSec100(currLong);
    171c:	c4 01       	movw	r24, r8
    171e:	b3 01       	movw	r22, r6
    1720:	d3 d4       	rcall	.+2470   	; 0x20c8 <__data_load_end+0x60>
    1722:	7b 01       	movw	r14, r22
    1724:	8c 01       	movw	r16, r24
  int32_t homeLongSec100 = wgs84ToSec100(homeLong);
    1726:	69 81       	ldd	r22, Y+1	; 0x01
    1728:	7a 81       	ldd	r23, Y+2	; 0x02
    172a:	8b 81       	ldd	r24, Y+3	; 0x03
    172c:	9c 81       	ldd	r25, Y+4	; 0x04
    172e:	cc d4       	rcall	.+2456   	; 0x20c8 <__data_load_end+0x60>
    1730:	9b 01       	movw	r18, r22
    1732:	ac 01       	movw	r20, r24

  deltaLong = homeLongSec100 - currLongSec100; // Calculate deltas
    1734:	2e 19       	sub	r18, r14
    1736:	3f 09       	sbc	r19, r15
    1738:	40 0b       	sbc	r20, r16
    173a:	51 0b       	sbc	r21, r17
  deltaLat = homeLatSec100 - currLatSec100; // delta long ainda com erro (Delta still long with error?)
    173c:	ed 80       	ldd	r14, Y+5	; 0x05
    173e:	fe 80       	ldd	r15, Y+6	; 0x06
    1740:	0f 81       	ldd	r16, Y+7	; 0x07
    1742:	18 85       	ldd	r17, Y+8	; 0x08
    1744:	ae 18       	sub	r10, r14
    1746:	bf 08       	sbc	r11, r15
    1748:	c0 0a       	sbc	r12, r16
    174a:	d1 0a       	sbc	r13, r17
    174c:	23 9c       	mul	r2, r3
    174e:	60 2d       	mov	r22, r0
    1750:	11 24       	eor	r1, r1

  deltaLong = deltaLong * c;   // corrige dla p/ lat da regio
    1752:	77 27       	eor	r23, r23
    1754:	67 fd       	sbrc	r22, 7
    1756:	70 95       	com	r23
    1758:	87 2f       	mov	r24, r23
    175a:	97 2f       	mov	r25, r23
    175c:	8e d3       	rcall	.+1820   	; 0x1e7a <__mulsi3>
  deltaLong = deltaLong / 100; // cosine is 0-100 so divide with 100
    175e:	24 e6       	ldi	r18, 0x64	; 100
    1760:	30 e0       	ldi	r19, 0x00	; 0
    1762:	40 e0       	ldi	r20, 0x00	; 0
    1764:	50 e0       	ldi	r21, 0x00	; 0
    1766:	fd d3       	rcall	.+2042   	; 0x1f62 <__divmodsi4>
    1768:	79 01       	movw	r14, r18
    176a:	8a 01       	movw	r16, r20

  // Make sure we don't go over uin32_t when doing sqr of deltaLong & deltaLat
  uint8_t mult = 1;
    176c:	33 24       	eor	r3, r3
    176e:	33 94       	inc	r3
    1770:	28 c0       	rjmp	.+80     	; 0x17c2 <main+0xb7e>
  while ((absi32(deltaLong) >= 0xFFFF) 
    1772:	2f ef       	ldi	r18, 0xFF	; 255
    1774:	62 16       	cp	r6, r18
    1776:	2f ef       	ldi	r18, 0xFF	; 255
    1778:	72 06       	cpc	r7, r18
    177a:	20 e0       	ldi	r18, 0x00	; 0
    177c:	82 06       	cpc	r8, r18
    177e:	20 e0       	ldi	r18, 0x00	; 0
    1780:	92 06       	cpc	r9, r18
    1782:	60 f4       	brcc	.+24     	; 0x179c <main+0xb58>
    1784:	d6 01       	movw	r26, r12
    1786:	c5 01       	movw	r24, r10
    1788:	d7 fc       	sbrc	r13, 7
    178a:	27 c0       	rjmp	.+78     	; 0x17da <main+0xb96>
         || (absi32(deltaLat) >= 0xFFFF)) {
    178c:	8f 3f       	cpi	r24, 0xFF	; 255
    178e:	3f ef       	ldi	r19, 0xFF	; 255
    1790:	93 07       	cpc	r25, r19
    1792:	30 e0       	ldi	r19, 0x00	; 0
    1794:	a3 07       	cpc	r26, r19
    1796:	30 e0       	ldi	r19, 0x00	; 0
    1798:	b3 07       	cpc	r27, r19
    179a:	38 f1       	brcs	.+78     	; 0x17ea <main+0xba6>
	  deltaLong /= 2;
    179c:	c8 01       	movw	r24, r16
    179e:	b7 01       	movw	r22, r14
    17a0:	22 e0       	ldi	r18, 0x02	; 2
    17a2:	30 e0       	ldi	r19, 0x00	; 0
    17a4:	40 e0       	ldi	r20, 0x00	; 0
    17a6:	50 e0       	ldi	r21, 0x00	; 0
    17a8:	dc d3       	rcall	.+1976   	; 0x1f62 <__divmodsi4>
    17aa:	79 01       	movw	r14, r18
    17ac:	8a 01       	movw	r16, r20
	  deltaLat /= 2;
    17ae:	c6 01       	movw	r24, r12
    17b0:	b5 01       	movw	r22, r10
    17b2:	22 e0       	ldi	r18, 0x02	; 2
    17b4:	30 e0       	ldi	r19, 0x00	; 0
    17b6:	40 e0       	ldi	r20, 0x00	; 0
    17b8:	50 e0       	ldi	r21, 0x00	; 0
    17ba:	d3 d3       	rcall	.+1958   	; 0x1f62 <__divmodsi4>
    17bc:	59 01       	movw	r10, r18
    17be:	6a 01       	movw	r12, r20
	  mult *= 2;
    17c0:	33 0c       	add	r3, r3
    17c2:	37 01       	movw	r6, r14
    17c4:	48 01       	movw	r8, r16
    17c6:	17 ff       	sbrs	r17, 7
    17c8:	d4 cf       	rjmp	.-88     	; 0x1772 <main+0xb2e>
    17ca:	66 24       	eor	r6, r6
    17cc:	77 24       	eor	r7, r7
    17ce:	43 01       	movw	r8, r6
    17d0:	6e 18       	sub	r6, r14
    17d2:	7f 08       	sbc	r7, r15
    17d4:	80 0a       	sbc	r8, r16
    17d6:	91 0a       	sbc	r9, r17
    17d8:	cc cf       	rjmp	.-104    	; 0x1772 <main+0xb2e>
    17da:	88 27       	eor	r24, r24
    17dc:	99 27       	eor	r25, r25
    17de:	dc 01       	movw	r26, r24
    17e0:	8a 19       	sub	r24, r10
    17e2:	9b 09       	sbc	r25, r11
    17e4:	ac 09       	sbc	r26, r12
    17e6:	bd 09       	sbc	r27, r13
    17e8:	d1 cf       	rjmp	.-94     	; 0x178c <main+0xb48>
    17ea:	89 87       	std	Y+9, r24	; 0x09
    17ec:	9a 87       	std	Y+10, r25	; 0x0a
    17ee:	ab 87       	std	Y+11, r26	; 0x0b
    17f0:	bc 87       	std	Y+12, r27	; 0x0c
  }
  
  uint32_t a = (deltaLong * deltaLong);
    17f2:	c8 01       	movw	r24, r16
    17f4:	b7 01       	movw	r22, r14
    17f6:	a8 01       	movw	r20, r16
    17f8:	97 01       	movw	r18, r14
    17fa:	3f d3       	rcall	.+1662   	; 0x1e7a <__mulsi3>
    17fc:	69 83       	std	Y+1, r22	; 0x01
    17fe:	7a 83       	std	Y+2, r23	; 0x02
    1800:	8b 83       	std	Y+3, r24	; 0x03
    1802:	9c 83       	std	Y+4, r25	; 0x04
  uint32_t b = (deltaLat * deltaLat);
    1804:	c6 01       	movw	r24, r12
    1806:	b5 01       	movw	r22, r10
    1808:	a6 01       	movw	r20, r12
    180a:	95 01       	movw	r18, r10
    180c:	36 d3       	rcall	.+1644   	; 0x1e7a <__mulsi3>
    180e:	69 8b       	std	Y+17, r22	; 0x11
    1810:	7a 8b       	std	Y+18, r23	; 0x12
    1812:	8b 8b       	std	Y+19, r24	; 0x13
    1814:	9c 8b       	std	Y+20, r25	; 0x14

  // Make sure that the squared deltas don't go over uin32_t when adding them together.
  // This should only activate at long distances!
  uint8_t mult2 = 1;
  while ((a >> 24) + (b >> 24) > 0xFF) {
    1816:	69 81       	ldd	r22, Y+1	; 0x01
    1818:	7a 81       	ldd	r23, Y+2	; 0x02
    181a:	8b 81       	ldd	r24, Y+3	; 0x03
    181c:	9c 81       	ldd	r25, Y+4	; 0x04
    181e:	49 2f       	mov	r20, r25
    1820:	55 27       	eor	r21, r21
    1822:	66 27       	eor	r22, r22
    1824:	77 27       	eor	r23, r23
    1826:	89 89       	ldd	r24, Y+17	; 0x11
    1828:	9a 89       	ldd	r25, Y+18	; 0x12
    182a:	ab 89       	ldd	r26, Y+19	; 0x13
    182c:	bc 89       	ldd	r27, Y+20	; 0x14
    182e:	8b 2f       	mov	r24, r27
    1830:	99 27       	eor	r25, r25
    1832:	aa 27       	eor	r26, r26
    1834:	bb 27       	eor	r27, r27
    1836:	8d 87       	std	Y+13, r24	; 0x0d
    1838:	9e 87       	std	Y+14, r25	; 0x0e
    183a:	af 87       	std	Y+15, r26	; 0x0f
    183c:	b8 8b       	std	Y+16, r27	; 0x10
    183e:	48 0f       	add	r20, r24
    1840:	59 1f       	adc	r21, r25
    1842:	6a 1f       	adc	r22, r26
    1844:	7b 1f       	adc	r23, r27
    1846:	4f 3f       	cpi	r20, 0xFF	; 255
    1848:	51 05       	cpc	r21, r1
    184a:	61 05       	cpc	r22, r1
    184c:	71 05       	cpc	r23, r1
    184e:	09 f0       	breq	.+2      	; 0x1852 <main+0xc0e>
    1850:	08 f4       	brcc	.+2      	; 0x1854 <main+0xc10>
    1852:	4c c1       	rjmp	.+664    	; 0x1aec <main+0xea8>
    1854:	22 24       	eor	r2, r2
    1856:	23 94       	inc	r2
    1858:	29 89       	ldd	r18, Y+17	; 0x11
    185a:	3a 89       	ldd	r19, Y+18	; 0x12
    185c:	4b 89       	ldd	r20, Y+19	; 0x13
    185e:	5c 89       	ldd	r21, Y+20	; 0x14
    1860:	ed 82       	std	Y+5, r14	; 0x05
    1862:	fe 82       	std	Y+6, r15	; 0x06
    1864:	0f 83       	std	Y+7, r16	; 0x07
    1866:	18 87       	std	Y+8, r17	; 0x08
    1868:	ad 86       	std	Y+13, r10	; 0x0d
    186a:	be 86       	std	Y+14, r11	; 0x0e
    186c:	cf 86       	std	Y+15, r12	; 0x0f
    186e:	d8 8a       	std	Y+16, r13	; 0x10
    a /= 4;
    1870:	a9 80       	ldd	r10, Y+1	; 0x01
    1872:	ba 80       	ldd	r11, Y+2	; 0x02
    1874:	cb 80       	ldd	r12, Y+3	; 0x03
    1876:	dc 80       	ldd	r13, Y+4	; 0x04
    1878:	d6 94       	lsr	r13
    187a:	c7 94       	ror	r12
    187c:	b7 94       	ror	r11
    187e:	a7 94       	ror	r10
    1880:	d6 94       	lsr	r13
    1882:	c7 94       	ror	r12
    1884:	b7 94       	ror	r11
    1886:	a7 94       	ror	r10
    1888:	a9 82       	std	Y+1, r10	; 0x01
    188a:	ba 82       	std	Y+2, r11	; 0x02
    188c:	cb 82       	std	Y+3, r12	; 0x03
    188e:	dc 82       	std	Y+4, r13	; 0x04
    b /= 4;
    1890:	56 95       	lsr	r21
    1892:	47 95       	ror	r20
    1894:	37 95       	ror	r19
    1896:	27 95       	ror	r18
    1898:	56 95       	lsr	r21
    189a:	47 95       	ror	r20
    189c:	37 95       	ror	r19
    189e:	27 95       	ror	r18
    mult2 *= 2;
    18a0:	22 0c       	add	r2, r2
  uint32_t b = (deltaLat * deltaLat);

  // Make sure that the squared deltas don't go over uin32_t when adding them together.
  // This should only activate at long distances!
  uint8_t mult2 = 1;
  while ((a >> 24) + (b >> 24) > 0xFF) {
    18a2:	e5 2e       	mov	r14, r21
    18a4:	ff 24       	eor	r15, r15
    18a6:	00 27       	eor	r16, r16
    18a8:	11 27       	eor	r17, r17
    18aa:	8d 2d       	mov	r24, r13
    18ac:	99 27       	eor	r25, r25
    18ae:	aa 27       	eor	r26, r26
    18b0:	bb 27       	eor	r27, r27
    18b2:	e8 0e       	add	r14, r24
    18b4:	f9 1e       	adc	r15, r25
    18b6:	0a 1f       	adc	r16, r26
    18b8:	1b 1f       	adc	r17, r27
    18ba:	6f ef       	ldi	r22, 0xFF	; 255
    18bc:	e6 16       	cp	r14, r22
    18be:	f1 04       	cpc	r15, r1
    18c0:	01 05       	cpc	r16, r1
    18c2:	11 05       	cpc	r17, r1
    18c4:	09 f0       	breq	.+2      	; 0x18c8 <main+0xc84>
    18c6:	a0 f6       	brcc	.-88     	; 0x1870 <main+0xc2c>
    18c8:	29 8b       	std	Y+17, r18	; 0x11
    18ca:	3a 8b       	std	Y+18, r19	; 0x12
    18cc:	4b 8b       	std	Y+19, r20	; 0x13
    18ce:	5c 8b       	std	Y+20, r21	; 0x14
    18d0:	ed 80       	ldd	r14, Y+5	; 0x05
    18d2:	fe 80       	ldd	r15, Y+6	; 0x06
    18d4:	0f 81       	ldd	r16, Y+7	; 0x07
    18d6:	18 85       	ldd	r17, Y+8	; 0x08
    18d8:	ad 84       	ldd	r10, Y+13	; 0x0d
    18da:	be 84       	ldd	r11, Y+14	; 0x0e
    18dc:	cf 84       	ldd	r12, Y+15	; 0x0f
    18de:	d8 88       	ldd	r13, Y+16	; 0x10
    a /= 4;
    b /= 4;
    mult2 *= 2;
  }
  
  distance = calcSqrt(a + b);
    18e0:	89 81       	ldd	r24, Y+1	; 0x01
    18e2:	9a 81       	ldd	r25, Y+2	; 0x02
    18e4:	ab 81       	ldd	r26, Y+3	; 0x03
    18e6:	bc 81       	ldd	r27, Y+4	; 0x04
    18e8:	29 89       	ldd	r18, Y+17	; 0x11
    18ea:	3a 89       	ldd	r19, Y+18	; 0x12
    18ec:	4b 89       	ldd	r20, Y+19	; 0x13
    18ee:	5c 89       	ldd	r21, Y+20	; 0x14
    18f0:	82 0f       	add	r24, r18
    18f2:	93 1f       	adc	r25, r19
    18f4:	a4 1f       	adc	r26, r20
    18f6:	b5 1f       	adc	r27, r21
    18f8:	89 83       	std	Y+1, r24	; 0x01
    18fa:	9a 83       	std	Y+2, r25	; 0x02
    18fc:	ab 83       	std	Y+3, r26	; 0x03
    18fe:	bc 83       	std	Y+4, r27	; 0x04
}

static uint32_t calcSqrt(uint32_t input)
{
  int32_t nv;
  int32_t v = input>>1;
    1900:	b6 95       	lsr	r27
    1902:	a7 95       	ror	r26
    1904:	97 95       	ror	r25
    1906:	87 95       	ror	r24
    1908:	8d 83       	std	Y+5, r24	; 0x05
    190a:	9e 83       	std	Y+6, r25	; 0x06
    190c:	af 83       	std	Y+7, r26	; 0x07
    190e:	b8 87       	std	Y+8, r27	; 0x08
  int32_t c = 0;
  if (!v) {
    1910:	00 97       	sbiw	r24, 0x00	; 0
    1912:	a1 05       	cpc	r26, r1
    1914:	b1 05       	cpc	r27, r1
    1916:	09 f4       	brne	.+2      	; 0x191a <main+0xcd6>
    1918:	d2 c0       	rjmp	.+420    	; 0x1abe <main+0xe7a>
    191a:	80 e0       	ldi	r24, 0x00	; 0
    191c:	90 e0       	ldi	r25, 0x00	; 0
    191e:	9e 87       	std	Y+14, r25	; 0x0e
    1920:	8d 87       	std	Y+13, r24	; 0x0d
    1922:	0c c0       	rjmp	.+24     	; 0x193c <main+0xcf8>
    return input;
  }	
  do {
    nv = (v + input / v)>>1;
    if (absu32(v - nv) <= 1) {
    1924:	8d 85       	ldd	r24, Y+13	; 0x0d
    1926:	9e 85       	ldd	r25, Y+14	; 0x0e
    1928:	01 96       	adiw	r24, 0x01	; 1
    192a:	9e 87       	std	Y+14, r25	; 0x0e
    192c:	8d 87       	std	Y+13, r24	; 0x0d
      return nv;
	  }	  
    v = nv;
  } while (c++ < 25);
    192e:	8a 31       	cpi	r24, 0x1A	; 26
    1930:	91 05       	cpc	r25, r1
    1932:	21 f1       	breq	.+72     	; 0x197c <main+0xd38>
  do {
    nv = (v + input / v)>>1;
    if (absu32(v - nv) <= 1) {
      return nv;
	  }	  
    v = nv;
    1934:	2d 83       	std	Y+5, r18	; 0x05
    1936:	3e 83       	std	Y+6, r19	; 0x06
    1938:	4f 83       	std	Y+7, r20	; 0x07
    193a:	58 87       	std	Y+8, r21	; 0x08
  int32_t c = 0;
  if (!v) {
    return input;
  }	
  do {
    nv = (v + input / v)>>1;
    193c:	69 81       	ldd	r22, Y+1	; 0x01
    193e:	7a 81       	ldd	r23, Y+2	; 0x02
    1940:	8b 81       	ldd	r24, Y+3	; 0x03
    1942:	9c 81       	ldd	r25, Y+4	; 0x04
    1944:	2d 81       	ldd	r18, Y+5	; 0x05
    1946:	3e 81       	ldd	r19, Y+6	; 0x06
    1948:	4f 81       	ldd	r20, Y+7	; 0x07
    194a:	58 85       	ldd	r21, Y+8	; 0x08
    194c:	e8 d2       	rcall	.+1488   	; 0x1f1e <__udivmodsi4>
    194e:	6d 81       	ldd	r22, Y+5	; 0x05
    1950:	7e 81       	ldd	r23, Y+6	; 0x06
    1952:	8f 81       	ldd	r24, Y+7	; 0x07
    1954:	98 85       	ldd	r25, Y+8	; 0x08
    1956:	26 0f       	add	r18, r22
    1958:	37 1f       	adc	r19, r23
    195a:	48 1f       	adc	r20, r24
    195c:	59 1f       	adc	r21, r25
    195e:	56 95       	lsr	r21
    1960:	47 95       	ror	r20
    1962:	37 95       	ror	r19
    1964:	27 95       	ror	r18
    if (absu32(v - nv) <= 1) {
    1966:	dc 01       	movw	r26, r24
    1968:	cb 01       	movw	r24, r22
    196a:	82 1b       	sub	r24, r18
    196c:	93 0b       	sbc	r25, r19
    196e:	a4 0b       	sbc	r26, r20
    1970:	b5 0b       	sbc	r27, r21
    1972:	82 30       	cpi	r24, 0x02	; 2
    1974:	91 05       	cpc	r25, r1
    1976:	a1 05       	cpc	r26, r1
    1978:	b1 05       	cpc	r27, r1
    197a:	a0 f6       	brcc	.-88     	; 0x1924 <main+0xce0>
    197c:	ca 01       	movw	r24, r20
    197e:	b9 01       	movw	r22, r18
  distance *= mult2;
    1980:	22 2d       	mov	r18, r2
    1982:	30 e0       	ldi	r19, 0x00	; 0
    1984:	40 e0       	ldi	r20, 0x00	; 0
    1986:	50 e0       	ldi	r21, 0x00	; 0
    1988:	78 d2       	rcall	.+1264   	; 0x1e7a <__mulsi3>
    198a:	69 83       	std	Y+1, r22	; 0x01
    198c:	7a 83       	std	Y+2, r23	; 0x02
    198e:	8b 83       	std	Y+3, r24	; 0x03
    1990:	9c 83       	std	Y+4, r25	; 0x04

  // Only calculate bearing if bearing pointer is set.
  if (bearingResult != NULL) {
    bearing = 0;
    if (distance > 0) { // Over home -> do not compute; Home forced to 0
    1992:	61 15       	cp	r22, r1
    1994:	71 05       	cpc	r23, r1
    1996:	81 05       	cpc	r24, r1
    1998:	91 05       	cpc	r25, r1
    199a:	09 f4       	brne	.+2      	; 0x199e <main+0xd5a>
    199c:	46 c0       	rjmp	.+140    	; 0x1a2a <main+0xde6>
      if (absi32(deltaLong) >= absi32(deltaLat)) { // low angle, sine is better
    199e:	29 85       	ldd	r18, Y+9	; 0x09
    19a0:	3a 85       	ldd	r19, Y+10	; 0x0a
    19a2:	4b 85       	ldd	r20, Y+11	; 0x0b
    19a4:	5c 85       	ldd	r21, Y+12	; 0x0c
    19a6:	62 16       	cp	r6, r18
    19a8:	73 06       	cpc	r7, r19
    19aa:	84 06       	cpc	r8, r20
    19ac:	95 06       	cpc	r9, r21
    19ae:	08 f4       	brcc	.+2      	; 0x19b2 <main+0xd6e>
    19b0:	a0 c0       	rjmp	.+320    	; 0x1af2 <main+0xeae>
        c = (absi32(deltaLat) * 100) / distance; // computes sine -> dist > 0
    19b2:	ca 01       	movw	r24, r20
    19b4:	b9 01       	movw	r22, r18
    19b6:	24 e6       	ldi	r18, 0x64	; 100
    19b8:	30 e0       	ldi	r19, 0x00	; 0
    19ba:	40 e0       	ldi	r20, 0x00	; 0
    19bc:	50 e0       	ldi	r21, 0x00	; 0
    19be:	5d d2       	rcall	.+1210   	; 0x1e7a <__mulsi3>
    19c0:	29 81       	ldd	r18, Y+1	; 0x01
    19c2:	3a 81       	ldd	r19, Y+2	; 0x02
    19c4:	4b 81       	ldd	r20, Y+3	; 0x03
    19c6:	5c 81       	ldd	r21, Y+4	; 0x04
    19c8:	aa d2       	rcall	.+1364   	; 0x1f1e <__udivmodsi4>
    19ca:	62 2e       	mov	r6, r18
  distance = calcSqrt(a + b);
  distance *= mult2;

  // Only calculate bearing if bearing pointer is set.
  if (bearingResult != NULL) {
    bearing = 0;
    19cc:	20 e0       	ldi	r18, 0x00	; 0
    19ce:	30 e0       	ldi	r19, 0x00	; 0
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
	int8_t mult = 1;
    19d0:	41 e0       	ldi	r20, 0x01	; 1
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    19d2:	80 e0       	ldi	r24, 0x00	; 0
    19d4:	90 e0       	ldi	r25, 0x00	; 0
		pos = pos - 180;
		mult = -1;
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
		pos = 180 - pos;
    19d6:	64 eb       	ldi	r22, 0xB4	; 180
    19d8:	86 2e       	mov	r8, r22
    19da:	91 2c       	mov	r9, r1
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
    19dc:	8c 5c       	subi	r24, 0xCC	; 204
    19de:	9f 4f       	sbci	r25, 0xFF	; 255
    19e0:	fc 01       	movw	r30, r24
    19e2:	84 91       	lpm	r24, Z+
    19e4:	84 9f       	mul	r24, r20
    19e6:	40 2d       	mov	r20, r0
    19e8:	11 24       	eor	r1, r1
    if (distance > 0) { // Over home -> do not compute; Home forced to 0
      if (absi32(deltaLong) >= absi32(deltaLat)) { // low angle, sine is better
        c = (absi32(deltaLat) * 100) / distance; // computes sine -> dist > 0
        while((mySin(bearing) <= c) && (bearing < 90)) {
    19ea:	64 16       	cp	r6, r20
    19ec:	0c f4       	brge	.+2      	; 0x19f0 <main+0xdac>
    19ee:	49 c0       	rjmp	.+146    	; 0x1a82 <main+0xe3e>
    19f0:	2a 35       	cpi	r18, 0x5A	; 90
    19f2:	31 05       	cpc	r19, r1
    19f4:	09 f4       	brne	.+2      	; 0x19f8 <main+0xdb4>
    19f6:	45 c0       	rjmp	.+138    	; 0x1a82 <main+0xe3e>
          ++bearing;
    19f8:	2f 5f       	subi	r18, 0xFF	; 255
    19fa:	3f 4f       	sbci	r19, 0xFF	; 255
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    19fc:	c9 01       	movw	r24, r18
    19fe:	68 e6       	ldi	r22, 0x68	; 104
    1a00:	71 e0       	ldi	r23, 0x01	; 1
    1a02:	66 d2       	rcall	.+1228   	; 0x1ed0 <__udivmodhi4>
	int8_t mult = 1;
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    1a04:	84 3b       	cpi	r24, 0xB4	; 180
    1a06:	91 05       	cpc	r25, r1
    1a08:	58 f0       	brcs	.+22     	; 0x1a20 <main+0xddc>
		pos = pos - 180;
    1a0a:	84 5b       	subi	r24, 0xB4	; 180
    1a0c:	90 40       	sbci	r25, 0x00	; 0
		mult = -1;
    1a0e:	4f ef       	ldi	r20, 0xFF	; 255
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
    1a10:	8a 35       	cpi	r24, 0x5A	; 90
    1a12:	91 05       	cpc	r25, r1
    1a14:	18 f3       	brcs	.-58     	; 0x19dc <main+0xd98>
		pos = 180 - pos;
    1a16:	b4 01       	movw	r22, r8
    1a18:	68 1b       	sub	r22, r24
    1a1a:	79 0b       	sbc	r23, r25
    1a1c:	cb 01       	movw	r24, r22
    1a1e:	de cf       	rjmp	.-68     	; 0x19dc <main+0xd98>
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
	int8_t mult = 1;
    1a20:	41 e0       	ldi	r20, 0x01	; 1
    1a22:	f6 cf       	rjmp	.-20     	; 0x1a10 <main+0xdcc>
		level *= outMax - outMin;
		level /= inMax - inMin;
		level += outMin;
	}
	else {
		level = outMin;
    1a24:	60 e0       	ldi	r22, 0x00	; 0
    1a26:	70 e0       	ldi	r23, 0x00	; 0
    1a28:	25 cd       	rjmp	.-1462   	; 0x1474 <main+0x830>
  distance = calcSqrt(a + b);
  distance *= mult2;

  // Only calculate bearing if bearing pointer is set.
  if (bearingResult != NULL) {
    bearing = 0;
    1a2a:	80 e0       	ldi	r24, 0x00	; 0
    1a2c:	90 e0       	ldi	r25, 0x00	; 0
	      else { // SW quadrant
          bearing = 270 - bearing;
        }
      }
    }
    *bearingResult = bearing;
    1a2e:	90 93 34 04 	sts	0x0434, r25
    1a32:	80 93 33 04 	sts	0x0433, r24
	}
  distance = distance * 309; // ate aqui em segundo * 100
    1a36:	69 81       	ldd	r22, Y+1	; 0x01
    1a38:	7a 81       	ldd	r23, Y+2	; 0x02
    1a3a:	8b 81       	ldd	r24, Y+3	; 0x03
    1a3c:	9c 81       	ldd	r25, Y+4	; 0x04
    1a3e:	25 e3       	ldi	r18, 0x35	; 53
    1a40:	31 e0       	ldi	r19, 0x01	; 1
    1a42:	40 e0       	ldi	r20, 0x00	; 0
    1a44:	50 e0       	ldi	r21, 0x00	; 0
    1a46:	19 d2       	rcall	.+1074   	; 0x1e7a <__mulsi3>
  distance = distance / 1000; // metros, agora
    1a48:	28 ee       	ldi	r18, 0xE8	; 232
    1a4a:	33 e0       	ldi	r19, 0x03	; 3
    1a4c:	40 e0       	ldi	r20, 0x00	; 0
    1a4e:	50 e0       	ldi	r21, 0x00	; 0
    1a50:	66 d2       	rcall	.+1228   	; 0x1f1e <__udivmodsi4>
    1a52:	79 01       	movw	r14, r18
    1a54:	8a 01       	movw	r16, r20
  distance *= mult;
    1a56:	23 2d       	mov	r18, r3
    1a58:	30 e0       	ldi	r19, 0x00	; 0
    1a5a:	40 e0       	ldi	r20, 0x00	; 0
    1a5c:	50 e0       	ldi	r21, 0x00	; 0
    1a5e:	c8 01       	movw	r24, r16
    1a60:	b7 01       	movw	r22, r14
    1a62:	0b d2       	rcall	.+1046   	; 0x1e7a <__mulsi3>
#ifdef IMPERIAL_SYSTEM  
  distance *= 3281;
	distance /= 1000;
#endif //IMPERIAL_SYSTEM
  *distanceResult = distance;
    1a64:	60 93 2f 04 	sts	0x042F, r22
    1a68:	70 93 30 04 	sts	0x0430, r23
    1a6c:	80 93 31 04 	sts	0x0431, r24
    1a70:	90 93 32 04 	sts	0x0432, r25
    1a74:	37 cc       	rjmp	.-1938   	; 0x12e4 <main+0x6a0>
    1a76:	6d 81       	ldd	r22, Y+5	; 0x05
    1a78:	7e 81       	ldd	r23, Y+6	; 0x06
	    else { // high angle, cosine is better
        c = (absi32(deltaLong) * 100) / distance; // Computes cosine
        while((mySin(bearing) <= c) && (bearing < 90)) {
          ++bearing;
        }
        bearing = 90 - bearing;
    1a7a:	2a e5       	ldi	r18, 0x5A	; 90
    1a7c:	30 e0       	ldi	r19, 0x00	; 0
    1a7e:	26 1b       	sub	r18, r22
    1a80:	37 0b       	sbc	r19, r23
      }
      if (deltaLat == 0) {
    1a82:	a1 14       	cp	r10, r1
    1a84:	b1 04       	cpc	r11, r1
    1a86:	c1 04       	cpc	r12, r1
    1a88:	d1 04       	cpc	r13, r1
    1a8a:	09 f0       	breq	.+2      	; 0x1a8e <main+0xe4a>
    1a8c:	77 c0       	rjmp	.+238    	; 0x1b7c <main+0xf38>
        if (deltaLong >= 0) { // Home = East
    1a8e:	17 fd       	sbrc	r17, 7
    1a90:	72 c0       	rjmp	.+228    	; 0x1b76 <main+0xf32>
          bearing = 90; 
    1a92:	8a e5       	ldi	r24, 0x5A	; 90
    1a94:	90 e0       	ldi	r25, 0x00	; 0
    1a96:	cb cf       	rjmp	.-106    	; 0x1a2e <main+0xdea>

  // considers flat earth around vehicle and reference

  // Ernani Reis, Aug 2011
  
  if (currLat == homeLat && currLong == homeLong) {
    1a98:	62 16       	cp	r6, r18
    1a9a:	73 06       	cpc	r7, r19
    1a9c:	84 06       	cpc	r8, r20
    1a9e:	95 06       	cpc	r9, r21
    1aa0:	09 f0       	breq	.+2      	; 0x1aa4 <main+0xe60>
    1aa2:	08 ce       	rjmp	.-1008   	; 0x16b4 <main+0xa70>
	  *distanceResult = 0;
    1aa4:	10 92 2f 04 	sts	0x042F, r1
    1aa8:	10 92 30 04 	sts	0x0430, r1
    1aac:	10 92 31 04 	sts	0x0431, r1
    1ab0:	10 92 32 04 	sts	0x0432, r1
	  *bearingResult = 0;
    1ab4:	10 92 34 04 	sts	0x0434, r1
    1ab8:	10 92 33 04 	sts	0x0433, r1
    1abc:	13 cc       	rjmp	.-2010   	; 0x12e4 <main+0x6a0>
{
  int32_t nv;
  int32_t v = input>>1;
  int32_t c = 0;
  if (!v) {
    return input;
    1abe:	69 81       	ldd	r22, Y+1	; 0x01
    1ac0:	7a 81       	ldd	r23, Y+2	; 0x02
    1ac2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ac4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ac6:	5c cf       	rjmp	.-328    	; 0x1980 <main+0xd3c>
static void finishGpsDecoding() {
	
if (gGpsLastData.pos.altitude > gGpsLastValidData.pos.altitude) 
altitudeArrow = 1;
		
else if (gGpsLastData.pos.altitude < gGpsLastValidData.pos.altitude)
    1ac8:	28 17       	cp	r18, r24
    1aca:	39 07       	cpc	r19, r25
    1acc:	0c f0       	brlt	.+2      	; 0x1ad0 <main+0xe8c>
    1ace:	a0 cd       	rjmp	.-1216   	; 0x1610 <main+0x9cc>
altitudeArrow = -1;
    1ad0:	40 93 d3 03 	sts	0x03D3, r20
    1ad4:	9d cd       	rjmp	.-1222   	; 0x1610 <main+0x9cc>
    1ad6:	33 24       	eor	r3, r3
    1ad8:	33 94       	inc	r3
    1ada:	07 ce       	rjmp	.-1010   	; 0x16ea <main+0xaa6>
#ifndef COMMONUTILS_H_
#define COMMONUTILS_H_

// abs seems to only support 16 bits so I had to make my own.
static uint32_t absi32(int32_t a) {
	return (a > 0) ? a : -a;
    1adc:	90 95       	com	r25
    1ade:	80 95       	com	r24
    1ae0:	70 95       	com	r23
    1ae2:	61 95       	neg	r22
    1ae4:	7f 4f       	sbci	r23, 0xFF	; 255
    1ae6:	8f 4f       	sbci	r24, 0xFF	; 255
    1ae8:	9f 4f       	sbci	r25, 0xFF	; 255
    1aea:	ec cd       	rjmp	.-1064   	; 0x16c4 <main+0xa80>
  uint32_t a = (deltaLong * deltaLong);
  uint32_t b = (deltaLat * deltaLat);

  // Make sure that the squared deltas don't go over uin32_t when adding them together.
  // This should only activate at long distances!
  uint8_t mult2 = 1;
    1aec:	22 24       	eor	r2, r2
    1aee:	23 94       	inc	r2
    1af0:	f7 ce       	rjmp	.-530    	; 0x18e0 <main+0xc9c>
        while((mySin(bearing) <= c) && (bearing < 90)) {
          ++bearing;
        }
      } 
	    else { // high angle, cosine is better
        c = (absi32(deltaLong) * 100) / distance; // Computes cosine
    1af2:	c4 01       	movw	r24, r8
    1af4:	b3 01       	movw	r22, r6
    1af6:	24 e6       	ldi	r18, 0x64	; 100
    1af8:	30 e0       	ldi	r19, 0x00	; 0
    1afa:	40 e0       	ldi	r20, 0x00	; 0
    1afc:	50 e0       	ldi	r21, 0x00	; 0
    1afe:	bd d1       	rcall	.+890    	; 0x1e7a <__mulsi3>
    1b00:	29 81       	ldd	r18, Y+1	; 0x01
    1b02:	3a 81       	ldd	r19, Y+2	; 0x02
    1b04:	4b 81       	ldd	r20, Y+3	; 0x03
    1b06:	5c 81       	ldd	r21, Y+4	; 0x04
    1b08:	0a d2       	rcall	.+1044   	; 0x1f1e <__udivmodsi4>
    1b0a:	62 2e       	mov	r6, r18
  distance = calcSqrt(a + b);
  distance *= mult2;

  // Only calculate bearing if bearing pointer is set.
  if (bearingResult != NULL) {
    bearing = 0;
    1b0c:	60 e0       	ldi	r22, 0x00	; 0
    1b0e:	70 e0       	ldi	r23, 0x00	; 0
    1b10:	41 e0       	ldi	r20, 0x01	; 1
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    1b12:	80 e0       	ldi	r24, 0x00	; 0
    1b14:	90 e0       	ldi	r25, 0x00	; 0
    1b16:	28 e6       	ldi	r18, 0x68	; 104
    1b18:	31 e0       	ldi	r19, 0x01	; 1
		pos = pos - 180;
		mult = -1;
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
		pos = 180 - pos;
    1b1a:	54 eb       	ldi	r21, 0xB4	; 180
    1b1c:	85 2e       	mov	r8, r21
    1b1e:	91 2c       	mov	r9, r1
    1b20:	7e 83       	std	Y+6, r23	; 0x06
    1b22:	6d 83       	std	Y+5, r22	; 0x05
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
    1b24:	8c 5c       	subi	r24, 0xCC	; 204
    1b26:	9f 4f       	sbci	r25, 0xFF	; 255
    1b28:	fc 01       	movw	r30, r24
    1b2a:	84 91       	lpm	r24, Z+
    1b2c:	84 9f       	mul	r24, r20
    1b2e:	40 2d       	mov	r20, r0
    1b30:	11 24       	eor	r1, r1
          ++bearing;
        }
      } 
	    else { // high angle, cosine is better
        c = (absi32(deltaLong) * 100) / distance; // Computes cosine
        while((mySin(bearing) <= c) && (bearing < 90)) {
    1b32:	64 16       	cp	r6, r20
    1b34:	0c f4       	brge	.+2      	; 0x1b38 <main+0xef4>
    1b36:	9f cf       	rjmp	.-194    	; 0x1a76 <main+0xe32>
    1b38:	4d 81       	ldd	r20, Y+5	; 0x05
    1b3a:	5e 81       	ldd	r21, Y+6	; 0x06
    1b3c:	4a 35       	cpi	r20, 0x5A	; 90
    1b3e:	51 05       	cpc	r21, r1
    1b40:	09 f4       	brne	.+2      	; 0x1b44 <main+0xf00>
    1b42:	99 cf       	rjmp	.-206    	; 0x1a76 <main+0xe32>
          ++bearing;
    1b44:	4d 81       	ldd	r20, Y+5	; 0x05
    1b46:	5e 81       	ldd	r21, Y+6	; 0x06
    1b48:	4f 5f       	subi	r20, 0xFF	; 255
    1b4a:	5f 4f       	sbci	r21, 0xFF	; 255
    1b4c:	5e 83       	std	Y+6, r21	; 0x06
    1b4e:	4d 83       	std	Y+5, r20	; 0x05
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    1b50:	ca 01       	movw	r24, r20
    1b52:	b9 01       	movw	r22, r18
    1b54:	bd d1       	rcall	.+890    	; 0x1ed0 <__udivmodhi4>
	int8_t mult = 1;
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    1b56:	84 3b       	cpi	r24, 0xB4	; 180
    1b58:	91 05       	cpc	r25, r1
    1b5a:	58 f0       	brcs	.+22     	; 0x1b72 <main+0xf2e>
		pos = pos - 180;
    1b5c:	84 5b       	subi	r24, 0xB4	; 180
    1b5e:	90 40       	sbci	r25, 0x00	; 0
		mult = -1;
    1b60:	4f ef       	ldi	r20, 0xFF	; 255
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
    1b62:	8a 35       	cpi	r24, 0x5A	; 90
    1b64:	91 05       	cpc	r25, r1
    1b66:	f0 f2       	brcs	.-68     	; 0x1b24 <main+0xee0>
		pos = 180 - pos;
    1b68:	b4 01       	movw	r22, r8
    1b6a:	68 1b       	sub	r22, r24
    1b6c:	79 0b       	sbc	r23, r25
    1b6e:	cb 01       	movw	r24, r22
    1b70:	d9 cf       	rjmp	.-78     	; 0x1b24 <main+0xee0>
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
	int8_t mult = 1;
    1b72:	41 e0       	ldi	r20, 0x01	; 1
    1b74:	f6 cf       	rjmp	.-20     	; 0x1b62 <main+0xf1e>
      if (deltaLat == 0) {
        if (deltaLong >= 0) { // Home = East
          bearing = 90; 
        } 
	      else { // Home = West
          bearing = 270;
    1b76:	8e e0       	ldi	r24, 0x0E	; 14
    1b78:	91 e0       	ldi	r25, 0x01	; 1
    1b7a:	59 cf       	rjmp	.-334    	; 0x1a2e <main+0xdea>
        }
      } 
      else if (deltaLat > 0) {
    1b7c:	1a 14       	cp	r1, r10
    1b7e:	1b 04       	cpc	r1, r11
    1b80:	1c 04       	cpc	r1, r12
    1b82:	1d 04       	cpc	r1, r13
    1b84:	3c f4       	brge	.+14     	; 0x1b94 <main+0xf50>
        if (deltaLong >= 0) { // NE quadrant
    1b86:	17 fd       	sbrc	r17, 7
    1b88:	0b c0       	rjmp	.+22     	; 0x1ba0 <main+0xf5c>
          bearing = 90 - bearing;
    1b8a:	8a e5       	ldi	r24, 0x5A	; 90
    1b8c:	90 e0       	ldi	r25, 0x00	; 0
    1b8e:	82 1b       	sub	r24, r18
    1b90:	93 0b       	sbc	r25, r19
    1b92:	4d cf       	rjmp	.-358    	; 0x1a2e <main+0xdea>
	      else { // NW quadrant
          bearing = 270 + bearing;
        }
      } 
	    else {
        if (deltaLong >= 0) { // SE quadrant
    1b94:	17 fd       	sbrc	r17, 7
    1b96:	08 c0       	rjmp	.+16     	; 0x1ba8 <main+0xf64>
          bearing = 90 + bearing;
    1b98:	c9 01       	movw	r24, r18
    1b9a:	86 5a       	subi	r24, 0xA6	; 166
    1b9c:	9f 4f       	sbci	r25, 0xFF	; 255
    1b9e:	47 cf       	rjmp	.-370    	; 0x1a2e <main+0xdea>
      else if (deltaLat > 0) {
        if (deltaLong >= 0) { // NE quadrant
          bearing = 90 - bearing;
        } 
	      else { // NW quadrant
          bearing = 270 + bearing;
    1ba0:	c9 01       	movw	r24, r18
    1ba2:	82 5f       	subi	r24, 0xF2	; 242
    1ba4:	9e 4f       	sbci	r25, 0xFE	; 254
    1ba6:	43 cf       	rjmp	.-378    	; 0x1a2e <main+0xdea>
	    else {
        if (deltaLong >= 0) { // SE quadrant
          bearing = 90 + bearing;
        } 
	      else { // SW quadrant
          bearing = 270 - bearing;
    1ba8:	8e e0       	ldi	r24, 0x0E	; 14
    1baa:	91 e0       	ldi	r25, 0x01	; 1
    1bac:	82 1b       	sub	r24, r18
    1bae:	93 0b       	sbc	r25, r19
    1bb0:	3e cf       	rjmp	.-388    	; 0x1a2e <main+0xdea>

00001bb2 <__vector_1>:
			//DDRB &= ~OUT1;
		}
	}
}

ISR(INT0_vect) {
    1bb2:	1f 92       	push	r1
    1bb4:	0f 92       	push	r0
    1bb6:	0f b6       	in	r0, 0x3f	; 63
    1bb8:	0f 92       	push	r0
    1bba:	11 24       	eor	r1, r1
    1bbc:	2f 93       	push	r18
    1bbe:	3f 93       	push	r19
    1bc0:	4f 93       	push	r20
    1bc2:	5f 93       	push	r21
    1bc4:	6f 93       	push	r22
    1bc6:	7f 93       	push	r23
    1bc8:	8f 93       	push	r24
    1bca:	9f 93       	push	r25
    1bcc:	af 93       	push	r26
    1bce:	bf 93       	push	r27
    1bd0:	ef 93       	push	r30
    1bd2:	ff 93       	push	r31
	TCNT1 = 0; // Reset sync lost timeout.
    1bd4:	10 92 85 00 	sts	0x0085, r1
    1bd8:	10 92 84 00 	sts	0x0084, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1bdc:	28 e2       	ldi	r18, 0x28	; 40
    1bde:	2a 95       	dec	r18
    1be0:	f1 f7       	brne	.-4      	; 0x1bde <__vector_1+0x2c>
}  

static void updateLine() {
  _delay_us(5); // wait 5us to see if H or V sync

	if(!(PIND & LTRIG)) { // H sync
    1be2:	4a 99       	sbic	0x09, 2	; 9
    1be4:	7a c0       	rjmp	.+244    	; 0x1cda <__vector_1+0x128>
		if (gActiveLine != 0) {
    1be6:	80 91 72 01 	lds	r24, 0x0172
    1bea:	90 91 73 01 	lds	r25, 0x0173
    1bee:	00 97       	sbiw	r24, 0x00	; 0
    1bf0:	09 f4       	brne	.+2      	; 0x1bf4 <__vector_1+0x42>
    1bf2:	35 c0       	rjmp	.+106    	; 0x1c5e <__vector_1+0xac>
			switch(gLineType) {
    1bf4:	20 91 75 01 	lds	r18, 0x0175
    1bf8:	21 30       	cpi	r18, 0x01	; 1
    1bfa:	09 f4       	brne	.+2      	; 0x1bfe <__vector_1+0x4c>
    1bfc:	91 c0       	rjmp	.+290    	; 0x1d20 <__vector_1+0x16e>
    1bfe:	22 30       	cpi	r18, 0x02	; 2
    1c00:	09 f0       	breq	.+2      	; 0x1c04 <__vector_1+0x52>
    1c02:	2d c0       	rjmp	.+90     	; 0x1c5e <__vector_1+0xac>
    1c04:	e3 e1       	ldi	r30, 0x13	; 19
    1c06:	f1 e0       	ldi	r31, 0x01	; 1
    1c08:	31 97       	sbiw	r30, 0x01	; 1
    1c0a:	f1 f7       	brne	.-4      	; 0x1c08 <__vector_1+0x56>
    1c0c:	00 c0       	rjmp	.+0      	; 0x1c0e <__vector_1+0x5c>
    1c0e:	00 00       	nop
{
#ifdef TEXT_SMALL_ENABLED
	SPSR &= ~(1<<SPI2X); // Set normal speed
#endif //TEXT_SMALL_ENABLED
  _delay_us(GRAPHICS_OFFSET);
  uint16_t currLine = gActivePixmapLine;
    1c10:	e0 91 7a 01 	lds	r30, 0x017A
    1c14:	f0 e0       	ldi	r31, 0x00	; 0
			//DDRB &= ~OUT1;
		}
	}
}

ISR(INT0_vect) {
    1c16:	e7 5b       	subi	r30, 0xB7	; 183
    1c18:	fc 4f       	sbci	r31, 0xFC	; 252
  for (uint8_t i = 0; i < GRAPHICS_WIDTH; ++i) {
    1c1a:	20 e0       	ldi	r18, 0x00	; 0
	  SPDR = gPixelData[i][currLine];
    1c1c:	30 81       	ld	r19, Z
    1c1e:	3e bd       	out	0x2e, r19	; 46
	  DDRB |= OUT1;
    1c20:	21 9a       	sbi	0x04, 1	; 4
	...
	  DELAY_9_NOP();
	  DELAY_9_NOP();
	  DELAY_5_NOP();
    1c4e:	00 00       	nop
#ifdef TEXT_SMALL_ENABLED
	SPSR &= ~(1<<SPI2X); // Set normal speed
#endif //TEXT_SMALL_ENABLED
  _delay_us(GRAPHICS_OFFSET);
  uint16_t currLine = gActivePixmapLine;
  for (uint8_t i = 0; i < GRAPHICS_WIDTH; ++i) {
    1c50:	2f 5f       	subi	r18, 0xFF	; 255
    1c52:	78 96       	adiw	r30, 0x18	; 24
    1c54:	23 30       	cpi	r18, 0x03	; 3
    1c56:	11 f7       	brne	.-60     	; 0x1c1c <__vector_1+0x6a>
	  DDRB |= OUT1;
	  DELAY_9_NOP();
	  DELAY_9_NOP();
	  DELAY_5_NOP();
  }
  DDRB &= ~OUT1;
    1c58:	21 98       	cbi	0x04, 1	; 4
  DELAY_1_NOP();
    1c5a:	00 00       	nop
  SPDR = 0x00;
    1c5c:	1e bc       	out	0x2e, r1	; 46
					break;
			}
		}
		
		// We save some time in beginning of line by pre-calculating next type.
		gLineType = LINE_TYPE_UNKNOWN; // Default case
    1c5e:	10 92 75 01 	sts	0x0175, r1
		gActiveLine++;
    1c62:	01 96       	adiw	r24, 0x01	; 1
    1c64:	90 93 73 01 	sts	0x0173, r25
    1c68:	80 93 72 01 	sts	0x0172, r24
		if (gActiveLine == UPDATE_LINE) {
    1c6c:	8e 36       	cpi	r24, 0x6E	; 110
    1c6e:	91 05       	cpc	r25, r1
    1c70:	09 f4       	brne	.+2      	; 0x1c74 <__vector_1+0xc2>
    1c72:	44 c0       	rjmp	.+136    	; 0x1cfc <__vector_1+0x14a>
			gUpdateScreenData = 1;
		}
		else if (gActiveLine == UPDATE_LINE + 1) {
    1c74:	8f 36       	cpi	r24, 0x6F	; 111
    1c76:	91 05       	cpc	r25, r1
    1c78:	09 f4       	brne	.+2      	; 0x1c7c <__vector_1+0xca>
    1c7a:	8f c0       	rjmp	.+286    	; 0x1d9a <__vector_1+0x1e8>
			gUpdateScreenData = 2;
		}

#ifdef TEXT_ENABLED	
		if (gActiveLine >= gActiveTextLine && gActiveLine < gActiveTextLastLine) {
    1c7c:	40 91 78 01 	lds	r20, 0x0178
    1c80:	50 91 79 01 	lds	r21, 0x0179
    1c84:	84 17       	cp	r24, r20
    1c86:	95 07       	cpc	r25, r21
    1c88:	a0 f1       	brcs	.+104    	; 0x1cf2 <__vector_1+0x140>
    1c8a:	20 91 52 01 	lds	r18, 0x0152
    1c8e:	30 91 53 01 	lds	r19, 0x0153
    1c92:	82 17       	cp	r24, r18
    1c94:	93 07       	cpc	r25, r19
    1c96:	b0 f1       	brcs	.+108    	; 0x1d04 <__vector_1+0x152>
		  gActivePixmapLine = (gActiveLine - gActiveTextLine);
		  if (gActiveTextSize == TEXT_SIZE_LARGE_MULT) {
		    gActivePixmapLine /= TEXT_SIZE_LARGE_MULT;
		  }
		}
		else if (gActiveLine == gActiveTextLastLine) {
    1c98:	82 17       	cp	r24, r18
    1c9a:	93 07       	cpc	r25, r19
    1c9c:	09 f4       	brne	.+2      	; 0x1ca0 <__vector_1+0xee>
    1c9e:	8e c0       	rjmp	.+284    	; 0x1dbc <__vector_1+0x20a>
			gActivePixmapLine = 1;
			return;
		}
#endif //TEXT_ENABLED		
#ifdef GRAPICSENABLED		
		else if (gActiveLine >= GRAPHICS_LINE && gActiveLine < (GRAPHICS_LINE + GRAPHICS_HEIGHT)) {
    1ca0:	9c 01       	movw	r18, r24
    1ca2:	29 56       	subi	r18, 0x69	; 105
    1ca4:	30 40       	sbci	r19, 0x00	; 0
    1ca6:	28 31       	cpi	r18, 0x18	; 24
    1ca8:	31 05       	cpc	r19, r1
    1caa:	30 f4       	brcc	.+12     	; 0x1cb8 <__vector_1+0x106>
			gLineType = LINE_TYPE_GRAPHICS;
    1cac:	22 e0       	ldi	r18, 0x02	; 2
    1cae:	20 93 75 01 	sts	0x0175, r18
			gActivePixmapLine = (gActiveLine - GRAPHICS_LINE);
    1cb2:	89 56       	subi	r24, 0x69	; 105
    1cb4:	80 93 7a 01 	sts	0x017A, r24
	TCNT1 = 0; // Reset sync lost timeout.
	updateLine();
}
    1cb8:	ff 91       	pop	r31
    1cba:	ef 91       	pop	r30
    1cbc:	bf 91       	pop	r27
    1cbe:	af 91       	pop	r26
    1cc0:	9f 91       	pop	r25
    1cc2:	8f 91       	pop	r24
    1cc4:	7f 91       	pop	r23
    1cc6:	6f 91       	pop	r22
    1cc8:	5f 91       	pop	r21
    1cca:	4f 91       	pop	r20
    1ccc:	3f 91       	pop	r19
    1cce:	2f 91       	pop	r18
    1cd0:	0f 90       	pop	r0
    1cd2:	0f be       	out	0x3f, r0	; 63
    1cd4:	0f 90       	pop	r0
    1cd6:	1f 90       	pop	r1
    1cd8:	18 95       	reti
		}
#endif //GRAPICSENABLED
	}
	else { // V sync
		if(gActiveLine > 200) {
    1cda:	80 91 72 01 	lds	r24, 0x0172
    1cde:	90 91 73 01 	lds	r25, 0x0173
    1ce2:	89 3c       	cpi	r24, 0xC9	; 201
    1ce4:	91 05       	cpc	r25, r1
    1ce6:	40 f3       	brcs	.-48     	; 0x1cb8 <__vector_1+0x106>
			gActiveLine = 0;
    1ce8:	10 92 73 01 	sts	0x0173, r1
    1cec:	10 92 72 01 	sts	0x0172, r1
    1cf0:	e3 cf       	rjmp	.-58     	; 0x1cb8 <__vector_1+0x106>
#ifdef TEXT_ENABLED	
		if (gActiveLine >= gActiveTextLine && gActiveLine < gActiveTextLastLine) {
	    gLineType = LINE_TYPE_TEXT;
		  gActivePixmapLine = (gActiveLine - gActiveTextLine);
		  if (gActiveTextSize == TEXT_SIZE_LARGE_MULT) {
		    gActivePixmapLine /= TEXT_SIZE_LARGE_MULT;
    1cf2:	20 91 52 01 	lds	r18, 0x0152
    1cf6:	30 91 53 01 	lds	r19, 0x0153
    1cfa:	ce cf       	rjmp	.-100    	; 0x1c98 <__vector_1+0xe6>
		
		// We save some time in beginning of line by pre-calculating next type.
		gLineType = LINE_TYPE_UNKNOWN; // Default case
		gActiveLine++;
		if (gActiveLine == UPDATE_LINE) {
			gUpdateScreenData = 1;
    1cfc:	21 e0       	ldi	r18, 0x01	; 1
    1cfe:	20 93 77 01 	sts	0x0177, r18
    1d02:	bc cf       	rjmp	.-136    	; 0x1c7c <__vector_1+0xca>
			gUpdateScreenData = 2;
		}

#ifdef TEXT_ENABLED	
		if (gActiveLine >= gActiveTextLine && gActiveLine < gActiveTextLastLine) {
	    gLineType = LINE_TYPE_TEXT;
    1d04:	21 e0       	ldi	r18, 0x01	; 1
    1d06:	20 93 75 01 	sts	0x0175, r18
		  gActivePixmapLine = (gActiveLine - gActiveTextLine);
    1d0a:	84 1b       	sub	r24, r20
    1d0c:	80 93 7a 01 	sts	0x017A, r24
		  if (gActiveTextSize == TEXT_SIZE_LARGE_MULT) {
    1d10:	90 91 54 01 	lds	r25, 0x0154
    1d14:	92 30       	cpi	r25, 0x02	; 2
    1d16:	81 f6       	brne	.-96     	; 0x1cb8 <__vector_1+0x106>
		    gActivePixmapLine /= TEXT_SIZE_LARGE_MULT;
    1d18:	86 95       	lsr	r24
    1d1a:	80 93 7a 01 	sts	0x017A, r24
    1d1e:	cc cf       	rjmp	.-104    	; 0x1cb8 <__vector_1+0x106>
	if(!(PIND & LTRIG)) { // H sync
		if (gActiveLine != 0) {
			switch(gLineType) {
				case LINE_TYPE_TEXT:
#ifdef TEXT_ENABLED				
					drawTextLine(gActiveTextId);
    1d20:	60 91 76 01 	lds	r22, 0x0176
    1d24:	e8 e1       	ldi	r30, 0x18	; 24
    1d26:	ea 95       	dec	r30
    1d28:	f1 f7       	brne	.-4      	; 0x1d26 <__vector_1+0x174>
    1d2a:	40 91 7a 01 	lds	r20, 0x017A
    1d2e:	50 e0       	ldi	r21, 0x00	; 0
			//DDRB &= ~OUT1;
		}
	}
}

ISR(INT0_vect) {
    1d30:	70 e0       	ldi	r23, 0x00	; 0
    1d32:	21 e2       	ldi	r18, 0x21	; 33
    1d34:	30 e0       	ldi	r19, 0x00	; 0
    1d36:	62 9f       	mul	r22, r18
    1d38:	d0 01       	movw	r26, r0
    1d3a:	63 9f       	mul	r22, r19
    1d3c:	b0 0d       	add	r27, r0
    1d3e:	72 9f       	mul	r23, r18
    1d40:	b0 0d       	add	r27, r0
    1d42:	11 24       	eor	r1, r1
    1d44:	a5 58       	subi	r26, 0x85	; 133
    1d46:	be 4f       	sbci	r27, 0xFE	; 254
    1d48:	42 9f       	mul	r20, r18
    1d4a:	f0 01       	movw	r30, r0
    1d4c:	43 9f       	mul	r20, r19
    1d4e:	f0 0d       	add	r31, r0
    1d50:	52 9f       	mul	r21, r18
    1d52:	f0 0d       	add	r31, r0
    1d54:	11 24       	eor	r1, r1
    1d56:	ef 5b       	subi	r30, 0xBF	; 191
    1d58:	fd 4f       	sbci	r31, 0xFD	; 253
    1d5a:	21 e2       	ldi	r18, 0x21	; 33
    1d5c:	16 c0       	rjmp	.+44     	; 0x1d8a <__vector_1+0x1d8>
{
	_delay_us(3);
	uint8_t currLine = gActivePixmapLine;
	for (uint8_t i = 0; i < TEXT_LINE_MAX_CHARS; ++i) {
		if (gText[textId][i] != ' ' && gText[textId][i] != 0) {
			DDRB |= OUT1;
    1d5e:	21 9a       	sbi	0x04, 1	; 4
		}
		else {
			DDRB &= ~OUT1;
			DELAY_1_NOP();
		}
		SPDR = gTextPixmap[(uint16_t)(currLine)*TEXT_LINE_MAX_CHARS + i];
    1d60:	31 91       	ld	r19, Z+
    1d62:	3e bd       	out	0x2e, r19	; 46
	...
		DELAY_4_NOP();
#ifndef TEXT_SMALL_ENABLED
		DELAY_6_NOP();
		DELAY_7_NOP();
    1d84:	00 00       	nop
    1d86:	21 50       	subi	r18, 0x01	; 1

static void drawTextLine(uint8_t textId)
{
	_delay_us(3);
	uint8_t currLine = gActivePixmapLine;
	for (uint8_t i = 0; i < TEXT_LINE_MAX_CHARS; ++i) {
    1d88:	61 f0       	breq	.+24     	; 0x1da2 <__vector_1+0x1f0>
		if (gText[textId][i] != ' ' && gText[textId][i] != 0) {
    1d8a:	3d 91       	ld	r19, X+
    1d8c:	30 32       	cpi	r19, 0x20	; 32
    1d8e:	11 f0       	breq	.+4      	; 0x1d94 <__vector_1+0x1e2>
    1d90:	33 23       	and	r19, r19
    1d92:	29 f7       	brne	.-54     	; 0x1d5e <__vector_1+0x1ac>
			DDRB |= OUT1;
		}
		else {
			DDRB &= ~OUT1;
    1d94:	21 98       	cbi	0x04, 1	; 4
			DELAY_1_NOP();
    1d96:	00 00       	nop
    1d98:	e3 cf       	rjmp	.-58     	; 0x1d60 <__vector_1+0x1ae>
		gActiveLine++;
		if (gActiveLine == UPDATE_LINE) {
			gUpdateScreenData = 1;
		}
		else if (gActiveLine == UPDATE_LINE + 1) {
			gUpdateScreenData = 2;
    1d9a:	22 e0       	ldi	r18, 0x02	; 2
    1d9c:	20 93 77 01 	sts	0x0177, r18
    1da0:	6d cf       	rjmp	.-294    	; 0x1c7c <__vector_1+0xca>
	...
		DELAY_6_NOP();
		DELAY_7_NOP();
#endif //TEXT_SMALL_ENABLED	
	}
	DELAY_10_NOP();
	SPDR = 0x00;
    1db6:	1e bc       	out	0x2e, r1	; 46
	DDRB &= ~OUT1;
    1db8:	21 98       	cbi	0x04, 1	; 4
    1dba:	51 cf       	rjmp	.-350    	; 0x1c5e <__vector_1+0xac>
		  if (gActiveTextSize == TEXT_SIZE_LARGE_MULT) {
		    gActivePixmapLine /= TEXT_SIZE_LARGE_MULT;
		  }
		}
		else if (gActiveLine == gActiveTextLastLine) {
		  gUpdateScreenData = 2;
    1dbc:	82 e0       	ldi	r24, 0x02	; 2
    1dbe:	80 93 77 01 	sts	0x0177, r24
			gActiveTextId = (gActiveTextId+1) % TEXT_LINES;
    1dc2:	80 91 76 01 	lds	r24, 0x0176
    1dc6:	90 e0       	ldi	r25, 0x00	; 0
    1dc8:	01 96       	adiw	r24, 0x01	; 1
    1dca:	66 e0       	ldi	r22, 0x06	; 6
    1dcc:	70 e0       	ldi	r23, 0x00	; 0
    1dce:	94 d0       	rcall	.+296    	; 0x1ef8 <__divmodhi4>
    1dd0:	80 93 76 01 	sts	0x0176, r24
			gActiveTextLine = gTextLines[gActiveTextId];
    1dd4:	fc 01       	movw	r30, r24
    1dd6:	ee 0f       	add	r30, r30
    1dd8:	ff 1f       	adc	r31, r31
    1dda:	eb 5a       	subi	r30, 0xAB	; 171
    1ddc:	fe 4f       	sbci	r31, 0xFE	; 254
    1dde:	20 81       	ld	r18, Z
    1de0:	31 81       	ldd	r19, Z+1	; 0x01
    1de2:	30 93 79 01 	sts	0x0179, r19
    1de6:	20 93 78 01 	sts	0x0178, r18
			gActiveTextSize = gTextLineSizes[gActiveTextId];
    1dea:	8f 59       	subi	r24, 0x9F	; 159
    1dec:	9e 4f       	sbci	r25, 0xFE	; 254
    1dee:	fc 01       	movw	r30, r24
    1df0:	80 81       	ld	r24, Z
    1df2:	80 93 54 01 	sts	0x0154, r24
			gActiveTextLastLine = gActiveTextLine + TEXT_CHAR_HEIGHT * gActiveTextSize;
    1df6:	90 e0       	ldi	r25, 0x00	; 0
    1df8:	88 0f       	add	r24, r24
    1dfa:	99 1f       	adc	r25, r25
    1dfc:	88 0f       	add	r24, r24
    1dfe:	99 1f       	adc	r25, r25
    1e00:	88 0f       	add	r24, r24
    1e02:	99 1f       	adc	r25, r25
    1e04:	82 0f       	add	r24, r18
    1e06:	93 1f       	adc	r25, r19
    1e08:	90 93 53 01 	sts	0x0153, r25
    1e0c:	80 93 52 01 	sts	0x0152, r24
			gActivePixmapLine = 1;
    1e10:	81 e0       	ldi	r24, 0x01	; 1
    1e12:	80 93 7a 01 	sts	0x017A, r24
    1e16:	50 cf       	rjmp	.-352    	; 0x1cb8 <__vector_1+0x106>

00001e18 <__vector_13>:
	TCNT1 = 0; // Reset sync lost timeout.
	updateLine();
}

ISR(TIMER1_OVF_vect)
{
    1e18:	1f 92       	push	r1
    1e1a:	0f 92       	push	r0
    1e1c:	0f b6       	in	r0, 0x3f	; 63
    1e1e:	0f 92       	push	r0
    1e20:	11 24       	eor	r1, r1
    1e22:	2f 93       	push	r18
    1e24:	3f 93       	push	r19
    1e26:	8f 93       	push	r24
    1e28:	9f 93       	push	r25
	static uint8_t lastLine = 0;
	if (lastLine == gActiveLine) {
    1e2a:	80 91 72 01 	lds	r24, 0x0172
    1e2e:	90 91 73 01 	lds	r25, 0x0173
    1e32:	20 91 74 01 	lds	r18, 0x0174
    1e36:	30 e0       	ldi	r19, 0x00	; 0
    1e38:	28 17       	cp	r18, r24
    1e3a:	39 07       	cpc	r19, r25
    1e3c:	21 f4       	brne	.+8      	; 0x1e46 <__vector_13+0x2e>
    PORTD ^= LED; // Toggle the LED
    1e3e:	2b b1       	in	r18, 0x0b	; 11
    1e40:	38 e0       	ldi	r19, 0x08	; 8
    1e42:	23 27       	eor	r18, r19
    1e44:	2b b9       	out	0x0b, r18	; 11
	}
	lastLine = gActiveLine;
    1e46:	80 93 74 01 	sts	0x0174, r24
}
    1e4a:	9f 91       	pop	r25
    1e4c:	8f 91       	pop	r24
    1e4e:	3f 91       	pop	r19
    1e50:	2f 91       	pop	r18
    1e52:	0f 90       	pop	r0
    1e54:	0f be       	out	0x3f, r0	; 63
    1e56:	0f 90       	pop	r0
    1e58:	1f 90       	pop	r1
    1e5a:	18 95       	reti

00001e5c <__umulhisi3>:
    1e5c:	53 9f       	mul	r21, r19
    1e5e:	c0 01       	movw	r24, r0
    1e60:	42 9f       	mul	r20, r18
    1e62:	b0 01       	movw	r22, r0
    1e64:	52 9f       	mul	r21, r18
    1e66:	70 0d       	add	r23, r0
    1e68:	81 1d       	adc	r24, r1
    1e6a:	11 24       	eor	r1, r1
    1e6c:	91 1d       	adc	r25, r1
    1e6e:	34 9f       	mul	r19, r20
    1e70:	70 0d       	add	r23, r0
    1e72:	81 1d       	adc	r24, r1
    1e74:	11 24       	eor	r1, r1
    1e76:	91 1d       	adc	r25, r1
    1e78:	08 95       	ret

00001e7a <__mulsi3>:
    1e7a:	62 9f       	mul	r22, r18
    1e7c:	d0 01       	movw	r26, r0
    1e7e:	73 9f       	mul	r23, r19
    1e80:	f0 01       	movw	r30, r0
    1e82:	82 9f       	mul	r24, r18
    1e84:	e0 0d       	add	r30, r0
    1e86:	f1 1d       	adc	r31, r1
    1e88:	64 9f       	mul	r22, r20
    1e8a:	e0 0d       	add	r30, r0
    1e8c:	f1 1d       	adc	r31, r1
    1e8e:	92 9f       	mul	r25, r18
    1e90:	f0 0d       	add	r31, r0
    1e92:	83 9f       	mul	r24, r19
    1e94:	f0 0d       	add	r31, r0
    1e96:	74 9f       	mul	r23, r20
    1e98:	f0 0d       	add	r31, r0
    1e9a:	65 9f       	mul	r22, r21
    1e9c:	f0 0d       	add	r31, r0
    1e9e:	99 27       	eor	r25, r25
    1ea0:	72 9f       	mul	r23, r18
    1ea2:	b0 0d       	add	r27, r0
    1ea4:	e1 1d       	adc	r30, r1
    1ea6:	f9 1f       	adc	r31, r25
    1ea8:	63 9f       	mul	r22, r19
    1eaa:	b0 0d       	add	r27, r0
    1eac:	e1 1d       	adc	r30, r1
    1eae:	f9 1f       	adc	r31, r25
    1eb0:	bd 01       	movw	r22, r26
    1eb2:	cf 01       	movw	r24, r30
    1eb4:	11 24       	eor	r1, r1
    1eb6:	08 95       	ret

00001eb8 <__udivmodqi4>:
    1eb8:	99 1b       	sub	r25, r25
    1eba:	79 e0       	ldi	r23, 0x09	; 9
    1ebc:	04 c0       	rjmp	.+8      	; 0x1ec6 <__udivmodqi4_ep>

00001ebe <__udivmodqi4_loop>:
    1ebe:	99 1f       	adc	r25, r25
    1ec0:	96 17       	cp	r25, r22
    1ec2:	08 f0       	brcs	.+2      	; 0x1ec6 <__udivmodqi4_ep>
    1ec4:	96 1b       	sub	r25, r22

00001ec6 <__udivmodqi4_ep>:
    1ec6:	88 1f       	adc	r24, r24
    1ec8:	7a 95       	dec	r23
    1eca:	c9 f7       	brne	.-14     	; 0x1ebe <__udivmodqi4_loop>
    1ecc:	80 95       	com	r24
    1ece:	08 95       	ret

00001ed0 <__udivmodhi4>:
    1ed0:	aa 1b       	sub	r26, r26
    1ed2:	bb 1b       	sub	r27, r27
    1ed4:	51 e1       	ldi	r21, 0x11	; 17
    1ed6:	07 c0       	rjmp	.+14     	; 0x1ee6 <__udivmodhi4_ep>

00001ed8 <__udivmodhi4_loop>:
    1ed8:	aa 1f       	adc	r26, r26
    1eda:	bb 1f       	adc	r27, r27
    1edc:	a6 17       	cp	r26, r22
    1ede:	b7 07       	cpc	r27, r23
    1ee0:	10 f0       	brcs	.+4      	; 0x1ee6 <__udivmodhi4_ep>
    1ee2:	a6 1b       	sub	r26, r22
    1ee4:	b7 0b       	sbc	r27, r23

00001ee6 <__udivmodhi4_ep>:
    1ee6:	88 1f       	adc	r24, r24
    1ee8:	99 1f       	adc	r25, r25
    1eea:	5a 95       	dec	r21
    1eec:	a9 f7       	brne	.-22     	; 0x1ed8 <__udivmodhi4_loop>
    1eee:	80 95       	com	r24
    1ef0:	90 95       	com	r25
    1ef2:	bc 01       	movw	r22, r24
    1ef4:	cd 01       	movw	r24, r26
    1ef6:	08 95       	ret

00001ef8 <__divmodhi4>:
    1ef8:	97 fb       	bst	r25, 7
    1efa:	09 2e       	mov	r0, r25
    1efc:	07 26       	eor	r0, r23
    1efe:	0a d0       	rcall	.+20     	; 0x1f14 <__divmodhi4_neg1>
    1f00:	77 fd       	sbrc	r23, 7
    1f02:	04 d0       	rcall	.+8      	; 0x1f0c <__divmodhi4_neg2>
    1f04:	e5 df       	rcall	.-54     	; 0x1ed0 <__udivmodhi4>
    1f06:	06 d0       	rcall	.+12     	; 0x1f14 <__divmodhi4_neg1>
    1f08:	00 20       	and	r0, r0
    1f0a:	1a f4       	brpl	.+6      	; 0x1f12 <__divmodhi4_exit>

00001f0c <__divmodhi4_neg2>:
    1f0c:	70 95       	com	r23
    1f0e:	61 95       	neg	r22
    1f10:	7f 4f       	sbci	r23, 0xFF	; 255

00001f12 <__divmodhi4_exit>:
    1f12:	08 95       	ret

00001f14 <__divmodhi4_neg1>:
    1f14:	f6 f7       	brtc	.-4      	; 0x1f12 <__divmodhi4_exit>
    1f16:	90 95       	com	r25
    1f18:	81 95       	neg	r24
    1f1a:	9f 4f       	sbci	r25, 0xFF	; 255
    1f1c:	08 95       	ret

00001f1e <__udivmodsi4>:
    1f1e:	a1 e2       	ldi	r26, 0x21	; 33
    1f20:	1a 2e       	mov	r1, r26
    1f22:	aa 1b       	sub	r26, r26
    1f24:	bb 1b       	sub	r27, r27
    1f26:	fd 01       	movw	r30, r26
    1f28:	0d c0       	rjmp	.+26     	; 0x1f44 <__udivmodsi4_ep>

00001f2a <__udivmodsi4_loop>:
    1f2a:	aa 1f       	adc	r26, r26
    1f2c:	bb 1f       	adc	r27, r27
    1f2e:	ee 1f       	adc	r30, r30
    1f30:	ff 1f       	adc	r31, r31
    1f32:	a2 17       	cp	r26, r18
    1f34:	b3 07       	cpc	r27, r19
    1f36:	e4 07       	cpc	r30, r20
    1f38:	f5 07       	cpc	r31, r21
    1f3a:	20 f0       	brcs	.+8      	; 0x1f44 <__udivmodsi4_ep>
    1f3c:	a2 1b       	sub	r26, r18
    1f3e:	b3 0b       	sbc	r27, r19
    1f40:	e4 0b       	sbc	r30, r20
    1f42:	f5 0b       	sbc	r31, r21

00001f44 <__udivmodsi4_ep>:
    1f44:	66 1f       	adc	r22, r22
    1f46:	77 1f       	adc	r23, r23
    1f48:	88 1f       	adc	r24, r24
    1f4a:	99 1f       	adc	r25, r25
    1f4c:	1a 94       	dec	r1
    1f4e:	69 f7       	brne	.-38     	; 0x1f2a <__udivmodsi4_loop>
    1f50:	60 95       	com	r22
    1f52:	70 95       	com	r23
    1f54:	80 95       	com	r24
    1f56:	90 95       	com	r25
    1f58:	9b 01       	movw	r18, r22
    1f5a:	ac 01       	movw	r20, r24
    1f5c:	bd 01       	movw	r22, r26
    1f5e:	cf 01       	movw	r24, r30
    1f60:	08 95       	ret

00001f62 <__divmodsi4>:
    1f62:	97 fb       	bst	r25, 7
    1f64:	09 2e       	mov	r0, r25
    1f66:	05 26       	eor	r0, r21
    1f68:	0e d0       	rcall	.+28     	; 0x1f86 <__divmodsi4_neg1>
    1f6a:	57 fd       	sbrc	r21, 7
    1f6c:	04 d0       	rcall	.+8      	; 0x1f76 <__divmodsi4_neg2>
    1f6e:	d7 df       	rcall	.-82     	; 0x1f1e <__udivmodsi4>
    1f70:	0a d0       	rcall	.+20     	; 0x1f86 <__divmodsi4_neg1>
    1f72:	00 1c       	adc	r0, r0
    1f74:	38 f4       	brcc	.+14     	; 0x1f84 <__divmodsi4_exit>

00001f76 <__divmodsi4_neg2>:
    1f76:	50 95       	com	r21
    1f78:	40 95       	com	r20
    1f7a:	30 95       	com	r19
    1f7c:	21 95       	neg	r18
    1f7e:	3f 4f       	sbci	r19, 0xFF	; 255
    1f80:	4f 4f       	sbci	r20, 0xFF	; 255
    1f82:	5f 4f       	sbci	r21, 0xFF	; 255

00001f84 <__divmodsi4_exit>:
    1f84:	08 95       	ret

00001f86 <__divmodsi4_neg1>:
    1f86:	f6 f7       	brtc	.-4      	; 0x1f84 <__divmodsi4_exit>
    1f88:	90 95       	com	r25
    1f8a:	80 95       	com	r24
    1f8c:	70 95       	com	r23
    1f8e:	61 95       	neg	r22
    1f90:	7f 4f       	sbci	r23, 0xFF	; 255
    1f92:	8f 4f       	sbci	r24, 0xFF	; 255
    1f94:	9f 4f       	sbci	r25, 0xFF	; 255
    1f96:	08 95       	ret

00001f98 <strncmp>:
    1f98:	fb 01       	movw	r30, r22
    1f9a:	dc 01       	movw	r26, r24
    1f9c:	41 50       	subi	r20, 0x01	; 1
    1f9e:	50 40       	sbci	r21, 0x00	; 0
    1fa0:	30 f0       	brcs	.+12     	; 0x1fae <strncmp+0x16>
    1fa2:	8d 91       	ld	r24, X+
    1fa4:	01 90       	ld	r0, Z+
    1fa6:	80 19       	sub	r24, r0
    1fa8:	19 f4       	brne	.+6      	; 0x1fb0 <strncmp+0x18>
    1faa:	00 20       	and	r0, r0
    1fac:	b9 f7       	brne	.-18     	; 0x1f9c <strncmp+0x4>
    1fae:	88 1b       	sub	r24, r24
    1fb0:	99 0b       	sbc	r25, r25
    1fb2:	08 95       	ret

00001fb4 <strncpy>:
    1fb4:	fb 01       	movw	r30, r22
    1fb6:	dc 01       	movw	r26, r24
    1fb8:	41 50       	subi	r20, 0x01	; 1
    1fba:	50 40       	sbci	r21, 0x00	; 0
    1fbc:	48 f0       	brcs	.+18     	; 0x1fd0 <strncpy+0x1c>
    1fbe:	01 90       	ld	r0, Z+
    1fc0:	0d 92       	st	X+, r0
    1fc2:	00 20       	and	r0, r0
    1fc4:	c9 f7       	brne	.-14     	; 0x1fb8 <strncpy+0x4>
    1fc6:	01 c0       	rjmp	.+2      	; 0x1fca <strncpy+0x16>
    1fc8:	1d 92       	st	X+, r1
    1fca:	41 50       	subi	r20, 0x01	; 1
    1fcc:	50 40       	sbci	r21, 0x00	; 0
    1fce:	e0 f7       	brcc	.-8      	; 0x1fc8 <strncpy+0x14>
    1fd0:	08 95       	ret

00001fd2 <__eerd_block_m88pa>:
    1fd2:	dc 01       	movw	r26, r24
    1fd4:	cb 01       	movw	r24, r22

00001fd6 <__eerd_blraw_m88pa>:
    1fd6:	fc 01       	movw	r30, r24
    1fd8:	f9 99       	sbic	0x1f, 1	; 31
    1fda:	fe cf       	rjmp	.-4      	; 0x1fd8 <__eerd_blraw_m88pa+0x2>
    1fdc:	06 c0       	rjmp	.+12     	; 0x1fea <__eerd_blraw_m88pa+0x14>
    1fde:	f2 bd       	out	0x22, r31	; 34
    1fe0:	e1 bd       	out	0x21, r30	; 33
    1fe2:	f8 9a       	sbi	0x1f, 0	; 31
    1fe4:	31 96       	adiw	r30, 0x01	; 1
    1fe6:	00 b4       	in	r0, 0x20	; 32
    1fe8:	0d 92       	st	X+, r0
    1fea:	41 50       	subi	r20, 0x01	; 1
    1fec:	50 40       	sbci	r21, 0x00	; 0
    1fee:	b8 f7       	brcc	.-18     	; 0x1fde <__eerd_blraw_m88pa+0x8>
    1ff0:	08 95       	ret

00001ff2 <_exit>:
    1ff2:	f8 94       	cli

00001ff4 <__stop_program>:
    1ff4:	ff cf       	rjmp	.-2      	; 0x1ff4 <__stop_program>
