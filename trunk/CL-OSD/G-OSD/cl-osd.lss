
cl-osd.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000074  00800100  00001e02  00001eb6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001e02  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000002d3  00800174  00800174  00001f2a  2**0
                  ALLOC
  3 .eeprom       00000200  00810000  00810000  00001f2a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .stab         00000960  00000000  00000000  0000212c  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      000001af  00000000  00000000  00002a8c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 000001f0  00000000  00000000  00002c40  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000025d1  00000000  00000000  00002e30  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000421  00000000  00000000  00005401  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001111  00000000  00000000  00005822  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000002cc  00000000  00000000  00006934  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000007f1  00000000  00000000  00006c00  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00002aad  00000000  00000000  000073f1  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macinfo 0000bfbf  00000000  00000000  00009e9e  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 000007b0  00000000  00000000  00015e5d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	47 c0       	rjmp	.+142    	; 0x90 <__ctors_end>
       2:	bb cc       	rjmp	.-1674   	; 0xfffff97a <__eeprom_end+0xff7ef77a>
       4:	60 c0       	rjmp	.+192    	; 0xc6 <__bad_interrupt>
       6:	5f c0       	rjmp	.+190    	; 0xc6 <__bad_interrupt>
       8:	5e c0       	rjmp	.+188    	; 0xc6 <__bad_interrupt>
       a:	5d c0       	rjmp	.+186    	; 0xc6 <__bad_interrupt>
       c:	5c c0       	rjmp	.+184    	; 0xc6 <__bad_interrupt>
       e:	5b c0       	rjmp	.+182    	; 0xc6 <__bad_interrupt>
      10:	5a c0       	rjmp	.+180    	; 0xc6 <__bad_interrupt>
      12:	59 c0       	rjmp	.+178    	; 0xc6 <__bad_interrupt>
      14:	58 c0       	rjmp	.+176    	; 0xc6 <__bad_interrupt>
      16:	57 c0       	rjmp	.+174    	; 0xc6 <__bad_interrupt>
      18:	56 c0       	rjmp	.+172    	; 0xc6 <__bad_interrupt>
      1a:	d9 cd       	rjmp	.-1102   	; 0xfffffbce <__eeprom_end+0xff7ef9ce>
      1c:	54 c0       	rjmp	.+168    	; 0xc6 <__bad_interrupt>
      1e:	53 c0       	rjmp	.+166    	; 0xc6 <__bad_interrupt>
      20:	52 c0       	rjmp	.+164    	; 0xc6 <__bad_interrupt>
      22:	51 c0       	rjmp	.+162    	; 0xc6 <__bad_interrupt>
      24:	50 c0       	rjmp	.+160    	; 0xc6 <__bad_interrupt>
      26:	4f c0       	rjmp	.+158    	; 0xc6 <__bad_interrupt>
      28:	4e c0       	rjmp	.+156    	; 0xc6 <__bad_interrupt>
      2a:	4d c0       	rjmp	.+154    	; 0xc6 <__bad_interrupt>
      2c:	4c c0       	rjmp	.+152    	; 0xc6 <__bad_interrupt>
      2e:	4b c0       	rjmp	.+150    	; 0xc6 <__bad_interrupt>
      30:	4a c0       	rjmp	.+148    	; 0xc6 <__bad_interrupt>
      32:	49 c0       	rjmp	.+146    	; 0xc6 <__bad_interrupt>

00000034 <sinData>:
      34:	00 02 03 05 07 09 0a 0c 0e 10 11 13 15 16 18 1a     ................
      44:	1c 1d 1f 21 22 24 25 27 29 2a 2c 2d 2f 30 32 34     ...!"$%')*,-/024
      54:	35 36 38 39 3b 3c 3e 3f 40 42 43 44 45 47 48 49     5689;<>?@BCDEGHI
      64:	4a 4b 4d 4e 4f 50 51 52 53 54 55 56 57 57 58 59     JKMNOPQRSTUVWWXY
      74:	5a 5b 5b 5c 5d 5d 5e 5f 5f 60 60 61 61 61 62 62     Z[[\]]^__``aaabb
      84:	62 63 63 63 63 64 64 64 64 64 64 00                 bccccdddddd.

00000090 <__ctors_end>:
      90:	11 24       	eor	r1, r1
      92:	1f be       	out	0x3f, r1	; 63
      94:	cf ef       	ldi	r28, 0xFF	; 255
      96:	d4 e0       	ldi	r29, 0x04	; 4
      98:	de bf       	out	0x3e, r29	; 62
      9a:	cd bf       	out	0x3d, r28	; 61

0000009c <__do_copy_data>:
      9c:	11 e0       	ldi	r17, 0x01	; 1
      9e:	a0 e0       	ldi	r26, 0x00	; 0
      a0:	b1 e0       	ldi	r27, 0x01	; 1
      a2:	e2 e0       	ldi	r30, 0x02	; 2
      a4:	fe e1       	ldi	r31, 0x1E	; 30
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x10>
      a8:	05 90       	lpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	a4 37       	cpi	r26, 0x74	; 116
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0xc>

000000b2 <__do_clear_bss>:
      b2:	14 e0       	ldi	r17, 0x04	; 4
      b4:	a4 e7       	ldi	r26, 0x74	; 116
      b6:	b1 e0       	ldi	r27, 0x01	; 1
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	a7 34       	cpi	r26, 0x47	; 71
      be:	b1 07       	cpc	r27, r17
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	23 d5       	rcall	.+2630   	; 0xb0a <main>
      c4:	9c ce       	rjmp	.-712    	; 0xfffffdfe <__eeprom_end+0xff7efbfe>

000000c6 <__bad_interrupt>:
      c6:	9c cf       	rjmp	.-200    	; 0x0 <__vectors>

000000c8 <wgs84ToSec100>:
  uint8_t checksumValid;
} TGpsData;

// Convert nmea WGS84 to seconds * 100
// wgs84 = DDMM[.]MMMM
static int32_t wgs84ToSec100(int32_t wgs84) { 
      c8:	4f 92       	push	r4
      ca:	5f 92       	push	r5
      cc:	6f 92       	push	r6
      ce:	7f 92       	push	r7
      d0:	8f 92       	push	r8
      d2:	9f 92       	push	r9
      d4:	af 92       	push	r10
      d6:	bf 92       	push	r11
      d8:	cf 92       	push	r12
      da:	df 92       	push	r13
      dc:	ef 92       	push	r14
      de:	ff 92       	push	r15
      e0:	1f 93       	push	r17
      e2:	cf 93       	push	r28
      e4:	df 93       	push	r29
      e6:	00 d0       	rcall	.+0      	; 0xe8 <wgs84ToSec100+0x20>
      e8:	00 d0       	rcall	.+0      	; 0xea <wgs84ToSec100+0x22>
      ea:	cd b7       	in	r28, 0x3d	; 61
      ec:	de b7       	in	r29, 0x3e	; 62
      ee:	6b 01       	movw	r12, r22
      f0:	7c 01       	movw	r14, r24
  int8_t mult = 1;
  
  if (wgs84 < 0) {
      f2:	97 fd       	sbrc	r25, 7
      f4:	73 c0       	rjmp	.+230    	; 0x1dc <wgs84ToSec100+0x114>
} TGpsData;

// Convert nmea WGS84 to seconds * 100
// wgs84 = DDMM[.]MMMM
static int32_t wgs84ToSec100(int32_t wgs84) { 
  int8_t mult = 1;
      f6:	11 e0       	ldi	r17, 0x01	; 1
  if (wgs84 < 0) {
    mult = -1;
    wgs84 = -wgs84;
  }
  
  uint8_t hour = wgs84 / 1000000; //Get hour part
      f8:	c7 01       	movw	r24, r14
      fa:	b6 01       	movw	r22, r12
      fc:	20 e4       	ldi	r18, 0x40	; 64
      fe:	32 e4       	ldi	r19, 0x42	; 66
     100:	4f e0       	ldi	r20, 0x0F	; 15
     102:	50 e0       	ldi	r21, 0x00	; 0
     104:	fd dd       	rcall	.-1030   	; 0xfffffd00 <__eeprom_end+0xff7efb00>
  uint8_t min = (wgs84 - (hour * 1000000)) / 10000; //Get minute part
     106:	42 2e       	mov	r4, r18
     108:	55 24       	eor	r5, r5
     10a:	66 24       	eor	r6, r6
     10c:	77 24       	eor	r7, r7
  uint32_t minDecimal = wgs84 % 10000; //Get minute decimal part
     10e:	c7 01       	movw	r24, r14
     110:	b6 01       	movw	r22, r12
     112:	20 e1       	ldi	r18, 0x10	; 16
     114:	37 e2       	ldi	r19, 0x27	; 39
     116:	40 e0       	ldi	r20, 0x00	; 0
     118:	50 e0       	ldi	r21, 0x00	; 0
     11a:	f2 dd       	rcall	.-1052   	; 0xfffffd00 <__eeprom_end+0xff7efb00>
     11c:	69 83       	std	Y+1, r22	; 0x01
     11e:	7a 83       	std	Y+2, r23	; 0x02
     120:	8b 83       	std	Y+3, r24	; 0x03
     122:	9c 83       	std	Y+4, r25	; 0x04
  
  int32_t sec100 = 0;
  sec100 += hour; // Add hour part
  sec100 *= 60;
     124:	c3 01       	movw	r24, r6
     126:	b2 01       	movw	r22, r4
     128:	2c e3       	ldi	r18, 0x3C	; 60
     12a:	30 e0       	ldi	r19, 0x00	; 0
     12c:	40 e0       	ldi	r20, 0x00	; 0
     12e:	50 e0       	ldi	r21, 0x00	; 0
     130:	7f dd       	rcall	.-1282   	; 0xfffffc30 <__eeprom_end+0xff7efa30>
     132:	4b 01       	movw	r8, r22
     134:	5c 01       	movw	r10, r24
    mult = -1;
    wgs84 = -wgs84;
  }
  
  uint8_t hour = wgs84 / 1000000; //Get hour part
  uint8_t min = (wgs84 - (hour * 1000000)) / 10000; //Get minute part
     136:	c3 01       	movw	r24, r6
     138:	b2 01       	movw	r22, r4
     13a:	20 ec       	ldi	r18, 0xC0	; 192
     13c:	3d eb       	ldi	r19, 0xBD	; 189
     13e:	40 ef       	ldi	r20, 0xF0	; 240
     140:	5f ef       	ldi	r21, 0xFF	; 255
     142:	76 dd       	rcall	.-1300   	; 0xfffffc30 <__eeprom_end+0xff7efa30>
     144:	6c 0d       	add	r22, r12
     146:	7d 1d       	adc	r23, r13
     148:	8e 1d       	adc	r24, r14
     14a:	9f 1d       	adc	r25, r15
     14c:	20 e1       	ldi	r18, 0x10	; 16
     14e:	37 e2       	ldi	r19, 0x27	; 39
     150:	40 e0       	ldi	r20, 0x00	; 0
     152:	50 e0       	ldi	r21, 0x00	; 0
     154:	d5 dd       	rcall	.-1110   	; 0xfffffd00 <__eeprom_end+0xff7efb00>
  uint32_t minDecimal = wgs84 % 10000; //Get minute decimal part
  
  int32_t sec100 = 0;
  sec100 += hour; // Add hour part
  sec100 *= 60;
  sec100 += min; // Add minute part
     156:	82 0e       	add	r8, r18
     158:	91 1c       	adc	r9, r1
     15a:	a1 1c       	adc	r10, r1
     15c:	b1 1c       	adc	r11, r1
  sec100 *= 60;
     15e:	c5 01       	movw	r24, r10
     160:	b4 01       	movw	r22, r8
     162:	2c e3       	ldi	r18, 0x3C	; 60
     164:	30 e0       	ldi	r19, 0x00	; 0
     166:	40 e0       	ldi	r20, 0x00	; 0
     168:	50 e0       	ldi	r21, 0x00	; 0
     16a:	62 dd       	rcall	.-1340   	; 0xfffffc30 <__eeprom_end+0xff7efa30>
     16c:	6b 01       	movw	r12, r22
     16e:	7c 01       	movw	r14, r24
  sec100 *= 100;
  minDecimal *= 60;
     170:	69 81       	ldd	r22, Y+1	; 0x01
     172:	7a 81       	ldd	r23, Y+2	; 0x02
     174:	8b 81       	ldd	r24, Y+3	; 0x03
     176:	9c 81       	ldd	r25, Y+4	; 0x04
     178:	5b dd       	rcall	.-1354   	; 0xfffffc30 <__eeprom_end+0xff7efa30>
     17a:	4b 01       	movw	r8, r22
     17c:	5c 01       	movw	r10, r24
  int32_t sec100 = 0;
  sec100 += hour; // Add hour part
  sec100 *= 60;
  sec100 += min; // Add minute part
  sec100 *= 60;
  sec100 *= 100;
     17e:	c7 01       	movw	r24, r14
     180:	b6 01       	movw	r22, r12
     182:	24 e6       	ldi	r18, 0x64	; 100
     184:	30 e0       	ldi	r19, 0x00	; 0
     186:	40 e0       	ldi	r20, 0x00	; 0
     188:	50 e0       	ldi	r21, 0x00	; 0
     18a:	52 dd       	rcall	.-1372   	; 0xfffffc30 <__eeprom_end+0xff7efa30>
     18c:	6b 01       	movw	r12, r22
     18e:	7c 01       	movw	r14, r24
  minDecimal *= 60;
  minDecimal /= 100;
     190:	c5 01       	movw	r24, r10
     192:	b4 01       	movw	r22, r8
     194:	93 dd       	rcall	.-1242   	; 0xfffffcbc <__eeprom_end+0xff7efabc>
  sec100 += minDecimal; // Add minute decimal part
     196:	c2 0e       	add	r12, r18
     198:	d3 1e       	adc	r13, r19
     19a:	e4 1e       	adc	r14, r20
     19c:	f5 1e       	adc	r15, r21
  
  if (mult == -1) {
     19e:	1f 3f       	cpi	r17, 0xFF	; 255
     1a0:	41 f4       	brne	.+16     	; 0x1b2 <wgs84ToSec100+0xea>
    return -sec100;
     1a2:	f0 94       	com	r15
     1a4:	e0 94       	com	r14
     1a6:	d0 94       	com	r13
     1a8:	c0 94       	com	r12
     1aa:	c1 1c       	adc	r12, r1
     1ac:	d1 1c       	adc	r13, r1
     1ae:	e1 1c       	adc	r14, r1
     1b0:	f1 1c       	adc	r15, r1
  } else {
    return sec100;
  }
}
     1b2:	c7 01       	movw	r24, r14
     1b4:	b6 01       	movw	r22, r12
     1b6:	24 96       	adiw	r28, 0x04	; 4
     1b8:	de bf       	out	0x3e, r29	; 62
     1ba:	cd bf       	out	0x3d, r28	; 61
     1bc:	df 91       	pop	r29
     1be:	cf 91       	pop	r28
     1c0:	1f 91       	pop	r17
     1c2:	ff 90       	pop	r15
     1c4:	ef 90       	pop	r14
     1c6:	df 90       	pop	r13
     1c8:	cf 90       	pop	r12
     1ca:	bf 90       	pop	r11
     1cc:	af 90       	pop	r10
     1ce:	9f 90       	pop	r9
     1d0:	8f 90       	pop	r8
     1d2:	7f 90       	pop	r7
     1d4:	6f 90       	pop	r6
     1d6:	5f 90       	pop	r5
     1d8:	4f 90       	pop	r4
     1da:	08 95       	ret
static int32_t wgs84ToSec100(int32_t wgs84) { 
  int8_t mult = 1;
  
  if (wgs84 < 0) {
    mult = -1;
    wgs84 = -wgs84;
     1dc:	f0 94       	com	r15
     1de:	e0 94       	com	r14
     1e0:	d0 94       	com	r13
     1e2:	c0 94       	com	r12
     1e4:	c1 1c       	adc	r12, r1
     1e6:	d1 1c       	adc	r13, r1
     1e8:	e1 1c       	adc	r14, r1
     1ea:	f1 1c       	adc	r15, r1
// wgs84 = DDMM[.]MMMM
static int32_t wgs84ToSec100(int32_t wgs84) { 
  int8_t mult = 1;
  
  if (wgs84 < 0) {
    mult = -1;
     1ec:	1f ef       	ldi	r17, 0xFF	; 255
     1ee:	84 cf       	rjmp	.-248    	; 0xf8 <wgs84ToSec100+0x30>

000001f0 <printNumber>:
	}
	strncpy(&str[pos], str2, length);
	return length+pos;
}

static uint8_t printNumber(char* const str, uint8_t pos, int32_t number) {
     1f0:	a0 e0       	ldi	r26, 0x00	; 0
     1f2:	b0 e0       	ldi	r27, 0x00	; 0
     1f4:	ed ef       	ldi	r30, 0xFD	; 253
     1f6:	f0 e0       	ldi	r31, 0x00	; 0
     1f8:	a0 cd       	rjmp	.-1216   	; 0xfffffd3a <__eeprom_end+0xff7efb3a>
     1fa:	2c 01       	movw	r4, r24
     1fc:	d6 2f       	mov	r29, r22
     1fe:	49 01       	movw	r8, r18
     200:	5a 01       	movw	r10, r20
#ifndef COMMONUTILS_H_
#define COMMONUTILS_H_

// abs seems to only support 16 bits so I had to make my own.
static uint32_t absi32(int32_t a) {
	return (a > 0) ? a : -a;
     202:	89 01       	movw	r16, r18
     204:	9a 01       	movw	r18, r20
     206:	b7 fc       	sbrc	r11, 7
     208:	71 c0       	rjmp	.+226    	; 0x2ec <printNumber+0xfc>
	uint8_t length = 1;
	int32_t tmp = absi32(number);
	while (tmp > 9) {
     20a:	c1 e0       	ldi	r28, 0x01	; 1
     20c:	0a 30       	cpi	r16, 0x0A	; 10
     20e:	11 05       	cpc	r17, r1
     210:	21 05       	cpc	r18, r1
     212:	31 05       	cpc	r19, r1
     214:	94 f0       	brlt	.+36     	; 0x23a <printNumber+0x4a>
		tmp /= 10;
     216:	9a e0       	ldi	r25, 0x0A	; 10
     218:	c9 2e       	mov	r12, r25
     21a:	d1 2c       	mov	r13, r1
     21c:	e1 2c       	mov	r14, r1
     21e:	f1 2c       	mov	r15, r1
     220:	c9 01       	movw	r24, r18
     222:	b8 01       	movw	r22, r16
     224:	a7 01       	movw	r20, r14
     226:	96 01       	movw	r18, r12
     228:	6b dd       	rcall	.-1322   	; 0xfffffd00 <__eeprom_end+0xff7efb00>
     22a:	89 01       	movw	r16, r18
     22c:	9a 01       	movw	r18, r20
		++length;
     22e:	cf 5f       	subi	r28, 0xFF	; 255
}

static uint8_t printNumber(char* const str, uint8_t pos, int32_t number) {
	uint8_t length = 1;
	int32_t tmp = absi32(number);
	while (tmp > 9) {
     230:	0a 30       	cpi	r16, 0x0A	; 10
     232:	11 05       	cpc	r17, r1
     234:	21 05       	cpc	r18, r1
     236:	31 05       	cpc	r19, r1
     238:	9c f7       	brge	.-26     	; 0x220 <printNumber+0x30>
		tmp /= 10;
		++length;
	}
	if (number < 0) {
     23a:	b7 fc       	sbrc	r11, 7
     23c:	55 c0       	rjmp	.+170    	; 0x2e8 <printNumber+0xf8>
		++length;
	}
	if (pos + length >= TEXT_LINE_MAX_CHARS) {
     23e:	8d 2f       	mov	r24, r29
     240:	90 e0       	ldi	r25, 0x00	; 0
     242:	9c 01       	movw	r18, r24
     244:	2c 0f       	add	r18, r28
     246:	31 1d       	adc	r19, r1
     248:	21 32       	cpi	r18, 0x21	; 33
     24a:	31 05       	cpc	r19, r1
     24c:	34 f0       	brlt	.+12     	; 0x25a <printNumber+0x6a>
    return TEXT_LINE_MAX_CHARS;
     24e:	81 e2       	ldi	r24, 0x21	; 33
	}
	myItoa(number, &str[pos]);
	return pos+length;
}
     250:	cd b7       	in	r28, 0x3d	; 61
     252:	de b7       	in	r29, 0x3e	; 62
     254:	e0 e1       	ldi	r30, 0x10	; 16
     256:	8d cd       	rjmp	.-1254   	; 0xfffffd72 <__eeprom_end+0xff7efb72>
     258:	66 c0       	rjmp	.+204    	; 0x326 <printText>
		++length;
	}
	if (pos + length >= TEXT_LINE_MAX_CHARS) {
    return TEXT_LINE_MAX_CHARS;
	}
	myItoa(number, &str[pos]);
     25a:	48 0e       	add	r4, r24
     25c:	59 1e       	adc	r5, r25
static void myItoa(int32_t n, char s[])
{
  int8_t i;
  int8_t sign = 0;
 
  if (n < 0) {  
     25e:	b7 fc       	sbrc	r11, 7
     260:	4d c0       	rjmp	.+154    	; 0x2fc <printNumber+0x10c>
}

static void myItoa(int32_t n, char s[])
{
  int8_t i;
  int8_t sign = 0;
     262:	10 e0       	ldi	r17, 0x00	; 0
 
  if (n < 0) {  
	  sign = -1; /* record sign */
    n = -n;          /* make n positive */
     264:	32 01       	movw	r6, r4
  }	
  i = 0;
     266:	00 e0       	ldi	r16, 0x00	; 0
  do {       /* generate digits in reverse order */
    s[i++] = n % 10 + '0';   /* get next digit */
     268:	8a e0       	ldi	r24, 0x0A	; 10
     26a:	c8 2e       	mov	r12, r24
     26c:	d1 2c       	mov	r13, r1
     26e:	e1 2c       	mov	r14, r1
     270:	f1 2c       	mov	r15, r1
     272:	01 c0       	rjmp	.+2      	; 0x276 <printNumber+0x86>
     274:	08 2f       	mov	r16, r24
     276:	c5 01       	movw	r24, r10
     278:	b4 01       	movw	r22, r8
     27a:	a7 01       	movw	r20, r14
     27c:	96 01       	movw	r18, r12
     27e:	40 dd       	rcall	.-1408   	; 0xfffffd00 <__eeprom_end+0xff7efb00>
     280:	60 5d       	subi	r22, 0xD0	; 208
     282:	f3 01       	movw	r30, r6
     284:	61 93       	st	Z+, r22
     286:	3f 01       	movw	r6, r30
     288:	80 2f       	mov	r24, r16
     28a:	8f 5f       	subi	r24, 0xFF	; 255
  } while ((n /= 10) > 0);     /* delete it */
     28c:	49 01       	movw	r8, r18
     28e:	5a 01       	movw	r10, r20
     290:	12 16       	cp	r1, r18
     292:	13 06       	cpc	r1, r19
     294:	14 06       	cpc	r1, r20
     296:	15 06       	cpc	r1, r21
     298:	6c f3       	brlt	.-38     	; 0x274 <printNumber+0x84>
  if (sign < 0) {
     29a:	1f 3f       	cpi	r17, 0xFF	; 255
     29c:	c9 f1       	breq	.+114    	; 0x310 <printNumber+0x120>
    s[i++] = '-';
  }	
  s[i] = '\0';
     29e:	e8 2f       	mov	r30, r24
     2a0:	ff 27       	eor	r31, r31
     2a2:	e7 fd       	sbrc	r30, 7
     2a4:	f0 95       	com	r31
     2a6:	e4 0d       	add	r30, r4
     2a8:	f5 1d       	adc	r31, r5
     2aa:	10 82       	st	Z, r1
}

static void myReverse(char s[], uint8_t size) {
  uint8_t i;
  char c;
  size -= 1;
     2ac:	81 50       	subi	r24, 0x01	; 1
  for (i = 0; i <= size/2; i++) {
     2ae:	68 2f       	mov	r22, r24
     2b0:	66 95       	lsr	r22
     2b2:	28 2f       	mov	r18, r24
     2b4:	30 e0       	ldi	r19, 0x00	; 0
     2b6:	40 e0       	ldi	r20, 0x00	; 0
    c = s[i];
     2b8:	84 2f       	mov	r24, r20
     2ba:	90 e0       	ldi	r25, 0x00	; 0
     2bc:	f2 01       	movw	r30, r4
     2be:	e8 0f       	add	r30, r24
     2c0:	f9 1f       	adc	r31, r25
     2c2:	50 81       	ld	r21, Z
    s[i] = s[size - i];
     2c4:	d9 01       	movw	r26, r18
     2c6:	a8 1b       	sub	r26, r24
     2c8:	b9 0b       	sbc	r27, r25
     2ca:	a4 0d       	add	r26, r4
     2cc:	b5 1d       	adc	r27, r5
     2ce:	8c 91       	ld	r24, X
     2d0:	80 83       	st	Z, r24
    s[size - i] = c;
     2d2:	5c 93       	st	X, r21

static void myReverse(char s[], uint8_t size) {
  uint8_t i;
  char c;
  size -= 1;
  for (i = 0; i <= size/2; i++) {
     2d4:	4f 5f       	subi	r20, 0xFF	; 255
     2d6:	64 17       	cp	r22, r20
     2d8:	78 f7       	brcc	.-34     	; 0x2b8 <printNumber+0xc8>
	return pos+length;
     2da:	8c 2f       	mov	r24, r28
     2dc:	8d 0f       	add	r24, r29
}
     2de:	cd b7       	in	r28, 0x3d	; 61
     2e0:	de b7       	in	r29, 0x3e	; 62
     2e2:	e0 e1       	ldi	r30, 0x10	; 16
     2e4:	46 cd       	rjmp	.-1396   	; 0xfffffd72 <__eeprom_end+0xff7efb72>
     2e6:	1f c0       	rjmp	.+62     	; 0x326 <printText>
	while (tmp > 9) {
		tmp /= 10;
		++length;
	}
	if (number < 0) {
		++length;
     2e8:	cf 5f       	subi	r28, 0xFF	; 255
     2ea:	a9 cf       	rjmp	.-174    	; 0x23e <printNumber+0x4e>
#ifndef COMMONUTILS_H_
#define COMMONUTILS_H_

// abs seems to only support 16 bits so I had to make my own.
static uint32_t absi32(int32_t a) {
	return (a > 0) ? a : -a;
     2ec:	00 27       	eor	r16, r16
     2ee:	11 27       	eor	r17, r17
     2f0:	98 01       	movw	r18, r16
     2f2:	08 19       	sub	r16, r8
     2f4:	19 09       	sbc	r17, r9
     2f6:	2a 09       	sbc	r18, r10
     2f8:	3b 09       	sbc	r19, r11
     2fa:	87 cf       	rjmp	.-242    	; 0x20a <printNumber+0x1a>
  int8_t i;
  int8_t sign = 0;
 
  if (n < 0) {  
	  sign = -1; /* record sign */
    n = -n;          /* make n positive */
     2fc:	b0 94       	com	r11
     2fe:	a0 94       	com	r10
     300:	90 94       	com	r9
     302:	80 94       	com	r8
     304:	81 1c       	adc	r8, r1
     306:	91 1c       	adc	r9, r1
     308:	a1 1c       	adc	r10, r1
     30a:	b1 1c       	adc	r11, r1
{
  int8_t i;
  int8_t sign = 0;
 
  if (n < 0) {  
	  sign = -1; /* record sign */
     30c:	1f ef       	ldi	r17, 0xFF	; 255
     30e:	aa cf       	rjmp	.-172    	; 0x264 <printNumber+0x74>
  i = 0;
  do {       /* generate digits in reverse order */
    s[i++] = n % 10 + '0';   /* get next digit */
  } while ((n /= 10) > 0);     /* delete it */
  if (sign < 0) {
    s[i++] = '-';
     310:	e8 2f       	mov	r30, r24
     312:	ff 27       	eor	r31, r31
     314:	e7 fd       	sbrc	r30, 7
     316:	f0 95       	com	r31
     318:	e4 0d       	add	r30, r4
     31a:	f5 1d       	adc	r31, r5
     31c:	8d e2       	ldi	r24, 0x2D	; 45
     31e:	80 83       	st	Z, r24
     320:	80 2f       	mov	r24, r16
     322:	8e 5f       	subi	r24, 0xFE	; 254
     324:	bc cf       	rjmp	.-136    	; 0x29e <printNumber+0xae>

00000326 <printText>:
      gTextPixmap[j + (i*TEXT_LINE_MAX_CHARS)] = gTextLastCharBuffer[i];
	  }		  
	}
}

static uint8_t printText(char* const str, uint8_t pos, const char* const str2) {
     326:	0f 93       	push	r16
     328:	1f 93       	push	r17
     32a:	cf 93       	push	r28
     32c:	df 93       	push	r29
     32e:	8c 01       	movw	r16, r24
     330:	d6 2f       	mov	r29, r22
     332:	fa 01       	movw	r30, r20
	uint8_t length = strlen(str2);
     334:	da 01       	movw	r26, r20
     336:	0d 90       	ld	r0, X+
     338:	00 20       	and	r0, r0
     33a:	e9 f7       	brne	.-6      	; 0x336 <printText+0x10>
     33c:	11 97       	sbiw	r26, 0x01	; 1
     33e:	ca 2f       	mov	r28, r26
     340:	c4 1b       	sub	r28, r20
	if (pos + length >= TEXT_LINE_MAX_CHARS) {
     342:	70 e0       	ldi	r23, 0x00	; 0
     344:	8c 2f       	mov	r24, r28
     346:	90 e0       	ldi	r25, 0x00	; 0
     348:	9b 01       	movw	r18, r22
     34a:	28 0f       	add	r18, r24
     34c:	39 1f       	adc	r19, r25
     34e:	21 32       	cpi	r18, 0x21	; 33
     350:	31 05       	cpc	r19, r1
     352:	7c f0       	brlt	.+30     	; 0x372 <printText+0x4c>
     354:	41 e2       	ldi	r20, 0x21	; 33
     356:	50 e0       	ldi	r21, 0x00	; 0
    length = TEXT_LINE_MAX_CHARS;
     358:	c1 e2       	ldi	r28, 0x21	; 33
	}
	strncpy(&str[pos], str2, length);
     35a:	c8 01       	movw	r24, r16
     35c:	86 0f       	add	r24, r22
     35e:	97 1f       	adc	r25, r23
     360:	bf 01       	movw	r22, r30
     362:	2e dd       	rcall	.-1444   	; 0xfffffdc0 <__eeprom_end+0xff7efbc0>
	return length+pos;
}
     364:	8c 2f       	mov	r24, r28
     366:	8d 0f       	add	r24, r29
     368:	df 91       	pop	r29
     36a:	cf 91       	pop	r28
     36c:	1f 91       	pop	r17
     36e:	0f 91       	pop	r16
     370:	08 95       	ret
	}
}

static uint8_t printText(char* const str, uint8_t pos, const char* const str2) {
	uint8_t length = strlen(str2);
	if (pos + length >= TEXT_LINE_MAX_CHARS) {
     372:	ac 01       	movw	r20, r24
     374:	f2 cf       	rjmp	.-28     	; 0x35a <printText+0x34>

00000376 <printNumberWithUnit>:
	}
	myItoa(number, &str[pos]);
	return pos+length;
}

static uint8_t printNumberWithUnit(char* const str, uint8_t pos, int32_t number, const char* unit) {
     376:	0f 93       	push	r16
     378:	1f 93       	push	r17
     37a:	cf 93       	push	r28
     37c:	df 93       	push	r29
     37e:	ec 01       	movw	r28, r24
	pos = printNumber(str, pos, number);
     380:	37 df       	rcall	.-402    	; 0x1f0 <printNumber>
     382:	68 2f       	mov	r22, r24
	return printText(str, pos, unit);
     384:	ce 01       	movw	r24, r28
     386:	a8 01       	movw	r20, r16
     388:	ce df       	rcall	.-100    	; 0x326 <printText>
}
     38a:	df 91       	pop	r29
     38c:	cf 91       	pop	r28
     38e:	1f 91       	pop	r17
     390:	0f 91       	pop	r16
     392:	08 95       	ret

00000394 <printAdc>:
		str[pos++] = '0';
	}	
	return printNumber(str, pos, gTime.sec);
}

static uint8_t printAdc(char* const str, uint8_t pos, const uint8_t adcInput) {
     394:	0f 93       	push	r16
     396:	1f 93       	push	r17
     398:	cf 93       	push	r28
     39a:	df 93       	push	r29
     39c:	ec 01       	movw	r28, r24
	uint8_t low = gAnalogInputs[adcInput].low;
     39e:	e4 2f       	mov	r30, r20
     3a0:	f0 e0       	ldi	r31, 0x00	; 0
     3a2:	ee 0f       	add	r30, r30
     3a4:	ff 1f       	adc	r31, r31
     3a6:	e6 5c       	subi	r30, 0xC6	; 198
     3a8:	fb 4f       	sbci	r31, 0xFB	; 251
     3aa:	10 81       	ld	r17, Z
	uint8_t high = gAnalogInputs[adcInput].high;
	pos = printNumber(str, pos, high);
     3ac:	21 81       	ldd	r18, Z+1	; 0x01
     3ae:	30 e0       	ldi	r19, 0x00	; 0
     3b0:	40 e0       	ldi	r20, 0x00	; 0
     3b2:	50 e0       	ldi	r21, 0x00	; 0
     3b4:	1d df       	rcall	.-454    	; 0x1f0 <printNumber>
	str[pos++] = '.';
     3b6:	fe 01       	movw	r30, r28
     3b8:	e8 0f       	add	r30, r24
     3ba:	f1 1d       	adc	r31, r1
     3bc:	9e e2       	ldi	r25, 0x2E	; 46
     3be:	90 83       	st	Z, r25
     3c0:	68 2f       	mov	r22, r24
     3c2:	6f 5f       	subi	r22, 0xFF	; 255
	if(low < 10) {
     3c4:	1a 30       	cpi	r17, 0x0A	; 10
     3c6:	30 f4       	brcc	.+12     	; 0x3d4 <printAdc+0x40>
		str[pos++] = '0';
     3c8:	fe 01       	movw	r30, r28
     3ca:	e6 0f       	add	r30, r22
     3cc:	f1 1d       	adc	r31, r1
     3ce:	90 e3       	ldi	r25, 0x30	; 48
     3d0:	90 83       	st	Z, r25
     3d2:	6f 5f       	subi	r22, 0xFF	; 255
	}
	return printNumberWithUnit(str, pos, low, "V");		
     3d4:	21 2f       	mov	r18, r17
     3d6:	30 e0       	ldi	r19, 0x00	; 0
     3d8:	40 e0       	ldi	r20, 0x00	; 0
     3da:	50 e0       	ldi	r21, 0x00	; 0
     3dc:	ce 01       	movw	r24, r28
     3de:	00 e0       	ldi	r16, 0x00	; 0
     3e0:	11 e0       	ldi	r17, 0x01	; 1
     3e2:	c9 df       	rcall	.-110    	; 0x376 <printNumberWithUnit>
}
     3e4:	df 91       	pop	r29
     3e6:	cf 91       	pop	r28
     3e8:	1f 91       	pop	r17
     3ea:	0f 91       	pop	r16
     3ec:	08 95       	ret

000003ee <printGpsNumber>:
static uint8_t printBatterLevel(char* const str, uint8_t pos, const uint8_t adcInput) {
	uint8_t batterLevel = calcBatteryLevel(adcInput);
	return printNumberWithUnit(str, pos, batterLevel, "%");
}

static uint8_t printGpsNumber(char* const str, uint8_t pos, int32_t number, uint8_t numberLat) {
     3ee:	a0 e0       	ldi	r26, 0x00	; 0
     3f0:	b0 e0       	ldi	r27, 0x00	; 0
     3f2:	ec ef       	ldi	r30, 0xFC	; 252
     3f4:	f1 e0       	ldi	r31, 0x01	; 1
     3f6:	9f cc       	rjmp	.-1730   	; 0xfffffd36 <__eeprom_end+0xff7efb36>
     3f8:	1c 01       	movw	r2, r24
     3fa:	c6 2f       	mov	r28, r22
     3fc:	69 01       	movw	r12, r18
     3fe:	7a 01       	movw	r14, r20
	if (number == 0) {
     400:	21 15       	cp	r18, r1
     402:	31 05       	cpc	r19, r1
     404:	41 05       	cpc	r20, r1
     406:	51 05       	cpc	r21, r1
     408:	09 f4       	brne	.+2      	; 0x40c <printGpsNumber+0x1e>
     40a:	58 c0       	rjmp	.+176    	; 0x4bc <printGpsNumber+0xce>
	  pos = printText(str, pos, "--:--.----?");
#endif
	  return pos;
  }
	
	uint8_t hour = number / 1000000;
     40c:	ca 01       	movw	r24, r20
     40e:	b9 01       	movw	r22, r18
     410:	20 e4       	ldi	r18, 0x40	; 64
     412:	32 e4       	ldi	r19, 0x42	; 66
     414:	4f e0       	ldi	r20, 0x0F	; 15
     416:	50 e0       	ldi	r21, 0x00	; 0
     418:	73 dc       	rcall	.-1818   	; 0xfffffd00 <__eeprom_end+0xff7efb00>
     41a:	29 01       	movw	r4, r18
     41c:	3a 01       	movw	r6, r20
#ifdef GPS_GOOGLE_FORMAT
  uint32_t min = number - (hour * 1000000);
  min = (min * 100)/60;
#else
	uint8_t min = (number - (hour * 1000000)) / 10000; //Get minute part
     41e:	55 24       	eor	r5, r5
     420:	66 24       	eor	r6, r6
     422:	77 24       	eor	r7, r7
     424:	c3 01       	movw	r24, r6
     426:	b2 01       	movw	r22, r4
     428:	20 ec       	ldi	r18, 0xC0	; 192
     42a:	3d eb       	ldi	r19, 0xBD	; 189
     42c:	40 ef       	ldi	r20, 0xF0	; 240
     42e:	5f ef       	ldi	r21, 0xFF	; 255
     430:	ff db       	rcall	.-2050   	; 0xfffffc30 <__eeprom_end+0xff7efa30>
     432:	6c 0d       	add	r22, r12
     434:	7d 1d       	adc	r23, r13
     436:	8e 1d       	adc	r24, r14
     438:	9f 1d       	adc	r25, r15
     43a:	e0 e1       	ldi	r30, 0x10	; 16
     43c:	8e 2e       	mov	r8, r30
     43e:	e7 e2       	ldi	r30, 0x27	; 39
     440:	9e 2e       	mov	r9, r30
     442:	a1 2c       	mov	r10, r1
     444:	b1 2c       	mov	r11, r1
     446:	a5 01       	movw	r20, r10
     448:	94 01       	movw	r18, r8
     44a:	5a dc       	rcall	.-1868   	; 0xfffffd00 <__eeprom_end+0xff7efb00>
     44c:	d2 2f       	mov	r29, r18
  uint32_t minDecimal = number % 10000; //Get minute decimal part
     44e:	c7 01       	movw	r24, r14
     450:	b6 01       	movw	r22, r12
     452:	a5 01       	movw	r20, r10
     454:	94 01       	movw	r18, r8
     456:	54 dc       	rcall	.-1880   	; 0xfffffd00 <__eeprom_end+0xff7efb00>
     458:	4b 01       	movw	r8, r22
     45a:	5c 01       	movw	r10, r24
#endif
  
  const char* str2;
  if (numberLat) {
     45c:	00 23       	and	r16, r16
     45e:	21 f5       	brne	.+72     	; 0x4a8 <printGpsNumber+0xba>
	  str2 = number > 0 ? "N" : "S";
  }
  else {
	  str2 = number > 0 ? "E" : "W";
     460:	1c 14       	cp	r1, r12
     462:	1d 04       	cpc	r1, r13
     464:	1e 04       	cpc	r1, r14
     466:	1f 04       	cpc	r1, r15
     468:	8c f5       	brge	.+98     	; 0x4cc <printGpsNumber+0xde>
     46a:	56 e0       	ldi	r21, 0x06	; 6
     46c:	c5 2e       	mov	r12, r21
     46e:	51 e0       	ldi	r21, 0x01	; 1
     470:	d5 2e       	mov	r13, r21

#ifdef GPS_GOOGLE_FORMAT
  pos = printNumberWithUnit(str, pos, hour, ".");
  return printNumberWithUnit(str, pos, min, str2);
#else
  pos = printNumberWithUnit(str, pos, hour, ":");
     472:	c1 01       	movw	r24, r2
     474:	6c 2f       	mov	r22, r28
     476:	a3 01       	movw	r20, r6
     478:	92 01       	movw	r18, r4
     47a:	06 e1       	ldi	r16, 0x16	; 22
     47c:	11 e0       	ldi	r17, 0x01	; 1
     47e:	7b df       	rcall	.-266    	; 0x376 <printNumberWithUnit>
     480:	68 2f       	mov	r22, r24
  pos = printNumberWithUnit(str, pos, min, ".");
     482:	2d 2f       	mov	r18, r29
     484:	30 e0       	ldi	r19, 0x00	; 0
     486:	40 e0       	ldi	r20, 0x00	; 0
     488:	50 e0       	ldi	r21, 0x00	; 0
     48a:	c1 01       	movw	r24, r2
     48c:	08 e1       	ldi	r16, 0x18	; 24
     48e:	11 e0       	ldi	r17, 0x01	; 1
     490:	72 df       	rcall	.-284    	; 0x376 <printNumberWithUnit>
     492:	68 2f       	mov	r22, r24
  return printNumberWithUnit(str, pos, minDecimal, str2);
     494:	c1 01       	movw	r24, r2
     496:	a5 01       	movw	r20, r10
     498:	94 01       	movw	r18, r8
     49a:	86 01       	movw	r16, r12
     49c:	6c df       	rcall	.-296    	; 0x376 <printNumberWithUnit>
#endif
}
     49e:	cd b7       	in	r28, 0x3d	; 61
     4a0:	de b7       	in	r29, 0x3e	; 62
     4a2:	e2 e1       	ldi	r30, 0x12	; 18
     4a4:	64 cc       	rjmp	.-1848   	; 0xfffffd6e <__eeprom_end+0xff7efb6e>
     4a6:	1c c0       	rjmp	.+56     	; 0x4e0 <parseInt.constprop.5>
  uint32_t minDecimal = number % 10000; //Get minute decimal part
#endif
  
  const char* str2;
  if (numberLat) {
	  str2 = number > 0 ? "N" : "S";
     4a8:	1c 14       	cp	r1, r12
     4aa:	1d 04       	cpc	r1, r13
     4ac:	1e 04       	cpc	r1, r14
     4ae:	1f 04       	cpc	r1, r15
     4b0:	94 f4       	brge	.+36     	; 0x4d6 <printGpsNumber+0xe8>
     4b2:	68 e0       	ldi	r22, 0x08	; 8
     4b4:	c6 2e       	mov	r12, r22
     4b6:	61 e0       	ldi	r22, 0x01	; 1
     4b8:	d6 2e       	mov	r13, r22
     4ba:	db cf       	rjmp	.-74     	; 0x472 <printGpsNumber+0x84>
static uint8_t printGpsNumber(char* const str, uint8_t pos, int32_t number, uint8_t numberLat) {
	if (number == 0) {
#ifdef GPS_GOOGLE_FORMAT
    pos = printText(str, pos, "--.-------?");
#else
	  pos = printText(str, pos, "--:--.----?");
     4bc:	4a e0       	ldi	r20, 0x0A	; 10
     4be:	51 e0       	ldi	r21, 0x01	; 1
     4c0:	32 df       	rcall	.-412    	; 0x326 <printText>
#else
  pos = printNumberWithUnit(str, pos, hour, ":");
  pos = printNumberWithUnit(str, pos, min, ".");
  return printNumberWithUnit(str, pos, minDecimal, str2);
#endif
}
     4c2:	cd b7       	in	r28, 0x3d	; 61
     4c4:	de b7       	in	r29, 0x3e	; 62
     4c6:	e2 e1       	ldi	r30, 0x12	; 18
     4c8:	52 cc       	rjmp	.-1884   	; 0xfffffd6e <__eeprom_end+0xff7efb6e>
     4ca:	0a c0       	rjmp	.+20     	; 0x4e0 <parseInt.constprop.5>
  const char* str2;
  if (numberLat) {
	  str2 = number > 0 ? "N" : "S";
  }
  else {
	  str2 = number > 0 ? "E" : "W";
     4cc:	34 e0       	ldi	r19, 0x04	; 4
     4ce:	c3 2e       	mov	r12, r19
     4d0:	31 e0       	ldi	r19, 0x01	; 1
     4d2:	d3 2e       	mov	r13, r19
     4d4:	ce cf       	rjmp	.-100    	; 0x472 <printGpsNumber+0x84>
  uint32_t minDecimal = number % 10000; //Get minute decimal part
#endif
  
  const char* str2;
  if (numberLat) {
	  str2 = number > 0 ? "N" : "S";
     4d6:	42 e0       	ldi	r20, 0x02	; 2
     4d8:	c4 2e       	mov	r12, r20
     4da:	41 e0       	ldi	r20, 0x01	; 1
     4dc:	d4 2e       	mov	r13, r20
     4de:	c9 cf       	rjmp	.-110    	; 0x472 <printGpsNumber+0x84>

000004e0 <parseInt.constprop.5>:
	tmp /= 1000;
	*var = tmp;
}
#endif //IMPERIAL_SYSTEM

static int32_t parseInt(const char* const text, uint8_t maxLength) {
     4e0:	ff 92       	push	r15
     4e2:	0f 93       	push	r16
     4e4:	1f 93       	push	r17
     4e6:	cf 93       	push	r28
     4e8:	df 93       	push	r29
	uint8_t i = 0;
     4ea:	ff 24       	eor	r15, r15
     4ec:	f3 94       	inc	r15
     4ee:	80 91 d6 03 	lds	r24, 0x03D6
     4f2:	8d 32       	cpi	r24, 0x2D	; 45
     4f4:	09 f0       	breq	.+2      	; 0x4f8 <parseInt.constprop.5+0x18>
     4f6:	ff 24       	eor	r15, r15
	uint8_t neg = 0;
	if (text[0] == '-') {
		++i;
		neg = 1;
	}
	while (isDigit(text[i]) && i < maxLength) {
     4f8:	ef 2d       	mov	r30, r15
     4fa:	f0 e0       	ldi	r31, 0x00	; 0
     4fc:	ea 52       	subi	r30, 0x2A	; 42
     4fe:	fc 4f       	sbci	r31, 0xFC	; 252
     500:	d0 81       	ld	r29, Z
  } while (c++ < 25);
  return nv;
}

inline uint8_t isDigit(char c) {
	if (c >= '0' && c <= '9') {
     502:	8d 2f       	mov	r24, r29
     504:	80 53       	subi	r24, 0x30	; 48
     506:	8a 30       	cpi	r24, 0x0A	; 10
     508:	88 f0       	brcs	.+34     	; 0x52c <__stack+0x2d>
     50a:	00 e0       	ldi	r16, 0x00	; 0
     50c:	10 e0       	ldi	r17, 0x00	; 0
     50e:	98 01       	movw	r18, r16
		decimal *= 10;
		decimal += (text[i]) - '0';
		++i;		
	}
	return decimal * (neg ? -1 : 1);
     510:	ff 20       	and	r15, r15
     512:	99 f5       	brne	.+102    	; 0x57a <__stack+0x7b>
     514:	61 e0       	ldi	r22, 0x01	; 1
     516:	70 e0       	ldi	r23, 0x00	; 0
     518:	80 e0       	ldi	r24, 0x00	; 0
     51a:	90 e0       	ldi	r25, 0x00	; 0
     51c:	a9 01       	movw	r20, r18
     51e:	98 01       	movw	r18, r16
     520:	87 db       	rcall	.-2290   	; 0xfffffc30 <__eeprom_end+0xff7efa30>
}
     522:	cd b7       	in	r28, 0x3d	; 61
     524:	de b7       	in	r29, 0x3e	; 62
     526:	e5 e0       	ldi	r30, 0x05	; 5
     528:	2f cc       	rjmp	.-1954   	; 0xfffffd88 <__eeprom_end+0xff7efb88>
     52a:	31 c0       	rjmp	.+98     	; 0x58e <parseFloat.constprop.6>
     52c:	cf 2d       	mov	r28, r15
     52e:	00 e0       	ldi	r16, 0x00	; 0
     530:	10 e0       	ldi	r17, 0x00	; 0
     532:	98 01       	movw	r18, r16
	if (text[0] == '-') {
		++i;
		neg = 1;
	}
	while (isDigit(text[i]) && i < maxLength) {
		decimal *= 10;
     534:	c9 01       	movw	r24, r18
     536:	b8 01       	movw	r22, r16
     538:	2a e0       	ldi	r18, 0x0A	; 10
     53a:	30 e0       	ldi	r19, 0x00	; 0
     53c:	40 e0       	ldi	r20, 0x00	; 0
     53e:	50 e0       	ldi	r21, 0x00	; 0
     540:	77 db       	rcall	.-2322   	; 0xfffffc30 <__eeprom_end+0xff7efa30>
     542:	dc 01       	movw	r26, r24
     544:	cb 01       	movw	r24, r22
		decimal += (text[i]) - '0';
     546:	0d 2f       	mov	r16, r29
     548:	10 e0       	ldi	r17, 0x00	; 0
     54a:	00 53       	subi	r16, 0x30	; 48
     54c:	10 40       	sbci	r17, 0x00	; 0
     54e:	22 27       	eor	r18, r18
     550:	17 fd       	sbrc	r17, 7
     552:	20 95       	com	r18
     554:	32 2f       	mov	r19, r18
     556:	08 0f       	add	r16, r24
     558:	19 1f       	adc	r17, r25
     55a:	2a 1f       	adc	r18, r26
     55c:	3b 1f       	adc	r19, r27
		++i;		
     55e:	cf 5f       	subi	r28, 0xFF	; 255
	uint8_t neg = 0;
	if (text[0] == '-') {
		++i;
		neg = 1;
	}
	while (isDigit(text[i]) && i < maxLength) {
     560:	ec 2f       	mov	r30, r28
     562:	f0 e0       	ldi	r31, 0x00	; 0
     564:	ea 52       	subi	r30, 0x2A	; 42
     566:	fc 4f       	sbci	r31, 0xFC	; 252
     568:	d0 81       	ld	r29, Z
     56a:	8d 2f       	mov	r24, r29
     56c:	80 53       	subi	r24, 0x30	; 48
     56e:	8a 30       	cpi	r24, 0x0A	; 10
     570:	78 f6       	brcc	.-98     	; 0x510 <__stack+0x11>
     572:	cb 30       	cpi	r28, 0x0B	; 11
     574:	f8 f2       	brcs	.-66     	; 0x534 <__stack+0x35>
		decimal *= 10;
		decimal += (text[i]) - '0';
		++i;		
	}
	return decimal * (neg ? -1 : 1);
     576:	ff 20       	and	r15, r15
     578:	69 f2       	breq	.-102    	; 0x514 <__stack+0x15>
     57a:	6f ef       	ldi	r22, 0xFF	; 255
     57c:	7f ef       	ldi	r23, 0xFF	; 255
     57e:	cb 01       	movw	r24, r22
     580:	a9 01       	movw	r20, r18
     582:	98 01       	movw	r18, r16
     584:	55 db       	rcall	.-2390   	; 0xfffffc30 <__eeprom_end+0xff7efa30>
}
     586:	cd b7       	in	r28, 0x3d	; 61
     588:	de b7       	in	r29, 0x3e	; 62
     58a:	e5 e0       	ldi	r30, 0x05	; 5
     58c:	fd cb       	rjmp	.-2054   	; 0xfffffd88 <__eeprom_end+0xff7efb88>

0000058e <parseFloat.constprop.6>:

static int32_t parseFloat(const char* const text, uint8_t maxLength) {
     58e:	ff 92       	push	r15
     590:	0f 93       	push	r16
     592:	1f 93       	push	r17
     594:	cf 93       	push	r28
     596:	df 93       	push	r29
	
	uint32_t val = 0;
	uint8_t neg = 0;
     598:	ff 24       	eor	r15, r15
     59a:	f3 94       	inc	r15
     59c:	80 91 d6 03 	lds	r24, 0x03D6
     5a0:	8d 32       	cpi	r24, 0x2D	; 45
     5a2:	09 f0       	breq	.+2      	; 0x5a6 <parseFloat.constprop.6+0x18>
     5a4:	ff 24       	eor	r15, r15
     5a6:	cf 2d       	mov	r28, r15
     5a8:	00 e0       	ldi	r16, 0x00	; 0
     5aa:	10 e0       	ldi	r17, 0x00	; 0
     5ac:	98 01       	movw	r18, r16
     5ae:	18 c0       	rjmp	.+48     	; 0x5e0 <parseFloat.constprop.6+0x52>
		++i;
		neg = 1;
	}
	for (; i < maxLength; ++i) {
		if (isDigit(text[i])) {
			val *= 10;
     5b0:	c9 01       	movw	r24, r18
     5b2:	b8 01       	movw	r22, r16
     5b4:	2a e0       	ldi	r18, 0x0A	; 10
     5b6:	30 e0       	ldi	r19, 0x00	; 0
     5b8:	40 e0       	ldi	r20, 0x00	; 0
     5ba:	50 e0       	ldi	r21, 0x00	; 0
     5bc:	39 db       	rcall	.-2446   	; 0xfffffc30 <__eeprom_end+0xff7efa30>
     5be:	dc 01       	movw	r26, r24
     5c0:	cb 01       	movw	r24, r22
			val += (text[i]) - '0';
     5c2:	0d 2f       	mov	r16, r29
     5c4:	10 e0       	ldi	r17, 0x00	; 0
     5c6:	00 53       	subi	r16, 0x30	; 48
     5c8:	10 40       	sbci	r17, 0x00	; 0
     5ca:	22 27       	eor	r18, r18
     5cc:	17 fd       	sbrc	r17, 7
     5ce:	20 95       	com	r18
     5d0:	32 2f       	mov	r19, r18
     5d2:	08 0f       	add	r16, r24
     5d4:	19 1f       	adc	r17, r25
     5d6:	2a 1f       	adc	r18, r26
     5d8:	3b 1f       	adc	r19, r27
	uint8_t i = 0;
	if (text[0] == '-') {
		++i;
		neg = 1;
	}
	for (; i < maxLength; ++i) {
     5da:	cf 5f       	subi	r28, 0xFF	; 255
     5dc:	cb 30       	cpi	r28, 0x0B	; 11
     5de:	58 f4       	brcc	.+22     	; 0x5f6 <parseFloat.constprop.6+0x68>
		if (isDigit(text[i])) {
     5e0:	ec 2f       	mov	r30, r28
     5e2:	f0 e0       	ldi	r31, 0x00	; 0
     5e4:	ea 52       	subi	r30, 0x2A	; 42
     5e6:	fc 4f       	sbci	r31, 0xFC	; 252
     5e8:	d0 81       	ld	r29, Z
     5ea:	8d 2f       	mov	r24, r29
     5ec:	80 53       	subi	r24, 0x30	; 48
     5ee:	8a 30       	cpi	r24, 0x0A	; 10
     5f0:	f8 f2       	brcs	.-66     	; 0x5b0 <parseFloat.constprop.6+0x22>
			val *= 10;
			val += (text[i]) - '0';
		}
		else if (text[i] != '.') {
     5f2:	de 32       	cpi	r29, 0x2E	; 46
     5f4:	91 f3       	breq	.-28     	; 0x5da <parseFloat.constprop.6+0x4c>
			break;
		}			
	}
	return val * (neg ? -1 : 1);
     5f6:	ff 20       	and	r15, r15
     5f8:	61 f4       	brne	.+24     	; 0x612 <parseFloat.constprop.6+0x84>
     5fa:	61 e0       	ldi	r22, 0x01	; 1
     5fc:	70 e0       	ldi	r23, 0x00	; 0
     5fe:	80 e0       	ldi	r24, 0x00	; 0
     600:	90 e0       	ldi	r25, 0x00	; 0
     602:	a9 01       	movw	r20, r18
     604:	98 01       	movw	r18, r16
     606:	14 db       	rcall	.-2520   	; 0xfffffc30 <__eeprom_end+0xff7efa30>
}
     608:	cd b7       	in	r28, 0x3d	; 61
     60a:	de b7       	in	r29, 0x3e	; 62
     60c:	e5 e0       	ldi	r30, 0x05	; 5
     60e:	bc cb       	rjmp	.-2184   	; 0xfffffd88 <__eeprom_end+0xff7efb88>
     610:	0a c0       	rjmp	.+20     	; 0x626 <parseGpsPart>
		}
		else if (text[i] != '.') {
			break;
		}			
	}
	return val * (neg ? -1 : 1);
     612:	6f ef       	ldi	r22, 0xFF	; 255
     614:	7f ef       	ldi	r23, 0xFF	; 255
     616:	cb 01       	movw	r24, r22
     618:	a9 01       	movw	r20, r18
     61a:	98 01       	movw	r18, r16
     61c:	09 db       	rcall	.-2542   	; 0xfffffc30 <__eeprom_end+0xff7efa30>
}
     61e:	cd b7       	in	r28, 0x3d	; 61
     620:	de b7       	in	r29, 0x3e	; 62
     622:	e5 e0       	ldi	r30, 0x05	; 5
     624:	b1 cb       	rjmp	.-2206   	; 0xfffffd88 <__eeprom_end+0xff7efb88>

00000626 <parseGpsPart>:
	gGpsTextPartLength = strlen((const char*)gGpsText);
}
#endif //GPS_PART_TEXT

static void parseGpsPart() {
	if (gGpsTextType == GPS_TYPE_NONE) {
     626:	80 91 d4 03 	lds	r24, 0x03D4
     62a:	88 23       	and	r24, r24
     62c:	81 f1       	breq	.+96     	; 0x68e <parseGpsPart+0x68>
			gGpsTextPartStep = GPS_GPRMC_PART_OFFSET;
			//updateParts();
		}
	}
	else if (gGpsTextType != GPS_TYPE_NONE) {
		if (gGpsTextPos != 0) {
     62e:	80 91 d3 03 	lds	r24, 0x03D3
     632:	88 23       	and	r24, r24
     634:	59 f1       	breq	.+86     	; 0x68c <parseGpsPart+0x66>
			switch (gGpsTextPartStep) {
     636:	80 91 60 01 	lds	r24, 0x0160
     63a:	85 36       	cpi	r24, 0x65	; 101
     63c:	89 f0       	breq	.+34     	; 0x660 <parseGpsPart+0x3a>
     63e:	86 36       	cpi	r24, 0x66	; 102
     640:	08 f0       	brcs	.+2      	; 0x644 <parseGpsPart+0x1e>
     642:	44 c0       	rjmp	.+136    	; 0x6cc <parseGpsPart+0xa6>
     644:	84 30       	cpi	r24, 0x04	; 4
     646:	09 f4       	brne	.+2      	; 0x64a <parseGpsPart+0x24>
     648:	75 c0       	rjmp	.+234    	; 0x734 <parseGpsPart+0x10e>
     64a:	85 30       	cpi	r24, 0x05	; 5
     64c:	08 f0       	brcs	.+2      	; 0x650 <parseGpsPart+0x2a>
     64e:	7e c0       	rjmp	.+252    	; 0x74c <parseGpsPart+0x126>
     650:	82 30       	cpi	r24, 0x02	; 2
     652:	09 f4       	brne	.+2      	; 0x656 <parseGpsPart+0x30>
     654:	47 c0       	rjmp	.+142    	; 0x6e4 <parseGpsPart+0xbe>
     656:	83 30       	cpi	r24, 0x03	; 3
     658:	08 f0       	brcs	.+2      	; 0x65c <parseGpsPart+0x36>
     65a:	21 c1       	rjmp	.+578    	; 0x89e <parseGpsPart+0x278>
     65c:	81 30       	cpi	r24, 0x01	; 1
     65e:	b1 f4       	brne	.+44     	; 0x68c <parseGpsPart+0x66>
			case GPS_PART_GPGGA_TIME:
			case GPS_PART_GPRMC_TIME:
				gGpsLastData.gTime = parseInt(gGpsText, GPS_MAX_CHARS);
     660:	3f df       	rcall	.-386    	; 0x4e0 <parseInt.constprop.5>
     662:	dc 01       	movw	r26, r24
     664:	cb 01       	movw	r24, r22
     666:	80 93 85 01 	sts	0x0185, r24
     66a:	90 93 86 01 	sts	0x0186, r25
     66e:	a0 93 87 01 	sts	0x0187, r26
     672:	b0 93 88 01 	sts	0x0188, r27
     676:	08 95       	ret

static uint8_t parseHex(const char* const text, uint8_t maxLength) {
	uint8_t i = 0;
	uint32_t val = 0;
	while (text[i] != 0 && i < maxLength) {
     678:	80 e0       	ldi	r24, 0x00	; 0
     67a:	90 e0       	ldi	r25, 0x00	; 0
     67c:	dc 01       	movw	r26, r24
			  break;
			case GPS_PART_CHECKSUM:
				//updateParts();
				{
				uint8_t val = parseHex(gGpsText, GPS_MAX_CHARS);
				gGpsLastData.checksumValid = (val == gGpsChecksum);
     67e:	21 e0       	ldi	r18, 0x01	; 1
     680:	30 91 d5 03 	lds	r19, 0x03D5
     684:	38 13       	cpse	r19, r24
     686:	20 e0       	ldi	r18, 0x00	; 0
     688:	20 93 93 01 	sts	0x0193, r18
     68c:	08 95       	ret
}
#endif //GPS_PART_TEXT

static void parseGpsPart() {
	if (gGpsTextType == GPS_TYPE_NONE) {
		if (!strncmp((const char*)gGpsText, "GPGGA", 5)) {
     68e:	86 ed       	ldi	r24, 0xD6	; 214
     690:	93 e0       	ldi	r25, 0x03	; 3
     692:	6a e1       	ldi	r22, 0x1A	; 26
     694:	71 e0       	ldi	r23, 0x01	; 1
     696:	45 e0       	ldi	r20, 0x05	; 5
     698:	50 e0       	ldi	r21, 0x00	; 0
     69a:	84 db       	rcall	.-2296   	; 0xfffffda4 <__eeprom_end+0xff7efba4>
     69c:	00 97       	sbiw	r24, 0x00	; 0
     69e:	81 f0       	breq	.+32     	; 0x6c0 <parseGpsPart+0x9a>
			gGpsTextType = GPS_TYPE_GPGGA;
			gGpsTextPartStep = GPS_PART_NONE;
			//updateParts();
		}
		else if (!strncmp((const char*)gGpsText, "GPRMC", 5)) {
     6a0:	86 ed       	ldi	r24, 0xD6	; 214
     6a2:	93 e0       	ldi	r25, 0x03	; 3
     6a4:	60 e2       	ldi	r22, 0x20	; 32
     6a6:	71 e0       	ldi	r23, 0x01	; 1
     6a8:	45 e0       	ldi	r20, 0x05	; 5
     6aa:	50 e0       	ldi	r21, 0x00	; 0
     6ac:	7b db       	rcall	.-2314   	; 0xfffffda4 <__eeprom_end+0xff7efba4>
     6ae:	00 97       	sbiw	r24, 0x00	; 0
     6b0:	69 f7       	brne	.-38     	; 0x68c <parseGpsPart+0x66>
			gGpsTextType = GPS_TYPE_GPRMC;
     6b2:	82 e0       	ldi	r24, 0x02	; 2
     6b4:	80 93 d4 03 	sts	0x03D4, r24
			gGpsTextPartStep = GPS_GPRMC_PART_OFFSET;
     6b8:	84 e6       	ldi	r24, 0x64	; 100
     6ba:	80 93 60 01 	sts	0x0160, r24
     6be:	08 95       	ret
#endif //GPS_PART_TEXT

static void parseGpsPart() {
	if (gGpsTextType == GPS_TYPE_NONE) {
		if (!strncmp((const char*)gGpsText, "GPGGA", 5)) {
			gGpsTextType = GPS_TYPE_GPGGA;
     6c0:	81 e0       	ldi	r24, 0x01	; 1
     6c2:	80 93 d4 03 	sts	0x03D4, r24
			gGpsTextPartStep = GPS_PART_NONE;
     6c6:	10 92 60 01 	sts	0x0160, r1
     6ca:	08 95       	ret
			//updateParts();
		}
	}
	else if (gGpsTextType != GPS_TYPE_NONE) {
		if (gGpsTextPos != 0) {
			switch (gGpsTextPartStep) {
     6cc:	8a 36       	cpi	r24, 0x6A	; 106
     6ce:	b1 f0       	breq	.+44     	; 0x6fc <parseGpsPart+0xd6>
     6d0:	8b 36       	cpi	r24, 0x6B	; 107
     6d2:	08 f0       	brcs	.+2      	; 0x6d6 <parseGpsPart+0xb0>
     6d4:	4e c0       	rjmp	.+156    	; 0x772 <parseGpsPart+0x14c>
     6d6:	88 36       	cpi	r24, 0x68	; 104
     6d8:	09 f4       	brne	.+2      	; 0x6dc <parseGpsPart+0xb6>
     6da:	e1 c0       	rjmp	.+450    	; 0x89e <parseGpsPart+0x278>
     6dc:	89 36       	cpi	r24, 0x69	; 105
     6de:	50 f5       	brcc	.+84     	; 0x734 <parseGpsPart+0x10e>
     6e0:	87 36       	cpi	r24, 0x67	; 103
     6e2:	a1 f6       	brne	.-88     	; 0x68c <parseGpsPart+0x66>
				gGpsLastData.gTime = parseInt(gGpsText, GPS_MAX_CHARS);
				//updateParts();
				break;
			case GPS_PART_GPGGA_LAT:
			case GPS_PART_GPRMC_LAT:
				gGpsLastData.pos.latitude = parseFloat(gGpsText, GPS_MAX_CHARS);
     6e4:	54 df       	rcall	.-344    	; 0x58e <parseFloat.constprop.6>
     6e6:	dc 01       	movw	r26, r24
     6e8:	cb 01       	movw	r24, r22
     6ea:	80 93 7b 01 	sts	0x017B, r24
     6ee:	90 93 7c 01 	sts	0x017C, r25
     6f2:	a0 93 7d 01 	sts	0x017D, r26
     6f6:	b0 93 7e 01 	sts	0x017E, r27
     6fa:	08 95       	ret
				gGpsLastData.pos.longitude = parseFloat(gGpsText, GPS_MAX_CHARS);
				//updateParts();
				break;
			case GPS_PART_GPGGA_LONG_UNIT:
			case GPS_PART_GPRMC_LONG_UNIT:
				if (gGpsText[0] == 'W') {
     6fc:	80 91 d6 03 	lds	r24, 0x03D6
     700:	87 35       	cpi	r24, 0x57	; 87
     702:	21 f6       	brne	.-120    	; 0x68c <parseGpsPart+0x66>
					gGpsLastData.pos.longitude = -gGpsLastData.pos.longitude;
     704:	80 91 7f 01 	lds	r24, 0x017F
     708:	90 91 80 01 	lds	r25, 0x0180
     70c:	a0 91 81 01 	lds	r26, 0x0181
     710:	b0 91 82 01 	lds	r27, 0x0182
     714:	b0 95       	com	r27
     716:	a0 95       	com	r26
     718:	90 95       	com	r25
     71a:	81 95       	neg	r24
     71c:	9f 4f       	sbci	r25, 0xFF	; 255
     71e:	af 4f       	sbci	r26, 0xFF	; 255
     720:	bf 4f       	sbci	r27, 0xFF	; 255
     722:	80 93 7f 01 	sts	0x017F, r24
     726:	90 93 80 01 	sts	0x0180, r25
     72a:	a0 93 81 01 	sts	0x0181, r26
     72e:	b0 93 82 01 	sts	0x0182, r27
     732:	08 95       	ret
					gGpsLastData.pos.latitude = -gGpsLastData.pos.latitude;
				}
				break;
			case GPS_PART_GPGGA_LONG:
			case GPS_PART_GPRMC_LONG:
				gGpsLastData.pos.longitude = parseFloat(gGpsText, GPS_MAX_CHARS);
     734:	2c df       	rcall	.-424    	; 0x58e <parseFloat.constprop.6>
     736:	dc 01       	movw	r26, r24
     738:	cb 01       	movw	r24, r22
     73a:	80 93 7f 01 	sts	0x017F, r24
     73e:	90 93 80 01 	sts	0x0180, r25
     742:	a0 93 81 01 	sts	0x0181, r26
     746:	b0 93 82 01 	sts	0x0182, r27
     74a:	08 95       	ret
			//updateParts();
		}
	}
	else if (gGpsTextType != GPS_TYPE_NONE) {
		if (gGpsTextPos != 0) {
			switch (gGpsTextPartStep) {
     74c:	86 30       	cpi	r24, 0x06	; 6
     74e:	09 f4       	brne	.+2      	; 0x752 <parseGpsPart+0x12c>
     750:	a0 c0       	rjmp	.+320    	; 0x892 <parseGpsPart+0x26c>
     752:	86 30       	cpi	r24, 0x06	; 6
     754:	98 f2       	brcs	.-90     	; 0x6fc <parseGpsPart+0xd6>
     756:	87 30       	cpi	r24, 0x07	; 7
     758:	09 f4       	brne	.+2      	; 0x75c <parseGpsPart+0x136>
     75a:	95 c0       	rjmp	.+298    	; 0x886 <parseGpsPart+0x260>
     75c:	89 30       	cpi	r24, 0x09	; 9
     75e:	09 f0       	breq	.+2      	; 0x762 <parseGpsPart+0x13c>
     760:	95 cf       	rjmp	.-214    	; 0x68c <parseGpsPart+0x66>
				break;
			case GPS_PART_GPGGA_DILUTION:
				// Horizontal dilution of position
				break;
			case GPS_PART_GPGGA_ALTITUDE:
				gGpsLastData.pos.altitude = parseInt(gGpsText, GPS_MAX_CHARS);
     762:	be de       	rcall	.-644    	; 0x4e0 <parseInt.constprop.5>
     764:	dc 01       	movw	r26, r24
     766:	cb 01       	movw	r24, r22
     768:	90 93 84 01 	sts	0x0184, r25
     76c:	80 93 83 01 	sts	0x0183, r24
     770:	08 95       	ret
			//updateParts();
		}
	}
	else if (gGpsTextType != GPS_TYPE_NONE) {
		if (gGpsTextPos != 0) {
			switch (gGpsTextPartStep) {
     772:	8c 36       	cpi	r24, 0x6C	; 108
     774:	09 f4       	brne	.+2      	; 0x778 <parseGpsPart+0x152>
     776:	7f c0       	rjmp	.+254    	; 0x876 <parseGpsPart+0x250>
     778:	8c 36       	cpi	r24, 0x6C	; 108
     77a:	08 f4       	brcc	.+2      	; 0x77e <parseGpsPart+0x158>
     77c:	68 c0       	rjmp	.+208    	; 0x84e <parseGpsPart+0x228>
     77e:	8d 36       	cpi	r24, 0x6D	; 109
     780:	09 f4       	brne	.+2      	; 0x784 <parseGpsPart+0x15e>
     782:	59 c0       	rjmp	.+178    	; 0x836 <parseGpsPart+0x210>
     784:	88 3c       	cpi	r24, 0xC8	; 200
     786:	09 f0       	breq	.+2      	; 0x78a <parseGpsPart+0x164>
     788:	81 cf       	rjmp	.-254    	; 0x68c <parseGpsPart+0x66>
     78a:	20 91 d6 03 	lds	r18, 0x03D6
     78e:	22 23       	and	r18, r18
     790:	09 f4       	brne	.+2      	; 0x794 <parseGpsPart+0x16e>
     792:	72 cf       	rjmp	.-284    	; 0x678 <parseGpsPart+0x52>
				break;
			case GPS_PART_GPRMC_ANGLE:
				gGpsLastData.angle = parseInt(gGpsText, GPS_MAX_CHARS); // Only use int part
				break;
			case GPS_PART_GPRMC_DATE:
			  gGpsLastData.date = parseInt(gGpsText, GPS_MAX_CHARS);
     794:	e7 ed       	ldi	r30, 0xD7	; 215
     796:	f3 e0       	ldi	r31, 0x03	; 3
	strncpy((char*)gGpsTextPart, (char*)gGpsText, GPS_MAX_CHARS);
	gGpsTextPartLength = strlen((const char*)gGpsText);
}
#endif //GPS_PART_TEXT

static void parseGpsPart() {
     798:	80 e0       	ldi	r24, 0x00	; 0
     79a:	90 e0       	ldi	r25, 0x00	; 0
     79c:	dc 01       	movw	r26, r24
     79e:	15 c0       	rjmp	.+42     	; 0x7ca <parseGpsPart+0x1a4>
		val *= 16;
		if (text[i] >= 'A' && text[i] <= 'F') {
			val += 10 + text[i] - 'A';
     7a0:	30 e0       	ldi	r19, 0x00	; 0
     7a2:	27 53       	subi	r18, 0x37	; 55
     7a4:	30 40       	sbci	r19, 0x00	; 0
     7a6:	a9 01       	movw	r20, r18
     7a8:	66 27       	eor	r22, r22
     7aa:	57 fd       	sbrc	r21, 7
     7ac:	60 95       	com	r22
     7ae:	76 2f       	mov	r23, r22
     7b0:	84 0f       	add	r24, r20
     7b2:	95 1f       	adc	r25, r21
     7b4:	a6 1f       	adc	r26, r22
     7b6:	b7 1f       	adc	r27, r23
}

static uint8_t parseHex(const char* const text, uint8_t maxLength) {
	uint8_t i = 0;
	uint32_t val = 0;
	while (text[i] != 0 && i < maxLength) {
     7b8:	21 91       	ld	r18, Z+
     7ba:	22 23       	and	r18, r18
     7bc:	09 f4       	brne	.+2      	; 0x7c0 <parseGpsPart+0x19a>
     7be:	5f cf       	rjmp	.-322    	; 0x67e <parseGpsPart+0x58>
     7c0:	33 e0       	ldi	r19, 0x03	; 3
     7c2:	e2 3e       	cpi	r30, 0xE2	; 226
     7c4:	f3 07       	cpc	r31, r19
     7c6:	09 f4       	brne	.+2      	; 0x7ca <parseGpsPart+0x1a4>
     7c8:	5a cf       	rjmp	.-332    	; 0x67e <parseGpsPart+0x58>
		val *= 16;
     7ca:	88 0f       	add	r24, r24
     7cc:	99 1f       	adc	r25, r25
     7ce:	aa 1f       	adc	r26, r26
     7d0:	bb 1f       	adc	r27, r27
     7d2:	88 0f       	add	r24, r24
     7d4:	99 1f       	adc	r25, r25
     7d6:	aa 1f       	adc	r26, r26
     7d8:	bb 1f       	adc	r27, r27
     7da:	88 0f       	add	r24, r24
     7dc:	99 1f       	adc	r25, r25
     7de:	aa 1f       	adc	r26, r26
     7e0:	bb 1f       	adc	r27, r27
     7e2:	88 0f       	add	r24, r24
     7e4:	99 1f       	adc	r25, r25
     7e6:	aa 1f       	adc	r26, r26
     7e8:	bb 1f       	adc	r27, r27
		if (text[i] >= 'A' && text[i] <= 'F') {
     7ea:	32 2f       	mov	r19, r18
     7ec:	31 54       	subi	r19, 0x41	; 65
     7ee:	36 30       	cpi	r19, 0x06	; 6
     7f0:	b8 f2       	brcs	.-82     	; 0x7a0 <parseGpsPart+0x17a>
			val += 10 + text[i] - 'A';
		}
		else if (text[i] >= 'a' && text[i] <= 'f') {
     7f2:	32 2f       	mov	r19, r18
     7f4:	31 56       	subi	r19, 0x61	; 97
     7f6:	36 30       	cpi	r19, 0x06	; 6
     7f8:	68 f4       	brcc	.+26     	; 0x814 <parseGpsPart+0x1ee>
			val += 10 + text[i] - 'a';
     7fa:	30 e0       	ldi	r19, 0x00	; 0
     7fc:	27 55       	subi	r18, 0x57	; 87
     7fe:	30 40       	sbci	r19, 0x00	; 0
     800:	a9 01       	movw	r20, r18
     802:	66 27       	eor	r22, r22
     804:	57 fd       	sbrc	r21, 7
     806:	60 95       	com	r22
     808:	76 2f       	mov	r23, r22
     80a:	84 0f       	add	r24, r20
     80c:	95 1f       	adc	r25, r21
     80e:	a6 1f       	adc	r26, r22
     810:	b7 1f       	adc	r27, r23
     812:	d2 cf       	rjmp	.-92     	; 0x7b8 <parseGpsPart+0x192>
		}
		else if (text[i] >= '0' && text[i] <= '9') {
     814:	32 2f       	mov	r19, r18
     816:	30 53       	subi	r19, 0x30	; 48
     818:	3a 30       	cpi	r19, 0x0A	; 10
     81a:	70 f6       	brcc	.-100    	; 0x7b8 <parseGpsPart+0x192>
			val += text[i] - '0';
     81c:	30 e0       	ldi	r19, 0x00	; 0
     81e:	20 53       	subi	r18, 0x30	; 48
     820:	30 40       	sbci	r19, 0x00	; 0
     822:	a9 01       	movw	r20, r18
     824:	66 27       	eor	r22, r22
     826:	57 fd       	sbrc	r21, 7
     828:	60 95       	com	r22
     82a:	76 2f       	mov	r23, r22
     82c:	84 0f       	add	r24, r20
     82e:	95 1f       	adc	r25, r21
     830:	a6 1f       	adc	r26, r22
     832:	b7 1f       	adc	r27, r23
     834:	c1 cf       	rjmp	.-126    	; 0x7b8 <parseGpsPart+0x192>
				break;
			case GPS_PART_GPRMC_ANGLE:
				gGpsLastData.angle = parseInt(gGpsText, GPS_MAX_CHARS); // Only use int part
				break;
			case GPS_PART_GPRMC_DATE:
			  gGpsLastData.date = parseInt(gGpsText, GPS_MAX_CHARS);
     836:	54 de       	rcall	.-856    	; 0x4e0 <parseInt.constprop.5>
     838:	dc 01       	movw	r26, r24
     83a:	cb 01       	movw	r24, r22
     83c:	80 93 8f 01 	sts	0x018F, r24
     840:	90 93 90 01 	sts	0x0190, r25
     844:	a0 93 91 01 	sts	0x0191, r26
     848:	b0 93 92 01 	sts	0x0192, r27
     84c:	08 95       	ret
				break;
			case GPS_PART_GPGGA_GEOID_HEIGHT_UNIT:
				// Geoid unit
				break;
			case GPS_PART_GPRMC_SPEED:
				gGpsLastData.speed = parseInt(gGpsText, GPS_MAX_CHARS); // Only use int part
     84e:	48 de       	rcall	.-880    	; 0x4e0 <parseInt.constprop.5>
     850:	ab 01       	movw	r20, r22
     852:	bc 01       	movw	r22, r24
#ifdef METRIC_SYSTEM
				// Convert to km/h. 1 knot = 1.852 km/h = 463/250
				gGpsLastData.speed *= 463; // Might need bigger var if you go really fast! :-)
     854:	2f ec       	ldi	r18, 0xCF	; 207
     856:	31 e0       	ldi	r19, 0x01	; 1
     858:	42 9f       	mul	r20, r18
     85a:	c0 01       	movw	r24, r0
     85c:	43 9f       	mul	r20, r19
     85e:	90 0d       	add	r25, r0
     860:	52 9f       	mul	r21, r18
     862:	90 0d       	add	r25, r0
     864:	11 24       	eor	r1, r1
				gGpsLastData.speed /= 250;
     866:	6a ef       	ldi	r22, 0xFA	; 250
     868:	70 e0       	ldi	r23, 0x00	; 0
     86a:	01 da       	rcall	.-3070   	; 0xfffffc6e <__eeprom_end+0xff7efa6e>
     86c:	70 93 8c 01 	sts	0x018C, r23
     870:	60 93 8b 01 	sts	0x018B, r22
     874:	08 95       	ret
#else // IMPERIAL_SYSTEM
        knotToMph(&gGpsLastData.speed);
#endif // METRIC_SYSTEM
				break;
			case GPS_PART_GPRMC_ANGLE:
				gGpsLastData.angle = parseInt(gGpsText, GPS_MAX_CHARS); // Only use int part
     876:	34 de       	rcall	.-920    	; 0x4e0 <parseInt.constprop.5>
     878:	dc 01       	movw	r26, r24
     87a:	cb 01       	movw	r24, r22
     87c:	90 93 8e 01 	sts	0x018E, r25
     880:	80 93 8d 01 	sts	0x018D, r24
     884:	08 95       	ret
				break;
			case GPS_PART_GPRMC_STATUS:
				// Status
				break;
			case GPS_PART_GPGGA_SATS:
				gGpsLastData.sats = parseInt(gGpsText, GPS_MAX_CHARS);
     886:	2c de       	rcall	.-936    	; 0x4e0 <parseInt.constprop.5>
     888:	dc 01       	movw	r26, r24
     88a:	cb 01       	movw	r24, r22
     88c:	80 93 8a 01 	sts	0x018A, r24
     890:	08 95       	ret
					gGpsLastData.pos.longitude = -gGpsLastData.pos.longitude;
				}
				//updateParts();
				break;
			case GPS_PART_GPGGA_FIX:
				gGpsLastData.fix = parseInt(gGpsText, GPS_MAX_CHARS);
     892:	26 de       	rcall	.-948    	; 0x4e0 <parseInt.constprop.5>
     894:	dc 01       	movw	r26, r24
     896:	cb 01       	movw	r24, r22
     898:	80 93 89 01 	sts	0x0189, r24
     89c:	08 95       	ret
				gGpsLastData.pos.latitude = parseFloat(gGpsText, GPS_MAX_CHARS);
				//updateParts();
				break;
			case GPS_PART_GPGGA_LAT_UNIT:
			case GPS_PART_GPRMC_LAT_UNIT:
				if (gGpsText[0] == 'S') {
     89e:	80 91 d6 03 	lds	r24, 0x03D6
     8a2:	83 35       	cpi	r24, 0x53	; 83
     8a4:	09 f0       	breq	.+2      	; 0x8a8 <parseGpsPart+0x282>
     8a6:	f2 ce       	rjmp	.-540    	; 0x68c <parseGpsPart+0x66>
					gGpsLastData.pos.latitude = -gGpsLastData.pos.latitude;
     8a8:	80 91 7b 01 	lds	r24, 0x017B
     8ac:	90 91 7c 01 	lds	r25, 0x017C
     8b0:	a0 91 7d 01 	lds	r26, 0x017D
     8b4:	b0 91 7e 01 	lds	r27, 0x017E
     8b8:	b0 95       	com	r27
     8ba:	a0 95       	com	r26
     8bc:	90 95       	com	r25
     8be:	81 95       	neg	r24
     8c0:	9f 4f       	sbci	r25, 0xFF	; 255
     8c2:	af 4f       	sbci	r26, 0xFF	; 255
     8c4:	bf 4f       	sbci	r27, 0xFF	; 255
     8c6:	80 93 7b 01 	sts	0x017B, r24
     8ca:	90 93 7c 01 	sts	0x017C, r25
     8ce:	a0 93 7d 01 	sts	0x017D, r26
     8d2:	b0 93 7e 01 	sts	0x017E, r27
     8d6:	08 95       	ret

000008d8 <setPixel.constprop.8>:
		}		
	}
}	

inline uint8_t validPos(uint8_t x, uint8_t y) {
	if (x >= GRAPHICS_WIDTH_REAL || y >= GRAPHICS_HEIGHT) {
     8d8:	88 31       	cpi	r24, 0x18	; 24
     8da:	10 f4       	brcc	.+4      	; 0x8e0 <setPixel.constprop.8+0x8>
     8dc:	68 31       	cpi	r22, 0x18	; 24
     8de:	08 f0       	brcs	.+2      	; 0x8e2 <setPixel.constprop.8+0xa>
     8e0:	08 95       	ret
static void setPixel(uint8_t x, uint8_t y, uint8_t state) {
	if (!validPos(x, y)) {
		return;
	}
	uint8_t bitPos = 7-(x%8);
	uint8_t temp = gPixelData[x/8][y];
     8e2:	48 2f       	mov	r20, r24
     8e4:	46 95       	lsr	r20
     8e6:	46 95       	lsr	r20
     8e8:	46 95       	lsr	r20
     8ea:	50 e0       	ldi	r21, 0x00	; 0

static void setPixel(uint8_t x, uint8_t y, uint8_t state) {
	if (!validPos(x, y)) {
		return;
	}
	uint8_t bitPos = 7-(x%8);
     8ec:	80 95       	com	r24
     8ee:	87 70       	andi	r24, 0x07	; 7
	uint8_t temp = gPixelData[x/8][y];
	if (state == 0) {
		temp &= ~(1<<bitPos);
	}
	else if (state == 1) {
		temp |= (1<<bitPos);
     8f0:	21 e0       	ldi	r18, 0x01	; 1
     8f2:	30 e0       	ldi	r19, 0x00	; 0
     8f4:	02 c0       	rjmp	.+4      	; 0x8fa <setPixel.constprop.8+0x22>
     8f6:	22 0f       	add	r18, r18
     8f8:	33 1f       	adc	r19, r19
     8fa:	8a 95       	dec	r24
     8fc:	e2 f7       	brpl	.-8      	; 0x8f6 <setPixel.constprop.8+0x1e>
static void setPixel(uint8_t x, uint8_t y, uint8_t state) {
	if (!validPos(x, y)) {
		return;
	}
	uint8_t bitPos = 7-(x%8);
	uint8_t temp = gPixelData[x/8][y];
     8fe:	fa 01       	movw	r30, r20
     900:	ee 0f       	add	r30, r30
     902:	ff 1f       	adc	r31, r31
     904:	e4 0f       	add	r30, r20
     906:	f5 1f       	adc	r31, r21
     908:	ee 0f       	add	r30, r30
     90a:	ff 1f       	adc	r31, r31
     90c:	ee 0f       	add	r30, r30
     90e:	ff 1f       	adc	r31, r31
     910:	ee 0f       	add	r30, r30
     912:	ff 1f       	adc	r31, r31
     914:	e6 0f       	add	r30, r22
     916:	f1 1d       	adc	r31, r1
     918:	e6 51       	subi	r30, 0x16	; 22
     91a:	fc 4f       	sbci	r31, 0xFC	; 252
	if (state == 0) {
		temp &= ~(1<<bitPos);
	}
	else if (state == 1) {
		temp |= (1<<bitPos);
     91c:	80 81       	ld	r24, Z
     91e:	82 2b       	or	r24, r18
	}
	else {
		temp ^= (1<<bitPos);
	}
	gPixelData[x/8][y] = temp;
     920:	80 83       	st	Z, r24
     922:	08 95       	ret

00000924 <drawLine>:
	uint8_t temp = *a;
	*a = *b;
	*b = temp;
}

static void drawLine(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
     924:	a0 e0       	ldi	r26, 0x00	; 0
     926:	b0 e0       	ldi	r27, 0x00	; 0
     928:	e7 e9       	ldi	r30, 0x97	; 151
     92a:	f4 e0       	ldi	r31, 0x04	; 4
     92c:	0e ca       	rjmp	.-3044   	; 0xfffffd4a <__eeprom_end+0xff7efb4a>
     92e:	98 2f       	mov	r25, r24
     930:	c4 2f       	mov	r28, r20
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
     932:	02 2f       	mov	r16, r18
     934:	10 e0       	ldi	r17, 0x00	; 0
     936:	e6 2e       	mov	r14, r22
     938:	ff 24       	eor	r15, r15
     93a:	c4 2e       	mov	r12, r20
     93c:	dd 24       	eor	r13, r13
     93e:	a8 2f       	mov	r26, r24
     940:	b0 e0       	ldi	r27, 0x00	; 0
     942:	a8 01       	movw	r20, r16
     944:	4e 19       	sub	r20, r14
     946:	5f 09       	sbc	r21, r15
     948:	57 fd       	sbrc	r21, 7
     94a:	52 c0       	rjmp	.+164    	; 0x9f0 <drawLine+0xcc>
     94c:	f6 01       	movw	r30, r12
     94e:	ea 1b       	sub	r30, r26
     950:	fb 0b       	sbc	r31, r27
     952:	f7 fd       	sbrc	r31, 7
     954:	55 c0       	rjmp	.+170    	; 0xa00 <drawLine+0xdc>
     956:	d1 e0       	ldi	r29, 0x01	; 1
     958:	e4 17       	cp	r30, r20
     95a:	f5 07       	cpc	r31, r21
     95c:	b4 f1       	brlt	.+108    	; 0x9ca <drawLine+0xa6>
     95e:	d0 e0       	ldi	r29, 0x00	; 0
	if (steep) {
     960:	68 01       	movw	r12, r16
     962:	d7 01       	movw	r26, r14
		swap(&x0, &y0);
		swap(&x1, &y1);
	}		 
	if (x0 > x1) {
     964:	c9 17       	cp	r28, r25
     966:	c8 f1       	brcs	.+114    	; 0x9da <drawLine+0xb6>
     968:	ad 01       	movw	r20, r26
     96a:	d6 01       	movw	r26, r12
     96c:	6a 01       	movw	r12, r20
	int8_t deltax = x1 - x0;
	int8_t deltay = abs(y1 - y0);
	int8_t error = deltax / 2;
	int8_t ystep;
	int8_t y = y0;
	if (y0 < y1) { 
     96e:	62 17       	cp	r22, r18
     970:	e0 f1       	brcs	.+120    	; 0x9ea <drawLine+0xc6>
		ystep = 1; 
	}
	else {
		ystep = -1;
     972:	ee 24       	eor	r14, r14
     974:	ea 94       	dec	r14
	}		
	for (uint8_t x = x0; x <= x1; ++x) {
     976:	c9 17       	cp	r28, r25
     978:	20 f1       	brcs	.+72     	; 0x9c2 <drawLine+0x9e>
	}		 
	if (x0 > x1) {
		swap(&x0, &x1);
		swap(&y0, &y1);
	}		 
	int8_t deltax = x1 - x0;
     97a:	fc 2e       	mov	r15, r28
     97c:	f9 1a       	sub	r15, r25
	int8_t deltay = abs(y1 - y0);
	int8_t error = deltax / 2;
     97e:	1f 2d       	mov	r17, r15
     980:	f7 fc       	sbrc	r15, 7
     982:	46 c0       	rjmp	.+140    	; 0xa10 <drawLine+0xec>
     984:	15 95       	asr	r17
	int8_t ystep;
	int8_t y = y0;
     986:	06 2f       	mov	r16, r22
	if (x0 > x1) {
		swap(&x0, &x1);
		swap(&y0, &y1);
	}		 
	int8_t deltax = x1 - x0;
	int8_t deltay = abs(y1 - y0);
     988:	ac 19       	sub	r26, r12
     98a:	bd 09       	sbc	r27, r13
     98c:	b7 fd       	sbrc	r27, 7
     98e:	3c c0       	rjmp	.+120    	; 0xa08 <drawLine+0xe4>
     990:	da 2e       	mov	r13, r26
     992:	c9 2e       	mov	r12, r25
     994:	09 c0       	rjmp	.+18     	; 0x9a8 <drawLine+0x84>
	else {
		ystep = -1;
	}		
	for (uint8_t x = x0; x <= x1; ++x) {
		if (steep) {
			setPixel(y, x, 1);
     996:	80 2f       	mov	r24, r16
     998:	6c 2d       	mov	r22, r12
     99a:	9e df       	rcall	.-196    	; 0x8d8 <setPixel.constprop.8>
		}
		else { 
			setPixel(x, y, 1);
		}			
		error = error - deltay;
     99c:	1d 19       	sub	r17, r13
		if (error < 0) {
     99e:	17 fd       	sbrc	r17, 7
     9a0:	0b c0       	rjmp	.+22     	; 0x9b8 <drawLine+0x94>
		ystep = 1; 
	}
	else {
		ystep = -1;
	}		
	for (uint8_t x = x0; x <= x1; ++x) {
     9a2:	c3 94       	inc	r12
     9a4:	cc 15       	cp	r28, r12
     9a6:	68 f0       	brcs	.+26     	; 0x9c2 <drawLine+0x9e>
		if (steep) {
     9a8:	dd 23       	and	r29, r29
     9aa:	a9 f7       	brne	.-22     	; 0x996 <drawLine+0x72>
			setPixel(y, x, 1);
		}
		else { 
			setPixel(x, y, 1);
     9ac:	8c 2d       	mov	r24, r12
     9ae:	60 2f       	mov	r22, r16
     9b0:	93 df       	rcall	.-218    	; 0x8d8 <setPixel.constprop.8>
		}			
		error = error - deltay;
     9b2:	1d 19       	sub	r17, r13
		if (error < 0) {
     9b4:	17 ff       	sbrs	r17, 7
     9b6:	f5 cf       	rjmp	.-22     	; 0x9a2 <drawLine+0x7e>
			y = y + ystep;
     9b8:	0e 0d       	add	r16, r14
			error = error + deltax;
     9ba:	1f 0d       	add	r17, r15
		ystep = 1; 
	}
	else {
		ystep = -1;
	}		
	for (uint8_t x = x0; x <= x1; ++x) {
     9bc:	c3 94       	inc	r12
     9be:	cc 15       	cp	r28, r12
     9c0:	98 f7       	brcc	.-26     	; 0x9a8 <drawLine+0x84>
		if (error < 0) {
			y = y + ystep;
			error = error + deltax;
		}
	}				 
}
     9c2:	cd b7       	in	r28, 0x3d	; 61
     9c4:	de b7       	in	r29, 0x3e	; 62
     9c6:	e8 e0       	ldi	r30, 0x08	; 8
     9c8:	dc c9       	rjmp	.-3144   	; 0xfffffd82 <__eeprom_end+0xff7efb82>
	*b = temp;
}

static void drawLine(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep) {
     9ca:	8c 2f       	mov	r24, r28
  }
}

static void swap(uint8_t* a, uint8_t* b) {
	uint8_t temp = *a;
	*a = *b;
     9cc:	c2 2f       	mov	r28, r18
	*b = temp;
     9ce:	28 2f       	mov	r18, r24
}

static void drawLine(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep) {
     9d0:	89 2f       	mov	r24, r25
  }
}

static void swap(uint8_t* a, uint8_t* b) {
	uint8_t temp = *a;
	*a = *b;
     9d2:	96 2f       	mov	r25, r22
	*b = temp;
     9d4:	68 2f       	mov	r22, r24
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep) {
		swap(&x0, &y0);
		swap(&x1, &y1);
	}		 
	if (x0 > x1) {
     9d6:	c9 17       	cp	r28, r25
     9d8:	38 f6       	brcc	.-114    	; 0x968 <drawLine+0x44>
     9da:	86 2f       	mov	r24, r22
  }
}

static void swap(uint8_t* a, uint8_t* b) {
	uint8_t temp = *a;
	*a = *b;
     9dc:	62 2f       	mov	r22, r18
	*b = temp;
     9de:	28 2f       	mov	r18, r24
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep) {
		swap(&x0, &y0);
		swap(&x1, &y1);
	}		 
	if (x0 > x1) {
     9e0:	89 2f       	mov	r24, r25
     9e2:	9c 2f       	mov	r25, r28
     9e4:	c8 2f       	mov	r28, r24
	int8_t deltax = x1 - x0;
	int8_t deltay = abs(y1 - y0);
	int8_t error = deltax / 2;
	int8_t ystep;
	int8_t y = y0;
	if (y0 < y1) { 
     9e6:	62 17       	cp	r22, r18
     9e8:	20 f6       	brcc	.-120    	; 0x972 <drawLine+0x4e>
		ystep = 1; 
     9ea:	ee 24       	eor	r14, r14
     9ec:	e3 94       	inc	r14
     9ee:	c3 cf       	rjmp	.-122    	; 0x976 <drawLine+0x52>
	*a = *b;
	*b = temp;
}

static void drawLine(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
     9f0:	50 95       	com	r21
     9f2:	41 95       	neg	r20
     9f4:	5f 4f       	sbci	r21, 0xFF	; 255
     9f6:	f6 01       	movw	r30, r12
     9f8:	ea 1b       	sub	r30, r26
     9fa:	fb 0b       	sbc	r31, r27
     9fc:	f7 ff       	sbrs	r31, 7
     9fe:	ab cf       	rjmp	.-170    	; 0x956 <drawLine+0x32>
     a00:	f0 95       	com	r31
     a02:	e1 95       	neg	r30
     a04:	ff 4f       	sbci	r31, 0xFF	; 255
     a06:	a7 cf       	rjmp	.-178    	; 0x956 <drawLine+0x32>
	if (x0 > x1) {
		swap(&x0, &x1);
		swap(&y0, &y1);
	}		 
	int8_t deltax = x1 - x0;
	int8_t deltay = abs(y1 - y0);
     a08:	b0 95       	com	r27
     a0a:	a1 95       	neg	r26
     a0c:	bf 4f       	sbci	r27, 0xFF	; 255
     a0e:	c0 cf       	rjmp	.-128    	; 0x990 <drawLine+0x6c>
	int8_t error = deltax / 2;
     a10:	1f 5f       	subi	r17, 0xFF	; 255
     a12:	b8 cf       	rjmp	.-144    	; 0x984 <drawLine+0x60>

00000a14 <drawCircle.constprop.9>:
	gPixelData[x/8][y] = temp;
}

// Credit for this one goes to wikipedia! :-)
// Some mods done by me ( name, int -> uint8 )
static void drawCircle(uint8_t x0, uint8_t y0, uint8_t radius) {
     a14:	a5 e0       	ldi	r26, 0x05	; 5
     a16:	b0 e0       	ldi	r27, 0x00	; 0
     a18:	ef e0       	ldi	r30, 0x0F	; 15
     a1a:	f5 e0       	ldi	r31, 0x05	; 5
     a1c:	99 c9       	rjmp	.-3278   	; 0xfffffd50 <__eeprom_end+0xff7efb50>
     a1e:	18 2f       	mov	r17, r24
  volatile int8_t f = 1 - radius;
     a20:	81 e0       	ldi	r24, 0x01	; 1
     a22:	98 2f       	mov	r25, r24
     a24:	91 1b       	sub	r25, r17
     a26:	9d 83       	std	Y+5, r25	; 0x05
  volatile int8_t ddF_x = 1;
     a28:	8c 83       	std	Y+4, r24	; 0x04
  volatile int8_t ddF_y = -2 * radius;
     a2a:	81 2f       	mov	r24, r17
     a2c:	81 95       	neg	r24
     a2e:	88 0f       	add	r24, r24
     a30:	8b 83       	std	Y+3, r24	; 0x03
  volatile int8_t x = 0;
     a32:	1a 82       	std	Y+2, r1	; 0x02
  volatile int8_t y = radius;
     a34:	19 83       	std	Y+1, r17	; 0x01
 
  setPixel(x0, y0 + radius, 1);
     a36:	0b e0       	ldi	r16, 0x0B	; 11
     a38:	f0 2e       	mov	r15, r16
     a3a:	f1 0e       	add	r15, r17
     a3c:	8b e0       	ldi	r24, 0x0B	; 11
     a3e:	6f 2d       	mov	r22, r15
     a40:	4b df       	rcall	.-362    	; 0x8d8 <setPixel.constprop.8>
  setPixel(x0, y0 - radius, 1);
     a42:	0b e0       	ldi	r16, 0x0B	; 11
     a44:	01 1b       	sub	r16, r17
     a46:	8b e0       	ldi	r24, 0x0B	; 11
     a48:	60 2f       	mov	r22, r16
     a4a:	46 df       	rcall	.-372    	; 0x8d8 <setPixel.constprop.8>
  setPixel(x0 + radius, y0, 1);
     a4c:	8f 2d       	mov	r24, r15
     a4e:	6b e0       	ldi	r22, 0x0B	; 11
     a50:	43 df       	rcall	.-378    	; 0x8d8 <setPixel.constprop.8>
  setPixel(x0 - radius, y0, 1);
     a52:	80 2f       	mov	r24, r16
     a54:	6b e0       	ldi	r22, 0x0B	; 11
     a56:	40 df       	rcall	.-384    	; 0x8d8 <setPixel.constprop.8>
 
  while(x < y) {
     a58:	9a 81       	ldd	r25, Y+2	; 0x02
     a5a:	89 81       	ldd	r24, Y+1	; 0x01
     a5c:	98 17       	cp	r25, r24
     a5e:	0c f0       	brlt	.+2      	; 0xa62 <drawCircle.constprop.9+0x4e>
     a60:	51 c0       	rjmp	.+162    	; 0xb04 <drawCircle.constprop.9+0xf0>
    }
    x++;
    ddF_x += 2;
    f += ddF_x;    
    setPixel(x0 + x, y0 + y, 1);
    setPixel(x0 - x, y0 + y, 1);
     a62:	1b e0       	ldi	r17, 0x0B	; 11
 
  while(x < y) {
    // ddF_x == 2 * x + 1;
    // ddF_y == -2 * y;
    // f == x*x + y*y - radius*radius + 2*x - y + 1;
    if(f >= 0) {
     a64:	8d 81       	ldd	r24, Y+5	; 0x05
     a66:	87 fd       	sbrc	r24, 7
     a68:	0a c0       	rjmp	.+20     	; 0xa7e <drawCircle.constprop.9+0x6a>
      y--;
     a6a:	89 81       	ldd	r24, Y+1	; 0x01
     a6c:	81 50       	subi	r24, 0x01	; 1
     a6e:	89 83       	std	Y+1, r24	; 0x01
      ddF_y += 2;
     a70:	8b 81       	ldd	r24, Y+3	; 0x03
     a72:	8e 5f       	subi	r24, 0xFE	; 254
     a74:	8b 83       	std	Y+3, r24	; 0x03
      f += ddF_y;
     a76:	9d 81       	ldd	r25, Y+5	; 0x05
     a78:	8b 81       	ldd	r24, Y+3	; 0x03
     a7a:	89 0f       	add	r24, r25
     a7c:	8d 83       	std	Y+5, r24	; 0x05
    }
    x++;
     a7e:	8a 81       	ldd	r24, Y+2	; 0x02
     a80:	8f 5f       	subi	r24, 0xFF	; 255
     a82:	8a 83       	std	Y+2, r24	; 0x02
    ddF_x += 2;
     a84:	8c 81       	ldd	r24, Y+4	; 0x04
     a86:	8e 5f       	subi	r24, 0xFE	; 254
     a88:	8c 83       	std	Y+4, r24	; 0x04
    f += ddF_x;    
     a8a:	9d 81       	ldd	r25, Y+5	; 0x05
     a8c:	8c 81       	ldd	r24, Y+4	; 0x04
     a8e:	89 0f       	add	r24, r25
     a90:	8d 83       	std	Y+5, r24	; 0x05
    setPixel(x0 + x, y0 + y, 1);
     a92:	8a 81       	ldd	r24, Y+2	; 0x02
     a94:	69 81       	ldd	r22, Y+1	; 0x01
     a96:	65 5f       	subi	r22, 0xF5	; 245
     a98:	85 5f       	subi	r24, 0xF5	; 245
     a9a:	1e df       	rcall	.-452    	; 0x8d8 <setPixel.constprop.8>
    setPixel(x0 - x, y0 + y, 1);
     a9c:	8a 81       	ldd	r24, Y+2	; 0x02
     a9e:	69 81       	ldd	r22, Y+1	; 0x01
     aa0:	65 5f       	subi	r22, 0xF5	; 245
     aa2:	91 2f       	mov	r25, r17
     aa4:	98 1b       	sub	r25, r24
     aa6:	89 2f       	mov	r24, r25
     aa8:	17 df       	rcall	.-466    	; 0x8d8 <setPixel.constprop.8>
    setPixel(x0 + x, y0 - y, 1);
     aaa:	8a 81       	ldd	r24, Y+2	; 0x02
     aac:	99 81       	ldd	r25, Y+1	; 0x01
     aae:	61 2f       	mov	r22, r17
     ab0:	69 1b       	sub	r22, r25
     ab2:	85 5f       	subi	r24, 0xF5	; 245
     ab4:	11 df       	rcall	.-478    	; 0x8d8 <setPixel.constprop.8>
    setPixel(x0 - x, y0 - y, 1);
     ab6:	8a 81       	ldd	r24, Y+2	; 0x02
     ab8:	99 81       	ldd	r25, Y+1	; 0x01
     aba:	61 2f       	mov	r22, r17
     abc:	69 1b       	sub	r22, r25
     abe:	91 2f       	mov	r25, r17
     ac0:	98 1b       	sub	r25, r24
     ac2:	89 2f       	mov	r24, r25
     ac4:	09 df       	rcall	.-494    	; 0x8d8 <setPixel.constprop.8>
    setPixel(x0 + y, y0 + x, 1);
     ac6:	89 81       	ldd	r24, Y+1	; 0x01
     ac8:	6a 81       	ldd	r22, Y+2	; 0x02
     aca:	65 5f       	subi	r22, 0xF5	; 245
     acc:	85 5f       	subi	r24, 0xF5	; 245
     ace:	04 df       	rcall	.-504    	; 0x8d8 <setPixel.constprop.8>
    setPixel(x0 - y, y0 + x, 1);
     ad0:	89 81       	ldd	r24, Y+1	; 0x01
     ad2:	6a 81       	ldd	r22, Y+2	; 0x02
     ad4:	65 5f       	subi	r22, 0xF5	; 245
     ad6:	91 2f       	mov	r25, r17
     ad8:	98 1b       	sub	r25, r24
     ada:	89 2f       	mov	r24, r25
     adc:	fd de       	rcall	.-518    	; 0x8d8 <setPixel.constprop.8>
    setPixel(x0 + y, y0 - x, 1);
     ade:	89 81       	ldd	r24, Y+1	; 0x01
     ae0:	9a 81       	ldd	r25, Y+2	; 0x02
     ae2:	61 2f       	mov	r22, r17
     ae4:	69 1b       	sub	r22, r25
     ae6:	85 5f       	subi	r24, 0xF5	; 245
     ae8:	f7 de       	rcall	.-530    	; 0x8d8 <setPixel.constprop.8>
    setPixel(x0 - y, y0 - x, 1);
     aea:	89 81       	ldd	r24, Y+1	; 0x01
     aec:	9a 81       	ldd	r25, Y+2	; 0x02
     aee:	61 2f       	mov	r22, r17
     af0:	69 1b       	sub	r22, r25
     af2:	91 2f       	mov	r25, r17
     af4:	98 1b       	sub	r25, r24
     af6:	89 2f       	mov	r24, r25
     af8:	ef de       	rcall	.-546    	; 0x8d8 <setPixel.constprop.8>
  setPixel(x0, y0 + radius, 1);
  setPixel(x0, y0 - radius, 1);
  setPixel(x0 + radius, y0, 1);
  setPixel(x0 - radius, y0, 1);
 
  while(x < y) {
     afa:	9a 81       	ldd	r25, Y+2	; 0x02
     afc:	89 81       	ldd	r24, Y+1	; 0x01
     afe:	98 17       	cp	r25, r24
     b00:	0c f4       	brge	.+2      	; 0xb04 <drawCircle.constprop.9+0xf0>
     b02:	b0 cf       	rjmp	.-160    	; 0xa64 <drawCircle.constprop.9+0x50>
    setPixel(x0 + y, y0 + x, 1);
    setPixel(x0 - y, y0 + x, 1);
    setPixel(x0 + y, y0 - x, 1);
    setPixel(x0 - y, y0 - x, 1);
  }
}
     b04:	25 96       	adiw	r28, 0x05	; 5
     b06:	e5 e0       	ldi	r30, 0x05	; 5
     b08:	3f c9       	rjmp	.-3458   	; 0xfffffd88 <__eeprom_end+0xff7efb88>

00000b0a <main>:
#endif //GRAPICSENABLED
}

void main(void) __attribute__ ((noreturn)); // Main never returns, saves a few bytes

void main(void) {
     b0a:	a6 e1       	ldi	r26, 0x16	; 22
     b0c:	b0 e0       	ldi	r27, 0x00	; 0
     b0e:	ea e8       	ldi	r30, 0x8A	; 138
     b10:	f5 e0       	ldi	r31, 0x05	; 5
     b12:	11 c9       	rjmp	.-3550   	; 0xfffffd36 <__eeprom_end+0xff7efb36>
static uint8_t gKeyPressTime = 0;

static void setup(void)
{
	// Port setup
	PORTD = KEY; //key pullup & led off
     b14:	20 e1       	ldi	r18, 0x10	; 16
     b16:	2b b9       	out	0x0b, r18	; 11
	DDRD  = LED; // led output
     b18:	88 e0       	ldi	r24, 0x08	; 8
     b1a:	8a b9       	out	0x0a, r24	; 10
	PORTB &= ~OUT1;
     b1c:	29 98       	cbi	0x05, 1	; 5
	DDRB  = OUT2 | SS;
     b1e:	8c e0       	ldi	r24, 0x0C	; 12
     b20:	84 b9       	out	0x04, r24	; 4
	
	TIMSK1 |= (1 << TOIE1); // Enable overflow interrupt
     b22:	80 91 6f 00 	lds	r24, 0x006F
     b26:	81 60       	ori	r24, 0x01	; 1
     b28:	80 93 6f 00 	sts	0x006F, r24
	TCCR1B |= (1 << CS11); // Start timer at Fcpu/8
     b2c:	80 91 81 00 	lds	r24, 0x0081
     b30:	82 60       	ori	r24, 0x02	; 2
     b32:	80 93 81 00 	sts	0x0081, r24
static uint16_t gActiveTextLastLine = 2;
static uint8_t gLineType = LINE_TYPE_UNKNOWN;

static void setupLine() {
  // Line trigger
	EICRA = (1<<ISC00) | (1<<ISC01); //set INT0 as rising edge trigger
     b36:	83 e0       	ldi	r24, 0x03	; 3
     b38:	80 93 69 00 	sts	0x0069, r24
	EIMSK = (1<<INT0); //enable INTO in global interrupt mask
     b3c:	31 e0       	ldi	r19, 0x01	; 1
     b3e:	3d bb       	out	0x1d, r19	; 29
	ACSR = (1<<ACD); //Comparator disabled
     b40:	80 e8       	ldi	r24, 0x80	; 128
     b42:	80 bf       	out	0x30, r24	; 48
	ADCSRB = 0x00;
     b44:	10 92 7b 00 	sts	0x007B, r1

	// SPI setup
	SPDR = 0x00; // Clear spi reg or thrash will show on video
     b48:	1e bc       	out	0x2e, r1	; 46
#ifdef TEXT_SMALL_ENABLED
	SPSR |= (1<<SPI2X); // Set dual speed
#else
	SPSR &= ~(1<<SPI2X); // Clear dual speed
     b4a:	8d b5       	in	r24, 0x2d	; 45
     b4c:	8e 7f       	andi	r24, 0xFE	; 254
     b4e:	8d bd       	out	0x2d, r24	; 45
#endif //TEXT_SMALL_ENABLED
	SPCR = (1<<SPE) | (1<<MSTR) | (1<<CPHA);
     b50:	84 e5       	ldi	r24, 0x54	; 84
     b52:	8c bd       	out	0x2c, r24	; 44
	
#ifdef TEXT_ENABLED
	gActiveTextLine = gTextLines[gActiveTextId];
     b54:	e0 91 b8 01 	lds	r30, 0x01B8
     b58:	f0 e0       	ldi	r31, 0x00	; 0
     b5a:	ee 0f       	add	r30, r30
     b5c:	ff 1f       	adc	r31, r31
     b5e:	ec 5a       	subi	r30, 0xAC	; 172
     b60:	fe 4f       	sbci	r31, 0xFE	; 254
     b62:	80 81       	ld	r24, Z
     b64:	91 81       	ldd	r25, Z+1	; 0x01
     b66:	90 93 d2 03 	sts	0x03D2, r25
     b6a:	80 93 d1 03 	sts	0x03D1, r24

#else

static void setupAdc() {
  // ADC setup
	DIDR0 = 0x00;
     b6e:	10 92 7e 00 	sts	0x007E, r1
	ADMUX |= (1<<REFS0); // Ref is AVCC
     b72:	80 91 7c 00 	lds	r24, 0x007C
     b76:	80 64       	ori	r24, 0x40	; 64
     b78:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA |= (1<<ADPS2) | (1<<ADPS1); // | (1<<ADPS0); 
     b7c:	80 91 7a 00 	lds	r24, 0x007A
     b80:	86 60       	ori	r24, 0x06	; 6
     b82:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // Free running
     b86:	10 92 7b 00 	sts	0x007B, r1
static uint8_t gGpsTextPartLength = 0;
#endif //GPS_PART_TEXT

static void setupGps() {
	// USART setup
  UBRR0H = (uint8_t)(GPS_UBRR>>8); // set baud
     b8a:	30 93 c5 00 	sts	0x00C5, r19
  UBRR0L = (uint8_t)GPS_UBRR;
     b8e:	87 e3       	ldi	r24, 0x37	; 55
     b90:	80 93 c4 00 	sts	0x00C4, r24
  UCSR0C = (3<<UCSZ00); // 8N1
     b94:	86 e0       	ldi	r24, 0x06	; 6
     b96:	80 93 c2 00 	sts	0x00C2, r24
  UCSR0B = (1<<RXEN0); // Enable RX
     b9a:	20 93 c1 00 	sts	0x00C1, r18

#ifdef GPS_ENABLED
	setupGps();
#endif //GPS_ENABLED
	
	sei();
     b9e:	78 94       	sei
     ba0:	61 ec       	ldi	r22, 0xC1	; 193
     ba2:	26 2e       	mov	r2, r22
     ba4:	62 e0       	ldi	r22, 0x02	; 2
     ba6:	36 2e       	mov	r3, r22
	setup();

	while(1) {
    
#ifdef GPS_ENABLED
    if(UCSR0A & (1<<RXC0)) {
     ba8:	80 91 c0 00 	lds	r24, 0x00C0
     bac:	87 fd       	sbrc	r24, 7
     bae:	da c1       	rjmp	.+948    	; 0xf64 <main+0x45a>
      decodeGpsData(UDR0);
    }
#endif //GPS_ENABLED
    
#ifndef DEBUG
		if((PIND & KEY) != KEY) {
     bb0:	4c 99       	sbic	0x09, 4	; 9
     bb2:	5b c1       	rjmp	.+694    	; 0xe6a <main+0x360>
			gKeyPressed = 1;
     bb4:	81 e0       	ldi	r24, 0x01	; 1
     bb6:	80 93 79 01 	sts	0x0179, r24
			if(gKeyPressTime > 50) {
     bba:	80 91 7a 01 	lds	r24, 0x017A
     bbe:	83 33       	cpi	r24, 0x33	; 51
     bc0:	a8 f0       	brcs	.+42     	; 0xbec <main+0xe2>
				PORTD |= LED; // long press!
     bc2:	5b 9a       	sbi	0x0b, 3	; 11
#ifdef GPS_ENABLED
#ifdef HOME_SET_WITH_BUTTON
      if (gGpsLastData.checksumValid != 0 && gGpsLastData.fix != 0) {
     bc4:	80 91 93 01 	lds	r24, 0x0193
     bc8:	88 23       	and	r24, r24
     bca:	81 f0       	breq	.+32     	; 0xbec <main+0xe2>
     bcc:	80 91 89 01 	lds	r24, 0x0189
     bd0:	88 23       	and	r24, r24
     bd2:	61 f0       	breq	.+24     	; 0xbec <main+0xe2>

static void setHomePos() {
#ifdef STATISTICS_ENABLED	
	resetStatistics();
#endif //STATISTICS_ENABLED
	gHomePos = gGpsLastValidData.pos;
     bd4:	a4 e9       	ldi	r26, 0x94	; 148
     bd6:	b1 e0       	ldi	r27, 0x01	; 1
     bd8:	ee e9       	ldi	r30, 0x9E	; 158
     bda:	f1 e0       	ldi	r31, 0x01	; 1
     bdc:	8a e0       	ldi	r24, 0x0A	; 10
     bde:	01 90       	ld	r0, Z+
     be0:	0d 92       	st	X+, r0
     be2:	81 50       	subi	r24, 0x01	; 1
     be4:	e1 f7       	brne	.-8      	; 0xbde <main+0xd4>
	gHomePosSet = 1;
     be6:	81 e0       	ldi	r24, 0x01	; 1
     be8:	80 93 b7 01 	sts	0x01B7, r24
#ifdef DEBUG
		gUpdateScreenData = 2;
#endif //DEBUG

#ifdef TEXT_ENABLED
    if (gUpdateScreenData == 2) {
     bec:	80 91 74 01 	lds	r24, 0x0174
     bf0:	82 30       	cpi	r24, 0x02	; 2
     bf2:	09 f4       	brne	.+2      	; 0xbf6 <main+0xec>
     bf4:	47 c1       	rjmp	.+654    	; 0xe84 <main+0x37a>
      //DDRB |= OUT1;
      updateTextCharStartPos(gActiveTextId);
	    updateTextPixmap(gActiveTextId);
		  //DDRB &= ~OUT1;
	  }
	  else if (gUpdateScreenData == 1) {
     bf6:	80 91 74 01 	lds	r24, 0x0174
     bfa:	81 30       	cpi	r24, 0x01	; 1
     bfc:	a9 f6       	brne	.-86     	; 0xba8 <main+0x9e>
#else
    if (gUpdateScreenData == 1) {
#endif //TEXTENABLED
			gUpdateScreenData = 0;
     bfe:	10 92 74 01 	sts	0x0174, r1
#endif // ALARM_ENABLED
}
  

static void updateOnceEveryFrame() {
  if (gKeyPressed) {
     c02:	80 91 79 01 	lds	r24, 0x0179
     c06:	88 23       	and	r24, r24
     c08:	29 f0       	breq	.+10     	; 0xc14 <main+0x10a>
		++gKeyPressTime;
     c0a:	80 91 7a 01 	lds	r24, 0x017A
     c0e:	8f 5f       	subi	r24, 0xFF	; 255
     c10:	80 93 7a 01 	sts	0x017A, r24
	}

	if (gTimeTick == 0) {
     c14:	80 91 78 01 	lds	r24, 0x0178
     c18:	88 23       	and	r24, r24
     c1a:	09 f0       	breq	.+2      	; 0xc1e <main+0x114>
     c1c:	a9 c0       	rjmp	.+338    	; 0xd70 <main+0x266>

static void updateOnceEverySec() {
#ifndef GPS_ENABLED
  PORTD |= LED;
#else //GPS_ENABLED
  if (gGpsLastData.fix != 0) {
     c1e:	80 91 89 01 	lds	r24, 0x0189
     c22:	88 23       	and	r24, r24
     c24:	09 f4       	brne	.+2      	; 0xc28 <main+0x11e>
     c26:	a6 c3       	rjmp	.+1868   	; 0x1374 <main+0x86a>
		PORTD |= LED;
     c28:	5b 9a       	sbi	0x0b, 3	; 11
	
#ifdef DEBUG
  //testCalcHome();
#endif // DEBUG
  
	if (gHomePosSet) {
     c2a:	80 91 b7 01 	lds	r24, 0x01B7
     c2e:	88 23       	and	r24, r24
     c30:	09 f0       	breq	.+2      	; 0xc34 <main+0x12a>
     c32:	a9 c3       	rjmp	.+1874   	; 0x1386 <main+0x87c>
  distance *= mult;
#ifdef IMPERIAL_SYSTEM  
  distance *= 3281;
	distance /= 1000;
#endif //IMPERIAL_SYSTEM
  *distanceResult = distance;
     c34:	f2 e3       	ldi	r31, 0x32	; 50
     c36:	6f 2e       	mov	r6, r31
     c38:	f4 e0       	ldi	r31, 0x04	; 4
     c3a:	7f 2e       	mov	r7, r31
     c3c:	a2 e6       	ldi	r26, 0x62	; 98
     c3e:	4a 2e       	mov	r4, r26
     c40:	a1 e0       	ldi	r26, 0x01	; 1
     c42:	5a 2e       	mov	r5, r26
     c44:	86 e6       	ldi	r24, 0x66	; 102
     c46:	91 e0       	ldi	r25, 0x01	; 1
     c48:	9e 83       	std	Y+6, r25	; 0x06
     c4a:	8d 83       	std	Y+5, r24	; 0x05
     c4c:	8b e3       	ldi	r24, 0x3B	; 59
     c4e:	94 e0       	ldi	r25, 0x04	; 4
      if (deltaLat == 0) {
        if (deltaLong >= 0) { // Home = East
          bearing = 90; 
        } 
	      else { // Home = West
          bearing = 270;
     c50:	19 82       	std	Y+1, r1	; 0x01
	  ADCSRA &= ~(1<<ADEN) & ~(1<<ADATE); // ADC disabled & ADC auto trigger disabled
	  temp = ADCW;
#ifdef ADC_ENABLE_RAW	  
    gAnalogInputsRaw[i] = temp;
#endif
	  temp = (temp * 5 * 62) / 10;
     c52:	ba e0       	ldi	r27, 0x0A	; 10
     c54:	8b 2e       	mov	r8, r27
     c56:	91 2c       	mov	r9, r1
     c58:	a1 2c       	mov	r10, r1
     c5a:	b1 2c       	mov	r11, r1
     c5c:	98 8b       	std	Y+16, r25	; 0x10
     c5e:	8f 87       	std	Y+15, r24	; 0x0f
static void measureAnalog() {
  uint32_t temp = 0;
	uint8_t adcLow = 0; 
  uint8_t adcHigh = 0;
  for (uint8_t i = 0; i < ANALOG_IN_NUMBER; ++i) {
	  ADMUX &= 0xF0; // Clear mux
     c60:	80 91 7c 00 	lds	r24, 0x007C
     c64:	80 7f       	andi	r24, 0xF0	; 240
     c66:	80 93 7c 00 	sts	0x007C, r24
    ADMUX |= (i + ADC_OFFSET);	 //Setup adc mux
     c6a:	80 91 7c 00 	lds	r24, 0x007C
     c6e:	c9 80       	ldd	r12, Y+1	; 0x01
     c70:	8c 29       	or	r24, r12
     c72:	80 93 7c 00 	sts	0x007C, r24
	  ADCSRA |= (1<<ADEN) | (1<<ADATE); // ADC enable & ADC auto trigger enable
     c76:	80 91 7a 00 	lds	r24, 0x007A
     c7a:	80 6a       	ori	r24, 0xA0	; 160
     c7c:	80 93 7a 00 	sts	0x007A, r24
	  ADCSRA |= (1<<ADSC); // Start measure
     c80:	80 91 7a 00 	lds	r24, 0x007A
     c84:	80 64       	ori	r24, 0x40	; 64
     c86:	80 93 7a 00 	sts	0x007A, r24
     c8a:	2f 85       	ldd	r18, Y+15	; 0x0f
     c8c:	38 89       	ldd	r19, Y+16	; 0x10
	  while ((ADCSRA & (1<<ADIF)) == 0); // Wait to finish
     c8e:	80 91 7a 00 	lds	r24, 0x007A
     c92:	84 ff       	sbrs	r24, 4
     c94:	fc cf       	rjmp	.-8      	; 0xc8e <main+0x184>
     c96:	38 8b       	std	Y+16, r19	; 0x10
     c98:	2f 87       	std	Y+15, r18	; 0x0f
	  ADCSRA |= (1<<ADIF); // Clear ADC interrupt flag with a 1
     c9a:	80 91 7a 00 	lds	r24, 0x007A
     c9e:	80 61       	ori	r24, 0x10	; 16
     ca0:	80 93 7a 00 	sts	0x007A, r24
	  ADCSRA &= ~(1<<ADEN) & ~(1<<ADATE); // ADC disabled & ADC auto trigger disabled
     ca4:	80 91 7a 00 	lds	r24, 0x007A
     ca8:	8f 75       	andi	r24, 0x5F	; 95
     caa:	80 93 7a 00 	sts	0x007A, r24
	  temp = ADCW;
     cae:	20 91 78 00 	lds	r18, 0x0078
     cb2:	30 91 79 00 	lds	r19, 0x0079
#ifdef ADC_ENABLE_RAW	  
    gAnalogInputsRaw[i] = temp;
     cb6:	d3 01       	movw	r26, r6
     cb8:	2d 93       	st	X+, r18
     cba:	3d 93       	st	X+, r19
     cbc:	3d 01       	movw	r6, r26
#endif
	  temp = (temp * 5 * 62) / 10;
     cbe:	46 e3       	ldi	r20, 0x36	; 54
     cc0:	51 e0       	ldi	r21, 0x01	; 1
     cc2:	a7 d7       	rcall	.+3918   	; 0x1c12 <__umulhisi3>
     cc4:	a5 01       	movw	r20, r10
     cc6:	94 01       	movw	r18, r8
     cc8:	f9 d7       	rcall	.+4082   	; 0x1cbc <__udivmodsi4>
	  temp *= gAnalogMult[i];
     cca:	f2 01       	movw	r30, r4
     ccc:	61 91       	ld	r22, Z+
     cce:	2f 01       	movw	r4, r30
     cd0:	70 e0       	ldi	r23, 0x00	; 0
     cd2:	80 e0       	ldi	r24, 0x00	; 0
     cd4:	90 e0       	ldi	r25, 0x00	; 0
     cd6:	ac d7       	rcall	.+3928   	; 0x1c30 <__mulsi3>
	  temp /= gAnalogDiv[i];
     cd8:	ad 81       	ldd	r26, Y+5	; 0x05
     cda:	be 81       	ldd	r27, Y+6	; 0x06
     cdc:	2d 91       	ld	r18, X+
     cde:	be 83       	std	Y+6, r27	; 0x06
     ce0:	ad 83       	std	Y+5, r26	; 0x05
     ce2:	30 e0       	ldi	r19, 0x00	; 0
     ce4:	40 e0       	ldi	r20, 0x00	; 0
     ce6:	50 e0       	ldi	r21, 0x00	; 0
     ce8:	e9 d7       	rcall	.+4050   	; 0x1cbc <__udivmodsi4>
     cea:	89 01       	movw	r16, r18
     cec:	9a 01       	movw	r18, r20
	  adcHigh = temp / 1024;
     cee:	68 01       	movw	r12, r16
     cf0:	79 01       	movw	r14, r18
     cf2:	8a e0       	ldi	r24, 0x0A	; 10
     cf4:	f6 94       	lsr	r15
     cf6:	e7 94       	ror	r14
     cf8:	d7 94       	ror	r13
     cfa:	c7 94       	ror	r12
     cfc:	8a 95       	dec	r24
     cfe:	d1 f7       	brne	.-12     	; 0xcf4 <main+0x1ea>
     d00:	cb 86       	std	Y+11, r12	; 0x0b
     d02:	dc 86       	std	Y+12, r13	; 0x0c
     d04:	ed 86       	std	Y+13, r14	; 0x0d
     d06:	fe 86       	std	Y+14, r15	; 0x0e
#endif //GRAPICSENABLED
}

void main(void) __attribute__ ((noreturn)); // Main never returns, saves a few bytes

void main(void) {
     d08:	4f 85       	ldd	r20, Y+15	; 0x0f
     d0a:	58 89       	ldd	r21, Y+16	; 0x10
     d0c:	41 50       	subi	r20, 0x01	; 1
     d0e:	50 40       	sbci	r21, 0x00	; 0
     d10:	5a 87       	std	Y+10, r21	; 0x0a
     d12:	49 87       	std	Y+9, r20	; 0x09
	  temp -= (uint16_t)(adcHigh) * 1024;
     d14:	8c 2d       	mov	r24, r12
     d16:	90 e0       	ldi	r25, 0x00	; 0
     d18:	98 2f       	mov	r25, r24
     d1a:	88 27       	eor	r24, r24
     d1c:	99 0f       	add	r25, r25
     d1e:	99 0f       	add	r25, r25
     d20:	a0 e0       	ldi	r26, 0x00	; 0
     d22:	b0 e0       	ldi	r27, 0x00	; 0
     d24:	68 01       	movw	r12, r16
     d26:	79 01       	movw	r14, r18
     d28:	c8 1a       	sub	r12, r24
     d2a:	d9 0a       	sbc	r13, r25
     d2c:	ea 0a       	sbc	r14, r26
     d2e:	fb 0a       	sbc	r15, r27
     d30:	c7 01       	movw	r24, r14
     d32:	b6 01       	movw	r22, r12
	  adcLow = (temp * 100) / 1024;
     d34:	24 e6       	ldi	r18, 0x64	; 100
     d36:	30 e0       	ldi	r19, 0x00	; 0
     d38:	40 e0       	ldi	r20, 0x00	; 0
     d3a:	50 e0       	ldi	r21, 0x00	; 0
     d3c:	79 d7       	rcall	.+3826   	; 0x1c30 <__mulsi3>
     d3e:	dc 01       	movw	r26, r24
     d40:	cb 01       	movw	r24, r22
     d42:	ea e0       	ldi	r30, 0x0A	; 10
     d44:	b6 95       	lsr	r27
     d46:	a7 95       	ror	r26
     d48:	97 95       	ror	r25
     d4a:	87 95       	ror	r24
     d4c:	ea 95       	dec	r30
     d4e:	d1 f7       	brne	.-12     	; 0xd44 <main+0x23a>
     d50:	e9 85       	ldd	r30, Y+9	; 0x09
     d52:	fa 85       	ldd	r31, Y+10	; 0x0a
     d54:	80 83       	st	Z, r24
	
	  gAnalogInputs[i].low = adcLow;
    gAnalogInputs[i].high = adcHigh;
     d56:	eb 85       	ldd	r30, Y+11	; 0x0b
     d58:	af 85       	ldd	r26, Y+15	; 0x0f
     d5a:	b8 89       	ldd	r27, Y+16	; 0x10
     d5c:	ec 93       	st	X, r30

static void measureAnalog() {
  uint32_t temp = 0;
	uint8_t adcLow = 0; 
  uint8_t adcHigh = 0;
  for (uint8_t i = 0; i < ANALOG_IN_NUMBER; ++i) {
     d5e:	f9 81       	ldd	r31, Y+1	; 0x01
     d60:	ff 5f       	subi	r31, 0xFF	; 255
     d62:	f9 83       	std	Y+1, r31	; 0x01
     d64:	12 96       	adiw	r26, 0x02	; 2
     d66:	b8 8b       	std	Y+16, r27	; 0x10
     d68:	af 87       	std	Y+15, r26	; 0x0f
     d6a:	f4 30       	cpi	r31, 0x04	; 4
     d6c:	09 f0       	breq	.+2      	; 0xd70 <main+0x266>
     d6e:	78 cf       	rjmp	.-272    	; 0xc60 <main+0x156>
static volatile uint8_t gBlink1Hz = 0;

#ifdef TIME_ENABLED

static void updateTime() {
	++gTimeTick;
     d70:	80 91 78 01 	lds	r24, 0x0178
     d74:	8f 5f       	subi	r24, 0xFF	; 255
     d76:	80 93 78 01 	sts	0x0178, r24
	if (gTimeTick >= TIME_FRAMES_PER_SEC) {
     d7a:	80 91 78 01 	lds	r24, 0x0178
     d7e:	82 33       	cpi	r24, 0x32	; 50
     d80:	78 f0       	brcs	.+30     	; 0xda0 <main+0x296>
		gTimeTick = 0;
     d82:	10 92 78 01 	sts	0x0178, r1
		gTime.sec++;
     d86:	80 91 76 01 	lds	r24, 0x0176
     d8a:	8f 5f       	subi	r24, 0xFF	; 255
     d8c:	80 93 76 01 	sts	0x0176, r24
		gBlink1Hz = (gBlink1Hz+1)%2;
     d90:	80 91 75 01 	lds	r24, 0x0175
     d94:	90 e0       	ldi	r25, 0x00	; 0
     d96:	01 96       	adiw	r24, 0x01	; 1
     d98:	81 70       	andi	r24, 0x01	; 1
     d9a:	90 70       	andi	r25, 0x00	; 0
     d9c:	80 93 75 01 	sts	0x0175, r24
	}
	if (gTime.sec >= 60) {
     da0:	80 91 76 01 	lds	r24, 0x0176
     da4:	8c 33       	cpi	r24, 0x3C	; 60
     da6:	38 f0       	brcs	.+14     	; 0xdb6 <main+0x2ac>
		gTime.sec = 0;
     da8:	10 92 76 01 	sts	0x0176, r1
		gTime.min++;
     dac:	80 91 77 01 	lds	r24, 0x0177
     db0:	8f 5f       	subi	r24, 0xFF	; 255
     db2:	80 93 77 01 	sts	0x0177, r24
	}
	if (gTime.min >= 60) {
     db6:	80 91 77 01 	lds	r24, 0x0177
     dba:	8c 33       	cpi	r24, 0x3C	; 60
     dbc:	10 f0       	brcs	.+4      	; 0xdc2 <main+0x2b8>
		gTime.min = 0;
     dbe:	10 92 77 01 	sts	0x0177, r1
static uint8_t calcGenericLevel(uint8_t adcInput, uint16_t minLevel, uint16_t maxLevel) {
	uint16_t level = ((gAnalogInputs[adcInput].high * 100) + gAnalogInputs[adcInput].low);
	if (level > maxLevel) {
		level = 100;
	}		
	else if (level > minLevel) {
     dc2:	91 e0       	ldi	r25, 0x01	; 1
     dc4:	80 e0       	ldi	r24, 0x00	; 0
     dc6:	d9 2e       	mov	r13, r25
     dc8:	e8 2e       	mov	r14, r24
     dca:	2e 2d       	mov	r18, r14
     dcc:	30 e0       	ldi	r19, 0x00	; 0
     dce:	81 e2       	ldi	r24, 0x21	; 33
     dd0:	90 e0       	ldi	r25, 0x00	; 0
     dd2:	28 9f       	mul	r18, r24
     dd4:	f0 01       	movw	r30, r0
     dd6:	29 9f       	mul	r18, r25
     dd8:	f0 0d       	add	r31, r0
     dda:	38 9f       	mul	r19, r24
     ddc:	f0 0d       	add	r31, r0
     dde:	11 24       	eor	r1, r1
     de0:	e7 54       	subi	r30, 0x47	; 71
     de2:	fe 4f       	sbci	r31, 0xFE	; 254
     de4:	81 e2       	ldi	r24, 0x21	; 33
#endif // TEXT_INVERTED_ENABLED

// Functions
static void clearText(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
		gText[textId][j] = 0;
     de6:	11 92       	st	Z+, r1
     de8:	81 50       	subi	r24, 0x01	; 1
static uint8_t gTextInverted[TEXT_LINES][TEXT_LINE_MAX_CHARS/8];
#endif // TEXT_INVERTED_ENABLED

// Functions
static void clearText(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
     dea:	e9 f7       	brne	.-6      	; 0xde6 <main+0x2dc>
#ifdef TEXT_ENABLED
static void updateText(uint8_t textId) {
  //testPrintDebugInfo();
  uint8_t pos = 0;

	if (textId == 0) {
     dec:	ee 20       	and	r14, r14
     dee:	09 f4       	brne	.+2      	; 0xdf2 <main+0x2e8>
     df0:	e1 c0       	rjmp	.+450    	; 0xfb4 <main+0x4aa>
	  pos = printTime(gText[textId], TEXT_LINE_MAX_CHARS-9);
#else
    pos = printTime(gText[textId], TEXT_LINE_MAX_CHARS-6);
#endif //TIME_HOUR_ENABLED
  }
  else if (textId == 1) {
     df2:	cc 24       	eor	r12, r12
     df4:	c3 94       	inc	r12
     df6:	ec 14       	cp	r14, r12
     df8:	09 f4       	brne	.+2      	; 0xdfc <main+0x2f2>
     dfa:	39 c2       	rjmp	.+1138   	; 0x126e <main+0x764>
	    pos = printRssiLevel(gText[textId], 14, ANALOG_IN_3);
	  }
#endif //ANALOG_IN_NUMBER == 2

  }
  else if (textId == 2) {
     dfc:	52 e0       	ldi	r21, 0x02	; 2
     dfe:	e5 16       	cp	r14, r21
     e00:	09 f4       	brne	.+2      	; 0xe04 <main+0x2fa>
     e02:	f7 c1       	rjmp	.+1006   	; 0x11f2 <main+0x6e8>
	  else {
		  //printCompassArrow(gText[textId], 7, gGpsLastValidData.angle, 19);
	  }
#endif //GPS_ENABLED
  }	  
  else if (textId == 3) {
     e04:	63 e0       	ldi	r22, 0x03	; 3
     e06:	e6 16       	cp	r14, r22
     e08:	09 f4       	brne	.+2      	; 0xe0c <main+0x302>
     e0a:	0b c2       	rjmp	.+1046   	; 0x1222 <main+0x718>
	  else {
		  //printCompass(gText[textId], 7, gGpsLastValidData.angle, 19);
	  }
#endif //GPS_ENABLED
	}
	else if (textId == 4) {
     e0c:	74 e0       	ldi	r23, 0x04	; 4
     e0e:	e7 16       	cp	r14, r23
     e10:	09 f4       	brne	.+2      	; 0xe14 <main+0x30a>
     e12:	74 c2       	rjmp	.+1256   	; 0x12fc <main+0x7f2>
	  }		  
#endif //GPS_ENABLED
	}
	else if (textId == 5) {
#ifdef GPS_ENABLED
		pos = printText(gText[textId], 0, "SPD");
     e14:	8e e5       	ldi	r24, 0x5E	; 94
     e16:	92 e0       	ldi	r25, 0x02	; 2
     e18:	60 e0       	ldi	r22, 0x00	; 0
     e1a:	41 e4       	ldi	r20, 0x41	; 65
     e1c:	51 e0       	ldi	r21, 0x01	; 1
     e1e:	83 da       	rcall	.-2810   	; 0x326 <printText>
		pos = printText(gText[textId], 5, "LOS");
     e20:	8e e5       	ldi	r24, 0x5E	; 94
     e22:	92 e0       	ldi	r25, 0x02	; 2
     e24:	65 e0       	ldi	r22, 0x05	; 5
     e26:	45 e4       	ldi	r20, 0x45	; 69
     e28:	51 e0       	ldi	r21, 0x01	; 1
     e2a:	7d da       	rcall	.-2822   	; 0x326 <printText>
		
		if (gHomePosSet) {
     e2c:	90 91 b7 01 	lds	r25, 0x01B7
		  pos = printText(gText[textId], pos+3, "\146");
     e30:	68 2f       	mov	r22, r24
     e32:	6d 5f       	subi	r22, 0xFD	; 253
	else if (textId == 5) {
#ifdef GPS_ENABLED
		pos = printText(gText[textId], 0, "SPD");
		pos = printText(gText[textId], 5, "LOS");
		
		if (gHomePosSet) {
     e34:	99 23       	and	r25, r25
     e36:	09 f4       	brne	.+2      	; 0xe3a <main+0x330>
     e38:	77 c3       	rjmp	.+1774   	; 0x1528 <main+0xa1e>
		  pos = printText(gText[textId], pos+3, "\146");
     e3a:	8e e5       	ldi	r24, 0x5E	; 94
     e3c:	92 e0       	ldi	r25, 0x02	; 2
     e3e:	49 e4       	ldi	r20, 0x49	; 73
     e40:	51 e0       	ldi	r21, 0x01	; 1
     e42:	71 da       	rcall	.-2846   	; 0x326 <printText>
		}
		else {
			pos = printText(gText[textId], pos+3, "\147");
		}
		
		pos = printText(gText[textId], TEXT_LINE_MAX_CHARS-10, "\150");
     e44:	8e e5       	ldi	r24, 0x5E	; 94
     e46:	92 e0       	ldi	r25, 0x02	; 2
     e48:	67 e1       	ldi	r22, 0x17	; 23
     e4a:	4d e4       	ldi	r20, 0x4D	; 77
     e4c:	51 e0       	ldi	r21, 0x01	; 1
     e4e:	6b da       	rcall	.-2858   	; 0x326 <printText>
		pos = printText(gText[textId], TEXT_LINE_MAX_CHARS-5, "ALT");
     e50:	8e e5       	ldi	r24, 0x5E	; 94
     e52:	92 e0       	ldi	r25, 0x02	; 2
     e54:	6c e1       	ldi	r22, 0x1C	; 28
     e56:	4f e4       	ldi	r20, 0x4F	; 79
     e58:	51 e0       	ldi	r21, 0x01	; 1
     e5a:	65 da       	rcall	.-2870   	; 0x326 <printText>
#ifdef TIME_ENABLED
	updateTime();
#endif //TIMEENABLED

#ifdef TEXT_ENABLED
  for (uint8_t i = 0; i < TEXT_LINES; ++i) {
     e5c:	86 e0       	ldi	r24, 0x06	; 6
     e5e:	d8 16       	cp	r13, r24
     e60:	09 f4       	brne	.+2      	; 0xe64 <main+0x35a>
     e62:	e5 c0       	rjmp	.+458    	; 0x102e <main+0x524>
     e64:	e3 94       	inc	r14
     e66:	d3 94       	inc	r13
     e68:	b0 cf       	rjmp	.-160    	; 0xdca <main+0x2c0>
#endif //HOME_SET_WITH_BUTTON
#endif //GPS_ENABLED
			}
		}
		else {
			if (gKeyPressed) {
     e6a:	80 91 79 01 	lds	r24, 0x0179
     e6e:	81 11       	cpse	r24, r1
				PORTD &= ~LED;  // led off
     e70:	5b 98       	cbi	0x0b, 3	; 11
			}				
			gKeyPressed = 0;
     e72:	10 92 79 01 	sts	0x0179, r1
			gKeyPressTime = 0;
     e76:	10 92 7a 01 	sts	0x017A, r1
#ifdef DEBUG
		gUpdateScreenData = 2;
#endif //DEBUG

#ifdef TEXT_ENABLED
    if (gUpdateScreenData == 2) {
     e7a:	80 91 74 01 	lds	r24, 0x0174
     e7e:	82 30       	cpi	r24, 0x02	; 2
     e80:	09 f0       	breq	.+2      	; 0xe84 <main+0x37a>
     e82:	b9 ce       	rjmp	.-654    	; 0xbf6 <main+0xec>
		  gUpdateScreenData = 0;
     e84:	10 92 74 01 	sts	0x0174, r1
#endif //GRAPICSENABLED
}

void main(void) __attribute__ ((noreturn)); // Main never returns, saves a few bytes

void main(void) {
     e88:	20 91 b8 01 	lds	r18, 0x01B8
     e8c:	30 e0       	ldi	r19, 0x00	; 0
     e8e:	81 e2       	ldi	r24, 0x21	; 33
     e90:	90 e0       	ldi	r25, 0x00	; 0
     e92:	28 9f       	mul	r18, r24
     e94:	d0 01       	movw	r26, r0
     e96:	29 9f       	mul	r18, r25
     e98:	b0 0d       	add	r27, r0
     e9a:	38 9f       	mul	r19, r24
     e9c:	b0 0d       	add	r27, r0
     e9e:	11 24       	eor	r1, r1
     ea0:	a7 54       	subi	r26, 0x47	; 71
     ea2:	be 4f       	sbci	r27, 0xFE	; 254
		gUpdateScreenData = 2;
#endif //DEBUG

#ifdef TEXT_ENABLED
    if (gUpdateScreenData == 2) {
		  gUpdateScreenData = 0;
     ea4:	4f e7       	ldi	r20, 0x7F	; 127
     ea6:	e4 2e       	mov	r14, r20
     ea8:	42 e0       	ldi	r20, 0x02	; 2
     eaa:	f4 2e       	mov	r15, r20
#endif //GRAPICSENABLED
}

void main(void) __attribute__ ((noreturn)); // Main never returns, saves a few bytes

void main(void) {
     eac:	f7 01       	movw	r30, r14
     eae:	80 e0       	ldi	r24, 0x00	; 0
     eb0:	90 e0       	ldi	r25, 0x00	; 0
     eb2:	13 c0       	rjmp	.+38     	; 0xeda <main+0x3d0>
		uint8_t character = gText[textId][j];
		int16_t eepromPos;
		if (character == ' ' || character == 0) {
			eepromPos = -1;
		}
		else if (character < CHAR_OFFSET + CHAR_LENGTH) {
     eb4:	2b 35       	cpi	r18, 0x5B	; 91
     eb6:	08 f0       	brcs	.+2      	; 0xeba <main+0x3b0>
     eb8:	83 c1       	rjmp	.+774    	; 0x11c0 <main+0x6b6>
			uint16_t charPos = ((character - CHAR_OFFSET) * TEXT_CHAR_HEIGHT);
     eba:	82 2f       	mov	r24, r18
     ebc:	90 e0       	ldi	r25, 0x00	; 0
     ebe:	88 0f       	add	r24, r24
     ec0:	99 1f       	adc	r25, r25
     ec2:	88 0f       	add	r24, r24
     ec4:	99 1f       	adc	r25, r25
     ec6:	88 0f       	add	r24, r24
     ec8:	99 1f       	adc	r25, r25
			eepromPos = (int16_t)&(oem6x8[charPos]);
     eca:	88 52       	subi	r24, 0x28	; 40
     ecc:	91 40       	sbci	r25, 0x01	; 1
		else if (character > CHAR_SPECIAL_OFFSET && character < CHAR_SPECIAL_OFFSET+CHAR_SPECIAL_LENGTH) {
			uint16_t charPos = ((character - CHAR_SPECIAL_OFFSET) * TEXT_CHAR_HEIGHT);
			eepromPos = (int16_t)&(specialChars[charPos]);
		}
#endif //TEXT_USE_SPECIAL_CHARS
		gTextCharEepromPos[j] = eepromPos;
     ece:	81 93       	st	Z+, r24
     ed0:	91 93       	st	Z+, r25
	return 0;
}
#endif // TEXT_INVERTED_ENABLED

static void updateTextCharStartPos(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
     ed2:	42 e0       	ldi	r20, 0x02	; 2
     ed4:	e1 3c       	cpi	r30, 0xC1	; 193
     ed6:	f4 07       	cpc	r31, r20
     ed8:	69 f0       	breq	.+26     	; 0xef4 <main+0x3ea>
		uint8_t character = gText[textId][j];
     eda:	2d 91       	ld	r18, X+
		int16_t eepromPos;
		if (character == ' ' || character == 0) {
     edc:	20 32       	cpi	r18, 0x20	; 32
     ede:	11 f0       	breq	.+4      	; 0xee4 <main+0x3da>
     ee0:	22 23       	and	r18, r18
     ee2:	41 f7       	brne	.-48     	; 0xeb4 <main+0x3aa>
			eepromPos = -1;
     ee4:	8f ef       	ldi	r24, 0xFF	; 255
     ee6:	9f ef       	ldi	r25, 0xFF	; 255
		else if (character > CHAR_SPECIAL_OFFSET && character < CHAR_SPECIAL_OFFSET+CHAR_SPECIAL_LENGTH) {
			uint16_t charPos = ((character - CHAR_SPECIAL_OFFSET) * TEXT_CHAR_HEIGHT);
			eepromPos = (int16_t)&(specialChars[charPos]);
		}
#endif //TEXT_USE_SPECIAL_CHARS
		gTextCharEepromPos[j] = eepromPos;
     ee8:	81 93       	st	Z+, r24
     eea:	91 93       	st	Z+, r25
	return 0;
}
#endif // TEXT_INVERTED_ENABLED

static void updateTextCharStartPos(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
     eec:	42 e0       	ldi	r20, 0x02	; 2
     eee:	e1 3c       	cpi	r30, 0xC1	; 193
     ef0:	f4 07       	cpc	r31, r20
     ef2:	99 f7       	brne	.-26     	; 0xeda <main+0x3d0>
     ef4:	00 e0       	ldi	r16, 0x00	; 0
     ef6:	10 e0       	ldi	r17, 0x00	; 0
		  if (eepromPos != -1) {
		  eeprom_read_block((void*)gTextLastCharBuffer, (const void*)eepromPos, 8);
			  gTextLastCharEepromPos = eepromPos;
		  }
		  else {
			  memset(gTextLastCharBuffer, 0, 8);
     ef8:	b8 e0       	ldi	r27, 0x08	; 8
     efa:	db 2e       	mov	r13, r27
			  gTextLastCharEepromPos = -1;
     efc:	cc 24       	eor	r12, r12
     efe:	ca 94       	dec	r12
	}		
}

static void updateTextPixmap(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
		int16_t eepromPos = gTextCharEepromPos[j];
     f00:	d7 01       	movw	r26, r14
     f02:	8d 90       	ld	r8, X+
     f04:	9d 90       	ld	r9, X+
     f06:	7d 01       	movw	r14, r26
		if (gTextLastCharEepromPos != eepromPos) {
     f08:	80 91 53 01 	lds	r24, 0x0153
     f0c:	99 27       	eor	r25, r25
     f0e:	87 fd       	sbrc	r24, 7
     f10:	90 95       	com	r25
     f12:	88 16       	cp	r8, r24
     f14:	99 06       	cpc	r9, r25
     f16:	71 f0       	breq	.+28     	; 0xf34 <main+0x42a>
		  if (eepromPos != -1) {
     f18:	bf ef       	ldi	r27, 0xFF	; 255
     f1a:	8b 16       	cp	r8, r27
     f1c:	bf ef       	ldi	r27, 0xFF	; 255
     f1e:	9b 06       	cpc	r9, r27
     f20:	09 f4       	brne	.+2      	; 0xf24 <main+0x41a>
     f22:	5e c1       	rjmp	.+700    	; 0x11e0 <main+0x6d6>
		  eeprom_read_block((void*)gTextLastCharBuffer, (const void*)eepromPos, 8);
     f24:	81 ec       	ldi	r24, 0xC1	; 193
     f26:	92 e0       	ldi	r25, 0x02	; 2
     f28:	b4 01       	movw	r22, r8
     f2a:	48 e0       	ldi	r20, 0x08	; 8
     f2c:	50 e0       	ldi	r21, 0x00	; 0
     f2e:	57 d7       	rcall	.+3758   	; 0x1dde <__eerd_block_m88pa>
			  gTextLastCharEepromPos = eepromPos;
     f30:	80 92 53 01 	sts	0x0153, r8
     f34:	80 91 c1 02 	lds	r24, 0x02C1
     f38:	f8 01       	movw	r30, r16
     f3a:	e7 53       	subi	r30, 0x37	; 55
     f3c:	fd 4f       	sbci	r31, 0xFD	; 253
     f3e:	a2 ec       	ldi	r26, 0xC2	; 194
     f40:	b2 e0       	ldi	r27, 0x02	; 2
     f42:	01 c0       	rjmp	.+2      	; 0xf46 <main+0x43c>
		  }
		  else {
			  memset(gTextLastCharBuffer, 0, 8);
			  gTextLastCharEepromPos = -1;
     f44:	8d 91       	ld	r24, X+
		if (charInverted(textId, j)) {
		  gTextLastCharBuffer[i] = ~gTextLastCharBuffer[i];
		}
#endif // TEXT_INVERTED_ENABLED

      gTextPixmap[j + (i*TEXT_LINE_MAX_CHARS)] = gTextLastCharBuffer[i];
     f46:	80 83       	st	Z, r24
     f48:	b1 96       	adiw	r30, 0x21	; 33
			  memset(gTextLastCharBuffer, 0, 8);
			  gTextLastCharEepromPos = -1;
		  }
		}		  

	  for (uint8_t i = 0; i < TEXT_CHAR_HEIGHT; i++) {
     f4a:	32 e0       	ldi	r19, 0x02	; 2
     f4c:	a9 3c       	cpi	r26, 0xC9	; 201
     f4e:	b3 07       	cpc	r27, r19
     f50:	c9 f7       	brne	.-14     	; 0xf44 <main+0x43a>
     f52:	0f 5f       	subi	r16, 0xFF	; 255
     f54:	1f 4f       	sbci	r17, 0xFF	; 255
		gTextCharEepromPos[j] = eepromPos;
	}		
}

static void updateTextPixmap(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
     f56:	01 32       	cpi	r16, 0x21	; 33
     f58:	11 05       	cpc	r17, r1
     f5a:	91 f6       	brne	.-92     	; 0xf00 <main+0x3f6>
	setup();

	while(1) {
    
#ifdef GPS_ENABLED
    if(UCSR0A & (1<<RXC0)) {
     f5c:	80 91 c0 00 	lds	r24, 0x00C0
     f60:	87 ff       	sbrs	r24, 7
     f62:	26 ce       	rjmp	.-948    	; 0xbb0 <main+0xa6>
      decodeGpsData(UDR0);
     f64:	00 91 c6 00 	lds	r16, 0x00C6
#endif //STATISTICS_ENABLED
	}		  
}

static void decodeGpsData(char data) {
	if (gGpsTextPartStep == GPS_PART_FINISHED && data != '$') {
     f68:	90 91 60 01 	lds	r25, 0x0160
     f6c:	9f 3f       	cpi	r25, 0xFF	; 255
     f6e:	09 f4       	brne	.+2      	; 0xf72 <main+0x468>
     f70:	f9 c2       	rjmp	.+1522   	; 0x1564 <main+0xa5a>
		return;
	}
	
	switch (data) {
     f72:	04 32       	cpi	r16, 0x24	; 36
     f74:	09 f4       	brne	.+2      	; 0xf78 <main+0x46e>
     f76:	f9 c2       	rjmp	.+1522   	; 0x156a <main+0xa60>
     f78:	05 32       	cpi	r16, 0x25	; 37
     f7a:	08 f0       	brcs	.+2      	; 0xf7e <main+0x474>
     f7c:	06 c3       	rjmp	.+1548   	; 0x158a <main+0xa80>
     f7e:	0a 30       	cpi	r16, 0x0A	; 10
     f80:	09 f4       	brne	.+2      	; 0xf84 <main+0x47a>
     f82:	23 c3       	rjmp	.+1606   	; 0x15ca <main+0xac0>
     f84:	0d 30       	cpi	r16, 0x0D	; 13
     f86:	09 f4       	brne	.+2      	; 0xf8a <main+0x480>
     f88:	20 c3       	rjmp	.+1600   	; 0x15ca <main+0xac0>
	  gGpsTextPartStep = GPS_PART_FINISHED;
	  finishGpsDecoding();
		return;
		break;
	default:
		gGpsText[gGpsTextPos] = data;
     f8a:	80 91 d3 03 	lds	r24, 0x03D3
     f8e:	e8 2f       	mov	r30, r24
     f90:	f0 e0       	ldi	r31, 0x00	; 0
     f92:	ea 52       	subi	r30, 0x2A	; 42
     f94:	fc 4f       	sbci	r31, 0xFC	; 252
     f96:	00 83       	st	Z, r16
		if (gGpsTextPartStep != GPS_PART_CHECKSUM) {
     f98:	98 3c       	cpi	r25, 0xC8	; 200
     f9a:	29 f0       	breq	.+10     	; 0xfa6 <main+0x49c>
		  gGpsChecksum ^= data;
     f9c:	90 91 d5 03 	lds	r25, 0x03D5
     fa0:	90 27       	eor	r25, r16
     fa2:	90 93 d5 03 	sts	0x03D5, r25
		}
		if (gGpsTextPos < GPS_MAX_CHARS-1) {
     fa6:	8a 30       	cpi	r24, 0x0A	; 10
     fa8:	08 f0       	brcs	.+2      	; 0xfac <main+0x4a2>
     faa:	02 ce       	rjmp	.-1020   	; 0xbb0 <main+0xa6>
		  ++gGpsTextPos;
     fac:	8f 5f       	subi	r24, 0xFF	; 255
     fae:	80 93 d3 03 	sts	0x03D3, r24
     fb2:	fe cd       	rjmp	.-1028   	; 0xbb0 <main+0xa6>
static void updateText(uint8_t textId) {
  //testPrintDebugInfo();
  uint8_t pos = 0;

	if (textId == 0) {
		pos = printText(gText[textId], 0, "\1521");
     fb4:	89 eb       	ldi	r24, 0xB9	; 185
     fb6:	91 e0       	ldi	r25, 0x01	; 1
     fb8:	60 e0       	ldi	r22, 0x00	; 0
     fba:	46 e2       	ldi	r20, 0x26	; 38
     fbc:	51 e0       	ldi	r21, 0x01	; 1
     fbe:	b3 d9       	rcall	.-3226   	; 0x326 <printText>
#if ANALOG_IN_NUMBER == 2
    pos = printText(gText[textId], 7, "\151");
#else // ANALOG_IN_NUMBER > 2
    pos = printText(gText[textId], 7, "\1522");
     fc0:	89 eb       	ldi	r24, 0xB9	; 185
     fc2:	91 e0       	ldi	r25, 0x01	; 1
     fc4:	67 e0       	ldi	r22, 0x07	; 7
     fc6:	49 e2       	ldi	r20, 0x29	; 41
     fc8:	51 e0       	ldi	r21, 0x01	; 1
     fca:	ad d9       	rcall	.-3238   	; 0x326 <printText>
	  pos = printText(gText[textId], 14, "\151");    
     fcc:	89 eb       	ldi	r24, 0xB9	; 185
     fce:	91 e0       	ldi	r25, 0x01	; 1
     fd0:	6e e0       	ldi	r22, 0x0E	; 14
     fd2:	4c e2       	ldi	r20, 0x2C	; 44
     fd4:	51 e0       	ldi	r21, 0x01	; 1
     fd6:	a7 d9       	rcall	.-3250   	; 0x326 <printText>
	if (gTime.hour < 10) {
		str[pos++] = '0';
	}
	pos = printNumberWithUnit(str, pos, gTime.hour, ":");
#endif //TIME_HOUR_ENABLED
	if (gTime.min < 10) {
     fd8:	80 91 77 01 	lds	r24, 0x0177
     fdc:	8a 30       	cpi	r24, 0x0A	; 10
     fde:	08 f0       	brcs	.+2      	; 0xfe2 <main+0x4d8>
     fe0:	1e c1       	rjmp	.+572    	; 0x121e <main+0x714>
		str[pos++] = '0';
     fe2:	80 e3       	ldi	r24, 0x30	; 48
     fe4:	80 93 d4 01 	sts	0x01D4, r24
     fe8:	6c e1       	ldi	r22, 0x1C	; 28
	}	
	pos = printNumberWithUnit(str, pos, gTime.min, ":");
     fea:	20 91 77 01 	lds	r18, 0x0177
     fee:	30 e0       	ldi	r19, 0x00	; 0
     ff0:	40 e0       	ldi	r20, 0x00	; 0
     ff2:	50 e0       	ldi	r21, 0x00	; 0
     ff4:	89 eb       	ldi	r24, 0xB9	; 185
     ff6:	91 e0       	ldi	r25, 0x01	; 1
     ff8:	06 e1       	ldi	r16, 0x16	; 22
     ffa:	11 e0       	ldi	r17, 0x01	; 1
     ffc:	bc d9       	rcall	.-3208   	; 0x376 <printNumberWithUnit>
     ffe:	68 2f       	mov	r22, r24
	if (gTime.sec < 10) {
    1000:	80 91 76 01 	lds	r24, 0x0176
    1004:	8a 30       	cpi	r24, 0x0A	; 10
    1006:	38 f4       	brcc	.+14     	; 0x1016 <main+0x50c>
		str[pos++] = '0';
    1008:	e6 2f       	mov	r30, r22
    100a:	f0 e0       	ldi	r31, 0x00	; 0
    100c:	e7 54       	subi	r30, 0x47	; 71
    100e:	fe 4f       	sbci	r31, 0xFE	; 254
    1010:	80 e3       	ldi	r24, 0x30	; 48
    1012:	80 83       	st	Z, r24
    1014:	6f 5f       	subi	r22, 0xFF	; 255
	}	
	return printNumber(str, pos, gTime.sec);
    1016:	20 91 76 01 	lds	r18, 0x0176
    101a:	30 e0       	ldi	r19, 0x00	; 0
    101c:	40 e0       	ldi	r20, 0x00	; 0
    101e:	50 e0       	ldi	r21, 0x00	; 0
    1020:	89 eb       	ldi	r24, 0xB9	; 185
    1022:	91 e0       	ldi	r25, 0x01	; 1
    1024:	e5 d8       	rcall	.-3638   	; 0x1f0 <printNumber>
#ifdef TIME_ENABLED
	updateTime();
#endif //TIMEENABLED

#ifdef TEXT_ENABLED
  for (uint8_t i = 0; i < TEXT_LINES; ++i) {
    1026:	86 e0       	ldi	r24, 0x06	; 6
    1028:	d8 16       	cp	r13, r24
    102a:	09 f0       	breq	.+2      	; 0x102e <main+0x524>
    102c:	1b cf       	rjmp	.-458    	; 0xe64 <main+0x35a>
    102e:	80 e0       	ldi	r24, 0x00	; 0
    1030:	90 e0       	ldi	r25, 0x00	; 0
#endif //GRAPICSENABLED
}

void main(void) __attribute__ ((noreturn)); // Main never returns, saves a few bytes

void main(void) {
    1032:	fc 01       	movw	r30, r24
    1034:	ee 0f       	add	r30, r30
    1036:	ff 1f       	adc	r31, r31
    1038:	e8 0f       	add	r30, r24
    103a:	f9 1f       	adc	r31, r25
    103c:	ee 0f       	add	r30, r30
    103e:	ff 1f       	adc	r31, r31
    1040:	ee 0f       	add	r30, r30
    1042:	ff 1f       	adc	r31, r31
    1044:	ee 0f       	add	r30, r30
    1046:	ff 1f       	adc	r31, r31
    1048:	e6 51       	subi	r30, 0x16	; 22
    104a:	fc 4f       	sbci	r31, 0xFC	; 252
    104c:	20 e0       	ldi	r18, 0x00	; 0
// Functions

static void clearGraphics() {
	for (uint8_t x = 0; x < GRAPHICS_WIDTH; ++x) {
	  for (uint8_t y = 0; y < GRAPHICS_HEIGHT; ++y) {
			gPixelData[x][y] = 0x00;
    104e:	11 92       	st	Z+, r1

// Functions

static void clearGraphics() {
	for (uint8_t x = 0; x < GRAPHICS_WIDTH; ++x) {
	  for (uint8_t y = 0; y < GRAPHICS_HEIGHT; ++y) {
    1050:	2f 5f       	subi	r18, 0xFF	; 255
    1052:	28 31       	cpi	r18, 0x18	; 24
    1054:	e1 f7       	brne	.-8      	; 0x104e <main+0x544>
    1056:	01 96       	adiw	r24, 0x01	; 1
static uint8_t gPixelData[GRAPHICS_WIDTH][GRAPHICS_HEIGHT];

// Functions

static void clearGraphics() {
	for (uint8_t x = 0; x < GRAPHICS_WIDTH; ++x) {
    1058:	83 30       	cpi	r24, 0x03	; 3
    105a:	91 05       	cpc	r25, r1
    105c:	51 f7       	brne	.-44     	; 0x1032 <main+0x528>
}
#endif //TEXT_ENABLED

static void updateGrapics() {
#ifdef GPS_ENABLED
  drawArrow(gHomeBearing - gGpsLastValidData.angle);
    105e:	e0 90 e8 03 	lds	r14, 0x03E8
    1062:	f0 90 e9 03 	lds	r15, 0x03E9
    1066:	00 91 b0 01 	lds	r16, 0x01B0
    106a:	10 91 b1 01 	lds	r17, 0x01B1
		}
	}				 
}

static void drawArrow(uint16_t angle) {
	drawCircle(GRAPHICS_MID, GRAPHICS_MID, GRAPHICS_MID);
    106e:	8b e0       	ldi	r24, 0x0B	; 11
    1070:	d1 dc       	rcall	.-1630   	; 0xa14 <drawCircle.constprop.9>
	if (gHomeDistance < 10) {
    1072:	80 91 e4 03 	lds	r24, 0x03E4
    1076:	90 91 e5 03 	lds	r25, 0x03E5
    107a:	a0 91 e6 03 	lds	r26, 0x03E6
    107e:	b0 91 e7 03 	lds	r27, 0x03E7
    1082:	8a 30       	cpi	r24, 0x0A	; 10
    1084:	91 05       	cpc	r25, r1
    1086:	a1 05       	cpc	r26, r1
    1088:	b1 05       	cpc	r27, r1
    108a:	08 f4       	brcc	.+2      	; 0x108e <main+0x584>
    108c:	4a c2       	rjmp	.+1172   	; 0x1522 <main+0xa18>
	  drawCircle(GRAPHICS_MID, GRAPHICS_MID, 2);
	  return;
	}
	if (gGpsLastValidData.speed < HOME_FIX_MIN_SPEED || gGpsLastData.fix == 0) {
    108e:	80 91 ae 01 	lds	r24, 0x01AE
    1092:	90 91 af 01 	lds	r25, 0x01AF
    1096:	8a 30       	cpi	r24, 0x0A	; 10
    1098:	91 05       	cpc	r25, r1
    109a:	08 f4       	brcc	.+2      	; 0x109e <main+0x594>
    109c:	24 c1       	rjmp	.+584    	; 0x12e6 <main+0x7dc>
    109e:	80 91 89 01 	lds	r24, 0x0189
    10a2:	88 23       	and	r24, r24
    10a4:	09 f4       	brne	.+2      	; 0x10a8 <main+0x59e>
    10a6:	1f c1       	rjmp	.+574    	; 0x12e6 <main+0x7dc>
    10a8:	d7 01       	movw	r26, r14
    10aa:	a0 1b       	sub	r26, r16
    10ac:	b1 0b       	sbc	r27, r17
    10ae:	8d 01       	movw	r16, r26
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
}

static int8_t myCos(uint16_t angle) {
	return mySin(angle + 90);
    10b0:	cd 01       	movw	r24, r26
    10b2:	86 5a       	subi	r24, 0xA6	; 166
    10b4:	9f 4f       	sbci	r25, 0xFF	; 255
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    10b6:	68 e6       	ldi	r22, 0x68	; 104
    10b8:	71 e0       	ldi	r23, 0x01	; 1
    10ba:	d9 d5       	rcall	.+2994   	; 0x1c6e <__udivmodhi4>
	int8_t mult = 1;
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    10bc:	84 3b       	cpi	r24, 0xB4	; 180
    10be:	91 05       	cpc	r25, r1
    10c0:	08 f4       	brcc	.+2      	; 0x10c4 <main+0x5ba>
    10c2:	3a c2       	rjmp	.+1140   	; 0x1538 <main+0xa2e>
		pos = pos - 180;
    10c4:	84 5b       	subi	r24, 0xB4	; 180
    10c6:	90 40       	sbci	r25, 0x00	; 0
    10c8:	4f ef       	ldi	r20, 0xFF	; 255
		mult = -1;
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
    10ca:	8a 35       	cpi	r24, 0x5A	; 90
    10cc:	91 05       	cpc	r25, r1
    10ce:	30 f0       	brcs	.+12     	; 0x10dc <main+0x5d2>
		pos = 180 - pos;
    10d0:	24 eb       	ldi	r18, 0xB4	; 180
    10d2:	30 e0       	ldi	r19, 0x00	; 0
    10d4:	f9 01       	movw	r30, r18
    10d6:	e8 1b       	sub	r30, r24
    10d8:	f9 0b       	sbc	r31, r25
    10da:	cf 01       	movw	r24, r30
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
    10dc:	8c 5c       	subi	r24, 0xCC	; 204
    10de:	9f 4f       	sbci	r25, 0xFF	; 255
    10e0:	fc 01       	movw	r30, r24
    10e2:	84 91       	lpm	r24, Z
    10e4:	84 9f       	mul	r24, r20
    10e6:	20 2d       	mov	r18, r0
    10e8:	11 24       	eor	r1, r1
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    10ea:	c8 01       	movw	r24, r16
    10ec:	68 e6       	ldi	r22, 0x68	; 104
    10ee:	71 e0       	ldi	r23, 0x01	; 1
    10f0:	be d5       	rcall	.+2940   	; 0x1c6e <__udivmodhi4>
	int8_t mult = 1;
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    10f2:	84 3b       	cpi	r24, 0xB4	; 180
    10f4:	91 05       	cpc	r25, r1
    10f6:	08 f4       	brcc	.+2      	; 0x10fa <main+0x5f0>
    10f8:	1d c2       	rjmp	.+1082   	; 0x1534 <main+0xa2a>
		pos = pos - 180;
    10fa:	84 5b       	subi	r24, 0xB4	; 180
    10fc:	90 40       	sbci	r25, 0x00	; 0
    10fe:	3f ef       	ldi	r19, 0xFF	; 255
		mult = -1;
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
    1100:	8a 35       	cpi	r24, 0x5A	; 90
    1102:	91 05       	cpc	r25, r1
    1104:	30 f0       	brcs	.+12     	; 0x1112 <main+0x608>
		pos = 180 - pos;
    1106:	64 eb       	ldi	r22, 0xB4	; 180
    1108:	70 e0       	ldi	r23, 0x00	; 0
    110a:	6b 01       	movw	r12, r22
    110c:	c8 1a       	sub	r12, r24
    110e:	d9 0a       	sbc	r13, r25
    1110:	c6 01       	movw	r24, r12
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
    1112:	8c 5c       	subi	r24, 0xCC	; 204
    1114:	9f 4f       	sbci	r25, 0xFF	; 255
    1116:	fc 01       	movw	r30, r24
    1118:	84 91       	lpm	r24, Z
    111a:	83 9f       	mul	r24, r19
    111c:	40 2d       	mov	r20, r0
    111e:	11 24       	eor	r1, r1
		drawLine(GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID - (GRAPHICS_SIZE/4));
		return;
	}
	int16_t a = myCos(angle);
	int16_t b = mySin(angle);
	a = (a * (GRAPHICS_SIZE / 3)) / 100;
    1120:	82 2f       	mov	r24, r18
    1122:	99 27       	eor	r25, r25
    1124:	87 fd       	sbrc	r24, 7
    1126:	90 95       	com	r25
    1128:	88 0f       	add	r24, r24
    112a:	99 1f       	adc	r25, r25
    112c:	88 0f       	add	r24, r24
    112e:	99 1f       	adc	r25, r25
    1130:	88 0f       	add	r24, r24
    1132:	99 1f       	adc	r25, r25
    1134:	24 e6       	ldi	r18, 0x64	; 100
    1136:	30 e0       	ldi	r19, 0x00	; 0
    1138:	b9 01       	movw	r22, r18
    113a:	ad d5       	rcall	.+2906   	; 0x1c96 <__divmodhi4>
    113c:	4b 01       	movw	r8, r22
	b = (b * (GRAPHICS_SIZE / 3)) / 100;
    113e:	84 2f       	mov	r24, r20
    1140:	99 27       	eor	r25, r25
    1142:	87 fd       	sbrc	r24, 7
    1144:	90 95       	com	r25
    1146:	88 0f       	add	r24, r24
    1148:	99 1f       	adc	r25, r25
    114a:	88 0f       	add	r24, r24
    114c:	99 1f       	adc	r25, r25
    114e:	88 0f       	add	r24, r24
    1150:	99 1f       	adc	r25, r25
    1152:	b9 01       	movw	r22, r18
    1154:	a0 d5       	rcall	.+2880   	; 0x1c96 <__divmodhi4>
    1156:	8b 01       	movw	r16, r22
	drawLine(GRAPHICS_MID - b, GRAPHICS_MID + a, GRAPHICS_MID + b, GRAPHICS_MID - a); //Direction line
    1158:	68 2d       	mov	r22, r8
    115a:	bb e0       	ldi	r27, 0x0B	; 11
    115c:	eb 2e       	mov	r14, r27
    115e:	e0 0e       	add	r14, r16
    1160:	8b e0       	ldi	r24, 0x0B	; 11
    1162:	d8 2e       	mov	r13, r24
    1164:	d8 18       	sub	r13, r8
    1166:	65 5f       	subi	r22, 0xF5	; 245
    1168:	80 1b       	sub	r24, r16
    116a:	4e 2d       	mov	r20, r14
    116c:	2d 2d       	mov	r18, r13
    116e:	da db       	rcall	.-2124   	; 0x924 <drawLine>
	//drawLine(GRAPHICS_MID_X + a/2, GRAPHICS_MID_X + b/2, GRAPHICS_MID_X - a/2, GRAPHICS_MID_X - b/2); //Arrow bottom line
	drawLine(GRAPHICS_MID + b, GRAPHICS_MID - a, GRAPHICS_MID - a/2, GRAPHICS_MID - b/2); // Arrow "wings"
    1170:	c4 01       	movw	r24, r8
    1172:	97 fc       	sbrc	r9, 7
    1174:	7f c3       	rjmp	.+1790   	; 0x1874 <main+0xd6a>
    1176:	95 95       	asr	r25
    1178:	87 95       	ror	r24
    117a:	90 95       	com	r25
    117c:	81 95       	neg	r24
    117e:	9f 4f       	sbci	r25, 0xFF	; 255
    1180:	48 2f       	mov	r20, r24
    1182:	45 5f       	subi	r20, 0xF5	; 245
    1184:	98 01       	movw	r18, r16
    1186:	17 fd       	sbrc	r17, 7
    1188:	72 c3       	rjmp	.+1764   	; 0x186e <main+0xd64>
    118a:	c9 01       	movw	r24, r18
    118c:	95 95       	asr	r25
    118e:	87 95       	ror	r24
    1190:	90 95       	com	r25
    1192:	81 95       	neg	r24
    1194:	9f 4f       	sbci	r25, 0xFF	; 255
    1196:	28 2f       	mov	r18, r24
    1198:	25 5f       	subi	r18, 0xF5	; 245
    119a:	8e 2d       	mov	r24, r14
    119c:	6d 2d       	mov	r22, r13
    119e:	c2 db       	rcall	.-2172   	; 0x924 <drawLine>
	drawLine(GRAPHICS_MID + b, GRAPHICS_MID - a, GRAPHICS_MID + a/2, GRAPHICS_MID + b/2);
    11a0:	97 fc       	sbrc	r9, 7
    11a2:	61 c3       	rjmp	.+1730   	; 0x1866 <main+0xd5c>
    11a4:	a4 01       	movw	r20, r8
    11a6:	55 95       	asr	r21
    11a8:	47 95       	ror	r20
    11aa:	45 5f       	subi	r20, 0xF5	; 245
    11ac:	17 fd       	sbrc	r17, 7
    11ae:	58 c3       	rjmp	.+1712   	; 0x1860 <main+0xd56>
    11b0:	15 95       	asr	r17
    11b2:	07 95       	ror	r16
    11b4:	20 2f       	mov	r18, r16
    11b6:	25 5f       	subi	r18, 0xF5	; 245
    11b8:	8e 2d       	mov	r24, r14
    11ba:	6d 2d       	mov	r22, r13
    11bc:	b3 db       	rcall	.-2202   	; 0x924 <drawLine>
    11be:	f4 cc       	rjmp	.-1560   	; 0xba8 <main+0x9e>
		else if (character < CHAR_OFFSET + CHAR_LENGTH) {
			uint16_t charPos = ((character - CHAR_OFFSET) * TEXT_CHAR_HEIGHT);
			eepromPos = (int16_t)&(oem6x8[charPos]);
		}
#ifdef TEXT_USE_SPECIAL_CHARS
		else if (character > CHAR_SPECIAL_OFFSET && character < CHAR_SPECIAL_OFFSET+CHAR_SPECIAL_LENGTH) {
    11c0:	32 2f       	mov	r19, r18
    11c2:	35 56       	subi	r19, 0x65	; 101
    11c4:	39 30       	cpi	r19, 0x09	; 9
    11c6:	08 f0       	brcs	.+2      	; 0x11ca <main+0x6c0>
    11c8:	82 ce       	rjmp	.-764    	; 0xece <main+0x3c4>
			uint16_t charPos = ((character - CHAR_SPECIAL_OFFSET) * TEXT_CHAR_HEIGHT);
    11ca:	82 2f       	mov	r24, r18
    11cc:	90 e0       	ldi	r25, 0x00	; 0
    11ce:	88 0f       	add	r24, r24
    11d0:	99 1f       	adc	r25, r25
    11d2:	88 0f       	add	r24, r24
    11d4:	99 1f       	adc	r25, r25
    11d6:	88 0f       	add	r24, r24
    11d8:	99 1f       	adc	r25, r25
			eepromPos = (int16_t)&(specialChars[charPos]);
    11da:	80 57       	subi	r24, 0x70	; 112
    11dc:	91 40       	sbci	r25, 0x01	; 1
    11de:	77 ce       	rjmp	.-786    	; 0xece <main+0x3c4>
		  if (eepromPos != -1) {
		  eeprom_read_block((void*)gTextLastCharBuffer, (const void*)eepromPos, 8);
			  gTextLastCharEepromPos = eepromPos;
		  }
		  else {
			  memset(gTextLastCharBuffer, 0, 8);
    11e0:	f1 01       	movw	r30, r2
    11e2:	2d 2d       	mov	r18, r13
    11e4:	11 92       	st	Z+, r1
    11e6:	2a 95       	dec	r18
    11e8:	e9 f7       	brne	.-6      	; 0x11e4 <main+0x6da>
			  gTextLastCharEepromPos = -1;
    11ea:	c0 92 53 01 	sts	0x0153, r12
    11ee:	80 e0       	ldi	r24, 0x00	; 0
    11f0:	a3 ce       	rjmp	.-698    	; 0xf38 <main+0x42e>
#endif //ANALOG_IN_NUMBER == 2

  }
  else if (textId == 2) {
#ifdef GPS_ENABLED
	  if (gInfoShow) {
    11f2:	80 91 61 01 	lds	r24, 0x0161
    11f6:	88 23       	and	r24, r24
    11f8:	09 f4       	brne	.+2      	; 0x11fc <main+0x6f2>
    11fa:	30 ce       	rjmp	.-928    	; 0xe5c <main+0x352>
	    if (gHomePosSet) {
    11fc:	80 91 b7 01 	lds	r24, 0x01B7
    1200:	88 23       	and	r24, r24
    1202:	09 f0       	breq	.+2      	; 0x1206 <main+0x6fc>
    1204:	2b ce       	rjmp	.-938    	; 0xe5c <main+0x352>
#ifdef STATISTICS_ENABLED
		    pos = printText(gText[textId], 7, "LOS  SPD TRIP  ALT");
#endif //STATISTICS_ENABLED
	    }
	    else if (gBlink1Hz) {
    1206:	80 91 75 01 	lds	r24, 0x0175
    120a:	88 23       	and	r24, r24
    120c:	09 f4       	brne	.+2      	; 0x1210 <main+0x706>
    120e:	2a ce       	rjmp	.-940    	; 0xe64 <main+0x35a>
	      pos = printText(gText[textId], 10, "NO HOME POS");
    1210:	8b ef       	ldi	r24, 0xFB	; 251
    1212:	91 e0       	ldi	r25, 0x01	; 1
    1214:	6a e0       	ldi	r22, 0x0A	; 10
    1216:	43 e3       	ldi	r20, 0x33	; 51
    1218:	51 e0       	ldi	r21, 0x01	; 1
    121a:	85 d8       	rcall	.-3830   	; 0x326 <printText>
    121c:	23 ce       	rjmp	.-954    	; 0xe64 <main+0x35a>
	if (gTime.hour < 10) {
		str[pos++] = '0';
	}
	pos = printNumberWithUnit(str, pos, gTime.hour, ":");
#endif //TIME_HOUR_ENABLED
	if (gTime.min < 10) {
    121e:	6b e1       	ldi	r22, 0x1B	; 27
    1220:	e4 ce       	rjmp	.-568    	; 0xfea <main+0x4e0>
	  }
#endif //GPS_ENABLED
  }	  
  else if (textId == 3) {
#ifdef GPS_ENABLED
	  if (gInfoShow) {
    1222:	80 91 61 01 	lds	r24, 0x0161
    1226:	88 23       	and	r24, r24
    1228:	09 f4       	brne	.+2      	; 0x122c <main+0x722>
    122a:	18 ce       	rjmp	.-976    	; 0xe5c <main+0x352>
	    if (gHomePosSet) {
    122c:	80 91 b7 01 	lds	r24, 0x01B7
    1230:	88 23       	and	r24, r24
    1232:	09 f0       	breq	.+2      	; 0x1236 <main+0x72c>
    1234:	13 ce       	rjmp	.-986    	; 0xe5c <main+0x352>
		    printNumber(gText[textId], pos+9, gStatDistTraveled);
		    printNumber(gText[textId], pos+15, gStatMaxAltitude);
#endif //STATISTICS_ENABLED
	    }
	    else {
        pos = printGpsNumber(gText[textId], pos+4, gGpsLastValidData.pos.latitude, 1);
    1236:	20 91 9e 01 	lds	r18, 0x019E
    123a:	30 91 9f 01 	lds	r19, 0x019F
    123e:	40 91 a0 01 	lds	r20, 0x01A0
    1242:	50 91 a1 01 	lds	r21, 0x01A1
    1246:	8c e1       	ldi	r24, 0x1C	; 28
    1248:	92 e0       	ldi	r25, 0x02	; 2
    124a:	64 e0       	ldi	r22, 0x04	; 4
    124c:	01 e0       	ldi	r16, 0x01	; 1
    124e:	cf d8       	rcall	.-3682   	; 0x3ee <printGpsNumber>
        pos = printGpsNumber(gText[textId], pos+2, gGpsLastValidData.pos.longitude, 0);
    1250:	68 2f       	mov	r22, r24
    1252:	6e 5f       	subi	r22, 0xFE	; 254
    1254:	20 91 a2 01 	lds	r18, 0x01A2
    1258:	30 91 a3 01 	lds	r19, 0x01A3
    125c:	40 91 a4 01 	lds	r20, 0x01A4
    1260:	50 91 a5 01 	lds	r21, 0x01A5
    1264:	8c e1       	ldi	r24, 0x1C	; 28
    1266:	92 e0       	ldi	r25, 0x02	; 2
    1268:	00 e0       	ldi	r16, 0x00	; 0
    126a:	c1 d8       	rcall	.-3710   	; 0x3ee <printGpsNumber>
    126c:	fb cd       	rjmp	.-1034   	; 0xe64 <main+0x35a>
#else
    pos = printTime(gText[textId], TEXT_LINE_MAX_CHARS-6);
#endif //TIME_HOUR_ENABLED
  }
  else if (textId == 1) {
	  printText(gText[textId], TEXT_LINE_MAX_CHARS-1-strlen(TEXT_CALLSIGN), TEXT_CALLSIGN);
    126e:	8a ed       	ldi	r24, 0xDA	; 218
    1270:	91 e0       	ldi	r25, 0x01	; 1
    1272:	6e e1       	ldi	r22, 0x1E	; 30
    1274:	4e e2       	ldi	r20, 0x2E	; 46
    1276:	51 e0       	ldi	r21, 0x01	; 1
    1278:	56 d8       	rcall	.-3924   	; 0x326 <printText>
	  if (!gAlarmBatt1 || gBlink1Hz) {
	    pos = printAdc(gText[textId], 0, ANALOG_IN_1);
    127a:	8a ed       	ldi	r24, 0xDA	; 218
    127c:	91 e0       	ldi	r25, 0x01	; 1
    127e:	60 e0       	ldi	r22, 0x00	; 0
    1280:	40 e0       	ldi	r20, 0x00	; 0
    1282:	88 d8       	rcall	.-3824   	; 0x394 <printAdc>
    if (!gAlarmRssi || gBlink1Hz) {
      pos = printRssiLevel(gText[textId], 7, ANALOG_IN_2);
	  }	  
#else // ANALOG_IN_NUMBER > 2
    if (!gAlarmBatt2 || gBlink1Hz) {
      pos = printAdc(gText[textId], 7, ANALOG_IN_2);
    1284:	8a ed       	ldi	r24, 0xDA	; 218
    1286:	91 e0       	ldi	r25, 0x01	; 1
    1288:	67 e0       	ldi	r22, 0x07	; 7
    128a:	41 e0       	ldi	r20, 0x01	; 1
    128c:	83 d8       	rcall	.-3834   	; 0x394 <printAdc>
    gAnalogInputs[i].high = adcHigh;
  }    
}

static uint8_t calcGenericLevel(uint8_t adcInput, uint16_t minLevel, uint16_t maxLevel) {
	uint16_t level = ((gAnalogInputs[adcInput].high * 100) + gAnalogInputs[adcInput].low);
    128e:	20 91 3f 04 	lds	r18, 0x043F
    1292:	84 e6       	ldi	r24, 0x64	; 100
    1294:	28 9f       	mul	r18, r24
    1296:	90 01       	movw	r18, r0
    1298:	11 24       	eor	r1, r1
    129a:	80 91 3e 04 	lds	r24, 0x043E
    129e:	28 0f       	add	r18, r24
    12a0:	31 1d       	adc	r19, r1
	if (level > maxLevel) {
    12a2:	41 e0       	ldi	r20, 0x01	; 1
    12a4:	25 3f       	cpi	r18, 0xF5	; 245
    12a6:	34 07       	cpc	r19, r20
    12a8:	08 f0       	brcs	.+2      	; 0x12ac <main+0x7a2>
    12aa:	48 c1       	rjmp	.+656    	; 0x153c <main+0xa32>
		level = 100;
	}		
	else if (level > minLevel) {
    12ac:	29 37       	cpi	r18, 0x79	; 121
    12ae:	31 05       	cpc	r19, r1
    12b0:	08 f4       	brcc	.+2      	; 0x12b4 <main+0x7aa>
    12b2:	a8 c2       	rjmp	.+1360   	; 0x1804 <main+0xcfa>
		level -= minLevel;
    12b4:	28 57       	subi	r18, 0x78	; 120
    12b6:	30 40       	sbci	r19, 0x00	; 0
		level *= 100;
    12b8:	44 e6       	ldi	r20, 0x64	; 100
    12ba:	50 e0       	ldi	r21, 0x00	; 0
    12bc:	24 9f       	mul	r18, r20
    12be:	c0 01       	movw	r24, r0
    12c0:	25 9f       	mul	r18, r21
    12c2:	90 0d       	add	r25, r0
    12c4:	34 9f       	mul	r19, r20
    12c6:	90 0d       	add	r25, r0
    12c8:	11 24       	eor	r1, r1
		level /= maxLevel - minLevel;
    12ca:	6c e7       	ldi	r22, 0x7C	; 124
    12cc:	71 e0       	ldi	r23, 0x01	; 1
    12ce:	cf d4       	rcall	.+2462   	; 0x1c6e <__udivmodhi4>
    12d0:	9b 01       	movw	r18, r22
	if (level > maxLevel) {
		level = 100;
	}		
	else if (level > minLevel) {
		level -= minLevel;
		level *= 100;
    12d2:	30 e0       	ldi	r19, 0x00	; 0
    12d4:	40 e0       	ldi	r20, 0x00	; 0
    12d6:	50 e0       	ldi	r21, 0x00	; 0
	return printNumberWithUnit(str, pos, low, "V");		
}

static uint8_t printRssiLevel(char* const str, uint8_t pos, const uint8_t adcInput) {
	uint8_t rssiLevel = calcRssiLevel(adcInput);
	return printNumberWithUnit(str, pos, rssiLevel, "%");
    12d8:	8a ed       	ldi	r24, 0xDA	; 218
    12da:	91 e0       	ldi	r25, 0x01	; 1
    12dc:	6e e0       	ldi	r22, 0x0E	; 14
    12de:	01 e3       	ldi	r16, 0x31	; 49
    12e0:	11 e0       	ldi	r17, 0x01	; 1
    12e2:	49 d8       	rcall	.-3950   	; 0x376 <printNumberWithUnit>
    12e4:	bf cd       	rjmp	.-1154   	; 0xe64 <main+0x35a>
	if (gHomeDistance < 10) {
	  drawCircle(GRAPHICS_MID, GRAPHICS_MID, 2);
	  return;
	}
	if (gGpsLastValidData.speed < HOME_FIX_MIN_SPEED || gGpsLastData.fix == 0) {
		drawLine(GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4));
    12e6:	85 e0       	ldi	r24, 0x05	; 5
    12e8:	65 e0       	ldi	r22, 0x05	; 5
    12ea:	41 e1       	ldi	r20, 0x11	; 17
    12ec:	21 e1       	ldi	r18, 0x11	; 17
    12ee:	1a db       	rcall	.-2508   	; 0x924 <drawLine>
		drawLine(GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID - (GRAPHICS_SIZE/4));
    12f0:	85 e0       	ldi	r24, 0x05	; 5
    12f2:	61 e1       	ldi	r22, 0x11	; 17
    12f4:	41 e1       	ldi	r20, 0x11	; 17
    12f6:	25 e0       	ldi	r18, 0x05	; 5
    12f8:	15 db       	rcall	.-2518   	; 0x924 <drawLine>
    12fa:	56 cc       	rjmp	.-1876   	; 0xba8 <main+0x9e>
#endif //GPS_ENABLED
	}
	else if (textId == 4) {
#ifdef GPS_ENABLED
    if (!gAlarmSpeed || gBlink1Hz) {
	    pos = printNumber(gText[textId], 0, gGpsLastValidData.speed);
    12fc:	20 91 ae 01 	lds	r18, 0x01AE
    1300:	30 91 af 01 	lds	r19, 0x01AF
    1304:	40 e0       	ldi	r20, 0x00	; 0
    1306:	50 e0       	ldi	r21, 0x00	; 0
    1308:	8d e3       	ldi	r24, 0x3D	; 61
    130a:	92 e0       	ldi	r25, 0x02	; 2
    130c:	60 e0       	ldi	r22, 0x00	; 0
    130e:	70 d7       	rcall	.+3808   	; 0x21f0 <__data_load_end+0x37a>
	  }		
    if (!gHomePosSet) {
    1310:	80 91 b7 01 	lds	r24, 0x01B7
    1314:	88 23       	and	r24, r24
    1316:	09 f4       	brne	.+2      	; 0x131a <main+0x810>
    1318:	1e c1       	rjmp	.+572    	; 0x1556 <main+0xa4c>
		  pos = printText(gText[textId], 5, "-");
	  }
	  else {
		  if (!gAlarmDistance || gBlink1Hz) {
		    pos = printNumber(gText[textId], 5, gHomeDistance);
    131a:	20 91 e4 03 	lds	r18, 0x03E4
    131e:	30 91 e5 03 	lds	r19, 0x03E5
    1322:	40 91 e6 03 	lds	r20, 0x03E6
    1326:	50 91 e7 03 	lds	r21, 0x03E7
    132a:	8d e3       	ldi	r24, 0x3D	; 61
    132c:	92 e0       	ldi	r25, 0x02	; 2
    132e:	65 e0       	ldi	r22, 0x05	; 5
    1330:	5f d7       	rcall	.+3774   	; 0x21f0 <__data_load_end+0x37a>
		  }			
	  }		  
		if (gGpsLastValidData.fix) {
    1332:	80 91 ac 01 	lds	r24, 0x01AC
    1336:	88 23       	and	r24, r24
    1338:	09 f4       	brne	.+2      	; 0x133c <main+0x832>
    133a:	ec c0       	rjmp	.+472    	; 0x1514 <main+0xa0a>
		  pos = printNumber(gText[textId], TEXT_LINE_MAX_CHARS-10, gGpsLastValidData.sats);
    133c:	20 91 ad 01 	lds	r18, 0x01AD
    1340:	30 e0       	ldi	r19, 0x00	; 0
    1342:	40 e0       	ldi	r20, 0x00	; 0
    1344:	50 e0       	ldi	r21, 0x00	; 0
    1346:	8d e3       	ldi	r24, 0x3D	; 61
    1348:	92 e0       	ldi	r25, 0x02	; 2
    134a:	67 e1       	ldi	r22, 0x17	; 23
    134c:	51 d7       	rcall	.+3746   	; 0x21f0 <__data_load_end+0x37a>
		}
		else {			
		  pos = printText(gText[textId], TEXT_LINE_MAX_CHARS-10, "-");
	  }
	  if (!gAlarmAltitude || gBlink1Hz) {
		  pos = printNumber(gText[textId], TEXT_LINE_MAX_CHARS-5, gGpsLastValidData.pos.altitude - gHomePos.altitude);
    134e:	20 91 a6 01 	lds	r18, 0x01A6
    1352:	30 91 a7 01 	lds	r19, 0x01A7
    1356:	80 91 9c 01 	lds	r24, 0x019C
    135a:	90 91 9d 01 	lds	r25, 0x019D
    135e:	28 1b       	sub	r18, r24
    1360:	39 0b       	sbc	r19, r25
    1362:	44 27       	eor	r20, r20
    1364:	37 fd       	sbrc	r19, 7
    1366:	40 95       	com	r20
    1368:	54 2f       	mov	r21, r20
    136a:	8d e3       	ldi	r24, 0x3D	; 61
    136c:	92 e0       	ldi	r25, 0x02	; 2
    136e:	6c e1       	ldi	r22, 0x1C	; 28
    1370:	3f d7       	rcall	.+3710   	; 0x21f0 <__data_load_end+0x37a>
    1372:	74 cd       	rjmp	.-1304   	; 0xe5c <main+0x352>
#else //GPS_ENABLED
  if (gGpsLastData.fix != 0) {
		PORTD |= LED;
	}
	else {
		PORTD ^= LED;
    1374:	8b b1       	in	r24, 0x0b	; 11
    1376:	98 e0       	ldi	r25, 0x08	; 8
    1378:	89 27       	eor	r24, r25
    137a:	8b b9       	out	0x0b, r24	; 11
	
#ifdef DEBUG
  //testCalcHome();
#endif // DEBUG
  
	if (gHomePosSet) {
    137c:	80 91 b7 01 	lds	r24, 0x01B7
    1380:	88 23       	and	r24, r24
    1382:	09 f4       	brne	.+2      	; 0x1386 <main+0x87c>
    1384:	57 cc       	rjmp	.-1874   	; 0xc34 <main+0x12a>
	  calcHome(gGpsLastValidData.pos.latitude,
    1386:	c0 90 9e 01 	lds	r12, 0x019E
    138a:	d0 90 9f 01 	lds	r13, 0x019F
    138e:	e0 90 a0 01 	lds	r14, 0x01A0
    1392:	f0 90 a1 01 	lds	r15, 0x01A1
    1396:	40 90 a2 01 	lds	r4, 0x01A2
    139a:	50 90 a3 01 	lds	r5, 0x01A3
    139e:	60 90 a4 01 	lds	r6, 0x01A4
    13a2:	70 90 a5 01 	lds	r7, 0x01A5
    13a6:	80 90 94 01 	lds	r8, 0x0194
    13aa:	90 90 95 01 	lds	r9, 0x0195
    13ae:	a0 90 96 01 	lds	r10, 0x0196
    13b2:	b0 90 97 01 	lds	r11, 0x0197
    13b6:	40 91 98 01 	lds	r20, 0x0198
    13ba:	50 91 99 01 	lds	r21, 0x0199
    13be:	60 91 9a 01 	lds	r22, 0x019A
    13c2:	70 91 9b 01 	lds	r23, 0x019B
    13c6:	49 83       	std	Y+1, r20	; 0x01
    13c8:	5a 83       	std	Y+2, r21	; 0x02
    13ca:	6b 83       	std	Y+3, r22	; 0x03
    13cc:	7c 83       	std	Y+4, r23	; 0x04

  // considers flat earth around vehicle and reference

  // Ernani Reis, Aug 2011
  
  if (currLat == homeLat && currLong == homeLong) {
    13ce:	c8 14       	cp	r12, r8
    13d0:	d9 04       	cpc	r13, r9
    13d2:	ea 04       	cpc	r14, r10
    13d4:	fb 04       	cpc	r15, r11
    13d6:	09 f4       	brne	.+2      	; 0x13da <main+0x8d0>
    13d8:	4f c2       	rjmp	.+1182   	; 0x1878 <main+0xd6e>
  int32_t deltaLat; 
  int32_t deltaLong;
  uint32_t distance;
  uint16_t bearing;
      
  c = myCos(absi32(homeLat + currLat) / 2000000); // c ~ cos(lat) -> long to fix the delta
    13da:	d7 01       	movw	r26, r14
    13dc:	c6 01       	movw	r24, r12
    13de:	88 0d       	add	r24, r8
    13e0:	99 1d       	adc	r25, r9
    13e2:	aa 1d       	adc	r26, r10
    13e4:	bb 1d       	adc	r27, r11
#ifndef COMMONUTILS_H_
#define COMMONUTILS_H_

// abs seems to only support 16 bits so I had to make my own.
static uint32_t absi32(int32_t a) {
	return (a > 0) ? a : -a;
    13e6:	b7 ff       	sbrs	r27, 7
    13e8:	07 c0       	rjmp	.+14     	; 0x13f8 <main+0x8ee>
    13ea:	b0 95       	com	r27
    13ec:	a0 95       	com	r26
    13ee:	90 95       	com	r25
    13f0:	81 95       	neg	r24
    13f2:	9f 4f       	sbci	r25, 0xFF	; 255
    13f4:	af 4f       	sbci	r26, 0xFF	; 255
    13f6:	bf 4f       	sbci	r27, 0xFF	; 255
    13f8:	bc 01       	movw	r22, r24
    13fa:	cd 01       	movw	r24, r26
    13fc:	20 e8       	ldi	r18, 0x80	; 128
    13fe:	34 e8       	ldi	r19, 0x84	; 132
    1400:	4e e1       	ldi	r20, 0x1E	; 30
    1402:	50 e0       	ldi	r21, 0x00	; 0
    1404:	5b d4       	rcall	.+2230   	; 0x1cbc <__udivmodsi4>
}

static int8_t myCos(uint16_t angle) {
	return mySin(angle + 90);
    1406:	c9 01       	movw	r24, r18
    1408:	86 5a       	subi	r24, 0xA6	; 166
    140a:	9f 4f       	sbci	r25, 0xFF	; 255
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    140c:	68 e6       	ldi	r22, 0x68	; 104
    140e:	71 e0       	ldi	r23, 0x01	; 1
    1410:	2e d4       	rcall	.+2140   	; 0x1c6e <__udivmodhi4>
	int8_t mult = 1;
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    1412:	84 3b       	cpi	r24, 0xB4	; 180
    1414:	91 05       	cpc	r25, r1
    1416:	08 f4       	brcc	.+2      	; 0x141a <main+0x910>
    1418:	f9 c1       	rjmp	.+1010   	; 0x180c <main+0xd02>
		pos = pos - 180;
    141a:	84 5b       	subi	r24, 0xB4	; 180
    141c:	90 40       	sbci	r25, 0x00	; 0
    141e:	5f ef       	ldi	r21, 0xFF	; 255
    1420:	5d 83       	std	Y+5, r21	; 0x05
		mult = -1;
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
    1422:	8a 35       	cpi	r24, 0x5A	; 90
    1424:	91 05       	cpc	r25, r1
    1426:	30 f0       	brcs	.+12     	; 0x1434 <main+0x92a>
		pos = 180 - pos;
    1428:	24 eb       	ldi	r18, 0xB4	; 180
    142a:	30 e0       	ldi	r19, 0x00	; 0
    142c:	a9 01       	movw	r20, r18
    142e:	48 1b       	sub	r20, r24
    1430:	59 0b       	sbc	r21, r25
    1432:	ca 01       	movw	r24, r20
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
    1434:	8c 5c       	subi	r24, 0xCC	; 204
    1436:	9f 4f       	sbci	r25, 0xFF	; 255
    1438:	fc 01       	movw	r30, r24
    143a:	44 91       	lpm	r20, Z

  int32_t currLatSec100 = wgs84ToSec100(currLat); // Convert wgs84 to sec * 100
    143c:	c7 01       	movw	r24, r14
    143e:	b6 01       	movw	r22, r12
    1440:	4e 8b       	std	Y+22, r20	; 0x16
    1442:	42 d6       	rcall	.+3204   	; 0x20c8 <__data_load_end+0x252>
    1444:	8b 01       	movw	r16, r22
    1446:	9c 01       	movw	r18, r24
  int32_t homeLatSec100 = wgs84ToSec100(homeLat);
    1448:	c5 01       	movw	r24, r10
    144a:	b4 01       	movw	r22, r8
    144c:	2b 8b       	std	Y+19, r18	; 0x13
    144e:	3c 8b       	std	Y+20, r19	; 0x14
    1450:	3b d6       	rcall	.+3190   	; 0x20c8 <__data_load_end+0x252>
    1452:	4b 01       	movw	r8, r22
    1454:	5c 01       	movw	r10, r24
  int32_t currLongSec100 = wgs84ToSec100(currLong);
    1456:	c3 01       	movw	r24, r6
    1458:	b2 01       	movw	r22, r4
    145a:	36 d6       	rcall	.+3180   	; 0x20c8 <__data_load_end+0x252>
    145c:	6b 01       	movw	r12, r22
    145e:	7c 01       	movw	r14, r24
  int32_t homeLongSec100 = wgs84ToSec100(homeLong);
    1460:	69 81       	ldd	r22, Y+1	; 0x01
    1462:	7a 81       	ldd	r23, Y+2	; 0x02
    1464:	8b 81       	ldd	r24, Y+3	; 0x03
    1466:	9c 81       	ldd	r25, Y+4	; 0x04
    1468:	2f d6       	rcall	.+3166   	; 0x20c8 <__data_load_end+0x252>

  deltaLong = homeLongSec100 - currLongSec100; // Calculate deltas
    146a:	6c 19       	sub	r22, r12
    146c:	7d 09       	sbc	r23, r13
    146e:	8e 09       	sbc	r24, r14
    1470:	9f 09       	sbc	r25, r15
  deltaLat = homeLatSec100 - currLatSec100; // delta long ainda com erro (Delta still long with error?)
    1472:	2b 89       	ldd	r18, Y+19	; 0x13
    1474:	3c 89       	ldd	r19, Y+20	; 0x14
    1476:	24 01       	movw	r4, r8
    1478:	35 01       	movw	r6, r10
    147a:	40 1a       	sub	r4, r16
    147c:	51 0a       	sbc	r5, r17
    147e:	62 0a       	sbc	r6, r18
    1480:	73 0a       	sbc	r7, r19
    1482:	4e 89       	ldd	r20, Y+22	; 0x16
    1484:	cd 80       	ldd	r12, Y+5	; 0x05
    1486:	4c 9d       	mul	r20, r12
    1488:	20 2d       	mov	r18, r0
    148a:	11 24       	eor	r1, r1

  deltaLong = deltaLong * c;   // corrige dla p/ lat da regio
    148c:	33 27       	eor	r19, r19
    148e:	27 fd       	sbrc	r18, 7
    1490:	30 95       	com	r19
    1492:	43 2f       	mov	r20, r19
    1494:	53 2f       	mov	r21, r19
    1496:	cc d3       	rcall	.+1944   	; 0x1c30 <__mulsi3>
  deltaLong = deltaLong / 100; // cosine is 0-100 so divide with 100
    1498:	24 e6       	ldi	r18, 0x64	; 100
    149a:	30 e0       	ldi	r19, 0x00	; 0
    149c:	40 e0       	ldi	r20, 0x00	; 0
    149e:	50 e0       	ldi	r21, 0x00	; 0
    14a0:	2f d4       	rcall	.+2142   	; 0x1d00 <__divmodsi4>
    14a2:	49 01       	movw	r8, r18
    14a4:	5a 01       	movw	r10, r20

  // Make sure we don't go over uin32_t when doing sqr of deltaLong & deltaLat
  uint8_t mult = 1;
  while ((absi32(deltaLong) >= 0xFFFF) 
         || (absi32(deltaLat) >= 0xFFFF)) {
	  deltaLong /= 2;
    14a6:	a2 e0       	ldi	r26, 0x02	; 2
    14a8:	ca 2e       	mov	r12, r26
    14aa:	d1 2c       	mov	r13, r1
    14ac:	e1 2c       	mov	r14, r1
    14ae:	f1 2c       	mov	r15, r1
    14b0:	01 e0       	ldi	r16, 0x01	; 1
    14b2:	24 c0       	rjmp	.+72     	; 0x14fc <main+0x9f2>
  deltaLong = deltaLong * c;   // corrige dla p/ lat da regio
  deltaLong = deltaLong / 100; // cosine is 0-100 so divide with 100

  // Make sure we don't go over uin32_t when doing sqr of deltaLong & deltaLat
  uint8_t mult = 1;
  while ((absi32(deltaLong) >= 0xFFFF) 
    14b4:	4f 3f       	cpi	r20, 0xFF	; 255
    14b6:	3f ef       	ldi	r19, 0xFF	; 255
    14b8:	53 07       	cpc	r21, r19
    14ba:	30 e0       	ldi	r19, 0x00	; 0
    14bc:	63 07       	cpc	r22, r19
    14be:	30 e0       	ldi	r19, 0x00	; 0
    14c0:	73 07       	cpc	r23, r19
    14c2:	68 f4       	brcc	.+26     	; 0x14de <main+0x9d4>
    14c4:	d3 01       	movw	r26, r6
    14c6:	c2 01       	movw	r24, r4
    14c8:	77 fc       	sbrc	r7, 7
    14ca:	3d c0       	rjmp	.+122    	; 0x1546 <main+0xa3c>
         || (absi32(deltaLat) >= 0xFFFF)) {
    14cc:	8f 3f       	cpi	r24, 0xFF	; 255
    14ce:	ef ef       	ldi	r30, 0xFF	; 255
    14d0:	9e 07       	cpc	r25, r30
    14d2:	e0 e0       	ldi	r30, 0x00	; 0
    14d4:	ae 07       	cpc	r26, r30
    14d6:	e0 e0       	ldi	r30, 0x00	; 0
    14d8:	be 07       	cpc	r27, r30
    14da:	08 f4       	brcc	.+2      	; 0x14de <main+0x9d4>
    14dc:	b9 c0       	rjmp	.+370    	; 0x1650 <main+0xb46>
	  deltaLong /= 2;
    14de:	c5 01       	movw	r24, r10
    14e0:	b4 01       	movw	r22, r8
    14e2:	a7 01       	movw	r20, r14
    14e4:	96 01       	movw	r18, r12
    14e6:	0c d4       	rcall	.+2072   	; 0x1d00 <__divmodsi4>
    14e8:	49 01       	movw	r8, r18
    14ea:	5a 01       	movw	r10, r20
	  deltaLat /= 2;
    14ec:	c3 01       	movw	r24, r6
    14ee:	b2 01       	movw	r22, r4
    14f0:	a7 01       	movw	r20, r14
    14f2:	96 01       	movw	r18, r12
    14f4:	05 d4       	rcall	.+2058   	; 0x1d00 <__divmodsi4>
    14f6:	29 01       	movw	r4, r18
    14f8:	3a 01       	movw	r6, r20
	  mult *= 2;
    14fa:	00 0f       	add	r16, r16
    14fc:	b5 01       	movw	r22, r10
    14fe:	a4 01       	movw	r20, r8
    1500:	b7 fe       	sbrs	r11, 7
    1502:	d8 cf       	rjmp	.-80     	; 0x14b4 <main+0x9aa>
    1504:	44 27       	eor	r20, r20
    1506:	55 27       	eor	r21, r21
    1508:	ba 01       	movw	r22, r20
    150a:	48 19       	sub	r20, r8
    150c:	59 09       	sbc	r21, r9
    150e:	6a 09       	sbc	r22, r10
    1510:	7b 09       	sbc	r23, r11
    1512:	d0 cf       	rjmp	.-96     	; 0x14b4 <main+0x9aa>
	  }		  
		if (gGpsLastValidData.fix) {
		  pos = printNumber(gText[textId], TEXT_LINE_MAX_CHARS-10, gGpsLastValidData.sats);
		}
		else {			
		  pos = printText(gText[textId], TEXT_LINE_MAX_CHARS-10, "-");
    1514:	8d e3       	ldi	r24, 0x3D	; 61
    1516:	92 e0       	ldi	r25, 0x02	; 2
    1518:	67 e1       	ldi	r22, 0x17	; 23
    151a:	4f e3       	ldi	r20, 0x3F	; 63
    151c:	51 e0       	ldi	r21, 0x01	; 1
    151e:	03 d7       	rcall	.+3590   	; 0x2326 <__data_load_end+0x4b0>
    1520:	16 cf       	rjmp	.-468    	; 0x134e <main+0x844>
}

static void drawArrow(uint16_t angle) {
	drawCircle(GRAPHICS_MID, GRAPHICS_MID, GRAPHICS_MID);
	if (gHomeDistance < 10) {
	  drawCircle(GRAPHICS_MID, GRAPHICS_MID, 2);
    1522:	82 e0       	ldi	r24, 0x02	; 2
    1524:	77 da       	rcall	.-2834   	; 0xa14 <drawCircle.constprop.9>
    1526:	40 cb       	rjmp	.-2432   	; 0xba8 <main+0x9e>
		
		if (gHomePosSet) {
		  pos = printText(gText[textId], pos+3, "\146");
		}
		else {
			pos = printText(gText[textId], pos+3, "\147");
    1528:	8e e5       	ldi	r24, 0x5E	; 94
    152a:	92 e0       	ldi	r25, 0x02	; 2
    152c:	4b e4       	ldi	r20, 0x4B	; 75
    152e:	51 e0       	ldi	r21, 0x01	; 1
    1530:	fa d6       	rcall	.+3572   	; 0x2326 <__data_load_end+0x4b0>
    1532:	88 cc       	rjmp	.-1776   	; 0xe44 <main+0x33a>
static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
	int8_t mult = 1;
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    1534:	31 e0       	ldi	r19, 0x01	; 1
    1536:	e4 cd       	rjmp	.-1080   	; 0x1100 <main+0x5f6>
    1538:	41 e0       	ldi	r20, 0x01	; 1
    153a:	c7 cd       	rjmp	.-1138   	; 0x10ca <main+0x5c0>
  }    
}

static uint8_t calcGenericLevel(uint8_t adcInput, uint16_t minLevel, uint16_t maxLevel) {
	uint16_t level = ((gAnalogInputs[adcInput].high * 100) + gAnalogInputs[adcInput].low);
	if (level > maxLevel) {
    153c:	24 e6       	ldi	r18, 0x64	; 100
    153e:	30 e0       	ldi	r19, 0x00	; 0
    1540:	40 e0       	ldi	r20, 0x00	; 0
    1542:	50 e0       	ldi	r21, 0x00	; 0
    1544:	c9 ce       	rjmp	.-622    	; 0x12d8 <main+0x7ce>
    1546:	88 27       	eor	r24, r24
    1548:	99 27       	eor	r25, r25
    154a:	dc 01       	movw	r26, r24
    154c:	84 19       	sub	r24, r4
    154e:	95 09       	sbc	r25, r5
    1550:	a6 09       	sbc	r26, r6
    1552:	b7 09       	sbc	r27, r7
    1554:	bb cf       	rjmp	.-138    	; 0x14cc <main+0x9c2>
#ifdef GPS_ENABLED
    if (!gAlarmSpeed || gBlink1Hz) {
	    pos = printNumber(gText[textId], 0, gGpsLastValidData.speed);
	  }		
    if (!gHomePosSet) {
		  pos = printText(gText[textId], 5, "-");
    1556:	8d e3       	ldi	r24, 0x3D	; 61
    1558:	92 e0       	ldi	r25, 0x02	; 2
    155a:	65 e0       	ldi	r22, 0x05	; 5
    155c:	4f e3       	ldi	r20, 0x3F	; 63
    155e:	51 e0       	ldi	r21, 0x01	; 1
    1560:	e2 d6       	rcall	.+3524   	; 0x2326 <__data_load_end+0x4b0>
    1562:	e7 ce       	rjmp	.-562    	; 0x1332 <main+0x828>
#endif //STATISTICS_ENABLED
	}		  
}

static void decodeGpsData(char data) {
	if (gGpsTextPartStep == GPS_PART_FINISHED && data != '$') {
    1564:	04 32       	cpi	r16, 0x24	; 36
    1566:	09 f0       	breq	.+2      	; 0x156a <main+0xa60>
    1568:	23 cb       	rjmp	.-2490   	; 0xbb0 <main+0xa6>
		return;
	}
	
	switch (data) {
	case '$':
		gGpsTextPos = 0;
    156a:	10 92 d3 03 	sts	0x03D3, r1
		gGpsTextType = GPS_TYPE_NONE;
    156e:	10 92 d4 03 	sts	0x03D4, r1
		gGpsChecksum = 0;
    1572:	10 92 d5 03 	sts	0x03D5, r1
		gGpsTextPartStep = 0;
    1576:	10 92 60 01 	sts	0x0160, r1
    157a:	e6 ed       	ldi	r30, 0xD6	; 214
    157c:	f3 e0       	ldi	r31, 0x03	; 3
  UCSR0B = (1<<RXEN0); // Enable RX
}

static void clearGpsText() {
	for (uint8_t i = 0; i < GPS_MAX_CHARS; ++i) {
		gGpsText[i] = 0;
    157e:	11 92       	st	Z+, r1
  UCSR0C = (3<<UCSZ00); // 8N1
  UCSR0B = (1<<RXEN0); // Enable RX
}

static void clearGpsText() {
	for (uint8_t i = 0; i < GPS_MAX_CHARS; ++i) {
    1580:	23 e0       	ldi	r18, 0x03	; 3
    1582:	e1 3e       	cpi	r30, 0xE1	; 225
    1584:	f2 07       	cpc	r31, r18
    1586:	d9 f7       	brne	.-10     	; 0x157e <main+0xa74>
    1588:	13 cb       	rjmp	.-2522   	; 0xbb0 <main+0xa6>
static void decodeGpsData(char data) {
	if (gGpsTextPartStep == GPS_PART_FINISHED && data != '$') {
		return;
	}
	
	switch (data) {
    158a:	0a 32       	cpi	r16, 0x2A	; 42
    158c:	41 f0       	breq	.+16     	; 0x159e <main+0xa94>
    158e:	0c 32       	cpi	r16, 0x2C	; 44
    1590:	09 f0       	breq	.+2      	; 0x1594 <main+0xa8a>
    1592:	fb cc       	rjmp	.-1546   	; 0xf8a <main+0x480>
		clearFullGpsText();
		gGpsFullTextPos = 0;
#endif // FULLGPSTEXT
		break;
	case ',':
		gGpsChecksum ^= data;
    1594:	80 91 d5 03 	lds	r24, 0x03D5
    1598:	80 27       	eor	r24, r16
    159a:	80 93 d5 03 	sts	0x03D5, r24
	case '*':
		parseGpsPart();
    159e:	43 d8       	rcall	.-3962   	; 0x626 <parseGpsPart>
    15a0:	e6 ed       	ldi	r30, 0xD6	; 214
    15a2:	f3 e0       	ldi	r31, 0x03	; 3
  UCSR0B = (1<<RXEN0); // Enable RX
}

static void clearGpsText() {
	for (uint8_t i = 0; i < GPS_MAX_CHARS; ++i) {
		gGpsText[i] = 0;
    15a4:	11 92       	st	Z+, r1
  UCSR0C = (3<<UCSZ00); // 8N1
  UCSR0B = (1<<RXEN0); // Enable RX
}

static void clearGpsText() {
	for (uint8_t i = 0; i < GPS_MAX_CHARS; ++i) {
    15a6:	33 e0       	ldi	r19, 0x03	; 3
    15a8:	e1 3e       	cpi	r30, 0xE1	; 225
    15aa:	f3 07       	cpc	r31, r19
    15ac:	d9 f7       	brne	.-10     	; 0x15a4 <main+0xa9a>
	case ',':
		gGpsChecksum ^= data;
	case '*':
		parseGpsPart();
		clearGpsText();		
		gGpsTextPos = 0;
    15ae:	10 92 d3 03 	sts	0x03D3, r1
		gGpsTextPartStep++;
    15b2:	80 91 60 01 	lds	r24, 0x0160
    15b6:	8f 5f       	subi	r24, 0xFF	; 255
    15b8:	80 93 60 01 	sts	0x0160, r24
		if (data =='*') {
    15bc:	0a 32       	cpi	r16, 0x2A	; 42
    15be:	09 f0       	breq	.+2      	; 0x15c2 <main+0xab8>
    15c0:	f7 ca       	rjmp	.-2578   	; 0xbb0 <main+0xa6>
			gGpsTextPartStep = GPS_PART_CHECKSUM;
    15c2:	88 ec       	ldi	r24, 0xC8	; 200
    15c4:	80 93 60 01 	sts	0x0160, r24
    15c8:	f3 ca       	rjmp	.-2586   	; 0xbb0 <main+0xa6>
		}			
		break;
	case '\r':
	case '\n':
	  parseGpsPart();
    15ca:	2d d8       	rcall	.-4006   	; 0x626 <parseGpsPart>
	  gGpsTextPartStep = GPS_PART_FINISHED;
    15cc:	8f ef       	ldi	r24, 0xFF	; 255
    15ce:	80 93 60 01 	sts	0x0160, r24
	}	  
}
#endif //STATISTICS_ENABLED

static void finishGpsDecoding() {
	if (gGpsLastData.checksumValid != 0) {
    15d2:	80 91 93 01 	lds	r24, 0x0193
    15d6:	88 23       	and	r24, r24
    15d8:	09 f4       	brne	.+2      	; 0x15dc <main+0xad2>
    15da:	ea ca       	rjmp	.-2604   	; 0xbb0 <main+0xa6>
#ifdef STATISTICS_ENABLED
		updateDistanceTraveled();
#endif //STATISTICS_ENABLED    
		gGpsLastValidData = gGpsLastData;
    15dc:	ae e9       	ldi	r26, 0x9E	; 158
    15de:	b1 e0       	ldi	r27, 0x01	; 1
    15e0:	eb e7       	ldi	r30, 0x7B	; 123
    15e2:	f1 e0       	ldi	r31, 0x01	; 1
    15e4:	89 e1       	ldi	r24, 0x19	; 25
    15e6:	01 90       	ld	r0, Z+
    15e8:	0d 92       	st	X+, r0
    15ea:	81 50       	subi	r24, 0x01	; 1
    15ec:	e1 f7       	brne	.-8      	; 0x15e6 <main+0xadc>
		gGpsValidData = 1;
    15ee:	81 e0       	ldi	r24, 0x01	; 1
    15f0:	80 93 e1 03 	sts	0x03E1, r24
		gLastFix = gTime;
    15f4:	80 91 76 01 	lds	r24, 0x0176
    15f8:	90 91 77 01 	lds	r25, 0x0177
    15fc:	90 93 e3 03 	sts	0x03E3, r25
    1600:	80 93 e2 03 	sts	0x03E2, r24
		gInfoShow = gGpsLastValidData.speed < INFO_MIN_SPEED_SHOW;
    1604:	80 91 ae 01 	lds	r24, 0x01AE
    1608:	90 91 af 01 	lds	r25, 0x01AF
    160c:	21 e0       	ldi	r18, 0x01	; 1
    160e:	83 30       	cpi	r24, 0x03	; 3
    1610:	91 05       	cpc	r25, r1
    1612:	08 f0       	brcs	.+2      	; 0x1616 <main+0xb0c>
    1614:	20 e0       	ldi	r18, 0x00	; 0
    1616:	20 93 61 01 	sts	0x0161, r18

		if (gHomePosSet == 0) {
    161a:	20 91 b7 01 	lds	r18, 0x01B7
    161e:	22 23       	and	r18, r18
    1620:	09 f0       	breq	.+2      	; 0x1624 <main+0xb1a>
    1622:	c6 ca       	rjmp	.-2676   	; 0xbb0 <main+0xa6>
			if (gGpsLastValidData.fix != 0) {
    1624:	20 91 ac 01 	lds	r18, 0x01AC
    1628:	22 23       	and	r18, r18
    162a:	09 f4       	brne	.+2      	; 0x162e <main+0xb24>
    162c:	c1 ca       	rjmp	.-2686   	; 0xbb0 <main+0xa6>
		    else {
			    ++gHomeFixCount;
		    }
#endif //HOME_FIRST_FIX
#ifdef HOME_AUTO_SET
        if (gGpsLastValidData.speed >= HOME_FIX_MIN_SPEED) {
    162e:	8a 30       	cpi	r24, 0x0A	; 10
    1630:	91 05       	cpc	r25, r1
    1632:	08 f4       	brcc	.+2      	; 0x1636 <main+0xb2c>
    1634:	bd ca       	rjmp	.-2694   	; 0xbb0 <main+0xa6>

static void setHomePos() {
#ifdef STATISTICS_ENABLED	
	resetStatistics();
#endif //STATISTICS_ENABLED
	gHomePos = gGpsLastValidData.pos;
    1636:	a4 e9       	ldi	r26, 0x94	; 148
    1638:	b1 e0       	ldi	r27, 0x01	; 1
    163a:	ee e9       	ldi	r30, 0x9E	; 158
    163c:	f1 e0       	ldi	r31, 0x01	; 1
    163e:	8a e0       	ldi	r24, 0x0A	; 10
    1640:	01 90       	ld	r0, Z+
    1642:	0d 92       	st	X+, r0
    1644:	81 50       	subi	r24, 0x01	; 1
    1646:	e1 f7       	brne	.-8      	; 0x1640 <main+0xb36>
	gHomePosSet = 1;
    1648:	81 e0       	ldi	r24, 0x01	; 1
    164a:	80 93 b7 01 	sts	0x01B7, r24
    164e:	b0 ca       	rjmp	.-2720   	; 0xbb0 <main+0xa6>
    1650:	0d 8b       	std	Y+21, r16	; 0x15
    1652:	4b 87       	std	Y+11, r20	; 0x0b
    1654:	5c 87       	std	Y+12, r21	; 0x0c
    1656:	6d 87       	std	Y+13, r22	; 0x0d
    1658:	7e 87       	std	Y+14, r23	; 0x0e
    165a:	8f 87       	std	Y+15, r24	; 0x0f
    165c:	98 8b       	std	Y+16, r25	; 0x10
    165e:	a9 8b       	std	Y+17, r26	; 0x11
    1660:	ba 8b       	std	Y+18, r27	; 0x12
  }
  
  uint32_t a = (deltaLong * deltaLong);
    1662:	c5 01       	movw	r24, r10
    1664:	b4 01       	movw	r22, r8
    1666:	a5 01       	movw	r20, r10
    1668:	94 01       	movw	r18, r8
    166a:	e2 d2       	rcall	.+1476   	; 0x1c30 <__mulsi3>
    166c:	6b 01       	movw	r12, r22
    166e:	7c 01       	movw	r14, r24
  uint32_t b = (deltaLat * deltaLat);
    1670:	c3 01       	movw	r24, r6
    1672:	b2 01       	movw	r22, r4
    1674:	a3 01       	movw	r20, r6
    1676:	92 01       	movw	r18, r4
    1678:	db d2       	rcall	.+1462   	; 0x1c30 <__mulsi3>
    167a:	8b 01       	movw	r16, r22
    167c:	9c 01       	movw	r18, r24

  // Make sure that the squared deltas don't go over uin32_t when adding them together.
  // This should only activate at long distances!
  uint8_t mult2 = 1;
  while ((a >> 24) + (b >> 24) > 0xFF) {
    167e:	89 2f       	mov	r24, r25
    1680:	99 27       	eor	r25, r25
    1682:	aa 27       	eor	r26, r26
    1684:	bb 27       	eor	r27, r27
    1686:	4f 2d       	mov	r20, r15
    1688:	55 27       	eor	r21, r21
    168a:	66 27       	eor	r22, r22
    168c:	77 27       	eor	r23, r23
    168e:	84 0f       	add	r24, r20
    1690:	95 1f       	adc	r25, r21
    1692:	a6 1f       	adc	r26, r22
    1694:	b7 1f       	adc	r27, r23
    1696:	8f 3f       	cpi	r24, 0xFF	; 255
    1698:	91 05       	cpc	r25, r1
    169a:	a1 05       	cpc	r26, r1
    169c:	b1 05       	cpc	r27, r1
    169e:	09 f0       	breq	.+2      	; 0x16a2 <main+0xb98>
    16a0:	08 f4       	brcc	.+2      	; 0x16a4 <main+0xb9a>
    16a2:	53 c1       	rjmp	.+678    	; 0x194a <main+0xe40>
    a /= 4;
    16a4:	f6 94       	lsr	r15
    16a6:	e7 94       	ror	r14
    16a8:	d7 94       	ror	r13
    16aa:	c7 94       	ror	r12
    16ac:	f6 94       	lsr	r15
    16ae:	e7 94       	ror	r14
    16b0:	d7 94       	ror	r13
    16b2:	c7 94       	ror	r12
    b /= 4;
    16b4:	36 95       	lsr	r19
    16b6:	27 95       	ror	r18
    16b8:	17 95       	ror	r17
    16ba:	07 95       	ror	r16
    16bc:	36 95       	lsr	r19
    16be:	27 95       	ror	r18
    16c0:	17 95       	ror	r17
    16c2:	07 95       	ror	r16
    16c4:	42 e0       	ldi	r20, 0x02	; 2
    16c6:	50 e0       	ldi	r21, 0x00	; 0
    16c8:	60 e0       	ldi	r22, 0x00	; 0
    16ca:	70 e0       	ldi	r23, 0x00	; 0
    16cc:	4d 83       	std	Y+5, r20	; 0x05
    16ce:	5e 83       	std	Y+6, r21	; 0x06
    16d0:	6f 83       	std	Y+7, r22	; 0x07
    16d2:	78 87       	std	Y+8, r23	; 0x08
    mult2 *= 2;
  }
  
  distance = calcSqrt(a + b);
    16d4:	d7 01       	movw	r26, r14
    16d6:	c6 01       	movw	r24, r12
    16d8:	80 0f       	add	r24, r16
    16da:	91 1f       	adc	r25, r17
    16dc:	a2 1f       	adc	r26, r18
    16de:	b3 1f       	adc	r27, r19
    16e0:	89 83       	std	Y+1, r24	; 0x01
    16e2:	9a 83       	std	Y+2, r25	; 0x02
    16e4:	ab 83       	std	Y+3, r26	; 0x03
    16e6:	bc 83       	std	Y+4, r27	; 0x04
}

static uint32_t calcSqrt(uint32_t input)
{
  int32_t nv;
  int32_t v = input>>1;
    16e8:	6c 01       	movw	r12, r24
    16ea:	7d 01       	movw	r14, r26
    16ec:	f6 94       	lsr	r15
    16ee:	e7 94       	ror	r14
    16f0:	d7 94       	ror	r13
    16f2:	c7 94       	ror	r12
  int32_t c = 0;
  if (!v) {
    16f4:	c1 14       	cp	r12, r1
    16f6:	d1 04       	cpc	r13, r1
    16f8:	e1 04       	cpc	r14, r1
    16fa:	f1 04       	cpc	r15, r1
    16fc:	61 f1       	breq	.+88     	; 0x1756 <main+0xc4c>
    16fe:	1a 86       	std	Y+10, r1	; 0x0a
    1700:	19 86       	std	Y+9, r1	; 0x09
    1702:	0a c0       	rjmp	.+20     	; 0x1718 <main+0xc0e>
    return input;
  }	
  do {
    nv = (v + input / v)>>1;
    if (absu32(v - nv) <= 1) {
    1704:	a9 85       	ldd	r26, Y+9	; 0x09
    1706:	ba 85       	ldd	r27, Y+10	; 0x0a
    1708:	11 96       	adiw	r26, 0x01	; 1
    170a:	ba 87       	std	Y+10, r27	; 0x0a
    170c:	a9 87       	std	Y+9, r26	; 0x09
      return nv;
	  }	  
    v = nv;
  } while (c++ < 25);
    170e:	aa 31       	cpi	r26, 0x1A	; 26
    1710:	b1 05       	cpc	r27, r1
    1712:	e9 f0       	breq	.+58     	; 0x174e <main+0xc44>
  do {
    nv = (v + input / v)>>1;
    if (absu32(v - nv) <= 1) {
      return nv;
	  }	  
    v = nv;
    1714:	68 01       	movw	r12, r16
    1716:	79 01       	movw	r14, r18
  int32_t c = 0;
  if (!v) {
    return input;
  }	
  do {
    nv = (v + input / v)>>1;
    1718:	69 81       	ldd	r22, Y+1	; 0x01
    171a:	7a 81       	ldd	r23, Y+2	; 0x02
    171c:	8b 81       	ldd	r24, Y+3	; 0x03
    171e:	9c 81       	ldd	r25, Y+4	; 0x04
    1720:	a7 01       	movw	r20, r14
    1722:	96 01       	movw	r18, r12
    1724:	cb d2       	rcall	.+1430   	; 0x1cbc <__udivmodsi4>
    1726:	89 01       	movw	r16, r18
    1728:	9a 01       	movw	r18, r20
    172a:	0c 0d       	add	r16, r12
    172c:	1d 1d       	adc	r17, r13
    172e:	2e 1d       	adc	r18, r14
    1730:	3f 1d       	adc	r19, r15
    1732:	36 95       	lsr	r19
    1734:	27 95       	ror	r18
    1736:	17 95       	ror	r17
    1738:	07 95       	ror	r16
    if (absu32(v - nv) <= 1) {
    173a:	c0 1a       	sub	r12, r16
    173c:	d1 0a       	sbc	r13, r17
    173e:	e2 0a       	sbc	r14, r18
    1740:	f3 0a       	sbc	r15, r19
    1742:	92 e0       	ldi	r25, 0x02	; 2
    1744:	c9 16       	cp	r12, r25
    1746:	d1 04       	cpc	r13, r1
    1748:	e1 04       	cpc	r14, r1
    174a:	f1 04       	cpc	r15, r1
    174c:	d8 f6       	brcc	.-74     	; 0x1704 <main+0xbfa>
      return nv;
    174e:	09 83       	std	Y+1, r16	; 0x01
    1750:	1a 83       	std	Y+2, r17	; 0x02
    1752:	2b 83       	std	Y+3, r18	; 0x03
    1754:	3c 83       	std	Y+4, r19	; 0x04
  distance *= mult2;
    1756:	69 81       	ldd	r22, Y+1	; 0x01
    1758:	7a 81       	ldd	r23, Y+2	; 0x02
    175a:	8b 81       	ldd	r24, Y+3	; 0x03
    175c:	9c 81       	ldd	r25, Y+4	; 0x04
    175e:	2d 81       	ldd	r18, Y+5	; 0x05
    1760:	3e 81       	ldd	r19, Y+6	; 0x06
    1762:	4f 81       	ldd	r20, Y+7	; 0x07
    1764:	58 85       	ldd	r21, Y+8	; 0x08
    1766:	64 d2       	rcall	.+1224   	; 0x1c30 <__mulsi3>
    1768:	6b 01       	movw	r12, r22
    176a:	7c 01       	movw	r14, r24

  // Only calculate bearing if bearing pointer is set.
  if (bearingResult != NULL) {
    bearing = 0;
    if (distance > 0) { // Over home -> do not compute; Home forced to 0
    176c:	61 15       	cp	r22, r1
    176e:	71 05       	cpc	r23, r1
    1770:	81 05       	cpc	r24, r1
    1772:	91 05       	cpc	r25, r1
    1774:	09 f4       	brne	.+2      	; 0x1778 <main+0xc6e>
    1776:	4d c0       	rjmp	.+154    	; 0x1812 <main+0xd08>
      if (absi32(deltaLong) >= absi32(deltaLat)) { // low angle, sine is better
    1778:	2f 85       	ldd	r18, Y+15	; 0x0f
    177a:	38 89       	ldd	r19, Y+16	; 0x10
    177c:	49 89       	ldd	r20, Y+17	; 0x11
    177e:	5a 89       	ldd	r21, Y+18	; 0x12
    1780:	6b 85       	ldd	r22, Y+11	; 0x0b
    1782:	7c 85       	ldd	r23, Y+12	; 0x0c
    1784:	8d 85       	ldd	r24, Y+13	; 0x0d
    1786:	9e 85       	ldd	r25, Y+14	; 0x0e
    1788:	62 17       	cp	r22, r18
    178a:	73 07       	cpc	r23, r19
    178c:	84 07       	cpc	r24, r20
    178e:	95 07       	cpc	r25, r21
    1790:	08 f4       	brcc	.+2      	; 0x1794 <main+0xc8a>
    1792:	94 c0       	rjmp	.+296    	; 0x18bc <main+0xdb2>
        c = (absi32(deltaLat) * 100) / distance; // computes sine -> dist > 0
    1794:	ca 01       	movw	r24, r20
    1796:	b9 01       	movw	r22, r18
    1798:	24 e6       	ldi	r18, 0x64	; 100
    179a:	30 e0       	ldi	r19, 0x00	; 0
    179c:	40 e0       	ldi	r20, 0x00	; 0
    179e:	50 e0       	ldi	r21, 0x00	; 0
    17a0:	47 d2       	rcall	.+1166   	; 0x1c30 <__mulsi3>
    17a2:	a7 01       	movw	r20, r14
    17a4:	96 01       	movw	r18, r12
    17a6:	8a d2       	rcall	.+1300   	; 0x1cbc <__udivmodsi4>
    17a8:	52 2f       	mov	r21, r18
  distance = calcSqrt(a + b);
  distance *= mult2;

  // Only calculate bearing if bearing pointer is set.
  if (bearingResult != NULL) {
    bearing = 0;
    17aa:	20 e0       	ldi	r18, 0x00	; 0
    17ac:	30 e0       	ldi	r19, 0x00	; 0
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
	int8_t mult = 1;
    17ae:	41 e0       	ldi	r20, 0x01	; 1
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    17b0:	80 e0       	ldi	r24, 0x00	; 0
    17b2:	90 e0       	ldi	r25, 0x00	; 0
    17b4:	08 e6       	ldi	r16, 0x68	; 104
    17b6:	11 e0       	ldi	r17, 0x01	; 1
    17b8:	59 83       	std	Y+1, r21	; 0x01
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
		pos = 180 - pos;
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
    17ba:	8c 5c       	subi	r24, 0xCC	; 204
    17bc:	9f 4f       	sbci	r25, 0xFF	; 255
    17be:	fc 01       	movw	r30, r24
    17c0:	84 91       	lpm	r24, Z
    17c2:	84 9f       	mul	r24, r20
    17c4:	40 2d       	mov	r20, r0
    17c6:	11 24       	eor	r1, r1
    if (distance > 0) { // Over home -> do not compute; Home forced to 0
      if (absi32(deltaLong) >= absi32(deltaLat)) { // low angle, sine is better
        c = (absi32(deltaLat) * 100) / distance; // computes sine -> dist > 0
        while((mySin(bearing) <= c) && (bearing < 90)) {
    17c8:	f9 81       	ldd	r31, Y+1	; 0x01
    17ca:	f4 17       	cp	r31, r20
    17cc:	0c f4       	brge	.+2      	; 0x17d0 <main+0xcc6>
    17ce:	6b c0       	rjmp	.+214    	; 0x18a6 <main+0xd9c>
    17d0:	2a 35       	cpi	r18, 0x5A	; 90
    17d2:	31 05       	cpc	r19, r1
    17d4:	09 f4       	brne	.+2      	; 0x17d8 <main+0xcce>
    17d6:	67 c0       	rjmp	.+206    	; 0x18a6 <main+0xd9c>
          ++bearing;
    17d8:	2f 5f       	subi	r18, 0xFF	; 255
    17da:	3f 4f       	sbci	r19, 0xFF	; 255
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    17dc:	c9 01       	movw	r24, r18
    17de:	b8 01       	movw	r22, r16
    17e0:	46 d2       	rcall	.+1164   	; 0x1c6e <__udivmodhi4>
	int8_t mult = 1;
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    17e2:	84 3b       	cpi	r24, 0xB4	; 180
    17e4:	91 05       	cpc	r25, r1
    17e6:	60 f0       	brcs	.+24     	; 0x1800 <main+0xcf6>
		pos = pos - 180;
    17e8:	84 5b       	subi	r24, 0xB4	; 180
    17ea:	90 40       	sbci	r25, 0x00	; 0
		mult = -1;
    17ec:	4f ef       	ldi	r20, 0xFF	; 255
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
    17ee:	8a 35       	cpi	r24, 0x5A	; 90
    17f0:	91 05       	cpc	r25, r1
    17f2:	18 f3       	brcs	.-58     	; 0x17ba <main+0xcb0>
		pos = 180 - pos;
    17f4:	a4 eb       	ldi	r26, 0xB4	; 180
    17f6:	b0 e0       	ldi	r27, 0x00	; 0
    17f8:	a8 1b       	sub	r26, r24
    17fa:	b9 0b       	sbc	r27, r25
    17fc:	cd 01       	movw	r24, r26
    17fe:	dd cf       	rjmp	.-70     	; 0x17ba <main+0xcb0>
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
	int8_t mult = 1;
    1800:	41 e0       	ldi	r20, 0x01	; 1
    1802:	f5 cf       	rjmp	.-22     	; 0x17ee <main+0xce4>
		level = 100;
	}		
	else if (level > minLevel) {
    1804:	20 e0       	ldi	r18, 0x00	; 0
    1806:	30 e0       	ldi	r19, 0x00	; 0
    1808:	a9 01       	movw	r20, r18
    180a:	66 cd       	rjmp	.-1332   	; 0x12d8 <main+0x7ce>
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    180c:	21 e0       	ldi	r18, 0x01	; 1
    180e:	2d 83       	std	Y+5, r18	; 0x05
    1810:	08 ce       	rjmp	.-1008   	; 0x1422 <main+0x918>
  distance = calcSqrt(a + b);
  distance *= mult2;

  // Only calculate bearing if bearing pointer is set.
  if (bearingResult != NULL) {
    bearing = 0;
    1812:	80 e0       	ldi	r24, 0x00	; 0
    1814:	90 e0       	ldi	r25, 0x00	; 0
	      else { // SW quadrant
          bearing = 270 - bearing;
        }
      }
    }
    *bearingResult = bearing;
    1816:	90 93 e9 03 	sts	0x03E9, r25
    181a:	80 93 e8 03 	sts	0x03E8, r24
	}
  distance = distance * 309; // ate aqui em segundo * 100
    181e:	c7 01       	movw	r24, r14
    1820:	b6 01       	movw	r22, r12
    1822:	25 e3       	ldi	r18, 0x35	; 53
    1824:	31 e0       	ldi	r19, 0x01	; 1
    1826:	40 e0       	ldi	r20, 0x00	; 0
    1828:	50 e0       	ldi	r21, 0x00	; 0
    182a:	02 d2       	rcall	.+1028   	; 0x1c30 <__mulsi3>
  distance = distance / 1000; // metros, agora
    182c:	28 ee       	ldi	r18, 0xE8	; 232
    182e:	33 e0       	ldi	r19, 0x03	; 3
    1830:	40 e0       	ldi	r20, 0x00	; 0
    1832:	50 e0       	ldi	r21, 0x00	; 0
    1834:	43 d2       	rcall	.+1158   	; 0x1cbc <__udivmodsi4>
    1836:	69 01       	movw	r12, r18
    1838:	7a 01       	movw	r14, r20
  distance *= mult;
    183a:	6d 89       	ldd	r22, Y+21	; 0x15
    183c:	26 2f       	mov	r18, r22
    183e:	30 e0       	ldi	r19, 0x00	; 0
    1840:	40 e0       	ldi	r20, 0x00	; 0
    1842:	50 e0       	ldi	r21, 0x00	; 0
    1844:	c7 01       	movw	r24, r14
    1846:	b6 01       	movw	r22, r12
    1848:	f3 d1       	rcall	.+998    	; 0x1c30 <__mulsi3>
    184a:	dc 01       	movw	r26, r24
    184c:	cb 01       	movw	r24, r22
#ifdef IMPERIAL_SYSTEM  
  distance *= 3281;
	distance /= 1000;
#endif //IMPERIAL_SYSTEM
  *distanceResult = distance;
    184e:	80 93 e4 03 	sts	0x03E4, r24
    1852:	90 93 e5 03 	sts	0x03E5, r25
    1856:	a0 93 e6 03 	sts	0x03E6, r26
    185a:	b0 93 e7 03 	sts	0x03E7, r27
    185e:	ea c9       	rjmp	.-3116   	; 0xc34 <main+0x12a>
	a = (a * (GRAPHICS_SIZE / 3)) / 100;
	b = (b * (GRAPHICS_SIZE / 3)) / 100;
	drawLine(GRAPHICS_MID - b, GRAPHICS_MID + a, GRAPHICS_MID + b, GRAPHICS_MID - a); //Direction line
	//drawLine(GRAPHICS_MID_X + a/2, GRAPHICS_MID_X + b/2, GRAPHICS_MID_X - a/2, GRAPHICS_MID_X - b/2); //Arrow bottom line
	drawLine(GRAPHICS_MID + b, GRAPHICS_MID - a, GRAPHICS_MID - a/2, GRAPHICS_MID - b/2); // Arrow "wings"
	drawLine(GRAPHICS_MID + b, GRAPHICS_MID - a, GRAPHICS_MID + a/2, GRAPHICS_MID + b/2);
    1860:	0f 5f       	subi	r16, 0xFF	; 255
    1862:	1f 4f       	sbci	r17, 0xFF	; 255
    1864:	a5 cc       	rjmp	.-1718   	; 0x11b0 <main+0x6a6>
    1866:	08 94       	sec
    1868:	81 1c       	adc	r8, r1
    186a:	91 1c       	adc	r9, r1
    186c:	9b cc       	rjmp	.-1738   	; 0x11a4 <main+0x69a>
	int16_t b = mySin(angle);
	a = (a * (GRAPHICS_SIZE / 3)) / 100;
	b = (b * (GRAPHICS_SIZE / 3)) / 100;
	drawLine(GRAPHICS_MID - b, GRAPHICS_MID + a, GRAPHICS_MID + b, GRAPHICS_MID - a); //Direction line
	//drawLine(GRAPHICS_MID_X + a/2, GRAPHICS_MID_X + b/2, GRAPHICS_MID_X - a/2, GRAPHICS_MID_X - b/2); //Arrow bottom line
	drawLine(GRAPHICS_MID + b, GRAPHICS_MID - a, GRAPHICS_MID - a/2, GRAPHICS_MID - b/2); // Arrow "wings"
    186e:	2f 5f       	subi	r18, 0xFF	; 255
    1870:	3f 4f       	sbci	r19, 0xFF	; 255
    1872:	8b cc       	rjmp	.-1770   	; 0x118a <main+0x680>
    1874:	01 96       	adiw	r24, 0x01	; 1
    1876:	7f cc       	rjmp	.-1794   	; 0x1176 <main+0x66c>

  // considers flat earth around vehicle and reference

  // Ernani Reis, Aug 2011
  
  if (currLat == homeLat && currLong == homeLong) {
    1878:	44 16       	cp	r4, r20
    187a:	55 06       	cpc	r5, r21
    187c:	66 06       	cpc	r6, r22
    187e:	77 06       	cpc	r7, r23
    1880:	09 f0       	breq	.+2      	; 0x1884 <main+0xd7a>
    1882:	ab cd       	rjmp	.-1194   	; 0x13da <main+0x8d0>
	  *distanceResult = 0;
    1884:	10 92 e4 03 	sts	0x03E4, r1
    1888:	10 92 e5 03 	sts	0x03E5, r1
    188c:	10 92 e6 03 	sts	0x03E6, r1
    1890:	10 92 e7 03 	sts	0x03E7, r1
	  *bearingResult = 0;
    1894:	10 92 e9 03 	sts	0x03E9, r1
    1898:	10 92 e8 03 	sts	0x03E8, r1
    189c:	cb c9       	rjmp	.-3178   	; 0xc34 <main+0x12a>
	    else { // high angle, cosine is better
        c = (absi32(deltaLong) * 100) / distance; // Computes cosine
        while((mySin(bearing) <= c) && (bearing < 90)) {
          ++bearing;
        }
        bearing = 90 - bearing;
    189e:	2a e5       	ldi	r18, 0x5A	; 90
    18a0:	30 e0       	ldi	r19, 0x00	; 0
    18a2:	20 1b       	sub	r18, r16
    18a4:	31 0b       	sbc	r19, r17
      }
      if (deltaLat == 0) {
    18a6:	41 14       	cp	r4, r1
    18a8:	51 04       	cpc	r5, r1
    18aa:	61 04       	cpc	r6, r1
    18ac:	71 04       	cpc	r7, r1
    18ae:	09 f0       	breq	.+2      	; 0x18b2 <main+0xda8>
    18b0:	3d c0       	rjmp	.+122    	; 0x192c <main+0xe22>
        if (deltaLong >= 0) { // Home = East
    18b2:	b7 fc       	sbrc	r11, 7
    18b4:	47 c0       	rjmp	.+142    	; 0x1944 <main+0xe3a>
          bearing = 90; 
    18b6:	8a e5       	ldi	r24, 0x5A	; 90
    18b8:	90 e0       	ldi	r25, 0x00	; 0
    18ba:	ad cf       	rjmp	.-166    	; 0x1816 <main+0xd0c>
        while((mySin(bearing) <= c) && (bearing < 90)) {
          ++bearing;
        }
      } 
	    else { // high angle, cosine is better
        c = (absi32(deltaLong) * 100) / distance; // Computes cosine
    18bc:	6b 85       	ldd	r22, Y+11	; 0x0b
    18be:	7c 85       	ldd	r23, Y+12	; 0x0c
    18c0:	8d 85       	ldd	r24, Y+13	; 0x0d
    18c2:	9e 85       	ldd	r25, Y+14	; 0x0e
    18c4:	24 e6       	ldi	r18, 0x64	; 100
    18c6:	30 e0       	ldi	r19, 0x00	; 0
    18c8:	40 e0       	ldi	r20, 0x00	; 0
    18ca:	50 e0       	ldi	r21, 0x00	; 0
    18cc:	b1 d1       	rcall	.+866    	; 0x1c30 <__mulsi3>
    18ce:	a7 01       	movw	r20, r14
    18d0:	96 01       	movw	r18, r12
    18d2:	f4 d1       	rcall	.+1000   	; 0x1cbc <__udivmodsi4>
    18d4:	52 2f       	mov	r21, r18
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
	int8_t mult = 1;
    18d6:	41 e0       	ldi	r20, 0x01	; 1
  distance = calcSqrt(a + b);
  distance *= mult2;

  // Only calculate bearing if bearing pointer is set.
  if (bearingResult != NULL) {
    bearing = 0;
    18d8:	00 e0       	ldi	r16, 0x00	; 0
    18da:	10 e0       	ldi	r17, 0x00	; 0
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    18dc:	80 e0       	ldi	r24, 0x00	; 0
    18de:	90 e0       	ldi	r25, 0x00	; 0
    18e0:	28 e6       	ldi	r18, 0x68	; 104
    18e2:	31 e0       	ldi	r19, 0x01	; 1
    18e4:	59 83       	std	Y+1, r21	; 0x01
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
		pos = 180 - pos;
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
    18e6:	8c 5c       	subi	r24, 0xCC	; 204
    18e8:	9f 4f       	sbci	r25, 0xFF	; 255
    18ea:	fc 01       	movw	r30, r24
    18ec:	84 91       	lpm	r24, Z
    18ee:	84 9f       	mul	r24, r20
    18f0:	40 2d       	mov	r20, r0
    18f2:	11 24       	eor	r1, r1
          ++bearing;
        }
      } 
	    else { // high angle, cosine is better
        c = (absi32(deltaLong) * 100) / distance; // Computes cosine
        while((mySin(bearing) <= c) && (bearing < 90)) {
    18f4:	f9 81       	ldd	r31, Y+1	; 0x01
    18f6:	f4 17       	cp	r31, r20
    18f8:	94 f2       	brlt	.-92     	; 0x189e <main+0xd94>
    18fa:	0a 35       	cpi	r16, 0x5A	; 90
    18fc:	11 05       	cpc	r17, r1
    18fe:	79 f2       	breq	.-98     	; 0x189e <main+0xd94>
          ++bearing;
    1900:	0f 5f       	subi	r16, 0xFF	; 255
    1902:	1f 4f       	sbci	r17, 0xFF	; 255
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    1904:	c8 01       	movw	r24, r16
    1906:	b9 01       	movw	r22, r18
    1908:	b2 d1       	rcall	.+868    	; 0x1c6e <__udivmodhi4>
	int8_t mult = 1;
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    190a:	84 3b       	cpi	r24, 0xB4	; 180
    190c:	91 05       	cpc	r25, r1
    190e:	60 f0       	brcs	.+24     	; 0x1928 <main+0xe1e>
		pos = pos - 180;
    1910:	84 5b       	subi	r24, 0xB4	; 180
    1912:	90 40       	sbci	r25, 0x00	; 0
		mult = -1;
    1914:	4f ef       	ldi	r20, 0xFF	; 255
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
    1916:	8a 35       	cpi	r24, 0x5A	; 90
    1918:	91 05       	cpc	r25, r1
    191a:	28 f3       	brcs	.-54     	; 0x18e6 <main+0xddc>
		pos = 180 - pos;
    191c:	64 eb       	ldi	r22, 0xB4	; 180
    191e:	70 e0       	ldi	r23, 0x00	; 0
    1920:	68 1b       	sub	r22, r24
    1922:	79 0b       	sbc	r23, r25
    1924:	cb 01       	movw	r24, r22
    1926:	df cf       	rjmp	.-66     	; 0x18e6 <main+0xddc>
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
	int8_t mult = 1;
    1928:	41 e0       	ldi	r20, 0x01	; 1
    192a:	f5 cf       	rjmp	.-22     	; 0x1916 <main+0xe0c>
        } 
	      else { // Home = West
          bearing = 270;
        }
      } 
      else if (deltaLat > 0) {
    192c:	14 14       	cp	r1, r4
    192e:	15 04       	cpc	r1, r5
    1930:	16 04       	cpc	r1, r6
    1932:	17 04       	cpc	r1, r7
    1934:	bc f4       	brge	.+46     	; 0x1964 <main+0xe5a>
        if (deltaLong >= 0) { // NE quadrant
    1936:	b7 fc       	sbrc	r11, 7
    1938:	11 c0       	rjmp	.+34     	; 0x195c <main+0xe52>
          bearing = 90 - bearing;
    193a:	8a e5       	ldi	r24, 0x5A	; 90
    193c:	90 e0       	ldi	r25, 0x00	; 0
    193e:	82 1b       	sub	r24, r18
    1940:	93 0b       	sbc	r25, r19
    1942:	69 cf       	rjmp	.-302    	; 0x1816 <main+0xd0c>
      if (deltaLat == 0) {
        if (deltaLong >= 0) { // Home = East
          bearing = 90; 
        } 
	      else { // Home = West
          bearing = 270;
    1944:	8e e0       	ldi	r24, 0x0E	; 14
    1946:	91 e0       	ldi	r25, 0x01	; 1
    1948:	66 cf       	rjmp	.-308    	; 0x1816 <main+0xd0c>
  uint32_t b = (deltaLat * deltaLat);

  // Make sure that the squared deltas don't go over uin32_t when adding them together.
  // This should only activate at long distances!
  uint8_t mult2 = 1;
  while ((a >> 24) + (b >> 24) > 0xFF) {
    194a:	61 e0       	ldi	r22, 0x01	; 1
    194c:	70 e0       	ldi	r23, 0x00	; 0
    194e:	80 e0       	ldi	r24, 0x00	; 0
    1950:	90 e0       	ldi	r25, 0x00	; 0
    1952:	6d 83       	std	Y+5, r22	; 0x05
    1954:	7e 83       	std	Y+6, r23	; 0x06
    1956:	8f 83       	std	Y+7, r24	; 0x07
    1958:	98 87       	std	Y+8, r25	; 0x08
    195a:	bc ce       	rjmp	.-648    	; 0x16d4 <main+0xbca>
      else if (deltaLat > 0) {
        if (deltaLong >= 0) { // NE quadrant
          bearing = 90 - bearing;
        } 
	      else { // NW quadrant
          bearing = 270 + bearing;
    195c:	c9 01       	movw	r24, r18
    195e:	82 5f       	subi	r24, 0xF2	; 242
    1960:	9e 4f       	sbci	r25, 0xFE	; 254
    1962:	59 cf       	rjmp	.-334    	; 0x1816 <main+0xd0c>
        }
      } 
	    else {
        if (deltaLong >= 0) { // SE quadrant
    1964:	b7 fc       	sbrc	r11, 7
    1966:	04 c0       	rjmp	.+8      	; 0x1970 <main+0xe66>
          bearing = 90 + bearing;
    1968:	c9 01       	movw	r24, r18
    196a:	86 5a       	subi	r24, 0xA6	; 166
    196c:	9f 4f       	sbci	r25, 0xFF	; 255
    196e:	53 cf       	rjmp	.-346    	; 0x1816 <main+0xd0c>
        } 
	      else { // SW quadrant
          bearing = 270 - bearing;
    1970:	8e e0       	ldi	r24, 0x0E	; 14
    1972:	91 e0       	ldi	r25, 0x01	; 1
    1974:	82 1b       	sub	r24, r18
    1976:	93 0b       	sbc	r25, r19
    1978:	4e cf       	rjmp	.-356    	; 0x1816 <main+0xd0c>

0000197a <__vector_1>:
			//DDRB &= ~OUT1;
		}
	}
}

ISR(INT0_vect) {
    197a:	1f 92       	push	r1
    197c:	0f 92       	push	r0
    197e:	0f b6       	in	r0, 0x3f	; 63
    1980:	0f 92       	push	r0
    1982:	11 24       	eor	r1, r1
    1984:	2f 93       	push	r18
    1986:	3f 93       	push	r19
    1988:	4f 93       	push	r20
    198a:	5f 93       	push	r21
    198c:	6f 93       	push	r22
    198e:	7f 93       	push	r23
    1990:	8f 93       	push	r24
    1992:	9f 93       	push	r25
    1994:	af 93       	push	r26
    1996:	bf 93       	push	r27
    1998:	ef 93       	push	r30
    199a:	ff 93       	push	r31
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    199c:	88 e2       	ldi	r24, 0x28	; 40
    199e:	8a 95       	dec	r24
    19a0:	f1 f7       	brne	.-4      	; 0x199e <__vector_1+0x24>
}  

static void updateLine() {
  _delay_us(5); // wait 5us to see if H or V sync

	if(!(PIND & LTRIG)) { // H sync
    19a2:	4a 99       	sbic	0x09, 2	; 9
    19a4:	81 c0       	rjmp	.+258    	; 0x1aa8 <__vector_1+0x12e>
		if (gActiveLine != 0) {
    19a6:	60 91 42 04 	lds	r22, 0x0442
    19aa:	70 91 43 04 	lds	r23, 0x0443
    19ae:	61 15       	cp	r22, r1
    19b0:	71 05       	cpc	r23, r1
    19b2:	09 f4       	brne	.+2      	; 0x19b6 <__vector_1+0x3c>
    19b4:	39 c0       	rjmp	.+114    	; 0x1a28 <__vector_1+0xae>
			switch(gLineType) {
    19b6:	80 91 44 04 	lds	r24, 0x0444
    19ba:	81 30       	cpi	r24, 0x01	; 1
    19bc:	09 f4       	brne	.+2      	; 0x19c0 <__vector_1+0x46>
    19be:	92 c0       	rjmp	.+292    	; 0x1ae4 <__vector_1+0x16a>
    19c0:	82 30       	cpi	r24, 0x02	; 2
    19c2:	09 f0       	breq	.+2      	; 0x19c6 <__vector_1+0x4c>
    19c4:	31 c0       	rjmp	.+98     	; 0x1a28 <__vector_1+0xae>
    19c6:	e3 e1       	ldi	r30, 0x13	; 19
    19c8:	f1 e0       	ldi	r31, 0x01	; 1
    19ca:	31 97       	sbiw	r30, 0x01	; 1
    19cc:	f1 f7       	brne	.-4      	; 0x19ca <__vector_1+0x50>
    19ce:	00 c0       	rjmp	.+0      	; 0x19d0 <__vector_1+0x56>
    19d0:	00 00       	nop
{
#ifdef TEXT_SMALL_ENABLED
	SPSR &= ~(1<<SPI2X); // Set normal speed
#endif //TEXT_SMALL_ENABLED
  _delay_us(GRAPHICS_OFFSET);
  uint16_t currLine = gActivePixmapLine;
    19d2:	20 91 45 04 	lds	r18, 0x0445
    19d6:	30 e0       	ldi	r19, 0x00	; 0
    19d8:	80 e0       	ldi	r24, 0x00	; 0
    19da:	90 e0       	ldi	r25, 0x00	; 0
    19dc:	26 51       	subi	r18, 0x16	; 22
    19de:	3c 4f       	sbci	r19, 0xFC	; 252
    19e0:	f9 01       	movw	r30, r18
    19e2:	e8 0f       	add	r30, r24
    19e4:	f9 1f       	adc	r31, r25
  for (uint8_t i = 0; i < GRAPHICS_WIDTH; ++i) {
	  SPDR = gPixelData[i][currLine];
    19e6:	40 81       	ld	r20, Z
    19e8:	4e bd       	out	0x2e, r20	; 46
	  DDRB |= OUT1;
    19ea:	21 9a       	sbi	0x04, 1	; 4
	...
	  DELAY_9_NOP();
	  DELAY_9_NOP();
	  DELAY_5_NOP();
    1a18:	00 00       	nop
    1a1a:	48 96       	adiw	r24, 0x18	; 24
#ifdef TEXT_SMALL_ENABLED
	SPSR &= ~(1<<SPI2X); // Set normal speed
#endif //TEXT_SMALL_ENABLED
  _delay_us(GRAPHICS_OFFSET);
  uint16_t currLine = gActivePixmapLine;
  for (uint8_t i = 0; i < GRAPHICS_WIDTH; ++i) {
    1a1c:	88 34       	cpi	r24, 0x48	; 72
    1a1e:	91 05       	cpc	r25, r1
    1a20:	f9 f6       	brne	.-66     	; 0x19e0 <__vector_1+0x66>
	  DDRB |= OUT1;
	  DELAY_9_NOP();
	  DELAY_9_NOP();
	  DELAY_5_NOP();
  }
  DDRB &= ~OUT1;
    1a22:	21 98       	cbi	0x04, 1	; 4
  DELAY_1_NOP();
    1a24:	00 00       	nop
  SPDR = 0x00;
    1a26:	1e bc       	out	0x2e, r1	; 46
					break;
			}
		}
		
		// We save some time in beginning of line by pre-calculating next type.
		gLineType = LINE_TYPE_UNKNOWN; // Default case
    1a28:	10 92 44 04 	sts	0x0444, r1
		gActiveLine++;
    1a2c:	cb 01       	movw	r24, r22
    1a2e:	01 96       	adiw	r24, 0x01	; 1
    1a30:	90 93 43 04 	sts	0x0443, r25
    1a34:	80 93 42 04 	sts	0x0442, r24
		if (gActiveLine == UPDATE_LINE) {
    1a38:	8e 36       	cpi	r24, 0x6E	; 110
    1a3a:	91 05       	cpc	r25, r1
    1a3c:	09 f4       	brne	.+2      	; 0x1a40 <__vector_1+0xc6>
    1a3e:	40 c0       	rjmp	.+128    	; 0x1ac0 <__vector_1+0x146>
			gUpdateScreenData = 1;
		}
		if (gActiveLine == UPDATE_LINE + 1) {
    1a40:	8f 36       	cpi	r24, 0x6F	; 111
    1a42:	91 05       	cpc	r25, r1
    1a44:	19 f4       	brne	.+6      	; 0x1a4c <__vector_1+0xd2>
			gUpdateScreenData = 2;
    1a46:	22 e0       	ldi	r18, 0x02	; 2
    1a48:	20 93 74 01 	sts	0x0174, r18
		}			

#ifdef TEXT_ENABLED	
		if (gActiveLine >= gActiveTextLine && gActiveLine < gActiveTextLastLine) {
    1a4c:	40 91 d1 03 	lds	r20, 0x03D1
    1a50:	50 91 d2 03 	lds	r21, 0x03D2
    1a54:	20 91 6a 01 	lds	r18, 0x016A
    1a58:	30 91 6b 01 	lds	r19, 0x016B
    1a5c:	84 17       	cp	r24, r20
    1a5e:	95 07       	cpc	r25, r21
    1a60:	18 f0       	brcs	.+6      	; 0x1a68 <__vector_1+0xee>
    1a62:	82 17       	cp	r24, r18
    1a64:	93 07       	cpc	r25, r19
    1a66:	80 f1       	brcs	.+96     	; 0x1ac8 <__vector_1+0x14e>
		  gActivePixmapLine = (gActiveLine - gActiveTextLine);
		  if (gActiveTextSize == TEXT_SIZE_LARGE_MULT) {
		    gActivePixmapLine /= TEXT_SIZE_LARGE_MULT;
		  }
		}
		else if (gActiveLine == gActiveTextLastLine) {
    1a68:	82 17       	cp	r24, r18
    1a6a:	93 07       	cpc	r25, r19
    1a6c:	09 f4       	brne	.+2      	; 0x1a70 <__vector_1+0xf6>
    1a6e:	81 c0       	rjmp	.+258    	; 0x1b72 <__vector_1+0x1f8>
			gActivePixmapLine = 1;
			return;
		}
#endif //TEXT_ENABLED		
#ifdef GRAPICSENABLED		
		else if (gActiveLine >= GRAPHICS_LINE && gActiveLine < (GRAPHICS_LINE + GRAPHICS_HEIGHT)) {
    1a70:	68 56       	subi	r22, 0x68	; 104
    1a72:	70 40       	sbci	r23, 0x00	; 0
    1a74:	68 31       	cpi	r22, 0x18	; 24
    1a76:	71 05       	cpc	r23, r1
    1a78:	30 f4       	brcc	.+12     	; 0x1a86 <__vector_1+0x10c>
			gLineType = LINE_TYPE_GRAPHICS;
    1a7a:	92 e0       	ldi	r25, 0x02	; 2
    1a7c:	90 93 44 04 	sts	0x0444, r25
			gActivePixmapLine = (gActiveLine - GRAPHICS_LINE);
    1a80:	89 56       	subi	r24, 0x69	; 105
    1a82:	80 93 45 04 	sts	0x0445, r24
	updateLine();
}
    1a86:	ff 91       	pop	r31
    1a88:	ef 91       	pop	r30
    1a8a:	bf 91       	pop	r27
    1a8c:	af 91       	pop	r26
    1a8e:	9f 91       	pop	r25
    1a90:	8f 91       	pop	r24
    1a92:	7f 91       	pop	r23
    1a94:	6f 91       	pop	r22
    1a96:	5f 91       	pop	r21
    1a98:	4f 91       	pop	r20
    1a9a:	3f 91       	pop	r19
    1a9c:	2f 91       	pop	r18
    1a9e:	0f 90       	pop	r0
    1aa0:	0f be       	out	0x3f, r0	; 63
    1aa2:	0f 90       	pop	r0
    1aa4:	1f 90       	pop	r1
    1aa6:	18 95       	reti
		}
#endif //GRAPICSENABLED
	}
	else { // V sync
		if(gActiveLine > 200) {
    1aa8:	80 91 42 04 	lds	r24, 0x0442
    1aac:	90 91 43 04 	lds	r25, 0x0443
    1ab0:	89 3c       	cpi	r24, 0xC9	; 201
    1ab2:	91 05       	cpc	r25, r1
    1ab4:	40 f3       	brcs	.-48     	; 0x1a86 <__vector_1+0x10c>
			gActiveLine = 0;
    1ab6:	10 92 43 04 	sts	0x0443, r1
    1aba:	10 92 42 04 	sts	0x0442, r1
    1abe:	e3 cf       	rjmp	.-58     	; 0x1a86 <__vector_1+0x10c>
		
		// We save some time in beginning of line by pre-calculating next type.
		gLineType = LINE_TYPE_UNKNOWN; // Default case
		gActiveLine++;
		if (gActiveLine == UPDATE_LINE) {
			gUpdateScreenData = 1;
    1ac0:	21 e0       	ldi	r18, 0x01	; 1
    1ac2:	20 93 74 01 	sts	0x0174, r18
    1ac6:	c2 cf       	rjmp	.-124    	; 0x1a4c <__vector_1+0xd2>
			gUpdateScreenData = 2;
		}			

#ifdef TEXT_ENABLED	
		if (gActiveLine >= gActiveTextLine && gActiveLine < gActiveTextLastLine) {
	    gLineType = LINE_TYPE_TEXT;
    1ac8:	91 e0       	ldi	r25, 0x01	; 1
    1aca:	90 93 44 04 	sts	0x0444, r25
		  gActivePixmapLine = (gActiveLine - gActiveTextLine);
    1ace:	84 1b       	sub	r24, r20
    1ad0:	80 93 45 04 	sts	0x0445, r24
		  if (gActiveTextSize == TEXT_SIZE_LARGE_MULT) {
    1ad4:	90 91 6c 01 	lds	r25, 0x016C
    1ad8:	92 30       	cpi	r25, 0x02	; 2
    1ada:	a9 f6       	brne	.-86     	; 0x1a86 <__vector_1+0x10c>
		    gActivePixmapLine /= TEXT_SIZE_LARGE_MULT;
    1adc:	86 95       	lsr	r24
    1ade:	80 93 45 04 	sts	0x0445, r24
    1ae2:	d1 cf       	rjmp	.-94     	; 0x1a86 <__vector_1+0x10c>
	if(!(PIND & LTRIG)) { // H sync
		if (gActiveLine != 0) {
			switch(gLineType) {
				case LINE_TYPE_TEXT:
#ifdef TEXT_ENABLED				
					drawTextLine(gActiveTextId);
    1ae4:	20 91 b8 01 	lds	r18, 0x01B8
    1ae8:	98 e1       	ldi	r25, 0x18	; 24
    1aea:	9a 95       	dec	r25
    1aec:	f1 f7       	brne	.-4      	; 0x1aea <__vector_1+0x170>
}  

static void drawTextLine(uint8_t textId)
{
	_delay_us(3);
	uint8_t currLine = gActivePixmapLine;
    1aee:	a0 91 45 04 	lds	r26, 0x0445
			//DDRB &= ~OUT1;
		}
	}
}

ISR(INT0_vect) {
    1af2:	30 e0       	ldi	r19, 0x00	; 0
    1af4:	81 e2       	ldi	r24, 0x21	; 33
    1af6:	90 e0       	ldi	r25, 0x00	; 0
    1af8:	28 9f       	mul	r18, r24
    1afa:	f0 01       	movw	r30, r0
    1afc:	29 9f       	mul	r18, r25
    1afe:	f0 0d       	add	r31, r0
    1b00:	38 9f       	mul	r19, r24
    1b02:	f0 0d       	add	r31, r0
    1b04:	11 24       	eor	r1, r1
    1b06:	e7 54       	subi	r30, 0x47	; 71
    1b08:	fe 4f       	sbci	r31, 0xFE	; 254
    1b0a:	81 e2       	ldi	r24, 0x21	; 33
    1b0c:	a8 9f       	mul	r26, r24
    1b0e:	d0 01       	movw	r26, r0
    1b10:	11 24       	eor	r1, r1
    1b12:	a7 53       	subi	r26, 0x37	; 55
    1b14:	bd 4f       	sbci	r27, 0xFD	; 253
	for (uint8_t i = 0; i < TEXT_LINE_MAX_CHARS; ++i) {
    1b16:	80 e0       	ldi	r24, 0x00	; 0
    1b18:	17 c0       	rjmp	.+46     	; 0x1b48 <__vector_1+0x1ce>
		if (gText[textId][i] != ' ' && gText[textId][i] != 0) {
			DDRB |= OUT1;
    1b1a:	21 9a       	sbi	0x04, 1	; 4
		}
		else {
			DDRB &= ~OUT1;
			DELAY_1_NOP();
		}
		SPDR = gTextPixmap[(uint16_t)(currLine)*TEXT_LINE_MAX_CHARS + i];
    1b1c:	9d 91       	ld	r25, X+
    1b1e:	9e bd       	out	0x2e, r25	; 46
	...
		DELAY_4_NOP();
#ifndef TEXT_SMALL_ENABLED
		DELAY_6_NOP();
		DELAY_7_NOP();
    1b40:	00 00       	nop

static void drawTextLine(uint8_t textId)
{
	_delay_us(3);
	uint8_t currLine = gActivePixmapLine;
	for (uint8_t i = 0; i < TEXT_LINE_MAX_CHARS; ++i) {
    1b42:	8f 5f       	subi	r24, 0xFF	; 255
    1b44:	81 32       	cpi	r24, 0x21	; 33
    1b46:	41 f0       	breq	.+16     	; 0x1b58 <__vector_1+0x1de>
		if (gText[textId][i] != ' ' && gText[textId][i] != 0) {
    1b48:	91 91       	ld	r25, Z+
    1b4a:	90 32       	cpi	r25, 0x20	; 32
    1b4c:	11 f0       	breq	.+4      	; 0x1b52 <__vector_1+0x1d8>
    1b4e:	99 23       	and	r25, r25
    1b50:	21 f7       	brne	.-56     	; 0x1b1a <__vector_1+0x1a0>
			DDRB |= OUT1;
		}
		else {
			DDRB &= ~OUT1;
    1b52:	21 98       	cbi	0x04, 1	; 4
			DELAY_1_NOP();
    1b54:	00 00       	nop
    1b56:	e2 cf       	rjmp	.-60     	; 0x1b1c <__vector_1+0x1a2>
	...
		DELAY_6_NOP();
		DELAY_7_NOP();
#endif //TEXT_SMALL_ENABLED	
	}
	DELAY_10_NOP();
	SPDR = 0x00;
    1b6c:	1e bc       	out	0x2e, r1	; 46
	DDRB &= ~OUT1;
    1b6e:	21 98       	cbi	0x04, 1	; 4
    1b70:	5b cf       	rjmp	.-330    	; 0x1a28 <__vector_1+0xae>
		  if (gActiveTextSize == TEXT_SIZE_LARGE_MULT) {
		    gActivePixmapLine /= TEXT_SIZE_LARGE_MULT;
		  }
		}
		else if (gActiveLine == gActiveTextLastLine) {
		  gUpdateScreenData = 2;
    1b72:	82 e0       	ldi	r24, 0x02	; 2
    1b74:	80 93 74 01 	sts	0x0174, r24
			gActiveTextId = (gActiveTextId+1) % TEXT_LINES;
    1b78:	80 91 b8 01 	lds	r24, 0x01B8
    1b7c:	90 e0       	ldi	r25, 0x00	; 0
    1b7e:	01 96       	adiw	r24, 0x01	; 1
    1b80:	66 e0       	ldi	r22, 0x06	; 6
    1b82:	70 e0       	ldi	r23, 0x00	; 0
    1b84:	88 d0       	rcall	.+272    	; 0x1c96 <__divmodhi4>
    1b86:	80 93 b8 01 	sts	0x01B8, r24
			gActiveTextLine = gTextLines[gActiveTextId];
    1b8a:	fc 01       	movw	r30, r24
    1b8c:	ee 0f       	add	r30, r30
    1b8e:	ff 1f       	adc	r31, r31
    1b90:	ec 5a       	subi	r30, 0xAC	; 172
    1b92:	fe 4f       	sbci	r31, 0xFE	; 254
    1b94:	20 81       	ld	r18, Z
    1b96:	31 81       	ldd	r19, Z+1	; 0x01
    1b98:	30 93 d2 03 	sts	0x03D2, r19
    1b9c:	20 93 d1 03 	sts	0x03D1, r18
			gActiveTextSize = gTextLineSizes[gActiveTextId];
    1ba0:	83 59       	subi	r24, 0x93	; 147
    1ba2:	9e 4f       	sbci	r25, 0xFE	; 254
    1ba4:	fc 01       	movw	r30, r24
    1ba6:	80 81       	ld	r24, Z
    1ba8:	80 93 6c 01 	sts	0x016C, r24
			gActiveTextLastLine = gActiveTextLine + TEXT_CHAR_HEIGHT * gActiveTextSize;
    1bac:	90 e0       	ldi	r25, 0x00	; 0
    1bae:	88 0f       	add	r24, r24
    1bb0:	99 1f       	adc	r25, r25
    1bb2:	88 0f       	add	r24, r24
    1bb4:	99 1f       	adc	r25, r25
    1bb6:	88 0f       	add	r24, r24
    1bb8:	99 1f       	adc	r25, r25
    1bba:	82 0f       	add	r24, r18
    1bbc:	93 1f       	adc	r25, r19
    1bbe:	90 93 6b 01 	sts	0x016B, r25
    1bc2:	80 93 6a 01 	sts	0x016A, r24
			gActivePixmapLine = 1;
    1bc6:	81 e0       	ldi	r24, 0x01	; 1
    1bc8:	80 93 45 04 	sts	0x0445, r24
    1bcc:	5c cf       	rjmp	.-328    	; 0x1a86 <__vector_1+0x10c>

00001bce <__vector_13>:
	updateLine();
}

ISR(TIMER1_OVF_vect)
{
    1bce:	1f 92       	push	r1
    1bd0:	0f 92       	push	r0
    1bd2:	0f b6       	in	r0, 0x3f	; 63
    1bd4:	0f 92       	push	r0
    1bd6:	11 24       	eor	r1, r1
    1bd8:	2f 93       	push	r18
    1bda:	3f 93       	push	r19
    1bdc:	8f 93       	push	r24
    1bde:	9f 93       	push	r25
	static uint8_t lastLine = 0;
	if (lastLine == gActiveLine) {
    1be0:	80 91 42 04 	lds	r24, 0x0442
    1be4:	90 91 43 04 	lds	r25, 0x0443
    1be8:	20 91 46 04 	lds	r18, 0x0446
    1bec:	30 e0       	ldi	r19, 0x00	; 0
    1bee:	28 17       	cp	r18, r24
    1bf0:	39 07       	cpc	r19, r25
    1bf2:	21 f4       	brne	.+8      	; 0x1bfc <__vector_13+0x2e>
    PORTD ^= LED; // Toggle the LED
    1bf4:	2b b1       	in	r18, 0x0b	; 11
    1bf6:	38 e0       	ldi	r19, 0x08	; 8
    1bf8:	23 27       	eor	r18, r19
    1bfa:	2b b9       	out	0x0b, r18	; 11
	}
	lastLine = gActiveLine;
    1bfc:	80 93 46 04 	sts	0x0446, r24
}
    1c00:	9f 91       	pop	r25
    1c02:	8f 91       	pop	r24
    1c04:	3f 91       	pop	r19
    1c06:	2f 91       	pop	r18
    1c08:	0f 90       	pop	r0
    1c0a:	0f be       	out	0x3f, r0	; 63
    1c0c:	0f 90       	pop	r0
    1c0e:	1f 90       	pop	r1
    1c10:	18 95       	reti

00001c12 <__umulhisi3>:
    1c12:	53 9f       	mul	r21, r19
    1c14:	c0 01       	movw	r24, r0
    1c16:	42 9f       	mul	r20, r18
    1c18:	b0 01       	movw	r22, r0
    1c1a:	52 9f       	mul	r21, r18
    1c1c:	70 0d       	add	r23, r0
    1c1e:	81 1d       	adc	r24, r1
    1c20:	11 24       	eor	r1, r1
    1c22:	91 1d       	adc	r25, r1
    1c24:	34 9f       	mul	r19, r20
    1c26:	70 0d       	add	r23, r0
    1c28:	81 1d       	adc	r24, r1
    1c2a:	11 24       	eor	r1, r1
    1c2c:	91 1d       	adc	r25, r1
    1c2e:	08 95       	ret

00001c30 <__mulsi3>:
    1c30:	62 9f       	mul	r22, r18
    1c32:	d0 01       	movw	r26, r0
    1c34:	73 9f       	mul	r23, r19
    1c36:	f0 01       	movw	r30, r0
    1c38:	82 9f       	mul	r24, r18
    1c3a:	e0 0d       	add	r30, r0
    1c3c:	f1 1d       	adc	r31, r1
    1c3e:	64 9f       	mul	r22, r20
    1c40:	e0 0d       	add	r30, r0
    1c42:	f1 1d       	adc	r31, r1
    1c44:	92 9f       	mul	r25, r18
    1c46:	f0 0d       	add	r31, r0
    1c48:	83 9f       	mul	r24, r19
    1c4a:	f0 0d       	add	r31, r0
    1c4c:	74 9f       	mul	r23, r20
    1c4e:	f0 0d       	add	r31, r0
    1c50:	65 9f       	mul	r22, r21
    1c52:	f0 0d       	add	r31, r0
    1c54:	99 27       	eor	r25, r25
    1c56:	72 9f       	mul	r23, r18
    1c58:	b0 0d       	add	r27, r0
    1c5a:	e1 1d       	adc	r30, r1
    1c5c:	f9 1f       	adc	r31, r25
    1c5e:	63 9f       	mul	r22, r19
    1c60:	b0 0d       	add	r27, r0
    1c62:	e1 1d       	adc	r30, r1
    1c64:	f9 1f       	adc	r31, r25
    1c66:	bd 01       	movw	r22, r26
    1c68:	cf 01       	movw	r24, r30
    1c6a:	11 24       	eor	r1, r1
    1c6c:	08 95       	ret

00001c6e <__udivmodhi4>:
    1c6e:	aa 1b       	sub	r26, r26
    1c70:	bb 1b       	sub	r27, r27
    1c72:	51 e1       	ldi	r21, 0x11	; 17
    1c74:	07 c0       	rjmp	.+14     	; 0x1c84 <__udivmodhi4_ep>

00001c76 <__udivmodhi4_loop>:
    1c76:	aa 1f       	adc	r26, r26
    1c78:	bb 1f       	adc	r27, r27
    1c7a:	a6 17       	cp	r26, r22
    1c7c:	b7 07       	cpc	r27, r23
    1c7e:	10 f0       	brcs	.+4      	; 0x1c84 <__udivmodhi4_ep>
    1c80:	a6 1b       	sub	r26, r22
    1c82:	b7 0b       	sbc	r27, r23

00001c84 <__udivmodhi4_ep>:
    1c84:	88 1f       	adc	r24, r24
    1c86:	99 1f       	adc	r25, r25
    1c88:	5a 95       	dec	r21
    1c8a:	a9 f7       	brne	.-22     	; 0x1c76 <__udivmodhi4_loop>
    1c8c:	80 95       	com	r24
    1c8e:	90 95       	com	r25
    1c90:	bc 01       	movw	r22, r24
    1c92:	cd 01       	movw	r24, r26
    1c94:	08 95       	ret

00001c96 <__divmodhi4>:
    1c96:	97 fb       	bst	r25, 7
    1c98:	09 2e       	mov	r0, r25
    1c9a:	07 26       	eor	r0, r23
    1c9c:	0a d0       	rcall	.+20     	; 0x1cb2 <__divmodhi4_neg1>
    1c9e:	77 fd       	sbrc	r23, 7
    1ca0:	04 d0       	rcall	.+8      	; 0x1caa <__divmodhi4_neg2>
    1ca2:	e5 df       	rcall	.-54     	; 0x1c6e <__udivmodhi4>
    1ca4:	06 d0       	rcall	.+12     	; 0x1cb2 <__divmodhi4_neg1>
    1ca6:	00 20       	and	r0, r0
    1ca8:	1a f4       	brpl	.+6      	; 0x1cb0 <__divmodhi4_exit>

00001caa <__divmodhi4_neg2>:
    1caa:	70 95       	com	r23
    1cac:	61 95       	neg	r22
    1cae:	7f 4f       	sbci	r23, 0xFF	; 255

00001cb0 <__divmodhi4_exit>:
    1cb0:	08 95       	ret

00001cb2 <__divmodhi4_neg1>:
    1cb2:	f6 f7       	brtc	.-4      	; 0x1cb0 <__divmodhi4_exit>
    1cb4:	90 95       	com	r25
    1cb6:	81 95       	neg	r24
    1cb8:	9f 4f       	sbci	r25, 0xFF	; 255
    1cba:	08 95       	ret

00001cbc <__udivmodsi4>:
    1cbc:	a1 e2       	ldi	r26, 0x21	; 33
    1cbe:	1a 2e       	mov	r1, r26
    1cc0:	aa 1b       	sub	r26, r26
    1cc2:	bb 1b       	sub	r27, r27
    1cc4:	fd 01       	movw	r30, r26
    1cc6:	0d c0       	rjmp	.+26     	; 0x1ce2 <__udivmodsi4_ep>

00001cc8 <__udivmodsi4_loop>:
    1cc8:	aa 1f       	adc	r26, r26
    1cca:	bb 1f       	adc	r27, r27
    1ccc:	ee 1f       	adc	r30, r30
    1cce:	ff 1f       	adc	r31, r31
    1cd0:	a2 17       	cp	r26, r18
    1cd2:	b3 07       	cpc	r27, r19
    1cd4:	e4 07       	cpc	r30, r20
    1cd6:	f5 07       	cpc	r31, r21
    1cd8:	20 f0       	brcs	.+8      	; 0x1ce2 <__udivmodsi4_ep>
    1cda:	a2 1b       	sub	r26, r18
    1cdc:	b3 0b       	sbc	r27, r19
    1cde:	e4 0b       	sbc	r30, r20
    1ce0:	f5 0b       	sbc	r31, r21

00001ce2 <__udivmodsi4_ep>:
    1ce2:	66 1f       	adc	r22, r22
    1ce4:	77 1f       	adc	r23, r23
    1ce6:	88 1f       	adc	r24, r24
    1ce8:	99 1f       	adc	r25, r25
    1cea:	1a 94       	dec	r1
    1cec:	69 f7       	brne	.-38     	; 0x1cc8 <__udivmodsi4_loop>
    1cee:	60 95       	com	r22
    1cf0:	70 95       	com	r23
    1cf2:	80 95       	com	r24
    1cf4:	90 95       	com	r25
    1cf6:	9b 01       	movw	r18, r22
    1cf8:	ac 01       	movw	r20, r24
    1cfa:	bd 01       	movw	r22, r26
    1cfc:	cf 01       	movw	r24, r30
    1cfe:	08 95       	ret

00001d00 <__divmodsi4>:
    1d00:	97 fb       	bst	r25, 7
    1d02:	09 2e       	mov	r0, r25
    1d04:	05 26       	eor	r0, r21
    1d06:	0e d0       	rcall	.+28     	; 0x1d24 <__divmodsi4_neg1>
    1d08:	57 fd       	sbrc	r21, 7
    1d0a:	04 d0       	rcall	.+8      	; 0x1d14 <__divmodsi4_neg2>
    1d0c:	d7 df       	rcall	.-82     	; 0x1cbc <__udivmodsi4>
    1d0e:	0a d0       	rcall	.+20     	; 0x1d24 <__divmodsi4_neg1>
    1d10:	00 1c       	adc	r0, r0
    1d12:	38 f4       	brcc	.+14     	; 0x1d22 <__divmodsi4_exit>

00001d14 <__divmodsi4_neg2>:
    1d14:	50 95       	com	r21
    1d16:	40 95       	com	r20
    1d18:	30 95       	com	r19
    1d1a:	21 95       	neg	r18
    1d1c:	3f 4f       	sbci	r19, 0xFF	; 255
    1d1e:	4f 4f       	sbci	r20, 0xFF	; 255
    1d20:	5f 4f       	sbci	r21, 0xFF	; 255

00001d22 <__divmodsi4_exit>:
    1d22:	08 95       	ret

00001d24 <__divmodsi4_neg1>:
    1d24:	f6 f7       	brtc	.-4      	; 0x1d22 <__divmodsi4_exit>
    1d26:	90 95       	com	r25
    1d28:	80 95       	com	r24
    1d2a:	70 95       	com	r23
    1d2c:	61 95       	neg	r22
    1d2e:	7f 4f       	sbci	r23, 0xFF	; 255
    1d30:	8f 4f       	sbci	r24, 0xFF	; 255
    1d32:	9f 4f       	sbci	r25, 0xFF	; 255
    1d34:	08 95       	ret

00001d36 <__prologue_saves__>:
    1d36:	2f 92       	push	r2
    1d38:	3f 92       	push	r3
    1d3a:	4f 92       	push	r4
    1d3c:	5f 92       	push	r5
    1d3e:	6f 92       	push	r6
    1d40:	7f 92       	push	r7
    1d42:	8f 92       	push	r8
    1d44:	9f 92       	push	r9
    1d46:	af 92       	push	r10
    1d48:	bf 92       	push	r11
    1d4a:	cf 92       	push	r12
    1d4c:	df 92       	push	r13
    1d4e:	ef 92       	push	r14
    1d50:	ff 92       	push	r15
    1d52:	0f 93       	push	r16
    1d54:	1f 93       	push	r17
    1d56:	cf 93       	push	r28
    1d58:	df 93       	push	r29
    1d5a:	cd b7       	in	r28, 0x3d	; 61
    1d5c:	de b7       	in	r29, 0x3e	; 62
    1d5e:	ca 1b       	sub	r28, r26
    1d60:	db 0b       	sbc	r29, r27
    1d62:	0f b6       	in	r0, 0x3f	; 63
    1d64:	f8 94       	cli
    1d66:	de bf       	out	0x3e, r29	; 62
    1d68:	0f be       	out	0x3f, r0	; 63
    1d6a:	cd bf       	out	0x3d, r28	; 61
    1d6c:	09 94       	ijmp

00001d6e <__epilogue_restores__>:
    1d6e:	2a 88       	ldd	r2, Y+18	; 0x12
    1d70:	39 88       	ldd	r3, Y+17	; 0x11
    1d72:	48 88       	ldd	r4, Y+16	; 0x10
    1d74:	5f 84       	ldd	r5, Y+15	; 0x0f
    1d76:	6e 84       	ldd	r6, Y+14	; 0x0e
    1d78:	7d 84       	ldd	r7, Y+13	; 0x0d
    1d7a:	8c 84       	ldd	r8, Y+12	; 0x0c
    1d7c:	9b 84       	ldd	r9, Y+11	; 0x0b
    1d7e:	aa 84       	ldd	r10, Y+10	; 0x0a
    1d80:	b9 84       	ldd	r11, Y+9	; 0x09
    1d82:	c8 84       	ldd	r12, Y+8	; 0x08
    1d84:	df 80       	ldd	r13, Y+7	; 0x07
    1d86:	ee 80       	ldd	r14, Y+6	; 0x06
    1d88:	fd 80       	ldd	r15, Y+5	; 0x05
    1d8a:	0c 81       	ldd	r16, Y+4	; 0x04
    1d8c:	1b 81       	ldd	r17, Y+3	; 0x03
    1d8e:	aa 81       	ldd	r26, Y+2	; 0x02
    1d90:	b9 81       	ldd	r27, Y+1	; 0x01
    1d92:	ce 0f       	add	r28, r30
    1d94:	d1 1d       	adc	r29, r1
    1d96:	0f b6       	in	r0, 0x3f	; 63
    1d98:	f8 94       	cli
    1d9a:	de bf       	out	0x3e, r29	; 62
    1d9c:	0f be       	out	0x3f, r0	; 63
    1d9e:	cd bf       	out	0x3d, r28	; 61
    1da0:	ed 01       	movw	r28, r26
    1da2:	08 95       	ret

00001da4 <strncmp>:
    1da4:	fb 01       	movw	r30, r22
    1da6:	dc 01       	movw	r26, r24
    1da8:	41 50       	subi	r20, 0x01	; 1
    1daa:	50 40       	sbci	r21, 0x00	; 0
    1dac:	30 f0       	brcs	.+12     	; 0x1dba <strncmp+0x16>
    1dae:	8d 91       	ld	r24, X+
    1db0:	01 90       	ld	r0, Z+
    1db2:	80 19       	sub	r24, r0
    1db4:	19 f4       	brne	.+6      	; 0x1dbc <strncmp+0x18>
    1db6:	00 20       	and	r0, r0
    1db8:	b9 f7       	brne	.-18     	; 0x1da8 <strncmp+0x4>
    1dba:	88 1b       	sub	r24, r24
    1dbc:	99 0b       	sbc	r25, r25
    1dbe:	08 95       	ret

00001dc0 <strncpy>:
    1dc0:	fb 01       	movw	r30, r22
    1dc2:	dc 01       	movw	r26, r24
    1dc4:	41 50       	subi	r20, 0x01	; 1
    1dc6:	50 40       	sbci	r21, 0x00	; 0
    1dc8:	48 f0       	brcs	.+18     	; 0x1ddc <strncpy+0x1c>
    1dca:	01 90       	ld	r0, Z+
    1dcc:	0d 92       	st	X+, r0
    1dce:	00 20       	and	r0, r0
    1dd0:	c9 f7       	brne	.-14     	; 0x1dc4 <strncpy+0x4>
    1dd2:	01 c0       	rjmp	.+2      	; 0x1dd6 <strncpy+0x16>
    1dd4:	1d 92       	st	X+, r1
    1dd6:	41 50       	subi	r20, 0x01	; 1
    1dd8:	50 40       	sbci	r21, 0x00	; 0
    1dda:	e0 f7       	brcc	.-8      	; 0x1dd4 <strncpy+0x14>
    1ddc:	08 95       	ret

00001dde <__eerd_block_m88pa>:
    1dde:	dc 01       	movw	r26, r24
    1de0:	cb 01       	movw	r24, r22

00001de2 <__eerd_blraw_m88pa>:
    1de2:	fc 01       	movw	r30, r24
    1de4:	f9 99       	sbic	0x1f, 1	; 31
    1de6:	fe cf       	rjmp	.-4      	; 0x1de4 <__eerd_blraw_m88pa+0x2>
    1de8:	06 c0       	rjmp	.+12     	; 0x1df6 <__eerd_blraw_m88pa+0x14>
    1dea:	f2 bd       	out	0x22, r31	; 34
    1dec:	e1 bd       	out	0x21, r30	; 33
    1dee:	f8 9a       	sbi	0x1f, 0	; 31
    1df0:	31 96       	adiw	r30, 0x01	; 1
    1df2:	00 b4       	in	r0, 0x20	; 32
    1df4:	0d 92       	st	X+, r0
    1df6:	41 50       	subi	r20, 0x01	; 1
    1df8:	50 40       	sbci	r21, 0x00	; 0
    1dfa:	b8 f7       	brcc	.-18     	; 0x1dea <__eerd_blraw_m88pa+0x8>
    1dfc:	08 95       	ret

00001dfe <_exit>:
    1dfe:	f8 94       	cli

00001e00 <__stop_program>:
    1e00:	ff cf       	rjmp	.-2      	; 0x1e00 <__stop_program>
