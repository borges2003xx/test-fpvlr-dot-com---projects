
cl-osd.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000007c  00800100  00001fea  0000209e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001fea  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000002dc  0080017c  0080017c  0000211a  2**0
                  ALLOC
  3 .eeprom       00000200  00810000  00810000  0000211a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .stab         00000960  00000000  00000000  0000231c  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      000001db  00000000  00000000  00002c7c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000090  00000000  00000000  00002e57  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 0000003a  00000000  00000000  00002ee7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   00001d50  00000000  00000000  00002f21  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 0000037a  00000000  00000000  00004c71  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00001c1d  00000000  00000000  00004feb  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00000100  00000000  00000000  00006c08  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    000008e8  00000000  00000000  00006d08  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00002838  00000000  00000000  000075f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_macinfo 0000bc35  00000000  00000000  00009e28  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_pubtypes 0000008f  00000000  00000000  00015a5d  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 000007e8  00000000  00000000  00015aec  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	47 c0       	rjmp	.+142    	; 0x90 <__ctors_end>
       2:	d1 cd       	rjmp	.-1118   	; 0xfffffba6 <__eeprom_end+0xff7ef9a6>
       4:	60 c0       	rjmp	.+192    	; 0xc6 <__bad_interrupt>
       6:	5f c0       	rjmp	.+190    	; 0xc6 <__bad_interrupt>
       8:	5e c0       	rjmp	.+188    	; 0xc6 <__bad_interrupt>
       a:	5d c0       	rjmp	.+186    	; 0xc6 <__bad_interrupt>
       c:	5c c0       	rjmp	.+184    	; 0xc6 <__bad_interrupt>
       e:	5b c0       	rjmp	.+182    	; 0xc6 <__bad_interrupt>
      10:	5a c0       	rjmp	.+180    	; 0xc6 <__bad_interrupt>
      12:	59 c0       	rjmp	.+178    	; 0xc6 <__bad_interrupt>
      14:	58 c0       	rjmp	.+176    	; 0xc6 <__bad_interrupt>
      16:	57 c0       	rjmp	.+174    	; 0xc6 <__bad_interrupt>
      18:	56 c0       	rjmp	.+172    	; 0xc6 <__bad_interrupt>
      1a:	f8 ce       	rjmp	.-528    	; 0xfffffe0c <__eeprom_end+0xff7efc0c>
      1c:	54 c0       	rjmp	.+168    	; 0xc6 <__bad_interrupt>
      1e:	53 c0       	rjmp	.+166    	; 0xc6 <__bad_interrupt>
      20:	52 c0       	rjmp	.+164    	; 0xc6 <__bad_interrupt>
      22:	51 c0       	rjmp	.+162    	; 0xc6 <__bad_interrupt>
      24:	50 c0       	rjmp	.+160    	; 0xc6 <__bad_interrupt>
      26:	4f c0       	rjmp	.+158    	; 0xc6 <__bad_interrupt>
      28:	4e c0       	rjmp	.+156    	; 0xc6 <__bad_interrupt>
      2a:	4d c0       	rjmp	.+154    	; 0xc6 <__bad_interrupt>
      2c:	4c c0       	rjmp	.+152    	; 0xc6 <__bad_interrupt>
      2e:	4b c0       	rjmp	.+150    	; 0xc6 <__bad_interrupt>
      30:	4a c0       	rjmp	.+148    	; 0xc6 <__bad_interrupt>
      32:	49 c0       	rjmp	.+146    	; 0xc6 <__bad_interrupt>

00000034 <sinData>:
      34:	00 02 03 05 07 09 0a 0c 0e 10 11 13 15 16 18 1a     ................
      44:	1c 1d 1f 21 22 24 25 27 29 2a 2c 2d 2f 30 32 34     ...!"$%')*,-/024
      54:	35 36 38 39 3b 3c 3e 3f 40 42 43 44 45 47 48 49     5689;<>?@BCDEGHI
      64:	4a 4b 4d 4e 4f 50 51 52 53 54 55 56 57 57 58 59     JKMNOPQRSTUVWWXY
      74:	5a 5b 5b 5c 5d 5d 5e 5f 5f 60 60 61 61 61 62 62     Z[[\]]^__``aaabb
      84:	62 63 63 63 63 64 64 64 64 64 64 00                 bccccdddddd.

00000090 <__ctors_end>:
      90:	11 24       	eor	r1, r1
      92:	1f be       	out	0x3f, r1	; 63
      94:	c0 e0       	ldi	r28, 0x00	; 0
      96:	d4 e0       	ldi	r29, 0x04	; 4
      98:	de bf       	out	0x3e, r29	; 62
      9a:	cd bf       	out	0x3d, r28	; 61

0000009c <__do_copy_data>:
      9c:	11 e0       	ldi	r17, 0x01	; 1
      9e:	a0 e0       	ldi	r26, 0x00	; 0
      a0:	b1 e0       	ldi	r27, 0x01	; 1
      a2:	ea ee       	ldi	r30, 0xEA	; 234
      a4:	ff e1       	ldi	r31, 0x1F	; 31
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x10>
      a8:	05 90       	lpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	ac 37       	cpi	r26, 0x7C	; 124
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0xc>

000000b2 <__do_clear_bss>:
      b2:	14 e0       	ldi	r17, 0x04	; 4
      b4:	ac e7       	ldi	r26, 0x7C	; 124
      b6:	b1 e0       	ldi	r27, 0x01	; 1
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	a8 35       	cpi	r26, 0x58	; 88
      be:	b1 07       	cpc	r27, r17
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	a2 d5       	rcall	.+2884   	; 0xc08 <main>
      c4:	90 cf       	rjmp	.-224    	; 0xffffffe6 <__eeprom_end+0xff7efde6>

000000c6 <__bad_interrupt>:
      c6:	9c cf       	rjmp	.-200    	; 0x0 <__vectors>

000000c8 <wgs84ToSec100>:
  uint8_t checksumValid;
} TGpsData;

// Convert nmea WGS84 to seconds * 100
// wgs84 = DDMM[.]MMMM
static int32_t wgs84ToSec100(int32_t wgs84) { 
      c8:	2f 92       	push	r2
      ca:	3f 92       	push	r3
      cc:	4f 92       	push	r4
      ce:	5f 92       	push	r5
      d0:	6f 92       	push	r6
      d2:	7f 92       	push	r7
      d4:	8f 92       	push	r8
      d6:	9f 92       	push	r9
      d8:	af 92       	push	r10
      da:	bf 92       	push	r11
      dc:	cf 92       	push	r12
      de:	df 92       	push	r13
      e0:	ef 92       	push	r14
      e2:	ff 92       	push	r15
      e4:	0f 93       	push	r16
      e6:	1f 93       	push	r17
      e8:	df 93       	push	r29
      ea:	cf 93       	push	r28
      ec:	00 d0       	rcall	.+0      	; 0xee <wgs84ToSec100+0x26>
      ee:	00 d0       	rcall	.+0      	; 0xf0 <wgs84ToSec100+0x28>
      f0:	0f 92       	push	r0
      f2:	cd b7       	in	r28, 0x3d	; 61
      f4:	de b7       	in	r29, 0x3e	; 62
      f6:	7b 01       	movw	r14, r22
      f8:	8c 01       	movw	r16, r24
  int8_t mult = 1;
  
  if (wgs84 < 0) {
      fa:	97 fd       	sbrc	r25, 7
      fc:	7b c0       	rjmp	.+246    	; 0x1f4 <wgs84ToSec100+0x12c>
} TGpsData;

// Convert nmea WGS84 to seconds * 100
// wgs84 = DDMM[.]MMMM
static int32_t wgs84ToSec100(int32_t wgs84) { 
  int8_t mult = 1;
      fe:	e1 e0       	ldi	r30, 0x01	; 1
     100:	e9 83       	std	Y+1, r30	; 0x01
  if (wgs84 < 0) {
    mult = -1;
    wgs84 = -wgs84;
  }
  
  uint8_t hour = wgs84 / 1000000; //Get hour part
     102:	c8 01       	movw	r24, r16
     104:	b7 01       	movw	r22, r14
     106:	20 e4       	ldi	r18, 0x40	; 64
     108:	32 e4       	ldi	r19, 0x42	; 66
     10a:	4f e0       	ldi	r20, 0x0F	; 15
     10c:	50 e0       	ldi	r21, 0x00	; 0
     10e:	23 df       	rcall	.-442    	; 0xffffff56 <__eeprom_end+0xff7efd56>
  uint8_t min = (wgs84 - (hour * 1000000)) / 10000; //Get minute part
     110:	a2 2e       	mov	r10, r18
     112:	bb 24       	eor	r11, r11
     114:	cc 24       	eor	r12, r12
     116:	dd 24       	eor	r13, r13
  uint32_t minDecimal = wgs84 % 10000; //Get minute decimal part
     118:	80 e1       	ldi	r24, 0x10	; 16
     11a:	68 2e       	mov	r6, r24
     11c:	87 e2       	ldi	r24, 0x27	; 39
     11e:	78 2e       	mov	r7, r24
     120:	81 2c       	mov	r8, r1
     122:	91 2c       	mov	r9, r1
     124:	c8 01       	movw	r24, r16
     126:	b7 01       	movw	r22, r14
     128:	a4 01       	movw	r20, r8
     12a:	93 01       	movw	r18, r6
     12c:	14 df       	rcall	.-472    	; 0xffffff56 <__eeprom_end+0xff7efd56>
     12e:	6a 83       	std	Y+2, r22	; 0x02
     130:	7b 83       	std	Y+3, r23	; 0x03
     132:	8c 83       	std	Y+4, r24	; 0x04
     134:	9d 83       	std	Y+5, r25	; 0x05
  
  int32_t sec100 = 0;
  sec100 += hour; // Add hour part
  sec100 *= 60;
     136:	c6 01       	movw	r24, r12
     138:	b5 01       	movw	r22, r10
     13a:	2c e3       	ldi	r18, 0x3C	; 60
     13c:	30 e0       	ldi	r19, 0x00	; 0
     13e:	40 e0       	ldi	r20, 0x00	; 0
     140:	50 e0       	ldi	r21, 0x00	; 0
     142:	95 de       	rcall	.-726    	; 0xfffffe6e <__eeprom_end+0xff7efc6e>
     144:	1b 01       	movw	r2, r22
     146:	2c 01       	movw	r4, r24
    mult = -1;
    wgs84 = -wgs84;
  }
  
  uint8_t hour = wgs84 / 1000000; //Get hour part
  uint8_t min = (wgs84 - (hour * 1000000)) / 10000; //Get minute part
     148:	c6 01       	movw	r24, r12
     14a:	b5 01       	movw	r22, r10
     14c:	20 ec       	ldi	r18, 0xC0	; 192
     14e:	3d eb       	ldi	r19, 0xBD	; 189
     150:	40 ef       	ldi	r20, 0xF0	; 240
     152:	5f ef       	ldi	r21, 0xFF	; 255
     154:	8c de       	rcall	.-744    	; 0xfffffe6e <__eeprom_end+0xff7efc6e>
     156:	6e 0d       	add	r22, r14
     158:	7f 1d       	adc	r23, r15
     15a:	80 1f       	adc	r24, r16
     15c:	91 1f       	adc	r25, r17
     15e:	a4 01       	movw	r20, r8
     160:	93 01       	movw	r18, r6
     162:	f9 de       	rcall	.-526    	; 0xffffff56 <__eeprom_end+0xff7efd56>
  uint32_t minDecimal = wgs84 % 10000; //Get minute decimal part
  
  int32_t sec100 = 0;
  sec100 += hour; // Add hour part
  sec100 *= 60;
  sec100 += min; // Add minute part
     164:	22 0e       	add	r2, r18
     166:	31 1c       	adc	r3, r1
     168:	41 1c       	adc	r4, r1
     16a:	51 1c       	adc	r5, r1
  sec100 *= 60;
  sec100 *= 100;
  minDecimal *= 60;
     16c:	6a 81       	ldd	r22, Y+2	; 0x02
     16e:	7b 81       	ldd	r23, Y+3	; 0x03
     170:	8c 81       	ldd	r24, Y+4	; 0x04
     172:	9d 81       	ldd	r25, Y+5	; 0x05
     174:	2c e3       	ldi	r18, 0x3C	; 60
     176:	30 e0       	ldi	r19, 0x00	; 0
     178:	40 e0       	ldi	r20, 0x00	; 0
     17a:	50 e0       	ldi	r21, 0x00	; 0
     17c:	78 de       	rcall	.-784    	; 0xfffffe6e <__eeprom_end+0xff7efc6e>
     17e:	5b 01       	movw	r10, r22
     180:	6c 01       	movw	r12, r24
  int32_t sec100 = 0;
  sec100 += hour; // Add hour part
  sec100 *= 60;
  sec100 += min; // Add minute part
  sec100 *= 60;
  sec100 *= 100;
     182:	c2 01       	movw	r24, r4
     184:	b1 01       	movw	r22, r2
     186:	20 e7       	ldi	r18, 0x70	; 112
     188:	37 e1       	ldi	r19, 0x17	; 23
     18a:	40 e0       	ldi	r20, 0x00	; 0
     18c:	50 e0       	ldi	r21, 0x00	; 0
     18e:	6f de       	rcall	.-802    	; 0xfffffe6e <__eeprom_end+0xff7efc6e>
     190:	7b 01       	movw	r14, r22
     192:	8c 01       	movw	r16, r24
  minDecimal *= 60;
  minDecimal /= 100;
     194:	c6 01       	movw	r24, r12
     196:	b5 01       	movw	r22, r10
     198:	24 e6       	ldi	r18, 0x64	; 100
     19a:	30 e0       	ldi	r19, 0x00	; 0
     19c:	40 e0       	ldi	r20, 0x00	; 0
     19e:	50 e0       	ldi	r21, 0x00	; 0
     1a0:	b8 de       	rcall	.-656    	; 0xffffff12 <__eeprom_end+0xff7efd12>
  sec100 += minDecimal; // Add minute decimal part
     1a2:	e2 0e       	add	r14, r18
     1a4:	f3 1e       	adc	r15, r19
     1a6:	04 1f       	adc	r16, r20
     1a8:	15 1f       	adc	r17, r21
  
  if (mult == -1) {
     1aa:	f9 81       	ldd	r31, Y+1	; 0x01
     1ac:	ff 3f       	cpi	r31, 0xFF	; 255
     1ae:	41 f4       	brne	.+16     	; 0x1c0 <wgs84ToSec100+0xf8>
    return -sec100;
     1b0:	10 95       	com	r17
     1b2:	00 95       	com	r16
     1b4:	f0 94       	com	r15
     1b6:	e0 94       	com	r14
     1b8:	e1 1c       	adc	r14, r1
     1ba:	f1 1c       	adc	r15, r1
     1bc:	01 1d       	adc	r16, r1
     1be:	11 1d       	adc	r17, r1
  } else {
    return sec100;
  }
}
     1c0:	c8 01       	movw	r24, r16
     1c2:	b7 01       	movw	r22, r14
     1c4:	0f 90       	pop	r0
     1c6:	0f 90       	pop	r0
     1c8:	0f 90       	pop	r0
     1ca:	0f 90       	pop	r0
     1cc:	0f 90       	pop	r0
     1ce:	cf 91       	pop	r28
     1d0:	df 91       	pop	r29
     1d2:	1f 91       	pop	r17
     1d4:	0f 91       	pop	r16
     1d6:	ff 90       	pop	r15
     1d8:	ef 90       	pop	r14
     1da:	df 90       	pop	r13
     1dc:	cf 90       	pop	r12
     1de:	bf 90       	pop	r11
     1e0:	af 90       	pop	r10
     1e2:	9f 90       	pop	r9
     1e4:	8f 90       	pop	r8
     1e6:	7f 90       	pop	r7
     1e8:	6f 90       	pop	r6
     1ea:	5f 90       	pop	r5
     1ec:	4f 90       	pop	r4
     1ee:	3f 90       	pop	r3
     1f0:	2f 90       	pop	r2
     1f2:	08 95       	ret
static int32_t wgs84ToSec100(int32_t wgs84) { 
  int8_t mult = 1;
  
  if (wgs84 < 0) {
    mult = -1;
    wgs84 = -wgs84;
     1f4:	10 95       	com	r17
     1f6:	00 95       	com	r16
     1f8:	f0 94       	com	r15
     1fa:	e0 94       	com	r14
     1fc:	e1 1c       	adc	r14, r1
     1fe:	f1 1c       	adc	r15, r1
     200:	01 1d       	adc	r16, r1
     202:	11 1d       	adc	r17, r1
// wgs84 = DDMM[.]MMMM
static int32_t wgs84ToSec100(int32_t wgs84) { 
  int8_t mult = 1;
  
  if (wgs84 < 0) {
    mult = -1;
     204:	8f ef       	ldi	r24, 0xFF	; 255
     206:	89 83       	std	Y+1, r24	; 0x01
     208:	7c cf       	rjmp	.-264    	; 0x102 <wgs84ToSec100+0x3a>

0000020a <printNumber>:
	}
	strncpy(&str[pos], str2, length);
	return length+pos;
}

static uint8_t printNumber(char* const str, uint8_t pos, int32_t number) {
     20a:	4f 92       	push	r4
     20c:	5f 92       	push	r5
     20e:	6f 92       	push	r6
     210:	7f 92       	push	r7
     212:	8f 92       	push	r8
     214:	9f 92       	push	r9
     216:	af 92       	push	r10
     218:	bf 92       	push	r11
     21a:	cf 92       	push	r12
     21c:	df 92       	push	r13
     21e:	ef 92       	push	r14
     220:	ff 92       	push	r15
     222:	0f 93       	push	r16
     224:	1f 93       	push	r17
     226:	df 93       	push	r29
     228:	cf 93       	push	r28
     22a:	0f 92       	push	r0
     22c:	cd b7       	in	r28, 0x3d	; 61
     22e:	de b7       	in	r29, 0x3e	; 62
     230:	2c 01       	movw	r4, r24
     232:	c6 2e       	mov	r12, r22
     234:	79 01       	movw	r14, r18
     236:	8a 01       	movw	r16, r20
#ifndef COMMONUTILS_H_
#define COMMONUTILS_H_

// abs seems to only support 16 bits so I had to make my own.
static uint32_t absi32(int32_t a) {
	return (a > 0) ? a : -a;
     238:	17 fd       	sbrc	r17, 7
     23a:	7a c0       	rjmp	.+244    	; 0x330 <printNumber+0x126>
	uint8_t length = 1;
	int32_t tmp = absi32(number);
	while (tmp > 9) {
     23c:	2a 30       	cpi	r18, 0x0A	; 10
     23e:	31 05       	cpc	r19, r1
     240:	41 05       	cpc	r20, r1
     242:	51 05       	cpc	r21, r1
     244:	0c f4       	brge	.+2      	; 0x248 <printNumber+0x3e>
     246:	91 c0       	rjmp	.+290    	; 0x36a <printNumber+0x160>
     248:	dd 24       	eor	r13, r13
     24a:	d3 94       	inc	r13
		tmp /= 10;
     24c:	6a e0       	ldi	r22, 0x0A	; 10
     24e:	86 2e       	mov	r8, r22
     250:	91 2c       	mov	r9, r1
     252:	a1 2c       	mov	r10, r1
     254:	b1 2c       	mov	r11, r1
     256:	ca 01       	movw	r24, r20
     258:	b9 01       	movw	r22, r18
     25a:	a5 01       	movw	r20, r10
     25c:	94 01       	movw	r18, r8
     25e:	7b de       	rcall	.-778    	; 0xffffff56 <__eeprom_end+0xff7efd56>
		++length;
     260:	d3 94       	inc	r13
}

static uint8_t printNumber(char* const str, uint8_t pos, int32_t number) {
	uint8_t length = 1;
	int32_t tmp = absi32(number);
	while (tmp > 9) {
     262:	2a 30       	cpi	r18, 0x0A	; 10
     264:	31 05       	cpc	r19, r1
     266:	41 05       	cpc	r20, r1
     268:	51 05       	cpc	r21, r1
     26a:	ac f7       	brge	.-22     	; 0x256 <printNumber+0x4c>
		tmp /= 10;
		++length;
	}
	if (number < 0) {
     26c:	17 fd       	sbrc	r17, 7
     26e:	5e c0       	rjmp	.+188    	; 0x32c <printNumber+0x122>
		++length;
	}
	if (pos + length >= TEXT_LINE_MAX_CHARS) {
     270:	8c 2d       	mov	r24, r12
     272:	90 e0       	ldi	r25, 0x00	; 0
     274:	9c 01       	movw	r18, r24
     276:	2d 0d       	add	r18, r13
     278:	31 1d       	adc	r19, r1
     27a:	21 32       	cpi	r18, 0x21	; 33
     27c:	31 05       	cpc	r19, r1
     27e:	0c f0       	brlt	.+2      	; 0x282 <printNumber+0x78>
     280:	53 c0       	rjmp	.+166    	; 0x328 <printNumber+0x11e>
    return TEXT_LINE_MAX_CHARS;
	}
	myItoa(number, &str[pos]);
     282:	48 0e       	add	r4, r24
     284:	59 1e       	adc	r5, r25
static void myItoa(int32_t n, char s[])
{
  int8_t i;
  int8_t sign = 0;
 
  if (n < 0) {  
     286:	17 fd       	sbrc	r17, 7
     288:	5b c0       	rjmp	.+182    	; 0x340 <printNumber+0x136>
}

static void myItoa(int32_t n, char s[])
{
  int8_t i;
  int8_t sign = 0;
     28a:	19 82       	std	Y+1, r1	; 0x01
 
  if (n < 0) {  
	  sign = -1; /* record sign */
     28c:	52 01       	movw	r10, r4
    n = -n;          /* make n positive */
  }	
  i = 0;
  do {       /* generate digits in reverse order */
    s[i++] = n % 10 + '0';   /* get next digit */
     28e:	9a e0       	ldi	r25, 0x0A	; 10
     290:	69 2e       	mov	r6, r25
     292:	71 2c       	mov	r7, r1
     294:	81 2c       	mov	r8, r1
     296:	91 2c       	mov	r9, r1
     298:	c8 01       	movw	r24, r16
     29a:	b7 01       	movw	r22, r14
     29c:	a4 01       	movw	r20, r8
     29e:	93 01       	movw	r18, r6
     2a0:	5a de       	rcall	.-844    	; 0xffffff56 <__eeprom_end+0xff7efd56>
     2a2:	60 5d       	subi	r22, 0xD0	; 208
     2a4:	f5 01       	movw	r30, r10
     2a6:	61 93       	st	Z+, r22
     2a8:	5f 01       	movw	r10, r30
	}
	strncpy(&str[pos], str2, length);
	return length+pos;
}

static uint8_t printNumber(char* const str, uint8_t pos, int32_t number) {
     2aa:	8e 2f       	mov	r24, r30
     2ac:	84 19       	sub	r24, r4
  } while ((n /= 10) > 0);     /* delete it */
     2ae:	79 01       	movw	r14, r18
     2b0:	8a 01       	movw	r16, r20
     2b2:	12 16       	cp	r1, r18
     2b4:	13 06       	cpc	r1, r19
     2b6:	14 06       	cpc	r1, r20
     2b8:	15 06       	cpc	r1, r21
     2ba:	74 f3       	brlt	.-36     	; 0x298 <printNumber+0x8e>
  if (sign < 0) {
     2bc:	f9 81       	ldd	r31, Y+1	; 0x01
     2be:	ff 3f       	cpi	r31, 0xFF	; 255
     2c0:	09 f4       	brne	.+2      	; 0x2c4 <printNumber+0xba>
     2c2:	49 c0       	rjmp	.+146    	; 0x356 <printNumber+0x14c>
    s[i++] = '-';
  }	
  s[i] = '\0';
     2c4:	e8 2f       	mov	r30, r24
     2c6:	ff 27       	eor	r31, r31
     2c8:	e7 fd       	sbrc	r30, 7
     2ca:	f0 95       	com	r31
     2cc:	e4 0d       	add	r30, r4
     2ce:	f5 1d       	adc	r31, r5
     2d0:	10 82       	st	Z, r1
}

static void myReverse(char s[], uint8_t size) {
  uint8_t i;
  char c;
  size -= 1;
     2d2:	81 50       	subi	r24, 0x01	; 1
  for (i = 0; i <= size/2; i++) {
     2d4:	68 2f       	mov	r22, r24
     2d6:	66 95       	lsr	r22
     2d8:	28 2f       	mov	r18, r24
     2da:	30 e0       	ldi	r19, 0x00	; 0
     2dc:	40 e0       	ldi	r20, 0x00	; 0
    c = s[i];
     2de:	84 2f       	mov	r24, r20
     2e0:	90 e0       	ldi	r25, 0x00	; 0
     2e2:	d2 01       	movw	r26, r4
     2e4:	a8 0f       	add	r26, r24
     2e6:	b9 1f       	adc	r27, r25
     2e8:	5c 91       	ld	r21, X
    s[i] = s[size - i];
     2ea:	f9 01       	movw	r30, r18
     2ec:	e8 1b       	sub	r30, r24
     2ee:	f9 0b       	sbc	r31, r25
     2f0:	e4 0d       	add	r30, r4
     2f2:	f5 1d       	adc	r31, r5
     2f4:	80 81       	ld	r24, Z
     2f6:	8c 93       	st	X, r24
    s[size - i] = c;
     2f8:	50 83       	st	Z, r21

static void myReverse(char s[], uint8_t size) {
  uint8_t i;
  char c;
  size -= 1;
  for (i = 0; i <= size/2; i++) {
     2fa:	4f 5f       	subi	r20, 0xFF	; 255
     2fc:	64 17       	cp	r22, r20
     2fe:	78 f7       	brcc	.-34     	; 0x2de <printNumber+0xd4>
	}
	if (pos + length >= TEXT_LINE_MAX_CHARS) {
    return TEXT_LINE_MAX_CHARS;
	}
	myItoa(number, &str[pos]);
	return pos+length;
     300:	8d 2d       	mov	r24, r13
     302:	8c 0d       	add	r24, r12
}
     304:	0f 90       	pop	r0
     306:	cf 91       	pop	r28
     308:	df 91       	pop	r29
     30a:	1f 91       	pop	r17
     30c:	0f 91       	pop	r16
     30e:	ff 90       	pop	r15
     310:	ef 90       	pop	r14
     312:	df 90       	pop	r13
     314:	cf 90       	pop	r12
     316:	bf 90       	pop	r11
     318:	af 90       	pop	r10
     31a:	9f 90       	pop	r9
     31c:	8f 90       	pop	r8
     31e:	7f 90       	pop	r7
     320:	6f 90       	pop	r6
     322:	5f 90       	pop	r5
     324:	4f 90       	pop	r4
     326:	08 95       	ret
	}
	if (number < 0) {
		++length;
	}
	if (pos + length >= TEXT_LINE_MAX_CHARS) {
    return TEXT_LINE_MAX_CHARS;
     328:	81 e2       	ldi	r24, 0x21	; 33
     32a:	ec cf       	rjmp	.-40     	; 0x304 <printNumber+0xfa>
	while (tmp > 9) {
		tmp /= 10;
		++length;
	}
	if (number < 0) {
		++length;
     32c:	d3 94       	inc	r13
     32e:	a0 cf       	rjmp	.-192    	; 0x270 <printNumber+0x66>
#ifndef COMMONUTILS_H_
#define COMMONUTILS_H_

// abs seems to only support 16 bits so I had to make my own.
static uint32_t absi32(int32_t a) {
	return (a > 0) ? a : -a;
     330:	22 27       	eor	r18, r18
     332:	33 27       	eor	r19, r19
     334:	a9 01       	movw	r20, r18
     336:	2e 19       	sub	r18, r14
     338:	3f 09       	sbc	r19, r15
     33a:	40 0b       	sbc	r20, r16
     33c:	51 0b       	sbc	r21, r17
     33e:	7e cf       	rjmp	.-260    	; 0x23c <printNumber+0x32>
  int8_t i;
  int8_t sign = 0;
 
  if (n < 0) {  
	  sign = -1; /* record sign */
    n = -n;          /* make n positive */
     340:	10 95       	com	r17
     342:	00 95       	com	r16
     344:	f0 94       	com	r15
     346:	e0 94       	com	r14
     348:	e1 1c       	adc	r14, r1
     34a:	f1 1c       	adc	r15, r1
     34c:	01 1d       	adc	r16, r1
     34e:	11 1d       	adc	r17, r1
{
  int8_t i;
  int8_t sign = 0;
 
  if (n < 0) {  
	  sign = -1; /* record sign */
     350:	6f ef       	ldi	r22, 0xFF	; 255
     352:	69 83       	std	Y+1, r22	; 0x01
     354:	9b cf       	rjmp	.-202    	; 0x28c <printNumber+0x82>
  i = 0;
  do {       /* generate digits in reverse order */
    s[i++] = n % 10 + '0';   /* get next digit */
  } while ((n /= 10) > 0);     /* delete it */
  if (sign < 0) {
    s[i++] = '-';
     356:	e8 2f       	mov	r30, r24
     358:	ff 27       	eor	r31, r31
     35a:	e7 fd       	sbrc	r30, 7
     35c:	f0 95       	com	r31
     35e:	e4 0d       	add	r30, r4
     360:	f5 1d       	adc	r31, r5
     362:	9d e2       	ldi	r25, 0x2D	; 45
     364:	90 83       	st	Z, r25
     366:	8f 5f       	subi	r24, 0xFF	; 255
     368:	ad cf       	rjmp	.-166    	; 0x2c4 <printNumber+0xba>
	strncpy(&str[pos], str2, length);
	return length+pos;
}

static uint8_t printNumber(char* const str, uint8_t pos, int32_t number) {
	uint8_t length = 1;
     36a:	dd 24       	eor	r13, r13
     36c:	d3 94       	inc	r13
     36e:	7e cf       	rjmp	.-260    	; 0x26c <printNumber+0x62>

00000370 <printText>:
      gTextPixmap[j + (i*TEXT_LINE_MAX_CHARS)] = gTextLastCharBuffer[i];
	  }		  
	}
}

static uint8_t printText(char* const str, uint8_t pos, const char* const str2) {
     370:	0f 93       	push	r16
     372:	1f 93       	push	r17
     374:	9c 01       	movw	r18, r24
     376:	16 2f       	mov	r17, r22
     378:	fa 01       	movw	r30, r20
	uint8_t length = strlen(str2);
     37a:	da 01       	movw	r26, r20
     37c:	0d 90       	ld	r0, X+
     37e:	00 20       	and	r0, r0
     380:	e9 f7       	brne	.-6      	; 0x37c <printText+0xc>
     382:	11 97       	sbiw	r26, 0x01	; 1
     384:	0a 2f       	mov	r16, r26
     386:	04 1b       	sub	r16, r20
	if (pos + length >= TEXT_LINE_MAX_CHARS) {
     388:	40 2f       	mov	r20, r16
     38a:	50 e0       	ldi	r21, 0x00	; 0
     38c:	86 2f       	mov	r24, r22
     38e:	90 e0       	ldi	r25, 0x00	; 0
     390:	ba 01       	movw	r22, r20
     392:	68 0f       	add	r22, r24
     394:	79 1f       	adc	r23, r25
     396:	61 32       	cpi	r22, 0x21	; 33
     398:	71 05       	cpc	r23, r1
     39a:	1c f0       	brlt	.+6      	; 0x3a2 <printText+0x32>
     39c:	41 e2       	ldi	r20, 0x21	; 33
     39e:	50 e0       	ldi	r21, 0x00	; 0
    length = TEXT_LINE_MAX_CHARS;
     3a0:	01 e2       	ldi	r16, 0x21	; 33
	}
	strncpy(&str[pos], str2, length);
     3a2:	82 0f       	add	r24, r18
     3a4:	93 1f       	adc	r25, r19
     3a6:	bf 01       	movw	r22, r30
     3a8:	ff dd       	rcall	.-1026   	; 0xffffffa8 <__eeprom_end+0xff7efda8>
	return length+pos;
}
     3aa:	80 2f       	mov	r24, r16
     3ac:	81 0f       	add	r24, r17
     3ae:	1f 91       	pop	r17
     3b0:	0f 91       	pop	r16
     3b2:	08 95       	ret

000003b4 <printNumberWithUnit>:
		str[pos++] = '0';
	}
	return printNumber(str, pos, numberLow);
}

static uint8_t printNumberWithUnit(char* const str, uint8_t pos, int32_t number, const char* unit) {
     3b4:	0f 93       	push	r16
     3b6:	1f 93       	push	r17
     3b8:	cf 93       	push	r28
     3ba:	df 93       	push	r29
     3bc:	ec 01       	movw	r28, r24
	pos = printNumber(str, pos, number);
     3be:	25 df       	rcall	.-438    	; 0x20a <printNumber>
     3c0:	68 2f       	mov	r22, r24
	return printText(str, pos, unit);
     3c2:	ce 01       	movw	r24, r28
     3c4:	a8 01       	movw	r20, r16
     3c6:	d4 df       	rcall	.-88     	; 0x370 <printText>
}
     3c8:	df 91       	pop	r29
     3ca:	cf 91       	pop	r28
     3cc:	1f 91       	pop	r17
     3ce:	0f 91       	pop	r16
     3d0:	08 95       	ret

000003d2 <printGpsNumber>:
/*static uint8_t printBatterLevel(char* const str, uint8_t pos, const uint8_t adcInput) {
	uint8_t batterLevel = gSensorBatteryPercentage;
	return printNumberWithUnit(str, pos, batterLevel, "%");
}*/

static uint8_t printGpsNumber(char* const str, uint8_t pos, int32_t number, uint8_t numberLat) {
     3d2:	6f 92       	push	r6
     3d4:	7f 92       	push	r7
     3d6:	8f 92       	push	r8
     3d8:	9f 92       	push	r9
     3da:	af 92       	push	r10
     3dc:	bf 92       	push	r11
     3de:	cf 92       	push	r12
     3e0:	df 92       	push	r13
     3e2:	ef 92       	push	r14
     3e4:	ff 92       	push	r15
     3e6:	0f 93       	push	r16
     3e8:	1f 93       	push	r17
     3ea:	cf 93       	push	r28
     3ec:	df 93       	push	r29
     3ee:	ec 01       	movw	r28, r24
     3f0:	16 2f       	mov	r17, r22
	if (number == 0) {
     3f2:	21 15       	cp	r18, r1
     3f4:	31 05       	cpc	r19, r1
     3f6:	41 05       	cpc	r20, r1
     3f8:	51 05       	cpc	r21, r1
     3fa:	09 f4       	brne	.+2      	; 0x3fe <printGpsNumber+0x2c>
     3fc:	9e c0       	rjmp	.+316    	; 0x53a <__stack+0x13a>
#endif
	  return pos;
  }
  
  const char* str2;
  if (numberLat) {
     3fe:	00 23       	and	r16, r16
     400:	09 f0       	breq	.+2      	; 0x404 <__stack+0x4>
     402:	63 c0       	rjmp	.+198    	; 0x4ca <__stack+0xca>
	  str2 = number > 0 ? "N" : "S";
  }
  else {
	  str2 = number > 0 ? "E" : "W";
     404:	12 16       	cp	r1, r18
     406:	13 06       	cpc	r1, r19
     408:	14 06       	cpc	r1, r20
     40a:	15 06       	cpc	r1, r21
     40c:	0c f0       	brlt	.+2      	; 0x410 <__stack+0x10>
     40e:	99 c0       	rjmp	.+306    	; 0x542 <__stack+0x142>
     410:	e4 e0       	ldi	r30, 0x04	; 4
     412:	6e 2e       	mov	r6, r30
     414:	e1 e0       	ldi	r30, 0x01	; 1
     416:	7e 2e       	mov	r7, r30
#ifndef COMMONUTILS_H_
#define COMMONUTILS_H_

// abs seems to only support 16 bits so I had to make my own.
static uint32_t absi32(int32_t a) {
	return (a > 0) ? a : -a;
     418:	69 01       	movw	r12, r18
     41a:	7a 01       	movw	r14, r20
     41c:	57 fd       	sbrc	r21, 7
     41e:	a4 c0       	rjmp	.+328    	; 0x568 <__stack+0x168>
  }
  
  number = absi32(number);
 
	
	uint8_t hour = number / 1000000;
     420:	c7 01       	movw	r24, r14
     422:	b6 01       	movw	r22, r12
     424:	20 e4       	ldi	r18, 0x40	; 64
     426:	32 e4       	ldi	r19, 0x42	; 66
     428:	4f e0       	ldi	r20, 0x0F	; 15
     42a:	50 e0       	ldi	r21, 0x00	; 0
     42c:	94 dd       	rcall	.-1240   	; 0xffffff56 <__eeprom_end+0xff7efd56>
#ifdef GPS_GOOGLE_FORMAT
  uint32_t min = number - (hour * 1000000);
     42e:	82 2e       	mov	r8, r18
     430:	99 24       	eor	r9, r9
     432:	aa 24       	eor	r10, r10
     434:	bb 24       	eor	r11, r11
     436:	c5 01       	movw	r24, r10
     438:	b4 01       	movw	r22, r8
     43a:	20 ec       	ldi	r18, 0xC0	; 192
     43c:	3d eb       	ldi	r19, 0xBD	; 189
     43e:	40 ef       	ldi	r20, 0xF0	; 240
     440:	5f ef       	ldi	r21, 0xFF	; 255
     442:	15 dd       	rcall	.-1494   	; 0xfffffe6e <__eeprom_end+0xff7efc6e>
     444:	6c 0d       	add	r22, r12
     446:	7d 1d       	adc	r23, r13
     448:	8e 1d       	adc	r24, r14
     44a:	9f 1d       	adc	r25, r15
  min = (min * 100)/60;
     44c:	24 e6       	ldi	r18, 0x64	; 100
     44e:	30 e0       	ldi	r19, 0x00	; 0
     450:	40 e0       	ldi	r20, 0x00	; 0
     452:	50 e0       	ldi	r21, 0x00	; 0
     454:	0c dd       	rcall	.-1512   	; 0xfffffe6e <__eeprom_end+0xff7efc6e>
     456:	2c e3       	ldi	r18, 0x3C	; 60
     458:	30 e0       	ldi	r19, 0x00	; 0
     45a:	40 e0       	ldi	r20, 0x00	; 0
     45c:	50 e0       	ldi	r21, 0x00	; 0
     45e:	59 dd       	rcall	.-1358   	; 0xffffff12 <__eeprom_end+0xff7efd12>
     460:	69 01       	movw	r12, r18
     462:	7a 01       	movw	r14, r20
  //Calibrate Google GPS Coords
  if (numberLat) {
	  min = min + FUDGE_GOOGLE_LAT;    //Local calibration of Google GPS Lat (Truglodite)
  }
  else {
	  min = min + FUDGE_GOOGLE_LON;    //Local calibration of Google GPS Long (Truglodite)
     464:	80 ed       	ldi	r24, 0xD0	; 208
     466:	9d e1       	ldi	r25, 0x1D	; 29
     468:	a0 e0       	ldi	r26, 0x00	; 0
     46a:	b0 e0       	ldi	r27, 0x00	; 0
     46c:	c8 0e       	add	r12, r24
     46e:	d9 1e       	adc	r13, r25
     470:	ea 1e       	adc	r14, r26
     472:	fb 1e       	adc	r15, r27
	uint8_t min = (number - (hour * 1000000)) / 10000; //Get minute part
  uint32_t minDecimal = number % 10000; //Get minute decimal part
#endif

#ifdef GPS_GOOGLE_FORMAT
  pos = printNumberWithUnit(str, pos, hour, ".");
     474:	ce 01       	movw	r24, r28
     476:	61 2f       	mov	r22, r17
     478:	a5 01       	movw	r20, r10
     47a:	94 01       	movw	r18, r8
     47c:	04 e1       	ldi	r16, 0x14	; 20
     47e:	11 e0       	ldi	r17, 0x01	; 1
     480:	99 df       	rcall	.-206    	; 0x3b4 <printNumberWithUnit>
     482:	68 2f       	mov	r22, r24
  if (min < 10000) { // Added with inspiration from Joern
     484:	90 e1       	ldi	r25, 0x10	; 16
     486:	c9 16       	cp	r12, r25
     488:	97 e2       	ldi	r25, 0x27	; 39
     48a:	d9 06       	cpc	r13, r25
     48c:	90 e0       	ldi	r25, 0x00	; 0
     48e:	e9 06       	cpc	r14, r25
     490:	90 e0       	ldi	r25, 0x00	; 0
     492:	f9 06       	cpc	r15, r25
     494:	30 f4       	brcc	.+12     	; 0x4a2 <__stack+0xa2>
	  uint32_t temp = min;
		while (temp < 10000) {
			temp *= 10;
			pos = printNumber(str, pos, 0);
     496:	ce 01       	movw	r24, r28
     498:	20 e0       	ldi	r18, 0x00	; 0
     49a:	30 e0       	ldi	r19, 0x00	; 0
     49c:	a9 01       	movw	r20, r18
     49e:	b5 de       	rcall	.-662    	; 0x20a <printNumber>
     4a0:	68 2f       	mov	r22, r24
		}
  }
  return printNumberWithUnit(str, pos, min, str2);
     4a2:	ce 01       	movw	r24, r28
     4a4:	a7 01       	movw	r20, r14
     4a6:	96 01       	movw	r18, r12
     4a8:	83 01       	movw	r16, r6
     4aa:	84 df       	rcall	.-248    	; 0x3b4 <printNumberWithUnit>
			pos = printNumber(str, pos, 0);
		}
  }
  return printNumberWithUnit(str, pos, minDecimal, str2);
#endif
}
     4ac:	df 91       	pop	r29
     4ae:	cf 91       	pop	r28
     4b0:	1f 91       	pop	r17
     4b2:	0f 91       	pop	r16
     4b4:	ff 90       	pop	r15
     4b6:	ef 90       	pop	r14
     4b8:	df 90       	pop	r13
     4ba:	cf 90       	pop	r12
     4bc:	bf 90       	pop	r11
     4be:	af 90       	pop	r10
     4c0:	9f 90       	pop	r9
     4c2:	8f 90       	pop	r8
     4c4:	7f 90       	pop	r7
     4c6:	6f 90       	pop	r6
     4c8:	08 95       	ret
	  return pos;
  }
  
  const char* str2;
  if (numberLat) {
	  str2 = number > 0 ? "N" : "S";
     4ca:	12 16       	cp	r1, r18
     4cc:	13 06       	cpc	r1, r19
     4ce:	14 06       	cpc	r1, r20
     4d0:	15 06       	cpc	r1, r21
     4d2:	e4 f5       	brge	.+120    	; 0x54c <__stack+0x14c>
     4d4:	a0 e0       	ldi	r26, 0x00	; 0
     4d6:	6a 2e       	mov	r6, r26
     4d8:	a1 e0       	ldi	r26, 0x01	; 1
     4da:	7a 2e       	mov	r7, r26
     4dc:	69 01       	movw	r12, r18
     4de:	7a 01       	movw	r14, r20
     4e0:	57 fd       	sbrc	r21, 7
     4e2:	39 c0       	rjmp	.+114    	; 0x556 <__stack+0x156>
  }
  
  number = absi32(number);
 
	
	uint8_t hour = number / 1000000;
     4e4:	c7 01       	movw	r24, r14
     4e6:	b6 01       	movw	r22, r12
     4e8:	20 e4       	ldi	r18, 0x40	; 64
     4ea:	32 e4       	ldi	r19, 0x42	; 66
     4ec:	4f e0       	ldi	r20, 0x0F	; 15
     4ee:	50 e0       	ldi	r21, 0x00	; 0
     4f0:	32 dd       	rcall	.-1436   	; 0xffffff56 <__eeprom_end+0xff7efd56>
#ifdef GPS_GOOGLE_FORMAT
  uint32_t min = number - (hour * 1000000);
     4f2:	82 2e       	mov	r8, r18
     4f4:	99 24       	eor	r9, r9
     4f6:	aa 24       	eor	r10, r10
     4f8:	bb 24       	eor	r11, r11
     4fa:	c5 01       	movw	r24, r10
     4fc:	b4 01       	movw	r22, r8
     4fe:	20 ec       	ldi	r18, 0xC0	; 192
     500:	3d eb       	ldi	r19, 0xBD	; 189
     502:	40 ef       	ldi	r20, 0xF0	; 240
     504:	5f ef       	ldi	r21, 0xFF	; 255
     506:	b3 dc       	rcall	.-1690   	; 0xfffffe6e <__eeprom_end+0xff7efc6e>
     508:	6c 0d       	add	r22, r12
     50a:	7d 1d       	adc	r23, r13
     50c:	8e 1d       	adc	r24, r14
     50e:	9f 1d       	adc	r25, r15
  min = (min * 100)/60;
     510:	24 e6       	ldi	r18, 0x64	; 100
     512:	30 e0       	ldi	r19, 0x00	; 0
     514:	40 e0       	ldi	r20, 0x00	; 0
     516:	50 e0       	ldi	r21, 0x00	; 0
     518:	aa dc       	rcall	.-1708   	; 0xfffffe6e <__eeprom_end+0xff7efc6e>
     51a:	2c e3       	ldi	r18, 0x3C	; 60
     51c:	30 e0       	ldi	r19, 0x00	; 0
     51e:	40 e0       	ldi	r20, 0x00	; 0
     520:	50 e0       	ldi	r21, 0x00	; 0
     522:	f7 dc       	rcall	.-1554   	; 0xffffff12 <__eeprom_end+0xff7efd12>
     524:	69 01       	movw	r12, r18
     526:	7a 01       	movw	r14, r20
  //Calibrate Google GPS Coords
  if (numberLat) {
	  min = min + FUDGE_GOOGLE_LAT;    //Local calibration of Google GPS Lat (Truglodite)
     528:	8d e4       	ldi	r24, 0x4D	; 77
     52a:	94 e1       	ldi	r25, 0x14	; 20
     52c:	a0 e0       	ldi	r26, 0x00	; 0
     52e:	b0 e0       	ldi	r27, 0x00	; 0
     530:	c8 0e       	add	r12, r24
     532:	d9 1e       	adc	r13, r25
     534:	ea 1e       	adc	r14, r26
     536:	fb 1e       	adc	r15, r27
     538:	9d cf       	rjmp	.-198    	; 0x474 <__stack+0x74>
}*/

static uint8_t printGpsNumber(char* const str, uint8_t pos, int32_t number, uint8_t numberLat) {
	if (number == 0) {
#ifdef GPS_GOOGLE_FORMAT
    pos = printText(str, pos, "--.-------?");
     53a:	48 e0       	ldi	r20, 0x08	; 8
     53c:	51 e0       	ldi	r21, 0x01	; 1
     53e:	18 df       	rcall	.-464    	; 0x370 <printText>
#else
	  pos = printText(str, pos, "--:--.----?");
#endif
	  return pos;
     540:	b5 cf       	rjmp	.-150    	; 0x4ac <__stack+0xac>
  const char* str2;
  if (numberLat) {
	  str2 = number > 0 ? "N" : "S";
  }
  else {
	  str2 = number > 0 ? "E" : "W";
     542:	76 e0       	ldi	r23, 0x06	; 6
     544:	67 2e       	mov	r6, r23
     546:	71 e0       	ldi	r23, 0x01	; 1
     548:	77 2e       	mov	r7, r23
     54a:	66 cf       	rjmp	.-308    	; 0x418 <__stack+0x18>
	  return pos;
  }
  
  const char* str2;
  if (numberLat) {
	  str2 = number > 0 ? "N" : "S";
     54c:	f2 e0       	ldi	r31, 0x02	; 2
     54e:	6f 2e       	mov	r6, r31
     550:	f1 e0       	ldi	r31, 0x01	; 1
     552:	7f 2e       	mov	r7, r31
     554:	c3 cf       	rjmp	.-122    	; 0x4dc <__stack+0xdc>
     556:	f0 94       	com	r15
     558:	e0 94       	com	r14
     55a:	d0 94       	com	r13
     55c:	c0 94       	com	r12
     55e:	c1 1c       	adc	r12, r1
     560:	d1 1c       	adc	r13, r1
     562:	e1 1c       	adc	r14, r1
     564:	f1 1c       	adc	r15, r1
     566:	be cf       	rjmp	.-132    	; 0x4e4 <__stack+0xe4>
     568:	f0 94       	com	r15
     56a:	e0 94       	com	r14
     56c:	d0 94       	com	r13
     56e:	c0 94       	com	r12
     570:	c1 1c       	adc	r12, r1
     572:	d1 1c       	adc	r13, r1
     574:	e1 1c       	adc	r14, r1
     576:	f1 1c       	adc	r15, r1
     578:	53 cf       	rjmp	.-346    	; 0x420 <__stack+0x20>

0000057a <parseInt.clone.3>:
	tmp /= 1000;
	*var = tmp;
}
#endif //IMPERIAL_SYSTEM

static int32_t parseInt(const char* const text, uint8_t maxLength) {
     57a:	ff 92       	push	r15
     57c:	0f 93       	push	r16
     57e:	1f 93       	push	r17
	uint8_t i = 0;
     580:	ff 24       	eor	r15, r15
     582:	f3 94       	inc	r15
     584:	80 91 b9 03 	lds	r24, 0x03B9
     588:	8d 32       	cpi	r24, 0x2D	; 45
     58a:	09 f0       	breq	.+2      	; 0x58e <parseInt.clone.3+0x14>
     58c:	ff 24       	eor	r15, r15
	uint8_t neg = 0;
	if (text[0] == '-') {
		++i;
		neg = 1;
	}
	while (isDigit(text[i]) && i < maxLength) {
     58e:	ef 2d       	mov	r30, r15
     590:	f0 e0       	ldi	r31, 0x00	; 0
     592:	e7 54       	subi	r30, 0x47	; 71
     594:	fc 4f       	sbci	r31, 0xFC	; 252
     596:	00 81       	ld	r16, Z
  } while (c++ < 25);
  return nv;
}

inline uint8_t isDigit(char c) {
	if (c >= '0' && c <= '9') {
     598:	80 2f       	mov	r24, r16
     59a:	80 53       	subi	r24, 0x30	; 48
     59c:	8a 30       	cpi	r24, 0x0A	; 10
     59e:	70 f0       	brcs	.+28     	; 0x5bc <parseInt.clone.3+0x42>
     5a0:	20 e0       	ldi	r18, 0x00	; 0
     5a2:	30 e0       	ldi	r19, 0x00	; 0
     5a4:	a9 01       	movw	r20, r18
		decimal *= 10;
		decimal += (text[i]) - '0';
		++i;		
	}
	return decimal * (neg ? -1 : 1);
     5a6:	ff 20       	and	r15, r15
     5a8:	71 f5       	brne	.+92     	; 0x606 <parseInt.clone.3+0x8c>
     5aa:	61 e0       	ldi	r22, 0x01	; 1
     5ac:	70 e0       	ldi	r23, 0x00	; 0
     5ae:	80 e0       	ldi	r24, 0x00	; 0
     5b0:	90 e0       	ldi	r25, 0x00	; 0
     5b2:	5d dc       	rcall	.-1862   	; 0xfffffe6e <__eeprom_end+0xff7efc6e>
}
     5b4:	1f 91       	pop	r17
     5b6:	0f 91       	pop	r16
     5b8:	ff 90       	pop	r15
     5ba:	08 95       	ret
     5bc:	1f 2d       	mov	r17, r15
     5be:	20 e0       	ldi	r18, 0x00	; 0
     5c0:	30 e0       	ldi	r19, 0x00	; 0
     5c2:	a9 01       	movw	r20, r18
	if (text[0] == '-') {
		++i;
		neg = 1;
	}
	while (isDigit(text[i]) && i < maxLength) {
		decimal *= 10;
     5c4:	ca 01       	movw	r24, r20
     5c6:	b9 01       	movw	r22, r18
     5c8:	2a e0       	ldi	r18, 0x0A	; 10
     5ca:	30 e0       	ldi	r19, 0x00	; 0
     5cc:	40 e0       	ldi	r20, 0x00	; 0
     5ce:	50 e0       	ldi	r21, 0x00	; 0
     5d0:	4e dc       	rcall	.-1892   	; 0xfffffe6e <__eeprom_end+0xff7efc6e>
		decimal += (text[i]) - '0';
     5d2:	20 2f       	mov	r18, r16
     5d4:	30 e0       	ldi	r19, 0x00	; 0
     5d6:	20 53       	subi	r18, 0x30	; 48
     5d8:	30 40       	sbci	r19, 0x00	; 0
     5da:	44 27       	eor	r20, r20
     5dc:	37 fd       	sbrc	r19, 7
     5de:	40 95       	com	r20
     5e0:	54 2f       	mov	r21, r20
     5e2:	26 0f       	add	r18, r22
     5e4:	37 1f       	adc	r19, r23
     5e6:	48 1f       	adc	r20, r24
     5e8:	59 1f       	adc	r21, r25
		++i;		
     5ea:	1f 5f       	subi	r17, 0xFF	; 255
	uint8_t neg = 0;
	if (text[0] == '-') {
		++i;
		neg = 1;
	}
	while (isDigit(text[i]) && i < maxLength) {
     5ec:	e1 2f       	mov	r30, r17
     5ee:	f0 e0       	ldi	r31, 0x00	; 0
     5f0:	e7 54       	subi	r30, 0x47	; 71
     5f2:	fc 4f       	sbci	r31, 0xFC	; 252
     5f4:	00 81       	ld	r16, Z
     5f6:	80 2f       	mov	r24, r16
     5f8:	80 53       	subi	r24, 0x30	; 48
     5fa:	8a 30       	cpi	r24, 0x0A	; 10
     5fc:	a0 f6       	brcc	.-88     	; 0x5a6 <parseInt.clone.3+0x2c>
     5fe:	1b 30       	cpi	r17, 0x0B	; 11
     600:	08 f3       	brcs	.-62     	; 0x5c4 <parseInt.clone.3+0x4a>
		decimal *= 10;
		decimal += (text[i]) - '0';
		++i;		
	}
	return decimal * (neg ? -1 : 1);
     602:	ff 20       	and	r15, r15
     604:	91 f2       	breq	.-92     	; 0x5aa <parseInt.clone.3+0x30>
     606:	6f ef       	ldi	r22, 0xFF	; 255
     608:	7f ef       	ldi	r23, 0xFF	; 255
     60a:	cb 01       	movw	r24, r22
     60c:	30 dc       	rcall	.-1952   	; 0xfffffe6e <__eeprom_end+0xff7efc6e>
}
     60e:	1f 91       	pop	r17
     610:	0f 91       	pop	r16
     612:	ff 90       	pop	r15
     614:	08 95       	ret

00000616 <setPixel.clone.4>:
		}		
	}
}	

inline uint8_t validPos(uint8_t x, uint8_t y) {
	if (x >= GRAPHICS_WIDTH_REAL || y >= GRAPHICS_HEIGHT) {
     616:	88 31       	cpi	r24, 0x18	; 24
     618:	10 f4       	brcc	.+4      	; 0x61e <setPixel.clone.4+0x8>
     61a:	68 31       	cpi	r22, 0x18	; 24
     61c:	08 f0       	brcs	.+2      	; 0x620 <setPixel.clone.4+0xa>
     61e:	08 95       	ret
static void setPixel(uint8_t x, uint8_t y, uint8_t state) {
	if (!validPos(x, y)) {
		return;
	}
	uint8_t bitPos = 7-(x%8);
	uint8_t temp = gPixelData[x/8][y];
     620:	48 2f       	mov	r20, r24
     622:	46 95       	lsr	r20
     624:	46 95       	lsr	r20
     626:	46 95       	lsr	r20
     628:	50 e0       	ldi	r21, 0x00	; 0

static void setPixel(uint8_t x, uint8_t y, uint8_t state) {
	if (!validPos(x, y)) {
		return;
	}
	uint8_t bitPos = 7-(x%8);
     62a:	80 95       	com	r24
     62c:	87 70       	andi	r24, 0x07	; 7
	uint8_t temp = gPixelData[x/8][y];
	if (state == 0) {
		temp &= ~(1<<bitPos);
	}
	else if (state == 1) {
		temp |= (1<<bitPos);
     62e:	21 e0       	ldi	r18, 0x01	; 1
     630:	30 e0       	ldi	r19, 0x00	; 0
     632:	02 c0       	rjmp	.+4      	; 0x638 <setPixel.clone.4+0x22>
     634:	22 0f       	add	r18, r18
     636:	33 1f       	adc	r19, r19
     638:	8a 95       	dec	r24
     63a:	e2 f7       	brpl	.-8      	; 0x634 <setPixel.clone.4+0x1e>
static void setPixel(uint8_t x, uint8_t y, uint8_t state) {
	if (!validPos(x, y)) {
		return;
	}
	uint8_t bitPos = 7-(x%8);
	uint8_t temp = gPixelData[x/8][y];
     63c:	fa 01       	movw	r30, r20
     63e:	ee 0f       	add	r30, r30
     640:	ff 1f       	adc	r31, r31
     642:	e4 0f       	add	r30, r20
     644:	f5 1f       	adc	r31, r21
     646:	ee 0f       	add	r30, r30
     648:	ff 1f       	adc	r31, r31
     64a:	ee 0f       	add	r30, r30
     64c:	ff 1f       	adc	r31, r31
     64e:	ee 0f       	add	r30, r30
     650:	ff 1f       	adc	r31, r31
     652:	e6 0f       	add	r30, r22
     654:	f1 1d       	adc	r31, r1
     656:	ed 5a       	subi	r30, 0xAD	; 173
     658:	fc 4f       	sbci	r31, 0xFC	; 252
	if (state == 0) {
		temp &= ~(1<<bitPos);
	}
	else if (state == 1) {
		temp |= (1<<bitPos);
     65a:	80 81       	ld	r24, Z
     65c:	82 2b       	or	r24, r18
	}
	else {
		temp ^= (1<<bitPos);
	}
	gPixelData[x/8][y] = temp;
     65e:	80 83       	st	Z, r24
     660:	08 95       	ret

00000662 <drawCircle.clone.2>:
}

// Credit for this one goes to wikipedia! :-)
// Some mods done by me ( name, int -> uint8 )
static void drawCircle(uint8_t x0, uint8_t y0, uint8_t radius) {
     662:	ff 92       	push	r15
     664:	0f 93       	push	r16
     666:	1f 93       	push	r17
     668:	df 93       	push	r29
     66a:	cf 93       	push	r28
     66c:	00 d0       	rcall	.+0      	; 0x66e <drawCircle.clone.2+0xc>
     66e:	00 d0       	rcall	.+0      	; 0x670 <drawCircle.clone.2+0xe>
     670:	0f 92       	push	r0
     672:	cd b7       	in	r28, 0x3d	; 61
     674:	de b7       	in	r29, 0x3e	; 62
     676:	18 2f       	mov	r17, r24
  volatile int8_t f = 1 - radius;
     678:	81 e0       	ldi	r24, 0x01	; 1
     67a:	98 2f       	mov	r25, r24
     67c:	91 1b       	sub	r25, r17
     67e:	99 83       	std	Y+1, r25	; 0x01
  volatile int8_t ddF_x = 1;
     680:	8a 83       	std	Y+2, r24	; 0x02
  volatile int8_t ddF_y = -2 * radius;
     682:	81 2f       	mov	r24, r17
     684:	81 95       	neg	r24
     686:	88 0f       	add	r24, r24
     688:	8b 83       	std	Y+3, r24	; 0x03
  volatile int8_t x = 0;
     68a:	1c 82       	std	Y+4, r1	; 0x04
  volatile int8_t y = radius;
     68c:	1d 83       	std	Y+5, r17	; 0x05
 
  setPixel(x0, y0 + radius, 1);
     68e:	9b e0       	ldi	r25, 0x0B	; 11
     690:	f9 2e       	mov	r15, r25
     692:	f1 0e       	add	r15, r17
     694:	8b e0       	ldi	r24, 0x0B	; 11
     696:	6f 2d       	mov	r22, r15
     698:	be df       	rcall	.-132    	; 0x616 <setPixel.clone.4>
  setPixel(x0, y0 - radius, 1);
     69a:	0b e0       	ldi	r16, 0x0B	; 11
     69c:	01 1b       	sub	r16, r17
     69e:	8b e0       	ldi	r24, 0x0B	; 11
     6a0:	60 2f       	mov	r22, r16
     6a2:	b9 df       	rcall	.-142    	; 0x616 <setPixel.clone.4>
  setPixel(x0 + radius, y0, 1);
     6a4:	8f 2d       	mov	r24, r15
     6a6:	6b e0       	ldi	r22, 0x0B	; 11
     6a8:	b6 df       	rcall	.-148    	; 0x616 <setPixel.clone.4>
  setPixel(x0 - radius, y0, 1);
     6aa:	80 2f       	mov	r24, r16
     6ac:	6b e0       	ldi	r22, 0x0B	; 11
     6ae:	b3 df       	rcall	.-154    	; 0x616 <setPixel.clone.4>
 
  while(x < y) {
     6b0:	9c 81       	ldd	r25, Y+4	; 0x04
     6b2:	8d 81       	ldd	r24, Y+5	; 0x05
     6b4:	98 17       	cp	r25, r24
     6b6:	0c f0       	brlt	.+2      	; 0x6ba <drawCircle.clone.2+0x58>
     6b8:	51 c0       	rjmp	.+162    	; 0x75c <drawCircle.clone.2+0xfa>
    }
    x++;
    ddF_x += 2;
    f += ddF_x;    
    setPixel(x0 + x, y0 + y, 1);
    setPixel(x0 - x, y0 + y, 1);
     6ba:	1b e0       	ldi	r17, 0x0B	; 11
 
  while(x < y) {
    // ddF_x == 2 * x + 1;
    // ddF_y == -2 * y;
    // f == x*x + y*y - radius*radius + 2*x - y + 1;
    if(f >= 0) {
     6bc:	89 81       	ldd	r24, Y+1	; 0x01
     6be:	87 fd       	sbrc	r24, 7
     6c0:	0a c0       	rjmp	.+20     	; 0x6d6 <drawCircle.clone.2+0x74>
      y--;
     6c2:	8d 81       	ldd	r24, Y+5	; 0x05
     6c4:	81 50       	subi	r24, 0x01	; 1
     6c6:	8d 83       	std	Y+5, r24	; 0x05
      ddF_y += 2;
     6c8:	8b 81       	ldd	r24, Y+3	; 0x03
     6ca:	8e 5f       	subi	r24, 0xFE	; 254
     6cc:	8b 83       	std	Y+3, r24	; 0x03
      f += ddF_y;
     6ce:	99 81       	ldd	r25, Y+1	; 0x01
     6d0:	8b 81       	ldd	r24, Y+3	; 0x03
     6d2:	89 0f       	add	r24, r25
     6d4:	89 83       	std	Y+1, r24	; 0x01
    }
    x++;
     6d6:	8c 81       	ldd	r24, Y+4	; 0x04
     6d8:	8f 5f       	subi	r24, 0xFF	; 255
     6da:	8c 83       	std	Y+4, r24	; 0x04
    ddF_x += 2;
     6dc:	8a 81       	ldd	r24, Y+2	; 0x02
     6de:	8e 5f       	subi	r24, 0xFE	; 254
     6e0:	8a 83       	std	Y+2, r24	; 0x02
    f += ddF_x;    
     6e2:	99 81       	ldd	r25, Y+1	; 0x01
     6e4:	8a 81       	ldd	r24, Y+2	; 0x02
     6e6:	89 0f       	add	r24, r25
     6e8:	89 83       	std	Y+1, r24	; 0x01
    setPixel(x0 + x, y0 + y, 1);
     6ea:	8c 81       	ldd	r24, Y+4	; 0x04
     6ec:	6d 81       	ldd	r22, Y+5	; 0x05
     6ee:	65 5f       	subi	r22, 0xF5	; 245
     6f0:	85 5f       	subi	r24, 0xF5	; 245
     6f2:	91 df       	rcall	.-222    	; 0x616 <setPixel.clone.4>
    setPixel(x0 - x, y0 + y, 1);
     6f4:	8c 81       	ldd	r24, Y+4	; 0x04
     6f6:	6d 81       	ldd	r22, Y+5	; 0x05
     6f8:	65 5f       	subi	r22, 0xF5	; 245
     6fa:	91 2f       	mov	r25, r17
     6fc:	98 1b       	sub	r25, r24
     6fe:	89 2f       	mov	r24, r25
     700:	8a df       	rcall	.-236    	; 0x616 <setPixel.clone.4>
    setPixel(x0 + x, y0 - y, 1);
     702:	8c 81       	ldd	r24, Y+4	; 0x04
     704:	9d 81       	ldd	r25, Y+5	; 0x05
     706:	61 2f       	mov	r22, r17
     708:	69 1b       	sub	r22, r25
     70a:	85 5f       	subi	r24, 0xF5	; 245
     70c:	84 df       	rcall	.-248    	; 0x616 <setPixel.clone.4>
    setPixel(x0 - x, y0 - y, 1);
     70e:	8c 81       	ldd	r24, Y+4	; 0x04
     710:	9d 81       	ldd	r25, Y+5	; 0x05
     712:	61 2f       	mov	r22, r17
     714:	69 1b       	sub	r22, r25
     716:	91 2f       	mov	r25, r17
     718:	98 1b       	sub	r25, r24
     71a:	89 2f       	mov	r24, r25
     71c:	7c df       	rcall	.-264    	; 0x616 <setPixel.clone.4>
    setPixel(x0 + y, y0 + x, 1);
     71e:	8d 81       	ldd	r24, Y+5	; 0x05
     720:	6c 81       	ldd	r22, Y+4	; 0x04
     722:	65 5f       	subi	r22, 0xF5	; 245
     724:	85 5f       	subi	r24, 0xF5	; 245
     726:	77 df       	rcall	.-274    	; 0x616 <setPixel.clone.4>
    setPixel(x0 - y, y0 + x, 1);
     728:	8d 81       	ldd	r24, Y+5	; 0x05
     72a:	6c 81       	ldd	r22, Y+4	; 0x04
     72c:	65 5f       	subi	r22, 0xF5	; 245
     72e:	91 2f       	mov	r25, r17
     730:	98 1b       	sub	r25, r24
     732:	89 2f       	mov	r24, r25
     734:	70 df       	rcall	.-288    	; 0x616 <setPixel.clone.4>
    setPixel(x0 + y, y0 - x, 1);
     736:	8d 81       	ldd	r24, Y+5	; 0x05
     738:	9c 81       	ldd	r25, Y+4	; 0x04
     73a:	61 2f       	mov	r22, r17
     73c:	69 1b       	sub	r22, r25
     73e:	85 5f       	subi	r24, 0xF5	; 245
     740:	6a df       	rcall	.-300    	; 0x616 <setPixel.clone.4>
    setPixel(x0 - y, y0 - x, 1);
     742:	8d 81       	ldd	r24, Y+5	; 0x05
     744:	9c 81       	ldd	r25, Y+4	; 0x04
     746:	61 2f       	mov	r22, r17
     748:	69 1b       	sub	r22, r25
     74a:	91 2f       	mov	r25, r17
     74c:	98 1b       	sub	r25, r24
     74e:	89 2f       	mov	r24, r25
     750:	62 df       	rcall	.-316    	; 0x616 <setPixel.clone.4>
  setPixel(x0, y0 + radius, 1);
  setPixel(x0, y0 - radius, 1);
  setPixel(x0 + radius, y0, 1);
  setPixel(x0 - radius, y0, 1);
 
  while(x < y) {
     752:	9c 81       	ldd	r25, Y+4	; 0x04
     754:	8d 81       	ldd	r24, Y+5	; 0x05
     756:	98 17       	cp	r25, r24
     758:	0c f4       	brge	.+2      	; 0x75c <drawCircle.clone.2+0xfa>
     75a:	b0 cf       	rjmp	.-160    	; 0x6bc <drawCircle.clone.2+0x5a>
    setPixel(x0 + y, y0 + x, 1);
    setPixel(x0 - y, y0 + x, 1);
    setPixel(x0 + y, y0 - x, 1);
    setPixel(x0 - y, y0 - x, 1);
  }
}
     75c:	0f 90       	pop	r0
     75e:	0f 90       	pop	r0
     760:	0f 90       	pop	r0
     762:	0f 90       	pop	r0
     764:	0f 90       	pop	r0
     766:	cf 91       	pop	r28
     768:	df 91       	pop	r29
     76a:	1f 91       	pop	r17
     76c:	0f 91       	pop	r16
     76e:	ff 90       	pop	r15
     770:	08 95       	ret

00000772 <drawLine>:
	uint8_t temp = *a;
	*a = *b;
	*b = temp;
}

static void drawLine(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
     772:	af 92       	push	r10
     774:	bf 92       	push	r11
     776:	cf 92       	push	r12
     778:	df 92       	push	r13
     77a:	ef 92       	push	r14
     77c:	ff 92       	push	r15
     77e:	0f 93       	push	r16
     780:	1f 93       	push	r17
     782:	cf 93       	push	r28
     784:	df 93       	push	r29
     786:	d4 2e       	mov	r13, r20
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
     788:	42 2f       	mov	r20, r18
     78a:	50 e0       	ldi	r21, 0x00	; 0
     78c:	e6 2e       	mov	r14, r22
     78e:	ff 24       	eor	r15, r15
     790:	ed 2d       	mov	r30, r13
     792:	f0 e0       	ldi	r31, 0x00	; 0
     794:	a8 2f       	mov	r26, r24
     796:	b0 e0       	ldi	r27, 0x00	; 0
     798:	8a 01       	movw	r16, r20
     79a:	0e 19       	sub	r16, r14
     79c:	1f 09       	sbc	r17, r15
     79e:	17 fd       	sbrc	r17, 7
     7a0:	5f c0       	rjmp	.+190    	; 0x860 <drawLine+0xee>
     7a2:	ef 01       	movw	r28, r30
     7a4:	ca 1b       	sub	r28, r26
     7a6:	db 0b       	sbc	r29, r27
     7a8:	d7 fd       	sbrc	r29, 7
     7aa:	62 c0       	rjmp	.+196    	; 0x870 <drawLine+0xfe>
     7ac:	cc 24       	eor	r12, r12
     7ae:	c3 94       	inc	r12
     7b0:	c0 17       	cp	r28, r16
     7b2:	d1 07       	cpc	r29, r17
     7b4:	0c f4       	brge	.+2      	; 0x7b8 <drawLine+0x46>
     7b6:	3f c0       	rjmp	.+126    	; 0x836 <drawLine+0xc4>
     7b8:	cc 24       	eor	r12, r12
	if (steep) {
     7ba:	fa 01       	movw	r30, r20
     7bc:	d7 01       	movw	r26, r14
		swap(&x0, &y0);
		swap(&x1, &y1);
	}		 
	if (x0 > x1) {
     7be:	d8 16       	cp	r13, r24
     7c0:	08 f4       	brcc	.+2      	; 0x7c4 <drawLine+0x52>
     7c2:	42 c0       	rjmp	.+132    	; 0x848 <drawLine+0xd6>
     7c4:	ad 01       	movw	r20, r26
     7c6:	df 01       	movw	r26, r30
     7c8:	fa 01       	movw	r30, r20
	int8_t deltax = x1 - x0;
	int8_t deltay = abs(y1 - y0);
	int8_t error = deltax / 2;
	int8_t ystep;
	int8_t y = y0;
	if (y0 < y1) { 
     7ca:	62 17       	cp	r22, r18
     7cc:	08 f4       	brcc	.+2      	; 0x7d0 <drawLine+0x5e>
     7ce:	45 c0       	rjmp	.+138    	; 0x85a <drawLine+0xe8>
		ystep = 1; 
	}
	else {
		ystep = -1;
     7d0:	aa 24       	eor	r10, r10
     7d2:	aa 94       	dec	r10
	}		
	for (uint8_t x = x0; x <= x1; ++x) {
     7d4:	d8 16       	cp	r13, r24
     7d6:	20 f1       	brcs	.+72     	; 0x820 <drawLine+0xae>
	}		 
	if (x0 > x1) {
		swap(&x0, &x1);
		swap(&y0, &y1);
	}		 
	int8_t deltax = x1 - x0;
     7d8:	bd 2c       	mov	r11, r13
     7da:	b8 1a       	sub	r11, r24
	int8_t deltay = abs(y1 - y0);
	int8_t error = deltax / 2;
     7dc:	eb 2c       	mov	r14, r11
     7de:	b7 fc       	sbrc	r11, 7
     7e0:	4f c0       	rjmp	.+158    	; 0x880 <drawLine+0x10e>
     7e2:	e5 94       	asr	r14
	int8_t ystep;
	int8_t y = y0;
     7e4:	16 2f       	mov	r17, r22
	if (x0 > x1) {
		swap(&x0, &x1);
		swap(&y0, &y1);
	}		 
	int8_t deltax = x1 - x0;
	int8_t deltay = abs(y1 - y0);
     7e6:	ae 1b       	sub	r26, r30
     7e8:	bf 0b       	sbc	r27, r31
     7ea:	b7 fd       	sbrc	r27, 7
     7ec:	45 c0       	rjmp	.+138    	; 0x878 <drawLine+0x106>
     7ee:	fa 2e       	mov	r15, r26
     7f0:	08 2f       	mov	r16, r24
     7f2:	09 c0       	rjmp	.+18     	; 0x806 <drawLine+0x94>
	else {
		ystep = -1;
	}		
	for (uint8_t x = x0; x <= x1; ++x) {
		if (steep) {
			setPixel(y, x, 1);
     7f4:	81 2f       	mov	r24, r17
     7f6:	60 2f       	mov	r22, r16
     7f8:	0e df       	rcall	.-484    	; 0x616 <setPixel.clone.4>
		}
		else { 
			setPixel(x, y, 1);
		}			
		error = error - deltay;
     7fa:	ef 18       	sub	r14, r15
		if (error < 0) {
     7fc:	e7 fc       	sbrc	r14, 7
     7fe:	0b c0       	rjmp	.+22     	; 0x816 <drawLine+0xa4>
		ystep = 1; 
	}
	else {
		ystep = -1;
	}		
	for (uint8_t x = x0; x <= x1; ++x) {
     800:	0f 5f       	subi	r16, 0xFF	; 255
     802:	d0 16       	cp	r13, r16
     804:	68 f0       	brcs	.+26     	; 0x820 <drawLine+0xae>
		if (steep) {
     806:	cc 20       	and	r12, r12
     808:	a9 f7       	brne	.-22     	; 0x7f4 <drawLine+0x82>
			setPixel(y, x, 1);
		}
		else { 
			setPixel(x, y, 1);
     80a:	80 2f       	mov	r24, r16
     80c:	61 2f       	mov	r22, r17
     80e:	03 df       	rcall	.-506    	; 0x616 <setPixel.clone.4>
		}			
		error = error - deltay;
     810:	ef 18       	sub	r14, r15
		if (error < 0) {
     812:	e7 fe       	sbrs	r14, 7
     814:	f5 cf       	rjmp	.-22     	; 0x800 <drawLine+0x8e>
			y = y + ystep;
     816:	1a 0d       	add	r17, r10
			error = error + deltax;
     818:	eb 0c       	add	r14, r11
		ystep = 1; 
	}
	else {
		ystep = -1;
	}		
	for (uint8_t x = x0; x <= x1; ++x) {
     81a:	0f 5f       	subi	r16, 0xFF	; 255
     81c:	d0 16       	cp	r13, r16
     81e:	98 f7       	brcc	.-26     	; 0x806 <drawLine+0x94>
		if (error < 0) {
			y = y + ystep;
			error = error + deltax;
		}
	}				 
}
     820:	df 91       	pop	r29
     822:	cf 91       	pop	r28
     824:	1f 91       	pop	r17
     826:	0f 91       	pop	r16
     828:	ff 90       	pop	r15
     82a:	ef 90       	pop	r14
     82c:	df 90       	pop	r13
     82e:	cf 90       	pop	r12
     830:	bf 90       	pop	r11
     832:	af 90       	pop	r10
     834:	08 95       	ret
	*b = temp;
}

static void drawLine(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep) {
     836:	9d 2d       	mov	r25, r13
  }
}

static void swap(uint8_t* a, uint8_t* b) {
	uint8_t temp = *a;
	*a = *b;
     838:	d2 2e       	mov	r13, r18
	*b = temp;
     83a:	29 2f       	mov	r18, r25
}

static void drawLine(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep) {
     83c:	98 2f       	mov	r25, r24
  }
}

static void swap(uint8_t* a, uint8_t* b) {
	uint8_t temp = *a;
	*a = *b;
     83e:	86 2f       	mov	r24, r22
	*b = temp;
     840:	69 2f       	mov	r22, r25
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep) {
		swap(&x0, &y0);
		swap(&x1, &y1);
	}		 
	if (x0 > x1) {
     842:	d8 16       	cp	r13, r24
     844:	08 f0       	brcs	.+2      	; 0x848 <drawLine+0xd6>
     846:	be cf       	rjmp	.-132    	; 0x7c4 <drawLine+0x52>
     848:	96 2f       	mov	r25, r22
  }
}

static void swap(uint8_t* a, uint8_t* b) {
	uint8_t temp = *a;
	*a = *b;
     84a:	62 2f       	mov	r22, r18
	*b = temp;
     84c:	29 2f       	mov	r18, r25
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep) {
		swap(&x0, &y0);
		swap(&x1, &y1);
	}		 
	if (x0 > x1) {
     84e:	98 2f       	mov	r25, r24
     850:	8d 2d       	mov	r24, r13
     852:	d9 2e       	mov	r13, r25
	int8_t deltax = x1 - x0;
	int8_t deltay = abs(y1 - y0);
	int8_t error = deltax / 2;
	int8_t ystep;
	int8_t y = y0;
	if (y0 < y1) { 
     854:	62 17       	cp	r22, r18
     856:	08 f0       	brcs	.+2      	; 0x85a <drawLine+0xe8>
     858:	bb cf       	rjmp	.-138    	; 0x7d0 <drawLine+0x5e>
		ystep = 1; 
     85a:	aa 24       	eor	r10, r10
     85c:	a3 94       	inc	r10
     85e:	ba cf       	rjmp	.-140    	; 0x7d4 <drawLine+0x62>
	*a = *b;
	*b = temp;
}

static void drawLine(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
     860:	10 95       	com	r17
     862:	01 95       	neg	r16
     864:	1f 4f       	sbci	r17, 0xFF	; 255
     866:	ef 01       	movw	r28, r30
     868:	ca 1b       	sub	r28, r26
     86a:	db 0b       	sbc	r29, r27
     86c:	d7 ff       	sbrs	r29, 7
     86e:	9e cf       	rjmp	.-196    	; 0x7ac <drawLine+0x3a>
     870:	d0 95       	com	r29
     872:	c1 95       	neg	r28
     874:	df 4f       	sbci	r29, 0xFF	; 255
     876:	9a cf       	rjmp	.-204    	; 0x7ac <drawLine+0x3a>
	if (x0 > x1) {
		swap(&x0, &x1);
		swap(&y0, &y1);
	}		 
	int8_t deltax = x1 - x0;
	int8_t deltay = abs(y1 - y0);
     878:	b0 95       	com	r27
     87a:	a1 95       	neg	r26
     87c:	bf 4f       	sbci	r27, 0xFF	; 255
     87e:	b7 cf       	rjmp	.-146    	; 0x7ee <drawLine+0x7c>
	int8_t error = deltax / 2;
     880:	e3 94       	inc	r14
     882:	af cf       	rjmp	.-162    	; 0x7e2 <drawLine+0x70>

00000884 <parseFloat.clone.5>:

static int32_t parseFloat(const char* const text, uint8_t maxLength) {
     884:	ff 92       	push	r15
     886:	0f 93       	push	r16
     888:	1f 93       	push	r17
	
	uint32_t val = 0;
	uint8_t neg = 0;
     88a:	ff 24       	eor	r15, r15
     88c:	f3 94       	inc	r15
     88e:	80 91 b9 03 	lds	r24, 0x03B9
     892:	8d 32       	cpi	r24, 0x2D	; 45
     894:	09 f0       	breq	.+2      	; 0x898 <parseFloat.clone.5+0x14>
     896:	ff 24       	eor	r15, r15
     898:	1f 2d       	mov	r17, r15
     89a:	20 e0       	ldi	r18, 0x00	; 0
     89c:	30 e0       	ldi	r19, 0x00	; 0
     89e:	a9 01       	movw	r20, r18
     8a0:	16 c0       	rjmp	.+44     	; 0x8ce <parseFloat.clone.5+0x4a>
		++i;
		neg = 1;
	}
	for (; i < maxLength; ++i) {
		if (isDigit(text[i])) {
			val *= 10;
     8a2:	ca 01       	movw	r24, r20
     8a4:	b9 01       	movw	r22, r18
     8a6:	2a e0       	ldi	r18, 0x0A	; 10
     8a8:	30 e0       	ldi	r19, 0x00	; 0
     8aa:	40 e0       	ldi	r20, 0x00	; 0
     8ac:	50 e0       	ldi	r21, 0x00	; 0
     8ae:	df da       	rcall	.-2626   	; 0xfffffe6e <__eeprom_end+0xff7efc6e>
			val += (text[i]) - '0';
     8b0:	20 2f       	mov	r18, r16
     8b2:	30 e0       	ldi	r19, 0x00	; 0
     8b4:	20 53       	subi	r18, 0x30	; 48
     8b6:	30 40       	sbci	r19, 0x00	; 0
     8b8:	44 27       	eor	r20, r20
     8ba:	37 fd       	sbrc	r19, 7
     8bc:	40 95       	com	r20
     8be:	54 2f       	mov	r21, r20
     8c0:	26 0f       	add	r18, r22
     8c2:	37 1f       	adc	r19, r23
     8c4:	48 1f       	adc	r20, r24
     8c6:	59 1f       	adc	r21, r25
	uint8_t i = 0;
	if (text[0] == '-') {
		++i;
		neg = 1;
	}
	for (; i < maxLength; ++i) {
     8c8:	1f 5f       	subi	r17, 0xFF	; 255
     8ca:	1b 30       	cpi	r17, 0x0B	; 11
     8cc:	58 f4       	brcc	.+22     	; 0x8e4 <parseFloat.clone.5+0x60>
		if (isDigit(text[i])) {
     8ce:	e1 2f       	mov	r30, r17
     8d0:	f0 e0       	ldi	r31, 0x00	; 0
     8d2:	e7 54       	subi	r30, 0x47	; 71
     8d4:	fc 4f       	sbci	r31, 0xFC	; 252
     8d6:	00 81       	ld	r16, Z
     8d8:	80 2f       	mov	r24, r16
     8da:	80 53       	subi	r24, 0x30	; 48
     8dc:	8a 30       	cpi	r24, 0x0A	; 10
     8de:	08 f3       	brcs	.-62     	; 0x8a2 <parseFloat.clone.5+0x1e>
			val *= 10;
			val += (text[i]) - '0';
		}
		else if (text[i] != '.') {
     8e0:	0e 32       	cpi	r16, 0x2E	; 46
     8e2:	91 f3       	breq	.-28     	; 0x8c8 <parseFloat.clone.5+0x44>
			break;
		}			
	}
	return val * (neg ? -1 : 1);
     8e4:	ff 20       	and	r15, r15
     8e6:	49 f4       	brne	.+18     	; 0x8fa <parseFloat.clone.5+0x76>
     8e8:	61 e0       	ldi	r22, 0x01	; 1
     8ea:	70 e0       	ldi	r23, 0x00	; 0
     8ec:	80 e0       	ldi	r24, 0x00	; 0
     8ee:	90 e0       	ldi	r25, 0x00	; 0
     8f0:	be da       	rcall	.-2692   	; 0xfffffe6e <__eeprom_end+0xff7efc6e>
}
     8f2:	1f 91       	pop	r17
     8f4:	0f 91       	pop	r16
     8f6:	ff 90       	pop	r15
     8f8:	08 95       	ret
		}
		else if (text[i] != '.') {
			break;
		}			
	}
	return val * (neg ? -1 : 1);
     8fa:	6f ef       	ldi	r22, 0xFF	; 255
     8fc:	7f ef       	ldi	r23, 0xFF	; 255
     8fe:	cb 01       	movw	r24, r22
     900:	b6 da       	rcall	.-2708   	; 0xfffffe6e <__eeprom_end+0xff7efc6e>
}
     902:	1f 91       	pop	r17
     904:	0f 91       	pop	r16
     906:	ff 90       	pop	r15
     908:	08 95       	ret

0000090a <parseGpsPart>:
	gGpsTextPartLength = strlen((const char*)gGpsText);
}
#endif //GPS_PART_TEXT

static void parseGpsPart() {
	if (gGpsTextType == GPS_TYPE_NONE) {
     90a:	80 91 b7 03 	lds	r24, 0x03B7
     90e:	88 23       	and	r24, r24
     910:	71 f1       	breq	.+92     	; 0x96e <parseGpsPart+0x64>
			gGpsTextPartStep = GPS_GPRMC_PART_OFFSET;
			//updateParts();
		}
	}
	else if (gGpsTextType != GPS_TYPE_NONE) {
		if (gGpsTextPos != 0) {
     912:	80 91 b6 03 	lds	r24, 0x03B6
     916:	88 23       	and	r24, r24
     918:	49 f1       	breq	.+82     	; 0x96c <parseGpsPart+0x62>
			switch (gGpsTextPartStep) {
     91a:	80 91 72 01 	lds	r24, 0x0172
     91e:	85 36       	cpi	r24, 0x65	; 101
     920:	89 f0       	breq	.+34     	; 0x944 <parseGpsPart+0x3a>
     922:	86 36       	cpi	r24, 0x66	; 102
     924:	08 f0       	brcs	.+2      	; 0x928 <parseGpsPart+0x1e>
     926:	42 c0       	rjmp	.+132    	; 0x9ac <parseGpsPart+0xa2>
     928:	84 30       	cpi	r24, 0x04	; 4
     92a:	09 f4       	brne	.+2      	; 0x92e <parseGpsPart+0x24>
     92c:	71 c0       	rjmp	.+226    	; 0xa10 <parseGpsPart+0x106>
     92e:	85 30       	cpi	r24, 0x05	; 5
     930:	08 f0       	brcs	.+2      	; 0x934 <parseGpsPart+0x2a>
     932:	78 c0       	rjmp	.+240    	; 0xa24 <parseGpsPart+0x11a>
     934:	82 30       	cpi	r24, 0x02	; 2
     936:	09 f4       	brne	.+2      	; 0x93a <parseGpsPart+0x30>
     938:	45 c0       	rjmp	.+138    	; 0x9c4 <parseGpsPart+0xba>
     93a:	83 30       	cpi	r24, 0x03	; 3
     93c:	08 f0       	brcs	.+2      	; 0x940 <parseGpsPart+0x36>
     93e:	0d c1       	rjmp	.+538    	; 0xb5a <parseGpsPart+0x250>
     940:	81 30       	cpi	r24, 0x01	; 1
     942:	a1 f4       	brne	.+40     	; 0x96c <parseGpsPart+0x62>
			case GPS_PART_GPGGA_TIME:
			case GPS_PART_GPRMC_TIME:
				gGpsLastData.gTime = parseInt(gGpsText, GPS_MAX_CHARS);
     944:	1a de       	rcall	.-972    	; 0x57a <parseInt.clone.3>
     946:	60 93 a7 03 	sts	0x03A7, r22
     94a:	70 93 a8 03 	sts	0x03A8, r23
     94e:	80 93 a9 03 	sts	0x03A9, r24
     952:	90 93 aa 03 	sts	0x03AA, r25
				//updateParts();
				break;
     956:	08 95       	ret

static uint8_t parseHex(const char* const text, uint8_t maxLength) {
	uint8_t i = 0;
	uint32_t val = 0;
	while (text[i] != 0 && i < maxLength) {
     958:	80 e0       	ldi	r24, 0x00	; 0
     95a:	90 e0       	ldi	r25, 0x00	; 0
     95c:	dc 01       	movw	r26, r24
			  break;
			case GPS_PART_CHECKSUM:
				//updateParts();
				{
				uint8_t val = parseHex(gGpsText, GPS_MAX_CHARS);
				gGpsLastData.checksumValid = (val == gGpsChecksum);
     95e:	21 e0       	ldi	r18, 0x01	; 1
     960:	30 91 b8 03 	lds	r19, 0x03B8
     964:	38 13       	cpse	r19, r24
     966:	20 e0       	ldi	r18, 0x00	; 0
     968:	20 93 b5 03 	sts	0x03B5, r18
     96c:	08 95       	ret
}
#endif //GPS_PART_TEXT

static void parseGpsPart() {
	if (gGpsTextType == GPS_TYPE_NONE) {
		if (!strncmp((const char*)gGpsText, "GPGGA", 5)) {
     96e:	89 eb       	ldi	r24, 0xB9	; 185
     970:	93 e0       	ldi	r25, 0x03	; 3
     972:	66 e1       	ldi	r22, 0x16	; 22
     974:	71 e0       	ldi	r23, 0x01	; 1
     976:	45 e0       	ldi	r20, 0x05	; 5
     978:	50 e0       	ldi	r21, 0x00	; 0
     97a:	08 db       	rcall	.-2544   	; 0xffffff8c <__eeprom_end+0xff7efd8c>
     97c:	00 97       	sbiw	r24, 0x00	; 0
     97e:	81 f0       	breq	.+32     	; 0x9a0 <parseGpsPart+0x96>
			gGpsTextType = GPS_TYPE_GPGGA;
			gGpsTextPartStep = GPS_PART_NONE;
			//updateParts();
		}
		else if (!strncmp((const char*)gGpsText, "GPRMC", 5)) {
     980:	89 eb       	ldi	r24, 0xB9	; 185
     982:	93 e0       	ldi	r25, 0x03	; 3
     984:	6c e1       	ldi	r22, 0x1C	; 28
     986:	71 e0       	ldi	r23, 0x01	; 1
     988:	45 e0       	ldi	r20, 0x05	; 5
     98a:	50 e0       	ldi	r21, 0x00	; 0
     98c:	ff da       	rcall	.-2562   	; 0xffffff8c <__eeprom_end+0xff7efd8c>
     98e:	00 97       	sbiw	r24, 0x00	; 0
     990:	69 f7       	brne	.-38     	; 0x96c <parseGpsPart+0x62>
			gGpsTextType = GPS_TYPE_GPRMC;
     992:	82 e0       	ldi	r24, 0x02	; 2
     994:	80 93 b7 03 	sts	0x03B7, r24
			gGpsTextPartStep = GPS_GPRMC_PART_OFFSET;
     998:	84 e6       	ldi	r24, 0x64	; 100
     99a:	80 93 72 01 	sts	0x0172, r24
     99e:	08 95       	ret
#endif //GPS_PART_TEXT

static void parseGpsPart() {
	if (gGpsTextType == GPS_TYPE_NONE) {
		if (!strncmp((const char*)gGpsText, "GPGGA", 5)) {
			gGpsTextType = GPS_TYPE_GPGGA;
     9a0:	81 e0       	ldi	r24, 0x01	; 1
     9a2:	80 93 b7 03 	sts	0x03B7, r24
			gGpsTextPartStep = GPS_PART_NONE;
     9a6:	10 92 72 01 	sts	0x0172, r1
     9aa:	08 95       	ret
			//updateParts();
		}
	}
	else if (gGpsTextType != GPS_TYPE_NONE) {
		if (gGpsTextPos != 0) {
			switch (gGpsTextPartStep) {
     9ac:	8a 36       	cpi	r24, 0x6A	; 106
     9ae:	a1 f0       	breq	.+40     	; 0x9d8 <parseGpsPart+0xce>
     9b0:	8b 36       	cpi	r24, 0x6B	; 107
     9b2:	08 f0       	brcs	.+2      	; 0x9b6 <parseGpsPart+0xac>
     9b4:	48 c0       	rjmp	.+144    	; 0xa46 <parseGpsPart+0x13c>
     9b6:	88 36       	cpi	r24, 0x68	; 104
     9b8:	09 f4       	brne	.+2      	; 0x9bc <parseGpsPart+0xb2>
     9ba:	cf c0       	rjmp	.+414    	; 0xb5a <parseGpsPart+0x250>
     9bc:	89 36       	cpi	r24, 0x69	; 105
     9be:	40 f5       	brcc	.+80     	; 0xa10 <parseGpsPart+0x106>
     9c0:	87 36       	cpi	r24, 0x67	; 103
     9c2:	a1 f6       	brne	.-88     	; 0x96c <parseGpsPart+0x62>
				gGpsLastData.gTime = parseInt(gGpsText, GPS_MAX_CHARS);
				//updateParts();
				break;
			case GPS_PART_GPGGA_LAT:
			case GPS_PART_GPRMC_LAT:
				gGpsLastData.pos.latitude = parseFloat(gGpsText, GPS_MAX_CHARS);
     9c4:	5f df       	rcall	.-322    	; 0x884 <parseFloat.clone.5>
     9c6:	60 93 9d 03 	sts	0x039D, r22
     9ca:	70 93 9e 03 	sts	0x039E, r23
     9ce:	80 93 9f 03 	sts	0x039F, r24
     9d2:	90 93 a0 03 	sts	0x03A0, r25
				//updateParts();
				break;
     9d6:	08 95       	ret
				gGpsLastData.pos.longitude = parseFloat(gGpsText, GPS_MAX_CHARS);
				//updateParts();
				break;
			case GPS_PART_GPGGA_LONG_UNIT:
			case GPS_PART_GPRMC_LONG_UNIT:
				if (gGpsText[0] == 'W') {
     9d8:	80 91 b9 03 	lds	r24, 0x03B9
     9dc:	87 35       	cpi	r24, 0x57	; 87
     9de:	31 f6       	brne	.-116    	; 0x96c <parseGpsPart+0x62>
					gGpsLastData.pos.longitude = -gGpsLastData.pos.longitude;
     9e0:	80 91 a1 03 	lds	r24, 0x03A1
     9e4:	90 91 a2 03 	lds	r25, 0x03A2
     9e8:	a0 91 a3 03 	lds	r26, 0x03A3
     9ec:	b0 91 a4 03 	lds	r27, 0x03A4
     9f0:	b0 95       	com	r27
     9f2:	a0 95       	com	r26
     9f4:	90 95       	com	r25
     9f6:	81 95       	neg	r24
     9f8:	9f 4f       	sbci	r25, 0xFF	; 255
     9fa:	af 4f       	sbci	r26, 0xFF	; 255
     9fc:	bf 4f       	sbci	r27, 0xFF	; 255
     9fe:	80 93 a1 03 	sts	0x03A1, r24
     a02:	90 93 a2 03 	sts	0x03A2, r25
     a06:	a0 93 a3 03 	sts	0x03A3, r26
     a0a:	b0 93 a4 03 	sts	0x03A4, r27
     a0e:	08 95       	ret
					gGpsLastData.pos.latitude = -gGpsLastData.pos.latitude;
				}
				break;
			case GPS_PART_GPGGA_LONG:
			case GPS_PART_GPRMC_LONG:
				gGpsLastData.pos.longitude = parseFloat(gGpsText, GPS_MAX_CHARS);
     a10:	39 df       	rcall	.-398    	; 0x884 <parseFloat.clone.5>
     a12:	60 93 a1 03 	sts	0x03A1, r22
     a16:	70 93 a2 03 	sts	0x03A2, r23
     a1a:	80 93 a3 03 	sts	0x03A3, r24
     a1e:	90 93 a4 03 	sts	0x03A4, r25
				//updateParts();
				break;
     a22:	08 95       	ret
			//updateParts();
		}
	}
	else if (gGpsTextType != GPS_TYPE_NONE) {
		if (gGpsTextPos != 0) {
			switch (gGpsTextPartStep) {
     a24:	86 30       	cpi	r24, 0x06	; 6
     a26:	09 f4       	brne	.+2      	; 0xa2a <parseGpsPart+0x120>
     a28:	94 c0       	rjmp	.+296    	; 0xb52 <parseGpsPart+0x248>
     a2a:	86 30       	cpi	r24, 0x06	; 6
     a2c:	a8 f2       	brcs	.-86     	; 0x9d8 <parseGpsPart+0xce>
     a2e:	87 30       	cpi	r24, 0x07	; 7
     a30:	09 f4       	brne	.+2      	; 0xa34 <parseGpsPart+0x12a>
     a32:	8b c0       	rjmp	.+278    	; 0xb4a <parseGpsPart+0x240>
     a34:	89 30       	cpi	r24, 0x09	; 9
     a36:	09 f0       	breq	.+2      	; 0xa3a <parseGpsPart+0x130>
     a38:	99 cf       	rjmp	.-206    	; 0x96c <parseGpsPart+0x62>
				break;
			case GPS_PART_GPGGA_DILUTION:
				// Horizontal dilution of position
				break;
			case GPS_PART_GPGGA_ALTITUDE:
				gGpsLastData.pos.altitude = parseInt(gGpsText, GPS_MAX_CHARS);
     a3a:	9f dd       	rcall	.-1218   	; 0x57a <parseInt.clone.3>
     a3c:	70 93 a6 03 	sts	0x03A6, r23
     a40:	60 93 a5 03 	sts	0x03A5, r22
#ifdef IMPERIAL_SYSTEM
        meterToFeet(&gGpsLastData.pos.altitude);
#endif // IMPERIAL_SYSTEM
				//updateParts();
				break;
     a44:	08 95       	ret
			//updateParts();
		}
	}
	else if (gGpsTextType != GPS_TYPE_NONE) {
		if (gGpsTextPos != 0) {
			switch (gGpsTextPartStep) {
     a46:	8c 36       	cpi	r24, 0x6C	; 108
     a48:	09 f4       	brne	.+2      	; 0xa4c <parseGpsPart+0x142>
     a4a:	79 c0       	rjmp	.+242    	; 0xb3e <parseGpsPart+0x234>
     a4c:	8c 36       	cpi	r24, 0x6C	; 108
     a4e:	08 f4       	brcc	.+2      	; 0xa52 <parseGpsPart+0x148>
     a50:	63 c0       	rjmp	.+198    	; 0xb18 <parseGpsPart+0x20e>
     a52:	8d 36       	cpi	r24, 0x6D	; 109
     a54:	09 f4       	brne	.+2      	; 0xa58 <parseGpsPart+0x14e>
     a56:	56 c0       	rjmp	.+172    	; 0xb04 <parseGpsPart+0x1fa>
     a58:	88 3c       	cpi	r24, 0xC8	; 200
     a5a:	09 f0       	breq	.+2      	; 0xa5e <parseGpsPart+0x154>
     a5c:	87 cf       	rjmp	.-242    	; 0x96c <parseGpsPart+0x62>
     a5e:	20 91 b9 03 	lds	r18, 0x03B9
     a62:	22 23       	and	r18, r18
     a64:	09 f4       	brne	.+2      	; 0xa68 <parseGpsPart+0x15e>
     a66:	78 cf       	rjmp	.-272    	; 0x958 <parseGpsPart+0x4e>
			case GPS_PART_GPRMC_ANGLE:
				gGpsLastData.angle = parseInt(gGpsText, GPS_MAX_CHARS); // Only use int part
				break;
			case GPS_PART_GPRMC_DATE:
			  gGpsLastData.date = parseInt(gGpsText, GPS_MAX_CHARS);
			  break;
     a68:	ea eb       	ldi	r30, 0xBA	; 186
     a6a:	f3 e0       	ldi	r31, 0x03	; 3
	strncpy((char*)gGpsTextPart, (char*)gGpsText, GPS_MAX_CHARS);
	gGpsTextPartLength = strlen((const char*)gGpsText);
}
#endif //GPS_PART_TEXT

static void parseGpsPart() {
     a6c:	80 e0       	ldi	r24, 0x00	; 0
     a6e:	90 e0       	ldi	r25, 0x00	; 0
     a70:	dc 01       	movw	r26, r24
     a72:	14 c0       	rjmp	.+40     	; 0xa9c <parseGpsPart+0x192>
		val *= 16;
		if (text[i] >= 'A' && text[i] <= 'F') {
			val += 10 + text[i] - 'A';
     a74:	30 e0       	ldi	r19, 0x00	; 0
     a76:	27 53       	subi	r18, 0x37	; 55
     a78:	30 40       	sbci	r19, 0x00	; 0
     a7a:	44 27       	eor	r20, r20
     a7c:	37 fd       	sbrc	r19, 7
     a7e:	40 95       	com	r20
     a80:	54 2f       	mov	r21, r20
     a82:	82 0f       	add	r24, r18
     a84:	93 1f       	adc	r25, r19
     a86:	a4 1f       	adc	r26, r20
     a88:	b5 1f       	adc	r27, r21
}

static uint8_t parseHex(const char* const text, uint8_t maxLength) {
	uint8_t i = 0;
	uint32_t val = 0;
	while (text[i] != 0 && i < maxLength) {
     a8a:	21 91       	ld	r18, Z+
     a8c:	22 23       	and	r18, r18
     a8e:	09 f4       	brne	.+2      	; 0xa92 <parseGpsPart+0x188>
     a90:	66 cf       	rjmp	.-308    	; 0x95e <parseGpsPart+0x54>
     a92:	33 e0       	ldi	r19, 0x03	; 3
     a94:	e5 3c       	cpi	r30, 0xC5	; 197
     a96:	f3 07       	cpc	r31, r19
     a98:	09 f4       	brne	.+2      	; 0xa9c <parseGpsPart+0x192>
     a9a:	61 cf       	rjmp	.-318    	; 0x95e <parseGpsPart+0x54>
		val *= 16;
     a9c:	88 0f       	add	r24, r24
     a9e:	99 1f       	adc	r25, r25
     aa0:	aa 1f       	adc	r26, r26
     aa2:	bb 1f       	adc	r27, r27
     aa4:	88 0f       	add	r24, r24
     aa6:	99 1f       	adc	r25, r25
     aa8:	aa 1f       	adc	r26, r26
     aaa:	bb 1f       	adc	r27, r27
     aac:	88 0f       	add	r24, r24
     aae:	99 1f       	adc	r25, r25
     ab0:	aa 1f       	adc	r26, r26
     ab2:	bb 1f       	adc	r27, r27
     ab4:	88 0f       	add	r24, r24
     ab6:	99 1f       	adc	r25, r25
     ab8:	aa 1f       	adc	r26, r26
     aba:	bb 1f       	adc	r27, r27
		if (text[i] >= 'A' && text[i] <= 'F') {
     abc:	32 2f       	mov	r19, r18
     abe:	31 54       	subi	r19, 0x41	; 65
     ac0:	36 30       	cpi	r19, 0x06	; 6
     ac2:	c0 f2       	brcs	.-80     	; 0xa74 <parseGpsPart+0x16a>
			val += 10 + text[i] - 'A';
		}
		else if (text[i] >= 'a' && text[i] <= 'f') {
     ac4:	32 2f       	mov	r19, r18
     ac6:	31 56       	subi	r19, 0x61	; 97
     ac8:	36 30       	cpi	r19, 0x06	; 6
     aca:	60 f4       	brcc	.+24     	; 0xae4 <parseGpsPart+0x1da>
			val += 10 + text[i] - 'a';
     acc:	30 e0       	ldi	r19, 0x00	; 0
     ace:	27 55       	subi	r18, 0x57	; 87
     ad0:	30 40       	sbci	r19, 0x00	; 0
     ad2:	44 27       	eor	r20, r20
     ad4:	37 fd       	sbrc	r19, 7
     ad6:	40 95       	com	r20
     ad8:	54 2f       	mov	r21, r20
     ada:	82 0f       	add	r24, r18
     adc:	93 1f       	adc	r25, r19
     ade:	a4 1f       	adc	r26, r20
     ae0:	b5 1f       	adc	r27, r21
     ae2:	d3 cf       	rjmp	.-90     	; 0xa8a <parseGpsPart+0x180>
		}
		else if (text[i] >= '0' && text[i] <= '9') {
     ae4:	32 2f       	mov	r19, r18
     ae6:	30 53       	subi	r19, 0x30	; 48
     ae8:	3a 30       	cpi	r19, 0x0A	; 10
     aea:	78 f6       	brcc	.-98     	; 0xa8a <parseGpsPart+0x180>
			val += text[i] - '0';
     aec:	30 e0       	ldi	r19, 0x00	; 0
     aee:	20 53       	subi	r18, 0x30	; 48
     af0:	30 40       	sbci	r19, 0x00	; 0
     af2:	44 27       	eor	r20, r20
     af4:	37 fd       	sbrc	r19, 7
     af6:	40 95       	com	r20
     af8:	54 2f       	mov	r21, r20
     afa:	82 0f       	add	r24, r18
     afc:	93 1f       	adc	r25, r19
     afe:	a4 1f       	adc	r26, r20
     b00:	b5 1f       	adc	r27, r21
     b02:	c3 cf       	rjmp	.-122    	; 0xa8a <parseGpsPart+0x180>
				break;
			case GPS_PART_GPRMC_ANGLE:
				gGpsLastData.angle = parseInt(gGpsText, GPS_MAX_CHARS); // Only use int part
				break;
			case GPS_PART_GPRMC_DATE:
			  gGpsLastData.date = parseInt(gGpsText, GPS_MAX_CHARS);
     b04:	3a dd       	rcall	.-1420   	; 0x57a <parseInt.clone.3>
     b06:	60 93 b1 03 	sts	0x03B1, r22
     b0a:	70 93 b2 03 	sts	0x03B2, r23
     b0e:	80 93 b3 03 	sts	0x03B3, r24
     b12:	90 93 b4 03 	sts	0x03B4, r25
			  break;
     b16:	08 95       	ret
				break;
			case GPS_PART_GPGGA_GEOID_HEIGHT_UNIT:
				// Geoid unit
				break;
			case GPS_PART_GPRMC_SPEED:
				gGpsLastData.speed = parseInt(gGpsText, GPS_MAX_CHARS); // Only use int part
     b18:	30 dd       	rcall	.-1440   	; 0x57a <parseInt.clone.3>
#ifdef METRIC_SYSTEM
#ifndef GOSDII_GPS_SPEED_BUGFIX
				// Convert to km/h. 1 knot = 1.852 km/h = 463/250
				gGpsLastData.speed *= 463; // Might need bigger var if you go really fast! :-)
     b1a:	4f ec       	ldi	r20, 0xCF	; 207
     b1c:	51 e0       	ldi	r21, 0x01	; 1
     b1e:	64 9f       	mul	r22, r20
     b20:	90 01       	movw	r18, r0
     b22:	65 9f       	mul	r22, r21
     b24:	30 0d       	add	r19, r0
     b26:	74 9f       	mul	r23, r20
     b28:	30 0d       	add	r19, r0
     b2a:	11 24       	eor	r1, r1
				gGpsLastData.speed /= 250;
     b2c:	c9 01       	movw	r24, r18
     b2e:	6a ef       	ldi	r22, 0xFA	; 250
     b30:	70 e0       	ldi	r23, 0x00	; 0
     b32:	c8 d9       	rcall	.-3184   	; 0xfffffec4 <__eeprom_end+0xff7efcc4>
     b34:	70 93 ae 03 	sts	0x03AE, r23
     b38:	60 93 ad 03 	sts	0x03AD, r22
        knotToMph(&gGpsLastData.speed);
#else
		    kmphToMph(&gGpsLastData.speed);
#endif
#endif // METRIC_SYSTEM
				break;
     b3c:	08 95       	ret
			case GPS_PART_GPRMC_ANGLE:
				gGpsLastData.angle = parseInt(gGpsText, GPS_MAX_CHARS); // Only use int part
     b3e:	1d dd       	rcall	.-1478   	; 0x57a <parseInt.clone.3>
     b40:	70 93 b0 03 	sts	0x03B0, r23
     b44:	60 93 af 03 	sts	0x03AF, r22
				break;
     b48:	08 95       	ret
				break;
			case GPS_PART_GPRMC_STATUS:
				// Status
				break;
			case GPS_PART_GPGGA_SATS:
				gGpsLastData.sats = parseInt(gGpsText, GPS_MAX_CHARS);
     b4a:	17 dd       	rcall	.-1490   	; 0x57a <parseInt.clone.3>
     b4c:	60 93 ac 03 	sts	0x03AC, r22
				//updateParts();
				break;
     b50:	08 95       	ret
					gGpsLastData.pos.longitude = -gGpsLastData.pos.longitude;
				}
				//updateParts();
				break;
			case GPS_PART_GPGGA_FIX:
				gGpsLastData.fix = parseInt(gGpsText, GPS_MAX_CHARS);
     b52:	13 dd       	rcall	.-1498   	; 0x57a <parseInt.clone.3>
     b54:	60 93 ab 03 	sts	0x03AB, r22
				//updateParts();
				break;
     b58:	08 95       	ret
				gGpsLastData.pos.latitude = parseFloat(gGpsText, GPS_MAX_CHARS);
				//updateParts();
				break;
			case GPS_PART_GPGGA_LAT_UNIT:
			case GPS_PART_GPRMC_LAT_UNIT:
				if (gGpsText[0] == 'S') {
     b5a:	80 91 b9 03 	lds	r24, 0x03B9
     b5e:	83 35       	cpi	r24, 0x53	; 83
     b60:	09 f0       	breq	.+2      	; 0xb64 <parseGpsPart+0x25a>
     b62:	04 cf       	rjmp	.-504    	; 0x96c <parseGpsPart+0x62>
					gGpsLastData.pos.latitude = -gGpsLastData.pos.latitude;
     b64:	80 91 9d 03 	lds	r24, 0x039D
     b68:	90 91 9e 03 	lds	r25, 0x039E
     b6c:	a0 91 9f 03 	lds	r26, 0x039F
     b70:	b0 91 a0 03 	lds	r27, 0x03A0
     b74:	b0 95       	com	r27
     b76:	a0 95       	com	r26
     b78:	90 95       	com	r25
     b7a:	81 95       	neg	r24
     b7c:	9f 4f       	sbci	r25, 0xFF	; 255
     b7e:	af 4f       	sbci	r26, 0xFF	; 255
     b80:	bf 4f       	sbci	r27, 0xFF	; 255
     b82:	80 93 9d 03 	sts	0x039D, r24
     b86:	90 93 9e 03 	sts	0x039E, r25
     b8a:	a0 93 9f 03 	sts	0x039F, r26
     b8e:	b0 93 a0 03 	sts	0x03A0, r27
     b92:	08 95       	ret

00000b94 <printAdc.clone.6>:
		str[pos++] = '0';
	}	
	return printNumber(str, pos, gTime.sec);
}

static uint8_t printAdc(char* const str, uint8_t pos, const uint8_t adcInput) {
     b94:	ef 92       	push	r14
     b96:	ff 92       	push	r15
     b98:	0f 93       	push	r16
     b9a:	1f 93       	push	r17
     b9c:	cf 93       	push	r28
     b9e:	df 93       	push	r29
     ba0:	ec 01       	movw	r28, r24
	uint8_t low = gAnalogInputs[adcInput].low;
     ba2:	e6 2f       	mov	r30, r22
     ba4:	f0 e0       	ldi	r31, 0x00	; 0
     ba6:	ee 0f       	add	r30, r30
     ba8:	ff 1f       	adc	r31, r31
     baa:	e9 5b       	subi	r30, 0xB9	; 185
     bac:	fb 4f       	sbci	r31, 0xFB	; 251
	uint8_t high = gAnalogInputs[adcInput].high;
	return printFloatNumberWithUnit(str, pos, low, high, "V");		
     bae:	e0 80       	ld	r14, Z
     bb0:	ff 24       	eor	r15, r15
     bb2:	00 e0       	ldi	r16, 0x00	; 0
     bb4:	10 e0       	ldi	r17, 0x00	; 0
     bb6:	21 81       	ldd	r18, Z+1	; 0x01
     bb8:	30 e0       	ldi	r19, 0x00	; 0
     bba:	40 e0       	ldi	r20, 0x00	; 0
     bbc:	50 e0       	ldi	r21, 0x00	; 0
	myItoa(number, &str[pos]);
	return pos+length;
}

static uint8_t printFloatNumber(char* const str, uint8_t pos, int32_t numberLow, int32_t numberHigh) {
	pos = printNumber(str, pos, numberHigh);
     bbe:	64 e0       	ldi	r22, 0x04	; 4
     bc0:	24 db       	rcall	.-2488   	; 0x20a <printNumber>
	str[pos++] = '.';
     bc2:	fe 01       	movw	r30, r28
     bc4:	e8 0f       	add	r30, r24
     bc6:	f1 1d       	adc	r31, r1
     bc8:	9e e2       	ldi	r25, 0x2E	; 46
     bca:	90 83       	st	Z, r25
     bcc:	68 2f       	mov	r22, r24
     bce:	6f 5f       	subi	r22, 0xFF	; 255
	if(numberLow < 10) {
     bd0:	8a e0       	ldi	r24, 0x0A	; 10
     bd2:	e8 16       	cp	r14, r24
     bd4:	f1 04       	cpc	r15, r1
     bd6:	01 05       	cpc	r16, r1
     bd8:	11 05       	cpc	r17, r1
     bda:	34 f4       	brge	.+12     	; 0xbe8 <printAdc.clone.6+0x54>
		str[pos++] = '0';
     bdc:	fe 01       	movw	r30, r28
     bde:	e6 0f       	add	r30, r22
     be0:	f1 1d       	adc	r31, r1
     be2:	80 e3       	ldi	r24, 0x30	; 48
     be4:	80 83       	st	Z, r24
     be6:	6f 5f       	subi	r22, 0xFF	; 255
	}
	return printNumber(str, pos, numberLow);
     be8:	ce 01       	movw	r24, r28
     bea:	a8 01       	movw	r20, r16
     bec:	97 01       	movw	r18, r14
     bee:	0d db       	rcall	.-2534   	; 0x20a <printNumber>
     bf0:	68 2f       	mov	r22, r24
	return printText(str, pos, unit);
}

static uint8_t printFloatNumberWithUnit(char* const str, uint8_t pos, int32_t numberLow, int32_t numberHigh, const char* unit) {
	pos = printFloatNumber(str, pos, numberLow, numberHigh);
	return printText(str, pos, unit);
     bf2:	ce 01       	movw	r24, r28
     bf4:	42 e2       	ldi	r20, 0x22	; 34
     bf6:	51 e0       	ldi	r21, 0x01	; 1
     bf8:	bb db       	rcall	.-2186   	; 0x370 <printText>

static uint8_t printAdc(char* const str, uint8_t pos, const uint8_t adcInput) {
	uint8_t low = gAnalogInputs[adcInput].low;
	uint8_t high = gAnalogInputs[adcInput].high;
	return printFloatNumberWithUnit(str, pos, low, high, "V");		
}
     bfa:	df 91       	pop	r29
     bfc:	cf 91       	pop	r28
     bfe:	1f 91       	pop	r17
     c00:	0f 91       	pop	r16
     c02:	ff 90       	pop	r15
     c04:	ef 90       	pop	r14
     c06:	08 95       	ret

00000c08 <main>:
#endif //GRAPICSENABLED
}

void main(void) __attribute__ ((noreturn)); // Main never returns, saves a few bytes

void main(void) {
     c08:	df 93       	push	r29
     c0a:	cf 93       	push	r28
     c0c:	cd b7       	in	r28, 0x3d	; 61
     c0e:	de b7       	in	r29, 0x3e	; 62
     c10:	64 97       	sbiw	r28, 0x14	; 20
     c12:	0f b6       	in	r0, 0x3f	; 63
     c14:	f8 94       	cli
     c16:	de bf       	out	0x3e, r29	; 62
     c18:	0f be       	out	0x3f, r0	; 63
     c1a:	cd bf       	out	0x3d, r28	; 61
static uint8_t gKeyPressTime = 0;

static void setup(void)
{
	// Port setup
	PORTD = KEY; //key pullup & led off
     c1c:	20 e1       	ldi	r18, 0x10	; 16
     c1e:	2b b9       	out	0x0b, r18	; 11
	DDRD  = LED; // led output
     c20:	88 e0       	ldi	r24, 0x08	; 8
     c22:	8a b9       	out	0x0a, r24	; 10
	PORTB &= ~OUT1;
     c24:	29 98       	cbi	0x05, 1	; 5
	DDRB  = OUT2 | SS;
     c26:	8c e0       	ldi	r24, 0x0C	; 12
     c28:	84 b9       	out	0x04, r24	; 4
	
	TIMSK1 |= (1 << TOIE1); // Enable overflow interrupt
     c2a:	80 91 6f 00 	lds	r24, 0x006F
     c2e:	81 60       	ori	r24, 0x01	; 1
     c30:	80 93 6f 00 	sts	0x006F, r24
	TCCR1B |= (1 << CS11); // Start timer at Fcpu/8
     c34:	80 91 81 00 	lds	r24, 0x0081
     c38:	82 60       	ori	r24, 0x02	; 2
     c3a:	80 93 81 00 	sts	0x0081, r24
static uint16_t gActiveTextLastLine = 2;
static uint8_t gLineType = LINE_TYPE_UNKNOWN;

static void setupLine() {
  // Line trigger
	EICRA = (1<<ISC00) | (1<<ISC01); //set INT0 as rising edge trigger
     c3e:	83 e0       	ldi	r24, 0x03	; 3
     c40:	80 93 69 00 	sts	0x0069, r24
	EIMSK = (1<<INT0); //enable INTO in global interrupt mask
     c44:	31 e0       	ldi	r19, 0x01	; 1
     c46:	3d bb       	out	0x1d, r19	; 29
	ACSR = (1<<ACD); //Comparator disabled
     c48:	80 e8       	ldi	r24, 0x80	; 128
     c4a:	80 bf       	out	0x30, r24	; 48
	ADCSRB = 0x00;
     c4c:	10 92 7b 00 	sts	0x007B, r1

	// SPI setup
	SPDR = 0x00; // Clear spi reg or thrash will show on video
     c50:	1e bc       	out	0x2e, r1	; 46
#ifdef TEXT_SMALL_ENABLED
	SPSR |= (1<<SPI2X); // Set dual speed
#else
	SPSR &= ~(1<<SPI2X); // Clear dual speed
     c52:	8d b5       	in	r24, 0x2d	; 45
     c54:	8e 7f       	andi	r24, 0xFE	; 254
     c56:	8d bd       	out	0x2d, r24	; 45
#endif //TEXT_SMALL_ENABLED
	SPCR = (1<<SPE) | (1<<MSTR) | (1<<CPHA);
     c58:	84 e5       	ldi	r24, 0x54	; 84
     c5a:	8c bd       	out	0x2c, r24	; 44
	
#ifdef TEXT_ENABLED
	gActiveTextLine = gTextLines[gActiveTextId];
     c5c:	e0 91 80 01 	lds	r30, 0x0180
     c60:	f0 e0       	ldi	r31, 0x00	; 0
     c62:	ee 0f       	add	r30, r30
     c64:	ff 1f       	adc	r31, r31
     c66:	e0 5a       	subi	r30, 0xA0	; 160
     c68:	fe 4f       	sbci	r31, 0xFE	; 254
     c6a:	80 81       	ld	r24, Z
     c6c:	91 81       	ldd	r25, Z+1	; 0x01
     c6e:	90 93 83 01 	sts	0x0183, r25
     c72:	80 93 82 01 	sts	0x0182, r24

#ifdef ADC_ENABLED

static void setupAdc() {
  // ADC setup
	DIDR0 = 0x00;
     c76:	10 92 7e 00 	sts	0x007E, r1
	ADMUX |= (1<<REFS0); // Ref is AVCC
     c7a:	80 91 7c 00 	lds	r24, 0x007C
     c7e:	80 64       	ori	r24, 0x40	; 64
     c80:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA |= (1<<ADPS2) | (1<<ADPS1); // | (1<<ADPS0); 
     c84:	80 91 7a 00 	lds	r24, 0x007A
     c88:	86 60       	ori	r24, 0x06	; 6
     c8a:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // Free running
     c8e:	10 92 7b 00 	sts	0x007B, r1
static TGpsData gGpsLastData = {};
static TTime gLastFix = {};

static void setupGps() {
	// USART setup
	UBRR0H = (uint8_t)(GPS_UBRR>>8); // set baud
     c92:	30 93 c5 00 	sts	0x00C5, r19
	UBRR0L = (uint8_t)GPS_UBRR;
     c96:	87 e3       	ldi	r24, 0x37	; 55
     c98:	80 93 c4 00 	sts	0x00C4, r24
	UCSR0C = (3<<UCSZ00); // 8N1
     c9c:	86 e0       	ldi	r24, 0x06	; 6
     c9e:	80 93 c2 00 	sts	0x00C2, r24
	UCSR0B = (1<<RXEN0); // Enable RX
     ca2:	20 93 c1 00 	sts	0x00C1, r18

#ifdef GPS_ENABLED
	setupGps();
#endif //GPS_ENABLED
	
	sei();
     ca6:	78 94       	sei
     ca8:	e1 e3       	ldi	r30, 0x31	; 49
     caa:	4e 2e       	mov	r4, r30
     cac:	e4 e0       	ldi	r30, 0x04	; 4
     cae:	5e 2e       	mov	r5, r30
	setup();

	while(1) {
    
#ifdef GPS_ENABLED
    if(UCSR0A & (1<<RXC0)) {
     cb0:	80 91 c0 00 	lds	r24, 0x00C0
     cb4:	87 fd       	sbrc	r24, 7
     cb6:	27 c1       	rjmp	.+590    	; 0xf06 <main+0x2fe>
      decodeGpsData(UDR0);
    }
#endif //GPS_ENABLED
    
#ifndef DEBUG
		if((PIND & KEY) != KEY) {
     cb8:	4c 99       	sbic	0x09, 4	; 9
     cba:	a6 c0       	rjmp	.+332    	; 0xe08 <main+0x200>
			gKeyPressed = 1;
     cbc:	81 e0       	ldi	r24, 0x01	; 1
     cbe:	80 93 9b 03 	sts	0x039B, r24
			if(gKeyPressTime > 50) {
     cc2:	80 91 9c 03 	lds	r24, 0x039C
     cc6:	83 33       	cpi	r24, 0x33	; 51
     cc8:	e8 f0       	brcs	.+58     	; 0xd04 <main+0xfc>
				gKeyPressTime = 0;
     cca:	10 92 9c 03 	sts	0x039C, r1
				PORTD |= LED; // long press!
     cce:	5b 9a       	sbi	0x0b, 3	; 11
#ifdef GPS_ENABLED
#ifdef HOME_SET_WITH_BUTTON
      if (gGpsLastData.checksumValid != 0 && gGpsLastData.fix != 0) { // (Improved thanks to Yury Smirnov)
     cd0:	80 91 b5 03 	lds	r24, 0x03B5
     cd4:	88 23       	and	r24, r24
     cd6:	b1 f0       	breq	.+44     	; 0xd04 <main+0xfc>
     cd8:	80 91 ab 03 	lds	r24, 0x03AB
     cdc:	88 23       	and	r24, r24
     cde:	91 f0       	breq	.+36     	; 0xd04 <main+0xfc>
}

static void setHomePos() {

	gHomePos = gGpsLastValidData.pos;
     ce0:	a4 ee       	ldi	r26, 0xE4	; 228
     ce2:	b3 e0       	ldi	r27, 0x03	; 3
     ce4:	e4 ec       	ldi	r30, 0xC4	; 196
     ce6:	f3 e0       	ldi	r31, 0x03	; 3
     ce8:	8a e0       	ldi	r24, 0x0A	; 10
     cea:	01 90       	ld	r0, Z+
     cec:	0d 92       	st	X+, r0
     cee:	81 50       	subi	r24, 0x01	; 1
     cf0:	e1 f7       	brne	.-8      	; 0xcea <main+0xe2>
	gHomePosSet = 1;
     cf2:	81 e0       	ldi	r24, 0x01	; 1
     cf4:	80 93 e3 03 	sts	0x03E3, r24
	}
#endif //TIME_HOUR_ENABLED
}

static void resetTime() {
	gTimeTick = 0;
     cf8:	10 92 ee 03 	sts	0x03EE, r1
	gTime.sec = 0;
     cfc:	10 92 df 03 	sts	0x03DF, r1
	gTime.min = 0;
     d00:	10 92 e0 03 	sts	0x03E0, r1
#ifdef DEBUG
		gUpdateScreenData = 2;
#endif //DEBUG

#ifdef TEXT_ENABLED
    if (gUpdateScreenData == 2) {
     d04:	80 91 81 01 	lds	r24, 0x0181
     d08:	82 30       	cpi	r24, 0x02	; 2
     d0a:	09 f4       	brne	.+2      	; 0xd0e <main+0x106>
     d0c:	8a c0       	rjmp	.+276    	; 0xe22 <main+0x21a>
      //DDRB |= OUT1;
      updateTextCharStartPos(gActiveTextId);
	    updateTextPixmap(gActiveTextId);
		  //DDRB &= ~OUT1;
	  }
	  else if (gUpdateScreenData == 1) {
     d0e:	80 91 81 01 	lds	r24, 0x0181
     d12:	81 30       	cpi	r24, 0x01	; 1
     d14:	69 f6       	brne	.-102    	; 0xcb0 <main+0xa8>
#else
    if (gUpdateScreenData == 1) {
#endif //TEXTENABLED
			gUpdateScreenData = 0;
     d16:	10 92 81 01 	sts	0x0181, r1
#endif // ALARM_ENABLED

}  

static void updateOnceEveryFrame() {
  if (gKeyPressed) {
     d1a:	80 91 9b 03 	lds	r24, 0x039B
     d1e:	88 23       	and	r24, r24
     d20:	29 f0       	breq	.+10     	; 0xd2c <main+0x124>
		++gKeyPressTime;
     d22:	80 91 9c 03 	lds	r24, 0x039C
     d26:	8f 5f       	subi	r24, 0xFF	; 255
     d28:	80 93 9c 03 	sts	0x039C, r24
	}

	if ((gTimeTick%(TIME_FRAMES_PER_SEC/SCREEN_AND_SENSOR_UPDATES_PER_SEC) == 0)) {
     d2c:	80 91 ee 03 	lds	r24, 0x03EE
     d30:	69 e1       	ldi	r22, 0x19	; 25
     d32:	bc d8       	rcall	.-3720   	; 0xfffffeac <__eeprom_end+0xff7efcac>
     d34:	99 23       	and	r25, r25
     d36:	09 f4       	brne	.+2      	; 0xd3a <main+0x132>
     d38:	87 c2       	rjmp	.+1294   	; 0x1248 <main+0x640>
static volatile uint8_t gBlink1Hz = 0;

#ifdef TIME_ENABLED

static void updateTime() {
	++gTimeTick;
     d3a:	80 91 ee 03 	lds	r24, 0x03EE
     d3e:	8f 5f       	subi	r24, 0xFF	; 255
     d40:	80 93 ee 03 	sts	0x03EE, r24
	if (gTimeTick >= TIME_FRAMES_PER_SEC) {
     d44:	80 91 ee 03 	lds	r24, 0x03EE
     d48:	82 33       	cpi	r24, 0x32	; 50
     d4a:	78 f0       	brcs	.+30     	; 0xd6a <main+0x162>
		gTimeTick = 0;
     d4c:	10 92 ee 03 	sts	0x03EE, r1
		gTime.sec++;
     d50:	80 91 df 03 	lds	r24, 0x03DF
     d54:	8f 5f       	subi	r24, 0xFF	; 255
     d56:	80 93 df 03 	sts	0x03DF, r24
		gBlink1Hz = (gBlink1Hz+1)%2;
     d5a:	80 91 57 04 	lds	r24, 0x0457
     d5e:	90 e0       	ldi	r25, 0x00	; 0
     d60:	01 96       	adiw	r24, 0x01	; 1
     d62:	81 70       	andi	r24, 0x01	; 1
     d64:	90 70       	andi	r25, 0x00	; 0
     d66:	80 93 57 04 	sts	0x0457, r24
	}
	if (gTime.sec >= 60) {
     d6a:	80 91 df 03 	lds	r24, 0x03DF
     d6e:	8c 33       	cpi	r24, 0x3C	; 60
     d70:	38 f0       	brcs	.+14     	; 0xd80 <main+0x178>
		gTime.sec = 0;
     d72:	10 92 df 03 	sts	0x03DF, r1
		gTime.min++;
     d76:	80 91 e0 03 	lds	r24, 0x03E0
     d7a:	8f 5f       	subi	r24, 0xFF	; 255
     d7c:	80 93 e0 03 	sts	0x03E0, r24
	}
	if (gTime.min >= 60) {
     d80:	80 91 e0 03 	lds	r24, 0x03E0
     d84:	8c 33       	cpi	r24, 0x3C	; 60
     d86:	10 f0       	brcs	.+4      	; 0xd8c <main+0x184>
		gTime.min = 0;
     d88:	10 92 e0 03 	sts	0x03E0, r1
		str[pos++] = '0';
	}
	pos = printNumberWithUnit(str, pos, gTime.hour, ":");
#endif //TIME_HOUR_ENABLED
	if (gTime.min < 10) {
		str[pos++] = '0';
     d8c:	ee 24       	eor	r14, r14
     d8e:	e3 94       	inc	r14
     d90:	80 e0       	ldi	r24, 0x00	; 0
     d92:	90 e0       	ldi	r25, 0x00	; 0
#endif //GRAPICSENABLED
}

void main(void) __attribute__ ((noreturn)); // Main never returns, saves a few bytes

void main(void) {
     d94:	41 e2       	ldi	r20, 0x21	; 33
     d96:	a4 2e       	mov	r10, r20
     d98:	b1 2c       	mov	r11, r1
	}	
	pos = printNumberWithUnit(str, pos, gTime.min, ":");
	if (gTime.sec < 10) {
		str[pos++] = '0';
     d9a:	30 e3       	ldi	r19, 0x30	; 48
     d9c:	83 2e       	mov	r8, r19
     d9e:	3c 01       	movw	r6, r24
#ifdef TIME_ENABLED
	updateTime();
#endif //TIMEENABLED

#ifdef TEXT_ENABLED
  for (uint8_t i = 0; i < TEXT_LINES; ++i) {
     da0:	26 2d       	mov	r18, r6
#endif //GRAPICSENABLED
}

void main(void) __attribute__ ((noreturn)); // Main never returns, saves a few bytes

void main(void) {
     da2:	86 2d       	mov	r24, r6
     da4:	90 e0       	ldi	r25, 0x00	; 0
     da6:	8a 9d       	mul	r24, r10
     da8:	f0 01       	movw	r30, r0
     daa:	8b 9d       	mul	r24, r11
     dac:	f0 0d       	add	r31, r0
     dae:	9a 9d       	mul	r25, r10
     db0:	f0 0d       	add	r31, r0
     db2:	11 24       	eor	r1, r1
     db4:	eb 57       	subi	r30, 0x7B	; 123
     db6:	fe 4f       	sbci	r31, 0xFE	; 254
     db8:	81 e2       	ldi	r24, 0x21	; 33
#endif // TEXT_INVERTED_ENABLED

// Functions
static void clearText(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
		gText[textId][j] = 0;
     dba:	11 92       	st	Z+, r1
     dbc:	81 50       	subi	r24, 0x01	; 1
static uint8_t gTextInverted[TEXT_LINES][TEXT_LINE_MAX_CHARS/8];
#endif // TEXT_INVERTED_ENABLED

// Functions
static void clearText(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
     dbe:	e9 f7       	brne	.-6      	; 0xdba <main+0x1b2>
static void updateText(uint8_t textId) {
  //testPrintDebugInfo();
  uint8_t pos = 0;

  // --------------- TEXT LINE 1 (From top) -----------------------
	if (textId == 0) {
     dc0:	22 23       	and	r18, r18
     dc2:	09 f4       	brne	.+2      	; 0xdc6 <main+0x1be>
     dc4:	c8 c0       	rjmp	.+400    	; 0xf56 <main+0x34e>
#ifdef SHOW_GPS_IN_FLIGHT
	 printGpsNumber(gText[textId], pos, gGpsLastValidData.pos.latitude, 1); 
#endif	
  }
  // --------------- TEXT LINE 2 (From top) -----------------------
  else if (textId == 1) {
     dc6:	21 30       	cpi	r18, 0x01	; 1
     dc8:	09 f4       	brne	.+2      	; 0xdcc <main+0x1c4>
     dca:	d0 c1       	rjmp	.+928    	; 0x116c <main+0x564>
#ifdef SHOW_GPS_IN_FLIGHT
	 printGpsNumber(gText[textId], pos, gGpsLastValidData.pos.longitude, 0); 
#endif	
  }
  // --------------- TEXT LINE 3 (From top) -----------------------
  else if (textId == 2) {
     dcc:	22 30       	cpi	r18, 0x02	; 2
     dce:	09 f4       	brne	.+2      	; 0xdd2 <main+0x1ca>
     dd0:	1f c2       	rjmp	.+1086   	; 0x1210 <main+0x608>
	
	
#endif //GPS_ENABLED
  }
  // --------------- TEXT LINE 4 (From top) -----------------------
  else if (textId == 3) {
     dd2:	23 30       	cpi	r18, 0x03	; 3
     dd4:	09 f4       	brne	.+2      	; 0xdd8 <main+0x1d0>
     dd6:	7c c3       	rjmp	.+1784   	; 0x14d0 <main+0x8c8>
		  pos = printNumber(gText[textId], TEXT_LINE_MAX_CHARS-4, gGpsLastValidData.angle);
		 
#endif //GPS_ENABLED	  
	}
	// --------------- TEXT LINE 5 (From top) -----------------------
	else if (textId == 4) {
     dd8:	24 30       	cpi	r18, 0x04	; 4
     dda:	09 f4       	brne	.+2      	; 0xdde <main+0x1d6>
     ddc:	36 c3       	rjmp	.+1644   	; 0x144a <main+0x842>
#endif //TIME_HOUR_ENABLED
	}
	// --------------- TEXT LINE 6 (From top) -----------------------
	else if (textId == 5) {

    pos =  printText(gText[textId], 0, TEXT_CALL_SIGN); // Call sign
     dde:	8a e2       	ldi	r24, 0x2A	; 42
     de0:	92 e0       	ldi	r25, 0x02	; 2
     de2:	60 e0       	ldi	r22, 0x00	; 0
     de4:	42 e5       	ldi	r20, 0x52	; 82
     de6:	51 e0       	ldi	r21, 0x01	; 1
     de8:	c3 da       	rcall	.-2682   	; 0x370 <printText>
	pos = printText(gText[textId],TEXT_LINE_MAX_CHARS-9 , "FPVLR.COM");
     dea:	8a e2       	ldi	r24, 0x2A	; 42
     dec:	92 e0       	ldi	r25, 0x02	; 2
     dee:	68 e1       	ldi	r22, 0x18	; 24
     df0:	43 e5       	ldi	r20, 0x53	; 83
     df2:	51 e0       	ldi	r21, 0x01	; 1
     df4:	bd da       	rcall	.-2694   	; 0x370 <printText>
#ifdef TIME_ENABLED
	updateTime();
#endif //TIMEENABLED

#ifdef TEXT_ENABLED
  for (uint8_t i = 0; i < TEXT_LINES; ++i) {
     df6:	5e 2d       	mov	r21, r14
     df8:	56 30       	cpi	r21, 0x06	; 6
     dfa:	08 f0       	brcs	.+2      	; 0xdfe <main+0x1f6>
     dfc:	e0 c0       	rjmp	.+448    	; 0xfbe <main+0x3b6>
     dfe:	08 94       	sec
     e00:	61 1c       	adc	r6, r1
     e02:	71 1c       	adc	r7, r1
     e04:	e3 94       	inc	r14
     e06:	cc cf       	rjmp	.-104    	; 0xda0 <main+0x198>
#endif //HOME_SET_WITH_BUTTON
#endif //GPS_ENABLED
			}
		}
		else {
			if (gKeyPressed) {
     e08:	80 91 9b 03 	lds	r24, 0x039B
     e0c:	81 11       	cpse	r24, r1
				PORTD &= ~LED;  // led off
     e0e:	5b 98       	cbi	0x0b, 3	; 11
			}				
			gKeyPressed = 0;
     e10:	10 92 9b 03 	sts	0x039B, r1
			gKeyPressTime = 0;
     e14:	10 92 9c 03 	sts	0x039C, r1
#ifdef DEBUG
		gUpdateScreenData = 2;
#endif //DEBUG

#ifdef TEXT_ENABLED
    if (gUpdateScreenData == 2) {
     e18:	80 91 81 01 	lds	r24, 0x0181
     e1c:	82 30       	cpi	r24, 0x02	; 2
     e1e:	09 f0       	breq	.+2      	; 0xe22 <main+0x21a>
     e20:	76 cf       	rjmp	.-276    	; 0xd0e <main+0x106>
		  gUpdateScreenData = 0;
     e22:	10 92 81 01 	sts	0x0181, r1
#endif //GRAPICSENABLED
}

void main(void) __attribute__ ((noreturn)); // Main never returns, saves a few bytes

void main(void) {
     e26:	20 91 80 01 	lds	r18, 0x0180
     e2a:	30 e0       	ldi	r19, 0x00	; 0
     e2c:	81 e2       	ldi	r24, 0x21	; 33
     e2e:	90 e0       	ldi	r25, 0x00	; 0
     e30:	28 9f       	mul	r18, r24
     e32:	d0 01       	movw	r26, r0
     e34:	29 9f       	mul	r18, r25
     e36:	b0 0d       	add	r27, r0
     e38:	38 9f       	mul	r19, r24
     e3a:	b0 0d       	add	r27, r0
     e3c:	11 24       	eor	r1, r1
     e3e:	ab 57       	subi	r26, 0x7B	; 123
     e40:	be 4f       	sbci	r27, 0xFE	; 254
		gUpdateScreenData = 2;
#endif //DEBUG

#ifdef TEXT_ENABLED
    if (gUpdateScreenData == 2) {
		  gUpdateScreenData = 0;
     e42:	7f ee       	ldi	r23, 0xEF	; 239
     e44:	e7 2e       	mov	r14, r23
     e46:	73 e0       	ldi	r23, 0x03	; 3
     e48:	f7 2e       	mov	r15, r23
#endif //GRAPICSENABLED
}

void main(void) __attribute__ ((noreturn)); // Main never returns, saves a few bytes

void main(void) {
     e4a:	f7 01       	movw	r30, r14
     e4c:	80 e0       	ldi	r24, 0x00	; 0
     e4e:	90 e0       	ldi	r25, 0x00	; 0
     e50:	13 c0       	rjmp	.+38     	; 0xe78 <main+0x270>
		uint8_t character = gText[textId][j];
		int16_t eepromPos;
		if (character == ' ' || character == 0) {
			eepromPos = -1;
		}
		else if (character < CHAR_OFFSET + CHAR_LENGTH) {
     e52:	2b 35       	cpi	r18, 0x5B	; 91
     e54:	08 f0       	brcs	.+2      	; 0xe58 <main+0x250>
     e56:	71 c1       	rjmp	.+738    	; 0x113a <main+0x532>
			uint16_t charPos = ((character - CHAR_OFFSET) * TEXT_CHAR_HEIGHT);
     e58:	82 2f       	mov	r24, r18
     e5a:	90 e0       	ldi	r25, 0x00	; 0
     e5c:	88 0f       	add	r24, r24
     e5e:	99 1f       	adc	r25, r25
     e60:	88 0f       	add	r24, r24
     e62:	99 1f       	adc	r25, r25
     e64:	88 0f       	add	r24, r24
     e66:	99 1f       	adc	r25, r25
			eepromPos = (int16_t)&(oem6x8[charPos]);
     e68:	88 52       	subi	r24, 0x28	; 40
     e6a:	91 40       	sbci	r25, 0x01	; 1
		else if (character > CHAR_SPECIAL_OFFSET && character < CHAR_SPECIAL_OFFSET+CHAR_SPECIAL_LENGTH) {
			uint16_t charPos = ((character - CHAR_SPECIAL_OFFSET) * TEXT_CHAR_HEIGHT);
			eepromPos = (int16_t)&(specialChars[charPos]);
		}
#endif //TEXT_USE_SPECIAL_CHARS
		gTextCharEepromPos[j] = eepromPos;
     e6c:	81 93       	st	Z+, r24
     e6e:	91 93       	st	Z+, r25
	return 0;
}
#endif // TEXT_INVERTED_ENABLED

static void updateTextCharStartPos(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
     e70:	24 e0       	ldi	r18, 0x04	; 4
     e72:	e1 33       	cpi	r30, 0x31	; 49
     e74:	f2 07       	cpc	r31, r18
     e76:	69 f0       	breq	.+26     	; 0xe92 <main+0x28a>
		uint8_t character = gText[textId][j];
     e78:	2d 91       	ld	r18, X+
		int16_t eepromPos;
		if (character == ' ' || character == 0) {
     e7a:	20 32       	cpi	r18, 0x20	; 32
     e7c:	11 f0       	breq	.+4      	; 0xe82 <main+0x27a>
     e7e:	22 23       	and	r18, r18
     e80:	41 f7       	brne	.-48     	; 0xe52 <main+0x24a>
			eepromPos = -1;
     e82:	8f ef       	ldi	r24, 0xFF	; 255
     e84:	9f ef       	ldi	r25, 0xFF	; 255
		else if (character > CHAR_SPECIAL_OFFSET && character < CHAR_SPECIAL_OFFSET+CHAR_SPECIAL_LENGTH) {
			uint16_t charPos = ((character - CHAR_SPECIAL_OFFSET) * TEXT_CHAR_HEIGHT);
			eepromPos = (int16_t)&(specialChars[charPos]);
		}
#endif //TEXT_USE_SPECIAL_CHARS
		gTextCharEepromPos[j] = eepromPos;
     e86:	81 93       	st	Z+, r24
     e88:	91 93       	st	Z+, r25
	return 0;
}
#endif // TEXT_INVERTED_ENABLED

static void updateTextCharStartPos(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
     e8a:	24 e0       	ldi	r18, 0x04	; 4
     e8c:	e1 33       	cpi	r30, 0x31	; 49
     e8e:	f2 07       	cpc	r31, r18
     e90:	99 f7       	brne	.-26     	; 0xe78 <main+0x270>
     e92:	80 e0       	ldi	r24, 0x00	; 0
     e94:	90 e0       	ldi	r25, 0x00	; 0
		  if (eepromPos != -1) {
		  eeprom_read_block((void*)gTextLastCharBuffer, (const void*)eepromPos, 8);
			  gTextLastCharEepromPos = eepromPos;
		  }
		  else {
			  memset(gTextLastCharBuffer, 0, 8);
     e96:	48 e0       	ldi	r20, 0x08	; 8
     e98:	a4 2e       	mov	r10, r20
			  gTextLastCharEepromPos = -1;
     e9a:	88 24       	eor	r8, r8
     e9c:	8a 94       	dec	r8
     e9e:	3c 01       	movw	r6, r24
	}		
}

static void updateTextPixmap(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
		int16_t eepromPos = gTextCharEepromPos[j];
     ea0:	d7 01       	movw	r26, r14
     ea2:	0d 91       	ld	r16, X+
     ea4:	1d 91       	ld	r17, X+
     ea6:	7d 01       	movw	r14, r26
		if (gTextLastCharEepromPos != eepromPos) {
     ea8:	80 91 73 01 	lds	r24, 0x0173
     eac:	99 27       	eor	r25, r25
     eae:	87 fd       	sbrc	r24, 7
     eb0:	90 95       	com	r25
     eb2:	08 17       	cp	r16, r24
     eb4:	19 07       	cpc	r17, r25
     eb6:	69 f0       	breq	.+26     	; 0xed2 <main+0x2ca>
		  if (eepromPos != -1) {
     eb8:	bf ef       	ldi	r27, 0xFF	; 255
     eba:	0f 3f       	cpi	r16, 0xFF	; 255
     ebc:	1b 07       	cpc	r17, r27
     ebe:	09 f4       	brne	.+2      	; 0xec2 <main+0x2ba>
     ec0:	4c c1       	rjmp	.+664    	; 0x115a <main+0x552>
		  eeprom_read_block((void*)gTextLastCharBuffer, (const void*)eepromPos, 8);
     ec2:	81 e3       	ldi	r24, 0x31	; 49
     ec4:	94 e0       	ldi	r25, 0x04	; 4
     ec6:	b8 01       	movw	r22, r16
     ec8:	48 e0       	ldi	r20, 0x08	; 8
     eca:	50 e0       	ldi	r21, 0x00	; 0
     ecc:	7c d8       	rcall	.-3848   	; 0xffffffc6 <__eeprom_end+0xff7efdc6>
			  gTextLastCharEepromPos = eepromPos;
     ece:	00 93 73 01 	sts	0x0173, r16
     ed2:	80 91 31 04 	lds	r24, 0x0431
     ed6:	f3 01       	movw	r30, r6
     ed8:	e5 5b       	subi	r30, 0xB5	; 181
     eda:	fd 4f       	sbci	r31, 0xFD	; 253
     edc:	a2 e3       	ldi	r26, 0x32	; 50
     ede:	b4 e0       	ldi	r27, 0x04	; 4
     ee0:	01 c0       	rjmp	.+2      	; 0xee4 <main+0x2dc>
		  }
		  else {
			  memset(gTextLastCharBuffer, 0, 8);
			  gTextLastCharEepromPos = -1;
     ee2:	8d 91       	ld	r24, X+
		if (charInverted(textId, j)) {
		  gTextLastCharBuffer[i] = ~gTextLastCharBuffer[i];
		}
#endif // TEXT_INVERTED_ENABLED

      gTextPixmap[j + (i*TEXT_LINE_MAX_CHARS)] = gTextLastCharBuffer[i];
     ee4:	80 83       	st	Z, r24
     ee6:	b1 96       	adiw	r30, 0x21	; 33
			  memset(gTextLastCharBuffer, 0, 8);
			  gTextLastCharEepromPos = -1;
		  }
		}		  

	  for (uint8_t i = 0; i < TEXT_CHAR_HEIGHT; i++) {
     ee8:	04 e0       	ldi	r16, 0x04	; 4
     eea:	a9 33       	cpi	r26, 0x39	; 57
     eec:	b0 07       	cpc	r27, r16
     eee:	c9 f7       	brne	.-14     	; 0xee2 <main+0x2da>
     ef0:	08 94       	sec
     ef2:	61 1c       	adc	r6, r1
     ef4:	71 1c       	adc	r7, r1
		gTextCharEepromPos[j] = eepromPos;
	}		
}

static void updateTextPixmap(uint8_t textId) {
	for (uint8_t j = 0; j < TEXT_LINE_MAX_CHARS; ++j) {
     ef6:	11 e2       	ldi	r17, 0x21	; 33
     ef8:	61 16       	cp	r6, r17
     efa:	71 04       	cpc	r7, r1
     efc:	89 f6       	brne	.-94     	; 0xea0 <main+0x298>
	setup();

	while(1) {
    
#ifdef GPS_ENABLED
    if(UCSR0A & (1<<RXC0)) {
     efe:	80 91 c0 00 	lds	r24, 0x00C0
     f02:	87 ff       	sbrs	r24, 7
     f04:	d9 ce       	rjmp	.-590    	; 0xcb8 <main+0xb0>
      decodeGpsData(UDR0);
     f06:	00 91 c6 00 	lds	r16, 0x00C6
		}			
	}
}

static void decodeGpsData(char data) {
	if (gGpsTextPartStep == GPS_PART_FINISHED && data != '$') {
     f0a:	90 91 72 01 	lds	r25, 0x0172
     f0e:	9f 3f       	cpi	r25, 0xFF	; 255
     f10:	09 f4       	brne	.+2      	; 0xf14 <main+0x30c>
     f12:	25 c3       	rjmp	.+1610   	; 0x155e <main+0x956>
		return;
	}
	
	switch (data) {
     f14:	04 32       	cpi	r16, 0x24	; 36
     f16:	09 f4       	brne	.+2      	; 0xf1a <main+0x312>
     f18:	25 c3       	rjmp	.+1610   	; 0x1564 <main+0x95c>
     f1a:	05 32       	cpi	r16, 0x25	; 37
     f1c:	08 f0       	brcs	.+2      	; 0xf20 <main+0x318>
     f1e:	3f c3       	rjmp	.+1662   	; 0x159e <main+0x996>
     f20:	0a 30       	cpi	r16, 0x0A	; 10
     f22:	09 f4       	brne	.+2      	; 0xf26 <main+0x31e>
     f24:	5c c3       	rjmp	.+1720   	; 0x15de <main+0x9d6>
     f26:	0d 30       	cpi	r16, 0x0D	; 13
     f28:	09 f4       	brne	.+2      	; 0xf2c <main+0x324>
     f2a:	59 c3       	rjmp	.+1714   	; 0x15de <main+0x9d6>
	  gGpsTextPartStep = GPS_PART_FINISHED;
	  finishGpsDecoding();
		return;
		break;
	default:
		gGpsText[gGpsTextPos] = data;
     f2c:	80 91 b6 03 	lds	r24, 0x03B6
     f30:	e8 2f       	mov	r30, r24
     f32:	f0 e0       	ldi	r31, 0x00	; 0
     f34:	e7 54       	subi	r30, 0x47	; 71
     f36:	fc 4f       	sbci	r31, 0xFC	; 252
     f38:	00 83       	st	Z, r16
		if (gGpsTextPartStep != GPS_PART_CHECKSUM) {
     f3a:	98 3c       	cpi	r25, 0xC8	; 200
     f3c:	29 f0       	breq	.+10     	; 0xf48 <main+0x340>
		  gGpsChecksum ^= data;
     f3e:	90 91 b8 03 	lds	r25, 0x03B8
     f42:	90 27       	eor	r25, r16
     f44:	90 93 b8 03 	sts	0x03B8, r25
		}
		if (gGpsTextPos < GPS_MAX_CHARS-1) {
     f48:	8a 30       	cpi	r24, 0x0A	; 10
     f4a:	08 f0       	brcs	.+2      	; 0xf4e <main+0x346>
     f4c:	b5 ce       	rjmp	.-662    	; 0xcb8 <main+0xb0>
		  ++gGpsTextPos;
     f4e:	8f 5f       	subi	r24, 0xFF	; 255
     f50:	80 93 b6 03 	sts	0x03B6, r24
     f54:	b1 ce       	rjmp	.-670    	; 0xcb8 <main+0xb0>
  uint8_t pos = 0;

  // --------------- TEXT LINE 1 (From top) -----------------------
	if (textId == 0) {
#ifdef SENSOR_VOLTAGE_1_ENABLED
		printText(gText[textId], pos+ 1, "\1521"); //Battery symbol + '1'
     f56:	85 e8       	ldi	r24, 0x85	; 133
     f58:	91 e0       	ldi	r25, 0x01	; 1
     f5a:	61 e0       	ldi	r22, 0x01	; 1
     f5c:	44 e2       	ldi	r20, 0x24	; 36
     f5e:	51 e0       	ldi	r21, 0x01	; 1
     f60:	07 da       	rcall	.-3058   	; 0x370 <printText>
#endif
		pos += 4 ;

#ifdef SENSOR_VOLTAGE_1_ENABLED
		 if (!gAlarmBatt1 || gBlink1Hz) {
     f62:	80 91 54 04 	lds	r24, 0x0454
     f66:	88 23       	and	r24, r24
     f68:	21 f0       	breq	.+8      	; 0xf72 <main+0x36a>
     f6a:	80 91 57 04 	lds	r24, 0x0457
     f6e:	88 23       	and	r24, r24
     f70:	21 f0       	breq	.+8      	; 0xf7a <main+0x372>
			 printAdc(gText[textId], pos , ANALOG_IN_1); // Voltage 1
     f72:	85 e8       	ldi	r24, 0x85	; 133
     f74:	91 e0       	ldi	r25, 0x01	; 1
     f76:	60 e0       	ldi	r22, 0x00	; 0
     f78:	0d de       	rcall	.-998    	; 0xb94 <printAdc.clone.6>
		 }
#endif
		 pos += 8;

#ifdef SENSOR_RSSI_ENABLED
     if (gSensorRssi > 0) {
     f7a:	80 91 53 04 	lds	r24, 0x0453
     f7e:	88 23       	and	r24, r24
     f80:	31 f0       	breq	.+12     	; 0xf8e <main+0x386>
	  printText(gText[textId], pos, "\151"); //Antenna symbol (RSSI)
     f82:	85 e8       	ldi	r24, 0x85	; 133
     f84:	91 e0       	ldi	r25, 0x01	; 1
     f86:	6c e0       	ldi	r22, 0x0C	; 12
     f88:	47 e2       	ldi	r20, 0x27	; 39
     f8a:	51 e0       	ldi	r21, 0x01	; 1
     f8c:	f1 d9       	rcall	.-3102   	; 0x370 <printText>
#endif
         pos += 6 ;
		 
#ifdef GPS_ENABLED

  		  pos = printText(gText[textId], pos, "\150"); // Satellites symbol
     f8e:	85 e8       	ldi	r24, 0x85	; 133
     f90:	91 e0       	ldi	r25, 0x01	; 1
     f92:	62 e1       	ldi	r22, 0x12	; 18
     f94:	49 e2       	ldi	r20, 0x29	; 41
     f96:	51 e0       	ldi	r21, 0x01	; 1
     f98:	eb d9       	rcall	.-3114   	; 0x370 <printText>
		
	#endif
	  pos += 2 ;	  
     f9a:	68 2f       	mov	r22, r24
     f9c:	6e 5f       	subi	r22, 0xFE	; 254
	  

#ifdef SHOW_GPS_IN_FLIGHT
	 printGpsNumber(gText[textId], pos, gGpsLastValidData.pos.latitude, 1); 
     f9e:	20 91 c4 03 	lds	r18, 0x03C4
     fa2:	30 91 c5 03 	lds	r19, 0x03C5
     fa6:	40 91 c6 03 	lds	r20, 0x03C6
     faa:	50 91 c7 03 	lds	r21, 0x03C7
     fae:	85 e8       	ldi	r24, 0x85	; 133
     fb0:	91 e0       	ldi	r25, 0x01	; 1
     fb2:	01 e0       	ldi	r16, 0x01	; 1
     fb4:	0e da       	rcall	.-3044   	; 0x3d2 <printGpsNumber>
#ifdef TIME_ENABLED
	updateTime();
#endif //TIMEENABLED

#ifdef TEXT_ENABLED
  for (uint8_t i = 0; i < TEXT_LINES; ++i) {
     fb6:	5e 2d       	mov	r21, r14
     fb8:	56 30       	cpi	r21, 0x06	; 6
     fba:	08 f4       	brcc	.+2      	; 0xfbe <main+0x3b6>
     fbc:	20 cf       	rjmp	.-448    	; 0xdfe <main+0x1f6>
     fbe:	80 e0       	ldi	r24, 0x00	; 0
     fc0:	90 e0       	ldi	r25, 0x00	; 0
#endif //GRAPICSENABLED
}

void main(void) __attribute__ ((noreturn)); // Main never returns, saves a few bytes

void main(void) {
     fc2:	fc 01       	movw	r30, r24
     fc4:	ee 0f       	add	r30, r30
     fc6:	ff 1f       	adc	r31, r31
     fc8:	e8 0f       	add	r30, r24
     fca:	f9 1f       	adc	r31, r25
     fcc:	ee 0f       	add	r30, r30
     fce:	ff 1f       	adc	r31, r31
     fd0:	ee 0f       	add	r30, r30
     fd2:	ff 1f       	adc	r31, r31
     fd4:	ee 0f       	add	r30, r30
     fd6:	ff 1f       	adc	r31, r31
     fd8:	ed 5a       	subi	r30, 0xAD	; 173
     fda:	fc 4f       	sbci	r31, 0xFC	; 252
     fdc:	28 e1       	ldi	r18, 0x18	; 24
// Functions

static void clearGraphics() {
	for (uint8_t x = 0; x < GRAPHICS_WIDTH; ++x) {
	  for (uint8_t y = 0; y < GRAPHICS_HEIGHT; ++y) {
			gPixelData[x][y] = 0x00;
     fde:	11 92       	st	Z+, r1
     fe0:	21 50       	subi	r18, 0x01	; 1

// Functions

static void clearGraphics() {
	for (uint8_t x = 0; x < GRAPHICS_WIDTH; ++x) {
	  for (uint8_t y = 0; y < GRAPHICS_HEIGHT; ++y) {
     fe2:	e9 f7       	brne	.-6      	; 0xfde <main+0x3d6>
     fe4:	01 96       	adiw	r24, 0x01	; 1
static uint8_t gPixelData[GRAPHICS_WIDTH][GRAPHICS_HEIGHT];

// Functions

static void clearGraphics() {
	for (uint8_t x = 0; x < GRAPHICS_WIDTH; ++x) {
     fe6:	83 30       	cpi	r24, 0x03	; 3
     fe8:	91 05       	cpc	r25, r1
     fea:	59 f7       	brne	.-42     	; 0xfc2 <main+0x3ba>
}
#endif //TEXT_ENABLED

static void updateGrapics() {
#ifdef GPS_ENABLED
  drawArrow(gHomeBearing - gGpsLastValidData.angle);
     fec:	00 91 3d 04 	lds	r16, 0x043D
     ff0:	10 91 3e 04 	lds	r17, 0x043E
     ff4:	e0 90 d6 03 	lds	r14, 0x03D6
     ff8:	f0 90 d7 03 	lds	r15, 0x03D7
		}
	}				 
}

static void drawArrow(uint16_t angle) {
	drawCircle(GRAPHICS_MID, GRAPHICS_MID, GRAPHICS_MID);
     ffc:	8b e0       	ldi	r24, 0x0B	; 11
     ffe:	31 db       	rcall	.-2462   	; 0x662 <drawCircle.clone.2>
	if (gHomeDistance < 10) {
    1000:	80 91 39 04 	lds	r24, 0x0439
    1004:	90 91 3a 04 	lds	r25, 0x043A
    1008:	a0 91 3b 04 	lds	r26, 0x043B
    100c:	b0 91 3c 04 	lds	r27, 0x043C
    1010:	8a 30       	cpi	r24, 0x0A	; 10
    1012:	91 05       	cpc	r25, r1
    1014:	a1 05       	cpc	r26, r1
    1016:	b1 05       	cpc	r27, r1
    1018:	08 f4       	brcc	.+2      	; 0x101c <main+0x414>
    101a:	57 c2       	rjmp	.+1198   	; 0x14ca <main+0x8c2>
	  drawCircle(GRAPHICS_MID, GRAPHICS_MID, 2);
	  return;
	}
	if (gGpsLastData.fix == 0) {
    101c:	80 91 ab 03 	lds	r24, 0x03AB
    1020:	88 23       	and	r24, r24
    1022:	09 f4       	brne	.+2      	; 0x1026 <main+0x41e>
    1024:	b1 c2       	rjmp	.+1378   	; 0x1588 <main+0x980>
    1026:	98 01       	movw	r18, r16
    1028:	2e 19       	sub	r18, r14
    102a:	3f 09       	sbc	r19, r15
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
}

static int8_t myCos(uint16_t angle) {
	return mySin(angle + 90);
    102c:	c9 01       	movw	r24, r18
    102e:	86 5a       	subi	r24, 0xA6	; 166
    1030:	9f 4f       	sbci	r25, 0xFF	; 255
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    1032:	68 e6       	ldi	r22, 0x68	; 104
    1034:	71 e0       	ldi	r23, 0x01	; 1
    1036:	46 d7       	rcall	.+3724   	; 0x1ec4 <__udivmodhi4>
	int8_t mult = 1;
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    1038:	84 3b       	cpi	r24, 0xB4	; 180
    103a:	91 05       	cpc	r25, r1
    103c:	08 f4       	brcc	.+2      	; 0x1040 <main+0x438>
    103e:	00 c1       	rjmp	.+512    	; 0x1240 <main+0x638>
		pos = pos - 180;
    1040:	84 5b       	subi	r24, 0xB4	; 180
    1042:	90 40       	sbci	r25, 0x00	; 0
		mult = -1;
    1044:	6f ef       	ldi	r22, 0xFF	; 255
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
    1046:	8a 35       	cpi	r24, 0x5A	; 90
    1048:	91 05       	cpc	r25, r1
    104a:	30 f0       	brcs	.+12     	; 0x1058 <main+0x450>
		pos = 180 - pos;
    104c:	44 eb       	ldi	r20, 0xB4	; 180
    104e:	50 e0       	ldi	r21, 0x00	; 0
    1050:	da 01       	movw	r26, r20
    1052:	a8 1b       	sub	r26, r24
    1054:	b9 0b       	sbc	r27, r25
    1056:	cd 01       	movw	r24, r26
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
    1058:	8c 5c       	subi	r24, 0xCC	; 204
    105a:	9f 4f       	sbci	r25, 0xFF	; 255
    105c:	fc 01       	movw	r30, r24
    105e:	84 91       	lpm	r24, Z+
    1060:	86 9f       	mul	r24, r22
    1062:	60 2d       	mov	r22, r0
    1064:	11 24       	eor	r1, r1
		drawLine(GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4));
		drawLine(GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID - (GRAPHICS_SIZE/4));
		return;
	}
	int16_t a = myCos(angle);
    1066:	06 2f       	mov	r16, r22
    1068:	11 27       	eor	r17, r17
    106a:	07 fd       	sbrc	r16, 7
    106c:	10 95       	com	r17
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    106e:	c9 01       	movw	r24, r18
    1070:	68 e6       	ldi	r22, 0x68	; 104
    1072:	71 e0       	ldi	r23, 0x01	; 1
    1074:	27 d7       	rcall	.+3662   	; 0x1ec4 <__udivmodhi4>
	int8_t mult = 1;
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    1076:	84 3b       	cpi	r24, 0xB4	; 180
    1078:	91 05       	cpc	r25, r1
    107a:	08 f4       	brcc	.+2      	; 0x107e <main+0x476>
    107c:	e3 c0       	rjmp	.+454    	; 0x1244 <main+0x63c>
		pos = pos - 180;
    107e:	84 5b       	subi	r24, 0xB4	; 180
    1080:	90 40       	sbci	r25, 0x00	; 0
		mult = -1;
    1082:	4f ef       	ldi	r20, 0xFF	; 255
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
    1084:	8a 35       	cpi	r24, 0x5A	; 90
    1086:	91 05       	cpc	r25, r1
    1088:	30 f0       	brcs	.+12     	; 0x1096 <main+0x48e>
		pos = 180 - pos;
    108a:	24 eb       	ldi	r18, 0xB4	; 180
    108c:	30 e0       	ldi	r19, 0x00	; 0
    108e:	59 01       	movw	r10, r18
    1090:	a8 1a       	sub	r10, r24
    1092:	b9 0a       	sbc	r11, r25
    1094:	c5 01       	movw	r24, r10
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
    1096:	8c 5c       	subi	r24, 0xCC	; 204
    1098:	9f 4f       	sbci	r25, 0xFF	; 255
    109a:	fc 01       	movw	r30, r24
    109c:	e4 90       	lpm	r14, Z+
	int16_t b = mySin(angle);
	a = (a * (GRAPHICS_SIZE / 3)) / 100;
    109e:	c8 01       	movw	r24, r16
    10a0:	88 0f       	add	r24, r24
    10a2:	99 1f       	adc	r25, r25
    10a4:	88 0f       	add	r24, r24
    10a6:	99 1f       	adc	r25, r25
    10a8:	88 0f       	add	r24, r24
    10aa:	99 1f       	adc	r25, r25
    10ac:	24 e6       	ldi	r18, 0x64	; 100
    10ae:	30 e0       	ldi	r19, 0x00	; 0
    10b0:	b9 01       	movw	r22, r18
    10b2:	1c d7       	rcall	.+3640   	; 0x1eec <__divmodhi4>
    10b4:	4b 01       	movw	r8, r22
    10b6:	e4 9e       	mul	r14, r20
    10b8:	80 2d       	mov	r24, r0
    10ba:	11 24       	eor	r1, r1
		drawLine(GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4));
		drawLine(GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID - (GRAPHICS_SIZE/4));
		return;
	}
	int16_t a = myCos(angle);
	int16_t b = mySin(angle);
    10bc:	99 27       	eor	r25, r25
    10be:	87 fd       	sbrc	r24, 7
    10c0:	90 95       	com	r25
	a = (a * (GRAPHICS_SIZE / 3)) / 100;
	b = (b * (GRAPHICS_SIZE / 3)) / 100;
    10c2:	88 0f       	add	r24, r24
    10c4:	99 1f       	adc	r25, r25
    10c6:	88 0f       	add	r24, r24
    10c8:	99 1f       	adc	r25, r25
    10ca:	88 0f       	add	r24, r24
    10cc:	99 1f       	adc	r25, r25
    10ce:	b9 01       	movw	r22, r18
    10d0:	0d d7       	rcall	.+3610   	; 0x1eec <__divmodhi4>
    10d2:	8b 01       	movw	r16, r22
	drawLine(GRAPHICS_MID - b, GRAPHICS_MID + a, GRAPHICS_MID + b, GRAPHICS_MID - a); //Direction line
    10d4:	68 2d       	mov	r22, r8
    10d6:	ab e0       	ldi	r26, 0x0B	; 11
    10d8:	aa 2e       	mov	r10, r26
    10da:	a0 0e       	add	r10, r16
    10dc:	8b e0       	ldi	r24, 0x0B	; 11
    10de:	e8 2e       	mov	r14, r24
    10e0:	e8 18       	sub	r14, r8
    10e2:	65 5f       	subi	r22, 0xF5	; 245
    10e4:	80 1b       	sub	r24, r16
    10e6:	4a 2d       	mov	r20, r10
    10e8:	2e 2d       	mov	r18, r14
    10ea:	43 db       	rcall	.-2426   	; 0x772 <drawLine>
	//drawLine(GRAPHICS_MID_X + a/2, GRAPHICS_MID_X + b/2, GRAPHICS_MID_X - a/2, GRAPHICS_MID_X - b/2); //Arrow bottom line
	drawLine(GRAPHICS_MID + b, GRAPHICS_MID - a, GRAPHICS_MID - a/2, GRAPHICS_MID - b/2); // Arrow "wings"
    10ec:	c4 01       	movw	r24, r8
    10ee:	97 fc       	sbrc	r9, 7
    10f0:	af c2       	rjmp	.+1374   	; 0x1650 <main+0xa48>
    10f2:	95 95       	asr	r25
    10f4:	87 95       	ror	r24
    10f6:	90 95       	com	r25
    10f8:	81 95       	neg	r24
    10fa:	9f 4f       	sbci	r25, 0xFF	; 255
    10fc:	48 2f       	mov	r20, r24
    10fe:	45 5f       	subi	r20, 0xF5	; 245
    1100:	c8 01       	movw	r24, r16
    1102:	17 fd       	sbrc	r17, 7
    1104:	a3 c2       	rjmp	.+1350   	; 0x164c <main+0xa44>
    1106:	95 95       	asr	r25
    1108:	87 95       	ror	r24
    110a:	90 95       	com	r25
    110c:	81 95       	neg	r24
    110e:	9f 4f       	sbci	r25, 0xFF	; 255
    1110:	28 2f       	mov	r18, r24
    1112:	25 5f       	subi	r18, 0xF5	; 245
    1114:	8a 2d       	mov	r24, r10
    1116:	6e 2d       	mov	r22, r14
    1118:	2c db       	rcall	.-2472   	; 0x772 <drawLine>
	drawLine(GRAPHICS_MID + b, GRAPHICS_MID - a, GRAPHICS_MID + a/2, GRAPHICS_MID + b/2);
    111a:	97 fc       	sbrc	r9, 7
    111c:	93 c2       	rjmp	.+1318   	; 0x1644 <main+0xa3c>
    111e:	a4 01       	movw	r20, r8
    1120:	55 95       	asr	r21
    1122:	47 95       	ror	r20
    1124:	45 5f       	subi	r20, 0xF5	; 245
    1126:	17 fd       	sbrc	r17, 7
    1128:	8a c2       	rjmp	.+1300   	; 0x163e <main+0xa36>
    112a:	15 95       	asr	r17
    112c:	07 95       	ror	r16
    112e:	20 2f       	mov	r18, r16
    1130:	25 5f       	subi	r18, 0xF5	; 245
    1132:	8a 2d       	mov	r24, r10
    1134:	6e 2d       	mov	r22, r14
    1136:	1d db       	rcall	.-2502   	; 0x772 <drawLine>
    1138:	bb cd       	rjmp	.-1162   	; 0xcb0 <main+0xa8>
		else if (character < CHAR_OFFSET + CHAR_LENGTH) {
			uint16_t charPos = ((character - CHAR_OFFSET) * TEXT_CHAR_HEIGHT);
			eepromPos = (int16_t)&(oem6x8[charPos]);
		}
#ifdef TEXT_USE_SPECIAL_CHARS
		else if (character > CHAR_SPECIAL_OFFSET && character < CHAR_SPECIAL_OFFSET+CHAR_SPECIAL_LENGTH) {
    113a:	32 2f       	mov	r19, r18
    113c:	35 56       	subi	r19, 0x65	; 101
    113e:	39 30       	cpi	r19, 0x09	; 9
    1140:	08 f0       	brcs	.+2      	; 0x1144 <main+0x53c>
    1142:	94 ce       	rjmp	.-728    	; 0xe6c <main+0x264>
			uint16_t charPos = ((character - CHAR_SPECIAL_OFFSET) * TEXT_CHAR_HEIGHT);
    1144:	82 2f       	mov	r24, r18
    1146:	90 e0       	ldi	r25, 0x00	; 0
    1148:	88 0f       	add	r24, r24
    114a:	99 1f       	adc	r25, r25
    114c:	88 0f       	add	r24, r24
    114e:	99 1f       	adc	r25, r25
    1150:	88 0f       	add	r24, r24
    1152:	99 1f       	adc	r25, r25
			eepromPos = (int16_t)&(specialChars[charPos]);
    1154:	80 57       	subi	r24, 0x70	; 112
    1156:	91 40       	sbci	r25, 0x01	; 1
    1158:	89 ce       	rjmp	.-750    	; 0xe6c <main+0x264>
		  if (eepromPos != -1) {
		  eeprom_read_block((void*)gTextLastCharBuffer, (const void*)eepromPos, 8);
			  gTextLastCharEepromPos = eepromPos;
		  }
		  else {
			  memset(gTextLastCharBuffer, 0, 8);
    115a:	f2 01       	movw	r30, r4
    115c:	ba 2c       	mov	r11, r10
    115e:	11 92       	st	Z+, r1
    1160:	ba 94       	dec	r11
    1162:	e9 f7       	brne	.-6      	; 0x115e <main+0x556>
			  gTextLastCharEepromPos = -1;
    1164:	80 92 73 01 	sts	0x0173, r8
    1168:	80 e0       	ldi	r24, 0x00	; 0
    116a:	b5 ce       	rjmp	.-662    	; 0xed6 <main+0x2ce>
  }
  // --------------- TEXT LINE 2 (From top) -----------------------
  else if (textId == 1) {
	  
#ifdef SENSOR_VOLTAGE_2_ENABLED
		if(((gSensorVoltage2.high * 100) + gSensorVoltage2.low) > 0) {
    116c:	80 91 52 04 	lds	r24, 0x0452
    1170:	04 e6       	ldi	r16, 0x64	; 100
    1172:	80 9f       	mul	r24, r16
    1174:	c0 01       	movw	r24, r0
    1176:	11 24       	eor	r1, r1
    1178:	20 91 51 04 	lds	r18, 0x0451
    117c:	82 0f       	add	r24, r18
    117e:	91 1d       	adc	r25, r1
    1180:	00 97       	sbiw	r24, 0x00	; 0
    1182:	f1 f0       	breq	.+60     	; 0x11c0 <main+0x5b8>
		printText(gText[textId], pos+ 1, "\1522"); //Battery symbol + '2'
    1184:	86 ea       	ldi	r24, 0xA6	; 166
    1186:	91 e0       	ldi	r25, 0x01	; 1
    1188:	61 e0       	ldi	r22, 0x01	; 1
    118a:	4b e2       	ldi	r20, 0x2B	; 43
    118c:	51 e0       	ldi	r21, 0x01	; 1
    118e:	f0 d8       	rcall	.-3616   	; 0x370 <printText>
		}
#endif		
		pos += 4 ;
#ifdef SENSOR_VOLTAGE_2_ENABLED
		 if(((gSensorVoltage2.high * 100) + gSensorVoltage2.low) > 0) {
    1190:	80 91 52 04 	lds	r24, 0x0452
    1194:	80 9f       	mul	r24, r16
    1196:	80 01       	movw	r16, r0
    1198:	11 24       	eor	r1, r1
    119a:	80 91 51 04 	lds	r24, 0x0451
    119e:	08 0f       	add	r16, r24
    11a0:	11 1d       	adc	r17, r1
    11a2:	01 15       	cp	r16, r1
    11a4:	11 05       	cpc	r17, r1
    11a6:	61 f0       	breq	.+24     	; 0x11c0 <main+0x5b8>
     if (!gAlarmBatt2 || gBlink1Hz) {
    11a8:	80 91 55 04 	lds	r24, 0x0455
    11ac:	88 23       	and	r24, r24
    11ae:	21 f0       	breq	.+8      	; 0x11b8 <main+0x5b0>
    11b0:	80 91 57 04 	lds	r24, 0x0457
    11b4:	88 23       	and	r24, r24
    11b6:	21 f0       	breq	.+8      	; 0x11c0 <main+0x5b8>
			 printAdc(gText[textId], pos , ANALOG_IN_2); // Voltage 2
    11b8:	86 ea       	ldi	r24, 0xA6	; 166
    11ba:	91 e0       	ldi	r25, 0x01	; 1
    11bc:	61 e0       	ldi	r22, 0x01	; 1
    11be:	ea dc       	rcall	.-1580   	; 0xb94 <printAdc.clone.6>
		  }
#endif
		 pos += 8;

#ifdef SENSOR_RSSI_ENABLED
      if ((!gAlarmRssi || gBlink1Hz ) && gSensorRssi > 0)
    11c0:	80 91 56 04 	lds	r24, 0x0456
    11c4:	88 23       	and	r24, r24
    11c6:	21 f0       	breq	.+8      	; 0x11d0 <main+0x5c8>
    11c8:	80 91 57 04 	lds	r24, 0x0457
    11cc:	88 23       	and	r24, r24
    11ce:	29 f0       	breq	.+10     	; 0x11da <main+0x5d2>
    11d0:	20 91 53 04 	lds	r18, 0x0453
    11d4:	22 23       	and	r18, r18
    11d6:	09 f0       	breq	.+2      	; 0x11da <main+0x5d2>
    11d8:	6e c1       	rjmp	.+732    	; 0x14b6 <main+0x8ae>
#endif
	  pos += 6 ;


#ifdef GPS_ENABLED
    if (gGpsLastValidData.fix) {
    11da:	80 91 d2 03 	lds	r24, 0x03D2
    11de:	88 23       	and	r24, r24
    11e0:	41 f1       	breq	.+80     	; 0x1232 <main+0x62a>
		printNumber(gText[textId], pos, gGpsLastValidData.sats); 
    11e2:	20 91 d3 03 	lds	r18, 0x03D3
    11e6:	30 e0       	ldi	r19, 0x00	; 0
    11e8:	40 e0       	ldi	r20, 0x00	; 0
    11ea:	50 e0       	ldi	r21, 0x00	; 0
    11ec:	86 ea       	ldi	r24, 0xA6	; 166
    11ee:	91 e0       	ldi	r25, 0x01	; 1
    11f0:	62 e1       	ldi	r22, 0x12	; 18
    11f2:	0b d8       	rcall	.-4074   	; 0x20a <printNumber>
	  }
#endif
	  pos += 3 ;	  
	  
#ifdef SHOW_GPS_IN_FLIGHT
	 printGpsNumber(gText[textId], pos, gGpsLastValidData.pos.longitude, 0); 
    11f4:	20 91 c8 03 	lds	r18, 0x03C8
    11f8:	30 91 c9 03 	lds	r19, 0x03C9
    11fc:	40 91 ca 03 	lds	r20, 0x03CA
    1200:	50 91 cb 03 	lds	r21, 0x03CB
    1204:	86 ea       	ldi	r24, 0xA6	; 166
    1206:	91 e0       	ldi	r25, 0x01	; 1
    1208:	65 e1       	ldi	r22, 0x15	; 21
    120a:	00 e0       	ldi	r16, 0x00	; 0
    120c:	e2 d8       	rcall	.-3644   	; 0x3d2 <printGpsNumber>
    120e:	f3 cd       	rjmp	.-1050   	; 0xdf6 <main+0x1ee>
  }
  // --------------- TEXT LINE 3 (From top) -----------------------
  else if (textId == 2) {
	 
#ifdef GPS_ENABLED
	  if (gHomePosSet) {
    1210:	80 91 e3 03 	lds	r24, 0x03E3
    1214:	88 23       	and	r24, r24
    1216:	09 f0       	breq	.+2      	; 0x121a <main+0x612>
    1218:	84 c1       	rjmp	.+776    	; 0x1522 <main+0x91a>
			 pos = printText(gText[textId], pos, "\146");
			 pos = printText(gText[textId], 2, "MT");
			 pos = printNumber(gText[textId], 5 , gHomeDistance);
		}
	    else if (gBlink1Hz) {
    121a:	80 91 57 04 	lds	r24, 0x0457
    121e:	88 23       	and	r24, r24
    1220:	09 f4       	brne	.+2      	; 0x1224 <main+0x61c>
    1222:	e9 cd       	rjmp	.-1070   	; 0xdf6 <main+0x1ee>
	      pos = printText(gText[textId], 10, "NO HOME POS");
    1224:	87 ec       	ldi	r24, 0xC7	; 199
    1226:	91 e0       	ldi	r25, 0x01	; 1
    1228:	6a e0       	ldi	r22, 0x0A	; 10
    122a:	47 e3       	ldi	r20, 0x37	; 55
    122c:	51 e0       	ldi	r21, 0x01	; 1
    122e:	a0 d8       	rcall	.-3776   	; 0x370 <printText>
    1230:	e2 cd       	rjmp	.-1084   	; 0xdf6 <main+0x1ee>
#ifdef GPS_ENABLED
    if (gGpsLastValidData.fix) {
		printNumber(gText[textId], pos, gGpsLastValidData.sats); 
		}
		else {			
		printText(gText[textId], pos, "-");
    1232:	86 ea       	ldi	r24, 0xA6	; 166
    1234:	91 e0       	ldi	r25, 0x01	; 1
    1236:	62 e1       	ldi	r22, 0x12	; 18
    1238:	40 e3       	ldi	r20, 0x30	; 48
    123a:	51 e0       	ldi	r21, 0x01	; 1
    123c:	99 d8       	rcall	.-3790   	; 0x370 <printText>
    123e:	da cf       	rjmp	.-76     	; 0x11f4 <main+0x5ec>
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
	int8_t mult = 1;
    1240:	61 e0       	ldi	r22, 0x01	; 1
    1242:	01 cf       	rjmp	.-510    	; 0x1046 <main+0x43e>
    1244:	41 e0       	ldi	r20, 0x01	; 1
    1246:	1e cf       	rjmp	.-452    	; 0x1084 <main+0x47c>

static void updateSensorsAndScreen() {
#ifndef GPS_ENABLED
  PORTD |= LED;
#else //GPS_ENABLED
  if (gGpsLastData.fix != 0) {
    1248:	80 91 ab 03 	lds	r24, 0x03AB
    124c:	88 23       	and	r24, r24
    124e:	09 f4       	brne	.+2      	; 0x1252 <main+0x64a>
    1250:	81 c1       	rjmp	.+770    	; 0x1554 <main+0x94c>
		PORTD |= LED;
    1252:	5b 9a       	sbi	0x0b, 3	; 11
	
#ifdef DEBUG
  //testCalcHome();
#endif // DEBUG
  
	if (gHomePosSet) {
    1254:	80 91 e3 03 	lds	r24, 0x03E3
    1258:	88 23       	and	r24, r24
    125a:	09 f0       	breq	.+2      	; 0x125e <main+0x656>
    125c:	fb c1       	rjmp	.+1014   	; 0x1654 <main+0xa4c>
  distance *= mult;
#ifdef IMPERIAL_SYSTEM  
  distance *= 3281;
	distance /= 1000;
#endif //IMPERIAL_SYSTEM
  *distanceResult = distance;
    125e:	bf e3       	ldi	r27, 0x3F	; 63
    1260:	8b 2e       	mov	r8, r27
    1262:	b4 e0       	ldi	r27, 0x04	; 4
    1264:	9b 2e       	mov	r9, r27
    1266:	a4 e7       	ldi	r26, 0x74	; 116
    1268:	6a 2e       	mov	r6, r26
    126a:	a1 e0       	ldi	r26, 0x01	; 1
    126c:	7a 2e       	mov	r7, r26
    126e:	f8 e7       	ldi	r31, 0x78	; 120
    1270:	2f 2e       	mov	r2, r31
    1272:	f1 e0       	ldi	r31, 0x01	; 1
    1274:	3f 2e       	mov	r3, r31
    1276:	87 e4       	ldi	r24, 0x47	; 71
    1278:	94 e0       	ldi	r25, 0x04	; 4
      if (deltaLat == 0) {
        if (deltaLong >= 0) { // Home = East
          bearing = 90; 
        } 
	      else { // Home = West
          bearing = 270;
    127a:	19 82       	std	Y+1, r1	; 0x01
	  ADCSRA &= ~(1<<ADEN) & ~(1<<ADATE); // ADC disabled & ADC auto trigger disabled
	  temp = ADCW;
#ifdef ADC_ENABLE_RAW	  
    gAnalogInputsRaw[i] = temp;
#endif
	  temp = (temp * 5 * 62) / 10;
    127c:	ea e0       	ldi	r30, 0x0A	; 10
    127e:	ae 2e       	mov	r10, r30
    1280:	b1 2c       	mov	r11, r1
    1282:	c1 2c       	mov	r12, r1
    1284:	d1 2c       	mov	r13, r1
    1286:	9a 87       	std	Y+10, r25	; 0x0a
    1288:	89 87       	std	Y+9, r24	; 0x09
static void measureAnalog() {
  uint32_t temp = 0;
	uint8_t adcLow = 0; 
  uint8_t adcHigh = 0;
  for (uint8_t i = 0; i < ANALOG_IN_NUMBER; ++i) {
	  ADMUX &= 0xF0; // Clear mux
    128a:	80 91 7c 00 	lds	r24, 0x007C
    128e:	80 7f       	andi	r24, 0xF0	; 240
    1290:	80 93 7c 00 	sts	0x007C, r24
    ADMUX |= (i + ADC_OFFSET);	 //Setup adc mux
    1294:	80 91 7c 00 	lds	r24, 0x007C
    1298:	59 81       	ldd	r21, Y+1	; 0x01
    129a:	85 2b       	or	r24, r21
    129c:	80 93 7c 00 	sts	0x007C, r24
	  ADCSRA |= (1<<ADEN) | (1<<ADATE); // ADC enable & ADC auto trigger enable
    12a0:	80 91 7a 00 	lds	r24, 0x007A
    12a4:	80 6a       	ori	r24, 0xA0	; 160
    12a6:	80 93 7a 00 	sts	0x007A, r24
	  ADCSRA |= (1<<ADSC); // Start measure
    12aa:	80 91 7a 00 	lds	r24, 0x007A
    12ae:	80 64       	ori	r24, 0x40	; 64
    12b0:	80 93 7a 00 	sts	0x007A, r24
    12b4:	29 85       	ldd	r18, Y+9	; 0x09
    12b6:	3a 85       	ldd	r19, Y+10	; 0x0a
	  while ((ADCSRA & (1<<ADIF)) == 0); // Wait to finish
    12b8:	80 91 7a 00 	lds	r24, 0x007A
    12bc:	84 ff       	sbrs	r24, 4
    12be:	fc cf       	rjmp	.-8      	; 0x12b8 <main+0x6b0>
    12c0:	3a 87       	std	Y+10, r19	; 0x0a
    12c2:	29 87       	std	Y+9, r18	; 0x09
	  ADCSRA |= (1<<ADIF); // Clear ADC interrupt flag with a 1
    12c4:	80 91 7a 00 	lds	r24, 0x007A
    12c8:	80 61       	ori	r24, 0x10	; 16
    12ca:	80 93 7a 00 	sts	0x007A, r24
	  ADCSRA &= ~(1<<ADEN) & ~(1<<ADATE); // ADC disabled & ADC auto trigger disabled
    12ce:	80 91 7a 00 	lds	r24, 0x007A
    12d2:	8f 75       	andi	r24, 0x5F	; 95
    12d4:	80 93 7a 00 	sts	0x007A, r24
	  temp = ADCW;
    12d8:	20 91 78 00 	lds	r18, 0x0078
    12dc:	30 91 79 00 	lds	r19, 0x0079
#ifdef ADC_ENABLE_RAW	  
    gAnalogInputsRaw[i] = temp;
    12e0:	d4 01       	movw	r26, r8
    12e2:	2d 93       	st	X+, r18
    12e4:	3d 93       	st	X+, r19
    12e6:	4d 01       	movw	r8, r26
#endif
	  temp = (temp * 5 * 62) / 10;
    12e8:	46 e3       	ldi	r20, 0x36	; 54
    12ea:	51 e0       	ldi	r21, 0x01	; 1
    12ec:	b1 d5       	rcall	.+2914   	; 0x1e50 <__umulhisi3>
    12ee:	a6 01       	movw	r20, r12
    12f0:	95 01       	movw	r18, r10
    12f2:	0f d6       	rcall	.+3102   	; 0x1f12 <__udivmodsi4>
    12f4:	79 01       	movw	r14, r18
    12f6:	8a 01       	movw	r16, r20
	  temp *= gAnalogMult[i];
    12f8:	f3 01       	movw	r30, r6
    12fa:	21 91       	ld	r18, Z+
    12fc:	3f 01       	movw	r6, r30
    12fe:	30 e0       	ldi	r19, 0x00	; 0
    1300:	40 e0       	ldi	r20, 0x00	; 0
    1302:	50 e0       	ldi	r21, 0x00	; 0
    1304:	c8 01       	movw	r24, r16
    1306:	b7 01       	movw	r22, r14
    1308:	b2 d5       	rcall	.+2916   	; 0x1e6e <__mulsi3>
	  temp /= gAnalogDiv[i];
    130a:	d1 01       	movw	r26, r2
    130c:	2d 91       	ld	r18, X+
    130e:	1d 01       	movw	r2, r26
    1310:	30 e0       	ldi	r19, 0x00	; 0
    1312:	40 e0       	ldi	r20, 0x00	; 0
    1314:	50 e0       	ldi	r21, 0x00	; 0
    1316:	fd d5       	rcall	.+3066   	; 0x1f12 <__udivmodsi4>
	  adcHigh = temp / 1024;
    1318:	79 01       	movw	r14, r18
    131a:	8a 01       	movw	r16, r20
    131c:	7a e0       	ldi	r23, 0x0A	; 10
    131e:	16 95       	lsr	r17
    1320:	07 95       	ror	r16
    1322:	f7 94       	ror	r15
    1324:	e7 94       	ror	r14
    1326:	7a 95       	dec	r23
    1328:	d1 f7       	brne	.-12     	; 0x131e <main+0x716>
    132a:	ed 82       	std	Y+5, r14	; 0x05
    132c:	fe 82       	std	Y+6, r15	; 0x06
    132e:	0f 83       	std	Y+7, r16	; 0x07
    1330:	18 87       	std	Y+8, r17	; 0x08
	  temp -= (uint16_t)(adcHigh) * 1024;
    1332:	8e 2d       	mov	r24, r14
    1334:	90 e0       	ldi	r25, 0x00	; 0
    1336:	98 2f       	mov	r25, r24
    1338:	88 27       	eor	r24, r24
    133a:	99 0f       	add	r25, r25
    133c:	99 0f       	add	r25, r25
    133e:	a0 e0       	ldi	r26, 0x00	; 0
    1340:	b0 e0       	ldi	r27, 0x00	; 0
    1342:	79 01       	movw	r14, r18
    1344:	8a 01       	movw	r16, r20
    1346:	e8 1a       	sub	r14, r24
    1348:	f9 0a       	sbc	r15, r25
    134a:	0a 0b       	sbc	r16, r26
    134c:	1b 0b       	sbc	r17, r27
    134e:	c8 01       	movw	r24, r16
    1350:	b7 01       	movw	r22, r14
	  adcLow = (temp * 100) / 1024;
    1352:	24 e6       	ldi	r18, 0x64	; 100
    1354:	30 e0       	ldi	r19, 0x00	; 0
    1356:	40 e0       	ldi	r20, 0x00	; 0
    1358:	50 e0       	ldi	r21, 0x00	; 0
    135a:	89 d5       	rcall	.+2834   	; 0x1e6e <__mulsi3>
    135c:	5a e0       	ldi	r21, 0x0A	; 10
    135e:	96 95       	lsr	r25
    1360:	87 95       	ror	r24
    1362:	77 95       	ror	r23
    1364:	67 95       	ror	r22
    1366:	5a 95       	dec	r21
    1368:	d1 f7       	brne	.-12     	; 0x135e <main+0x756>
    136a:	a9 85       	ldd	r26, Y+9	; 0x09
    136c:	ba 85       	ldd	r27, Y+10	; 0x0a
    136e:	6c 93       	st	X, r22
	
	  gAnalogInputs[i].low = adcLow;
    gAnalogInputs[i].high = adcHigh;
    1370:	ed 81       	ldd	r30, Y+5	; 0x05
    1372:	11 96       	adiw	r26, 0x01	; 1
    1374:	ec 93       	st	X, r30
    1376:	11 97       	sbiw	r26, 0x01	; 1

static void measureAnalog() {
  uint32_t temp = 0;
	uint8_t adcLow = 0; 
  uint8_t adcHigh = 0;
  for (uint8_t i = 0; i < ANALOG_IN_NUMBER; ++i) {
    1378:	f9 81       	ldd	r31, Y+1	; 0x01
    137a:	ff 5f       	subi	r31, 0xFF	; 255
    137c:	f9 83       	std	Y+1, r31	; 0x01
    137e:	12 96       	adiw	r26, 0x02	; 2
    1380:	ba 87       	std	Y+10, r27	; 0x0a
    1382:	a9 87       	std	Y+9, r26	; 0x09
    1384:	f4 30       	cpi	r31, 0x04	; 4
    1386:	09 f0       	breq	.+2      	; 0x138a <main+0x782>
    1388:	80 cf       	rjmp	.-256    	; 0x128a <main+0x682>
	return outMax - value + outMin;
}
*/
static void updateSensors() {
#ifdef SENSOR_VOLTAGE_1_ENABLED
    gSensorVoltage1 = gAnalogInputs[ANALOG_IN_1];
    138a:	80 91 47 04 	lds	r24, 0x0447
    138e:	90 91 48 04 	lds	r25, 0x0448
    1392:	90 93 50 04 	sts	0x0450, r25
    1396:	80 93 4f 04 	sts	0x044F, r24
#endif
#ifdef SENSOR_VOLTAGE_2_ENABLED
    gSensorVoltage2 = gAnalogInputs[ANALOG_IN_2];
    139a:	80 91 49 04 	lds	r24, 0x0449
    139e:	90 91 4a 04 	lds	r25, 0x044A
    13a2:	90 93 52 04 	sts	0x0452, r25
    13a6:	80 93 51 04 	sts	0x0451, r24
static void updateSensors() { DUMMY_FUNC }

#else //ADC_ENABLED

static uint8_t calcGenericVoltageLevel(uint8_t adcInput, uint16_t inMin, uint16_t inMax, uint16_t outMin, uint16_t outMax) {
	uint16_t level = ((gAnalogInputs[adcInput].high * 100) + gAnalogInputs[adcInput].low);
    13aa:	90 91 4c 04 	lds	r25, 0x044C
    13ae:	84 e6       	ldi	r24, 0x64	; 100
    13b0:	98 9f       	mul	r25, r24
    13b2:	c0 01       	movw	r24, r0
    13b4:	11 24       	eor	r1, r1
    13b6:	20 91 4b 04 	lds	r18, 0x044B
    13ba:	82 0f       	add	r24, r18
    13bc:	91 1d       	adc	r25, r1
	if (level > inMax) {
    13be:	01 e0       	ldi	r16, 0x01	; 1
    13c0:	85 3f       	cpi	r24, 0xF5	; 245
    13c2:	90 07       	cpc	r25, r16
    13c4:	08 f0       	brcs	.+2      	; 0x13c8 <main+0x7c0>
    13c6:	38 c1       	rjmp	.+624    	; 0x1638 <main+0xa30>
		level = outMax;
	}		
	else if (level > inMin) {
    13c8:	89 37       	cpi	r24, 0x79	; 121
    13ca:	91 05       	cpc	r25, r1
    13cc:	08 f4       	brcc	.+2      	; 0x13d0 <main+0x7c8>
    13ce:	24 c3       	rjmp	.+1608   	; 0x1a18 <main+0xe10>
		level -= inMin;
    13d0:	ac 01       	movw	r20, r24
    13d2:	48 57       	subi	r20, 0x78	; 120
    13d4:	50 40       	sbci	r21, 0x00	; 0
		level *= outMax - outMin;
    13d6:	24 e6       	ldi	r18, 0x64	; 100
    13d8:	30 e0       	ldi	r19, 0x00	; 0
    13da:	42 9f       	mul	r20, r18
    13dc:	c0 01       	movw	r24, r0
    13de:	43 9f       	mul	r20, r19
    13e0:	90 0d       	add	r25, r0
    13e2:	52 9f       	mul	r21, r18
    13e4:	90 0d       	add	r25, r0
    13e6:	11 24       	eor	r1, r1
		level /= inMax - inMin;
    13e8:	6c e7       	ldi	r22, 0x7C	; 124
    13ea:	71 e0       	ldi	r23, 0x01	; 1
    13ec:	6b d5       	rcall	.+2774   	; 0x1ec4 <__udivmodhi4>
		level += outMin;
	}
	else {
		level = outMin;
	}
	return level;
    13ee:	36 2f       	mov	r19, r22
#endif
#ifdef SENSOR_RSSI_ENABLED
#ifdef SENSOR_RSSI_REVERSED
   gSensorRssi = calcGenericVoltageLevelReverse(SENSOR_RSSI_INPUT, RSSI_MIN_VOLTAGE_INT, RSSI_MAX_VOLTAGE_INT, 0, 100);
#else
   gSensorRssi = calcGenericVoltageLevel(SENSOR_RSSI_INPUT, RSSI_MIN_VOLTAGE_INT, RSSI_MAX_VOLTAGE_INT, 0, 100);
    13f0:	60 93 53 04 	sts	0x0453, r22
	gAlarmDistance = (gHomeDistance > ALARM_DISTANCE_HIGH);
#endif
#endif //GPS_ENABLED

#ifdef ALARM_BATT1_LOW_INT
	gAlarmBatt1 = ((gSensorVoltage1.high * 100) + gSensorVoltage1.low) < ALARM_BATT1_LOW_INT;
    13f4:	90 91 50 04 	lds	r25, 0x0450
    13f8:	84 e6       	ldi	r24, 0x64	; 100
    13fa:	98 9f       	mul	r25, r24
    13fc:	c0 01       	movw	r24, r0
    13fe:	11 24       	eor	r1, r1
    1400:	20 91 4f 04 	lds	r18, 0x044F
    1404:	82 0f       	add	r24, r18
    1406:	91 1d       	adc	r25, r1
    1408:	21 e0       	ldi	r18, 0x01	; 1
    140a:	13 e0       	ldi	r17, 0x03	; 3
    140c:	88 3e       	cpi	r24, 0xE8	; 232
    140e:	91 07       	cpc	r25, r17
    1410:	08 f0       	brcs	.+2      	; 0x1414 <main+0x80c>
    1412:	20 e0       	ldi	r18, 0x00	; 0
    1414:	20 93 54 04 	sts	0x0454, r18
#ifdef ALARM_POWER_USAGE_HIGH
  gAlarmPowerUsage = (gSensorPowerUsage/1000) < ALARM_POWER_USAGE_HIGH;
#endif
#else // ANALOG_IN_NUMBER > 2
#ifdef ALARM_BATT2_LOW_INT
	gAlarmBatt2 = ((gSensorVoltage2.high * 100) + gSensorVoltage2.low) < ALARM_BATT2_LOW_INT; //Bugfix thanks to Benson
    1418:	90 91 52 04 	lds	r25, 0x0452
    141c:	84 e6       	ldi	r24, 0x64	; 100
    141e:	98 9f       	mul	r25, r24
    1420:	c0 01       	movw	r24, r0
    1422:	11 24       	eor	r1, r1
    1424:	20 91 51 04 	lds	r18, 0x0451
    1428:	82 0f       	add	r24, r18
    142a:	91 1d       	adc	r25, r1
    142c:	21 e0       	ldi	r18, 0x01	; 1
    142e:	43 e0       	ldi	r20, 0x03	; 3
    1430:	88 3e       	cpi	r24, 0xE8	; 232
    1432:	94 07       	cpc	r25, r20
    1434:	08 f0       	brcs	.+2      	; 0x1438 <main+0x830>
    1436:	20 e0       	ldi	r18, 0x00	; 0
    1438:	20 93 55 04 	sts	0x0455, r18
#endif
#ifdef ALARM_RSSI_LOW
	gAlarmRssi = gSensorRssi < ALARM_RSSI_LOW;
    143c:	81 e0       	ldi	r24, 0x01	; 1
    143e:	3e 31       	cpi	r19, 0x1E	; 30
    1440:	08 f0       	brcs	.+2      	; 0x1444 <main+0x83c>
    1442:	80 e0       	ldi	r24, 0x00	; 0
    1444:	80 93 56 04 	sts	0x0456, r24
    1448:	78 cc       	rjmp	.-1808   	; 0xd3a <main+0x132>
	}
	// --------------- TEXT LINE 5 (From top) -----------------------
	else if (textId == 4) {
#ifdef GPS_ENABLED

	    pos = printNumber(gText[textId], 0, gGpsLastValidData.speed); // Speed
    144a:	20 91 d4 03 	lds	r18, 0x03D4
    144e:	30 91 d5 03 	lds	r19, 0x03D5
    1452:	40 e0       	ldi	r20, 0x00	; 0
    1454:	50 e0       	ldi	r21, 0x00	; 0
    1456:	89 e0       	ldi	r24, 0x09	; 9
    1458:	92 e0       	ldi	r25, 0x02	; 2
    145a:	60 e0       	ldi	r22, 0x00	; 0
    145c:	d6 d6       	rcall	.+3500   	; 0x220a <__data_load_end+0x1a4>
			
        pos = printText(gText[textId],5 , "KM/H");
    145e:	89 e0       	ldi	r24, 0x09	; 9
    1460:	92 e0       	ldi	r25, 0x02	; 2
    1462:	65 e0       	ldi	r22, 0x05	; 5
    1464:	4b e4       	ldi	r20, 0x4B	; 75
    1466:	51 e0       	ldi	r21, 0x01	; 1
    1468:	83 d7       	rcall	.+3846   	; 0x2370 <__data_load_end+0x30a>
	if (gTime.hour < 10) {
		str[pos++] = '0';
	}
	pos = printNumberWithUnit(str, pos, gTime.hour, ":");
#endif //TIME_HOUR_ENABLED
	if (gTime.min < 10) {
    146a:	80 91 e0 03 	lds	r24, 0x03E0
    146e:	8a 30       	cpi	r24, 0x0A	; 10
    1470:	08 f0       	brcs	.+2      	; 0x1474 <main+0x86c>
    1472:	88 c0       	rjmp	.+272    	; 0x1584 <main+0x97c>
		str[pos++] = '0';
    1474:	80 92 24 02 	sts	0x0224, r8
    1478:	6c e1       	ldi	r22, 0x1C	; 28
	}	
	pos = printNumberWithUnit(str, pos, gTime.min, ":");
    147a:	20 91 e0 03 	lds	r18, 0x03E0
    147e:	30 e0       	ldi	r19, 0x00	; 0
    1480:	40 e0       	ldi	r20, 0x00	; 0
    1482:	50 e0       	ldi	r21, 0x00	; 0
    1484:	89 e0       	ldi	r24, 0x09	; 9
    1486:	92 e0       	ldi	r25, 0x02	; 2
    1488:	00 e5       	ldi	r16, 0x50	; 80
    148a:	11 e0       	ldi	r17, 0x01	; 1
    148c:	93 d7       	rcall	.+3878   	; 0x23b4 <__data_load_end+0x34e>
    148e:	68 2f       	mov	r22, r24
	if (gTime.sec < 10) {
    1490:	80 91 df 03 	lds	r24, 0x03DF
    1494:	8a 30       	cpi	r24, 0x0A	; 10
    1496:	30 f4       	brcc	.+12     	; 0x14a4 <main+0x89c>
		str[pos++] = '0';
    1498:	e6 2f       	mov	r30, r22
    149a:	f0 e0       	ldi	r31, 0x00	; 0
    149c:	e7 5f       	subi	r30, 0xF7	; 247
    149e:	fd 4f       	sbci	r31, 0xFD	; 253
    14a0:	80 82       	st	Z, r8
    14a2:	6f 5f       	subi	r22, 0xFF	; 255
	}	
	return printNumber(str, pos, gTime.sec);
    14a4:	20 91 df 03 	lds	r18, 0x03DF
    14a8:	30 e0       	ldi	r19, 0x00	; 0
    14aa:	40 e0       	ldi	r20, 0x00	; 0
    14ac:	50 e0       	ldi	r21, 0x00	; 0
    14ae:	89 e0       	ldi	r24, 0x09	; 9
    14b0:	92 e0       	ldi	r25, 0x02	; 2
    14b2:	ab d6       	rcall	.+3414   	; 0x220a <__data_load_end+0x1a4>
    14b4:	a0 cc       	rjmp	.-1728   	; 0xdf6 <main+0x1ee>
	return printFloatNumberWithUnit(str, pos, low, high, "V");		
}

static uint8_t printRssiLevel(char* const str, uint8_t pos, const uint8_t adcInput) {
	uint8_t rssiLevel = gSensorRssi;
	return printNumberWithUnit(str, pos, rssiLevel, "%");
    14b6:	30 e0       	ldi	r19, 0x00	; 0
    14b8:	40 e0       	ldi	r20, 0x00	; 0
    14ba:	50 e0       	ldi	r21, 0x00	; 0
    14bc:	86 ea       	ldi	r24, 0xA6	; 166
    14be:	91 e0       	ldi	r25, 0x01	; 1
    14c0:	6c e0       	ldi	r22, 0x0C	; 12
    14c2:	0e e2       	ldi	r16, 0x2E	; 46
    14c4:	11 e0       	ldi	r17, 0x01	; 1
    14c6:	76 d7       	rcall	.+3820   	; 0x23b4 <__data_load_end+0x34e>
    14c8:	88 ce       	rjmp	.-752    	; 0x11da <main+0x5d2>
}

static void drawArrow(uint16_t angle) {
	drawCircle(GRAPHICS_MID, GRAPHICS_MID, GRAPHICS_MID);
	if (gHomeDistance < 10) {
	  drawCircle(GRAPHICS_MID, GRAPHICS_MID, 2);
    14ca:	82 e0       	ldi	r24, 0x02	; 2
    14cc:	ca d8       	rcall	.-3692   	; 0x662 <drawCircle.clone.2>
    14ce:	f0 cb       	rjmp	.-2080   	; 0xcb0 <main+0xa8>
#endif //GPS_ENABLED
  }
  // --------------- TEXT LINE 4 (From top) -----------------------
  else if (textId == 3) {
#ifdef GPS_ENABLED
        printText(gText[textId], pos, "ALT"); //ALTITUDE
    14d0:	88 ee       	ldi	r24, 0xE8	; 232
    14d2:	91 e0       	ldi	r25, 0x01	; 1
    14d4:	60 e0       	ldi	r22, 0x00	; 0
    14d6:	43 e4       	ldi	r20, 0x43	; 67
    14d8:	51 e0       	ldi	r21, 0x01	; 1
    14da:	4a d7       	rcall	.+3732   	; 0x2370 <__data_load_end+0x30a>
	  
		  
	 else pos = printText(gText[textId], 5, "=");
*/	 
	
		 pos = printNumber(gText[textId], 7 , gGpsLastValidData.pos.altitude - gHomePos.altitude); // Altitude
    14dc:	20 91 cc 03 	lds	r18, 0x03CC
    14e0:	30 91 cd 03 	lds	r19, 0x03CD
    14e4:	80 91 ec 03 	lds	r24, 0x03EC
    14e8:	90 91 ed 03 	lds	r25, 0x03ED
    14ec:	28 1b       	sub	r18, r24
    14ee:	39 0b       	sbc	r19, r25
    14f0:	44 27       	eor	r20, r20
    14f2:	37 fd       	sbrc	r19, 7
    14f4:	40 95       	com	r20
    14f6:	54 2f       	mov	r21, r20
    14f8:	88 ee       	ldi	r24, 0xE8	; 232
    14fa:	91 e0       	ldi	r25, 0x01	; 1
    14fc:	67 e0       	ldi	r22, 0x07	; 7
    14fe:	85 d6       	rcall	.+3338   	; 0x220a <__data_load_end+0x1a4>
	   		
	  
          pos = printText(gText[textId],TEXT_LINE_MAX_CHARS-8 , "HDG");
    1500:	88 ee       	ldi	r24, 0xE8	; 232
    1502:	91 e0       	ldi	r25, 0x01	; 1
    1504:	69 e1       	ldi	r22, 0x19	; 25
    1506:	47 e4       	ldi	r20, 0x47	; 71
    1508:	51 e0       	ldi	r21, 0x01	; 1
    150a:	32 d7       	rcall	.+3684   	; 0x2370 <__data_load_end+0x30a>
		  pos = printNumber(gText[textId], TEXT_LINE_MAX_CHARS-4, gGpsLastValidData.angle);
    150c:	20 91 d6 03 	lds	r18, 0x03D6
    1510:	30 91 d7 03 	lds	r19, 0x03D7
    1514:	40 e0       	ldi	r20, 0x00	; 0
    1516:	50 e0       	ldi	r21, 0x00	; 0
    1518:	88 ee       	ldi	r24, 0xE8	; 232
    151a:	91 e0       	ldi	r25, 0x01	; 1
    151c:	6d e1       	ldi	r22, 0x1D	; 29
    151e:	75 d6       	rcall	.+3306   	; 0x220a <__data_load_end+0x1a4>
    1520:	6e cc       	rjmp	.-1828   	; 0xdfe <main+0x1f6>
  // --------------- TEXT LINE 3 (From top) -----------------------
  else if (textId == 2) {
	 
#ifdef GPS_ENABLED
	  if (gHomePosSet) {
			 pos = printText(gText[textId], pos, "\146");
    1522:	87 ec       	ldi	r24, 0xC7	; 199
    1524:	91 e0       	ldi	r25, 0x01	; 1
    1526:	60 e0       	ldi	r22, 0x00	; 0
    1528:	42 e3       	ldi	r20, 0x32	; 50
    152a:	51 e0       	ldi	r21, 0x01	; 1
    152c:	21 d7       	rcall	.+3650   	; 0x2370 <__data_load_end+0x30a>
			 pos = printText(gText[textId], 2, "MT");
    152e:	87 ec       	ldi	r24, 0xC7	; 199
    1530:	91 e0       	ldi	r25, 0x01	; 1
    1532:	62 e0       	ldi	r22, 0x02	; 2
    1534:	44 e3       	ldi	r20, 0x34	; 52
    1536:	51 e0       	ldi	r21, 0x01	; 1
    1538:	1b d7       	rcall	.+3638   	; 0x2370 <__data_load_end+0x30a>
			 pos = printNumber(gText[textId], 5 , gHomeDistance);
    153a:	20 91 39 04 	lds	r18, 0x0439
    153e:	30 91 3a 04 	lds	r19, 0x043A
    1542:	40 91 3b 04 	lds	r20, 0x043B
    1546:	50 91 3c 04 	lds	r21, 0x043C
    154a:	87 ec       	ldi	r24, 0xC7	; 199
    154c:	91 e0       	ldi	r25, 0x01	; 1
    154e:	65 e0       	ldi	r22, 0x05	; 5
    1550:	5c d6       	rcall	.+3256   	; 0x220a <__data_load_end+0x1a4>
    1552:	55 cc       	rjmp	.-1878   	; 0xdfe <main+0x1f6>
#else //GPS_ENABLED
  if (gGpsLastData.fix != 0) {
		PORTD |= LED;
	}
	else {
		PORTD ^= LED;
    1554:	8b b1       	in	r24, 0x0b	; 11
    1556:	98 e0       	ldi	r25, 0x08	; 8
    1558:	89 27       	eor	r24, r25
    155a:	8b b9       	out	0x0b, r24	; 11
    155c:	7b ce       	rjmp	.-778    	; 0x1254 <main+0x64c>
		}			
	}
}

static void decodeGpsData(char data) {
	if (gGpsTextPartStep == GPS_PART_FINISHED && data != '$') {
    155e:	04 32       	cpi	r16, 0x24	; 36
    1560:	09 f0       	breq	.+2      	; 0x1564 <main+0x95c>
    1562:	aa cb       	rjmp	.-2220   	; 0xcb8 <main+0xb0>
		return;
	}
	
	switch (data) {
	case '$':
		gGpsTextPos = 0;
    1564:	10 92 b6 03 	sts	0x03B6, r1
		gGpsTextType = GPS_TYPE_NONE;
    1568:	10 92 b7 03 	sts	0x03B7, r1
		gGpsChecksum = 0;
    156c:	10 92 b8 03 	sts	0x03B8, r1
		gGpsTextPartStep = 0;
    1570:	10 92 72 01 	sts	0x0172, r1
    1574:	e9 eb       	ldi	r30, 0xB9	; 185
    1576:	f3 e0       	ldi	r31, 0x03	; 3
static uint8_t gGpsTextPartLength = 0;
#endif //GPS_PART_TEXT

static void clearGpsText() {
	for (uint8_t i = 0; i < GPS_MAX_CHARS; ++i) {
		gGpsText[i] = 0;
    1578:	11 92       	st	Z+, r1
static char gGpsTextPart[GPS_MAX_CHARS];
static uint8_t gGpsTextPartLength = 0;
#endif //GPS_PART_TEXT

static void clearGpsText() {
	for (uint8_t i = 0; i < GPS_MAX_CHARS; ++i) {
    157a:	03 e0       	ldi	r16, 0x03	; 3
    157c:	e4 3c       	cpi	r30, 0xC4	; 196
    157e:	f0 07       	cpc	r31, r16
    1580:	d9 f7       	brne	.-10     	; 0x1578 <main+0x970>
    1582:	9a cb       	rjmp	.-2252   	; 0xcb8 <main+0xb0>
	if (gTime.hour < 10) {
		str[pos++] = '0';
	}
	pos = printNumberWithUnit(str, pos, gTime.hour, ":");
#endif //TIME_HOUR_ENABLED
	if (gTime.min < 10) {
    1584:	6b e1       	ldi	r22, 0x1B	; 27
    1586:	79 cf       	rjmp	.-270    	; 0x147a <main+0x872>
	  return;
	}
	if (gGpsLastData.fix == 0) {
		drawLine(GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4));
    1588:	85 e0       	ldi	r24, 0x05	; 5
    158a:	65 e0       	ldi	r22, 0x05	; 5
    158c:	41 e1       	ldi	r20, 0x11	; 17
    158e:	21 e1       	ldi	r18, 0x11	; 17
    1590:	f0 d8       	rcall	.-3616   	; 0x772 <drawLine>
		drawLine(GRAPHICS_MID - (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID + (GRAPHICS_SIZE/4), GRAPHICS_MID - (GRAPHICS_SIZE/4));
    1592:	85 e0       	ldi	r24, 0x05	; 5
    1594:	61 e1       	ldi	r22, 0x11	; 17
    1596:	41 e1       	ldi	r20, 0x11	; 17
    1598:	25 e0       	ldi	r18, 0x05	; 5
    159a:	eb d8       	rcall	.-3626   	; 0x772 <drawLine>
    159c:	89 cb       	rjmp	.-2286   	; 0xcb0 <main+0xa8>
static void decodeGpsData(char data) {
	if (gGpsTextPartStep == GPS_PART_FINISHED && data != '$') {
		return;
	}
	
	switch (data) {
    159e:	0a 32       	cpi	r16, 0x2A	; 42
    15a0:	41 f0       	breq	.+16     	; 0x15b2 <main+0x9aa>
    15a2:	0c 32       	cpi	r16, 0x2C	; 44
    15a4:	09 f0       	breq	.+2      	; 0x15a8 <main+0x9a0>
    15a6:	c2 cc       	rjmp	.-1660   	; 0xf2c <main+0x324>
		clearFullGpsText();
		gGpsFullTextPos = 0;
#endif // FULLGPSTEXT
		break;
	case ',':
		gGpsChecksum ^= data;
    15a8:	80 91 b8 03 	lds	r24, 0x03B8
    15ac:	80 27       	eor	r24, r16
    15ae:	80 93 b8 03 	sts	0x03B8, r24
	case '*':
		parseGpsPart();
    15b2:	ab d9       	rcall	.-3242   	; 0x90a <parseGpsPart>
    15b4:	e9 eb       	ldi	r30, 0xB9	; 185
    15b6:	f3 e0       	ldi	r31, 0x03	; 3
static uint8_t gGpsTextPartLength = 0;
#endif //GPS_PART_TEXT

static void clearGpsText() {
	for (uint8_t i = 0; i < GPS_MAX_CHARS; ++i) {
		gGpsText[i] = 0;
    15b8:	11 92       	st	Z+, r1
static char gGpsTextPart[GPS_MAX_CHARS];
static uint8_t gGpsTextPartLength = 0;
#endif //GPS_PART_TEXT

static void clearGpsText() {
	for (uint8_t i = 0; i < GPS_MAX_CHARS; ++i) {
    15ba:	13 e0       	ldi	r17, 0x03	; 3
    15bc:	e4 3c       	cpi	r30, 0xC4	; 196
    15be:	f1 07       	cpc	r31, r17
    15c0:	d9 f7       	brne	.-10     	; 0x15b8 <main+0x9b0>
	case ',':
		gGpsChecksum ^= data;
	case '*':
		parseGpsPart();
		clearGpsText();		
		gGpsTextPos = 0;
    15c2:	10 92 b6 03 	sts	0x03B6, r1
		gGpsTextPartStep++;
    15c6:	80 91 72 01 	lds	r24, 0x0172
    15ca:	8f 5f       	subi	r24, 0xFF	; 255
    15cc:	80 93 72 01 	sts	0x0172, r24
		if (data =='*') {
    15d0:	0a 32       	cpi	r16, 0x2A	; 42
    15d2:	09 f0       	breq	.+2      	; 0x15d6 <main+0x9ce>
    15d4:	71 cb       	rjmp	.-2334   	; 0xcb8 <main+0xb0>
			gGpsTextPartStep = GPS_PART_CHECKSUM;
    15d6:	88 ec       	ldi	r24, 0xC8	; 200
    15d8:	80 93 72 01 	sts	0x0172, r24
    15dc:	6d cb       	rjmp	.-2342   	; 0xcb8 <main+0xb0>
		}			
		break;
	case '\r':
	case '\n':
	  parseGpsPart();
    15de:	95 d9       	rcall	.-3286   	; 0x90a <parseGpsPart>
	  gGpsTextPartStep = GPS_PART_FINISHED;
    15e0:	4f ef       	ldi	r20, 0xFF	; 255
    15e2:	40 93 72 01 	sts	0x0172, r20



static void finishGpsDecoding() {
	
if (gGpsLastData.pos.altitude > gGpsLastValidData.pos.altitude) 
    15e6:	20 91 a5 03 	lds	r18, 0x03A5
    15ea:	30 91 a6 03 	lds	r19, 0x03A6
    15ee:	80 91 cc 03 	lds	r24, 0x03CC
    15f2:	90 91 cd 03 	lds	r25, 0x03CD
    15f6:	82 17       	cp	r24, r18
    15f8:	93 07       	cpc	r25, r19
    15fa:	0c f0       	brlt	.+2      	; 0x15fe <main+0x9f6>
    15fc:	5f c2       	rjmp	.+1214   	; 0x1abc <main+0xeb4>
altitudeArrow = 1;
    15fe:	81 e0       	ldi	r24, 0x01	; 1
    1600:	80 93 dd 03 	sts	0x03DD, r24
		
else if (gGpsLastData.pos.altitude < gGpsLastValidData.pos.altitude)
altitudeArrow = -1;


	if (gGpsLastData.checksumValid != 0) {
    1604:	80 91 b5 03 	lds	r24, 0x03B5
    1608:	88 23       	and	r24, r24
    160a:	09 f4       	brne	.+2      	; 0x160e <main+0xa06>
    160c:	55 cb       	rjmp	.-2390   	; 0xcb8 <main+0xb0>

		gGpsLastValidData = gGpsLastData;
    160e:	a4 ec       	ldi	r26, 0xC4	; 196
    1610:	b3 e0       	ldi	r27, 0x03	; 3
    1612:	ed e9       	ldi	r30, 0x9D	; 157
    1614:	f3 e0       	ldi	r31, 0x03	; 3
    1616:	89 e1       	ldi	r24, 0x19	; 25
    1618:	01 90       	ld	r0, Z+
    161a:	0d 92       	st	X+, r0
    161c:	81 50       	subi	r24, 0x01	; 1
    161e:	e1 f7       	brne	.-8      	; 0x1618 <main+0xa10>
		gGpsValidData = 1;
    1620:	81 e0       	ldi	r24, 0x01	; 1
    1622:	80 93 de 03 	sts	0x03DE, r24
		gLastFix = gTime;
    1626:	80 91 df 03 	lds	r24, 0x03DF
    162a:	90 91 e0 03 	lds	r25, 0x03E0
    162e:	90 93 e2 03 	sts	0x03E2, r25
    1632:	80 93 e1 03 	sts	0x03E1, r24
    1636:	40 cb       	rjmp	.-2432   	; 0xcb8 <main+0xb0>
#else //ADC_ENABLED

static uint8_t calcGenericVoltageLevel(uint8_t adcInput, uint16_t inMin, uint16_t inMax, uint16_t outMin, uint16_t outMax) {
	uint16_t level = ((gAnalogInputs[adcInput].high * 100) + gAnalogInputs[adcInput].low);
	if (level > inMax) {
		level = outMax;
    1638:	64 e6       	ldi	r22, 0x64	; 100
    163a:	70 e0       	ldi	r23, 0x00	; 0
    163c:	d8 ce       	rjmp	.-592    	; 0x13ee <main+0x7e6>
	a = (a * (GRAPHICS_SIZE / 3)) / 100;
	b = (b * (GRAPHICS_SIZE / 3)) / 100;
	drawLine(GRAPHICS_MID - b, GRAPHICS_MID + a, GRAPHICS_MID + b, GRAPHICS_MID - a); //Direction line
	//drawLine(GRAPHICS_MID_X + a/2, GRAPHICS_MID_X + b/2, GRAPHICS_MID_X - a/2, GRAPHICS_MID_X - b/2); //Arrow bottom line
	drawLine(GRAPHICS_MID + b, GRAPHICS_MID - a, GRAPHICS_MID - a/2, GRAPHICS_MID - b/2); // Arrow "wings"
	drawLine(GRAPHICS_MID + b, GRAPHICS_MID - a, GRAPHICS_MID + a/2, GRAPHICS_MID + b/2);
    163e:	0f 5f       	subi	r16, 0xFF	; 255
    1640:	1f 4f       	sbci	r17, 0xFF	; 255
    1642:	73 cd       	rjmp	.-1306   	; 0x112a <main+0x522>
    1644:	08 94       	sec
    1646:	81 1c       	adc	r8, r1
    1648:	91 1c       	adc	r9, r1
    164a:	69 cd       	rjmp	.-1326   	; 0x111e <main+0x516>
	int16_t b = mySin(angle);
	a = (a * (GRAPHICS_SIZE / 3)) / 100;
	b = (b * (GRAPHICS_SIZE / 3)) / 100;
	drawLine(GRAPHICS_MID - b, GRAPHICS_MID + a, GRAPHICS_MID + b, GRAPHICS_MID - a); //Direction line
	//drawLine(GRAPHICS_MID_X + a/2, GRAPHICS_MID_X + b/2, GRAPHICS_MID_X - a/2, GRAPHICS_MID_X - b/2); //Arrow bottom line
	drawLine(GRAPHICS_MID + b, GRAPHICS_MID - a, GRAPHICS_MID - a/2, GRAPHICS_MID - b/2); // Arrow "wings"
    164c:	01 96       	adiw	r24, 0x01	; 1
    164e:	5b cd       	rjmp	.-1354   	; 0x1106 <main+0x4fe>
    1650:	01 96       	adiw	r24, 0x01	; 1
    1652:	4f cd       	rjmp	.-1378   	; 0x10f2 <main+0x4ea>
#ifdef DEBUG
  //testCalcHome();
#endif // DEBUG
  
	if (gHomePosSet) {
	  calcHome(gGpsLastValidData.pos.latitude,
    1654:	e0 90 c4 03 	lds	r14, 0x03C4
    1658:	f0 90 c5 03 	lds	r15, 0x03C5
    165c:	00 91 c6 03 	lds	r16, 0x03C6
    1660:	10 91 c7 03 	lds	r17, 0x03C7
    1664:	60 90 c8 03 	lds	r6, 0x03C8
    1668:	70 90 c9 03 	lds	r7, 0x03C9
    166c:	80 90 ca 03 	lds	r8, 0x03CA
    1670:	90 90 cb 03 	lds	r9, 0x03CB
    1674:	a0 90 e4 03 	lds	r10, 0x03E4
    1678:	b0 90 e5 03 	lds	r11, 0x03E5
    167c:	c0 90 e6 03 	lds	r12, 0x03E6
    1680:	d0 90 e7 03 	lds	r13, 0x03E7
    1684:	20 91 e8 03 	lds	r18, 0x03E8
    1688:	30 91 e9 03 	lds	r19, 0x03E9
    168c:	40 91 ea 03 	lds	r20, 0x03EA
    1690:	50 91 eb 03 	lds	r21, 0x03EB
    1694:	29 83       	std	Y+1, r18	; 0x01
    1696:	3a 83       	std	Y+2, r19	; 0x02
    1698:	4b 83       	std	Y+3, r20	; 0x03
    169a:	5c 83       	std	Y+4, r21	; 0x04

  // considers flat earth around vehicle and reference

  // Ernani Reis, Aug 2011
  
  if (currLat == homeLat && currLong == homeLong) {
    169c:	ea 14       	cp	r14, r10
    169e:	fb 04       	cpc	r15, r11
    16a0:	0c 05       	cpc	r16, r12
    16a2:	1d 05       	cpc	r17, r13
    16a4:	09 f4       	brne	.+2      	; 0x16a8 <main+0xaa0>
    16a6:	f2 c1       	rjmp	.+996    	; 0x1a8c <main+0xe84>
  int32_t deltaLat; 
  int32_t deltaLong;
  uint32_t distance;
  uint16_t bearing;
      
  c = myCos(absi32(homeLat + currLat) / 2000000); // c ~ cos(lat) -> long to fix the delta
    16a8:	c6 01       	movw	r24, r12
    16aa:	b5 01       	movw	r22, r10
    16ac:	6e 0d       	add	r22, r14
    16ae:	7f 1d       	adc	r23, r15
    16b0:	80 1f       	adc	r24, r16
    16b2:	91 1f       	adc	r25, r17
#ifndef COMMONUTILS_H_
#define COMMONUTILS_H_

// abs seems to only support 16 bits so I had to make my own.
static uint32_t absi32(int32_t a) {
	return (a > 0) ? a : -a;
    16b4:	97 fd       	sbrc	r25, 7
    16b6:	0c c2       	rjmp	.+1048   	; 0x1ad0 <main+0xec8>
    16b8:	20 e8       	ldi	r18, 0x80	; 128
    16ba:	34 e8       	ldi	r19, 0x84	; 132
    16bc:	4e e1       	ldi	r20, 0x1E	; 30
    16be:	50 e0       	ldi	r21, 0x00	; 0
    16c0:	28 d4       	rcall	.+2128   	; 0x1f12 <__udivmodsi4>
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
}

static int8_t myCos(uint16_t angle) {
	return mySin(angle + 90);
    16c2:	c9 01       	movw	r24, r18
    16c4:	86 5a       	subi	r24, 0xA6	; 166
    16c6:	9f 4f       	sbci	r25, 0xFF	; 255
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    16c8:	68 e6       	ldi	r22, 0x68	; 104
    16ca:	71 e0       	ldi	r23, 0x01	; 1
    16cc:	fb d3       	rcall	.+2038   	; 0x1ec4 <__udivmodhi4>
	int8_t mult = 1;
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    16ce:	84 3b       	cpi	r24, 0xB4	; 180
    16d0:	91 05       	cpc	r25, r1
    16d2:	08 f4       	brcc	.+2      	; 0x16d6 <main+0xace>
    16d4:	fa c1       	rjmp	.+1012   	; 0x1aca <main+0xec2>
		pos = pos - 180;
    16d6:	84 5b       	subi	r24, 0xB4	; 180
    16d8:	90 40       	sbci	r25, 0x00	; 0
		mult = -1;
    16da:	33 24       	eor	r3, r3
    16dc:	3a 94       	dec	r3
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
    16de:	8a 35       	cpi	r24, 0x5A	; 90
    16e0:	91 05       	cpc	r25, r1
    16e2:	30 f0       	brcs	.+12     	; 0x16f0 <main+0xae8>
		pos = 180 - pos;
    16e4:	24 eb       	ldi	r18, 0xB4	; 180
    16e6:	30 e0       	ldi	r19, 0x00	; 0
    16e8:	a9 01       	movw	r20, r18
    16ea:	48 1b       	sub	r20, r24
    16ec:	59 0b       	sbc	r21, r25
    16ee:	ca 01       	movw	r24, r20
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
    16f0:	8c 5c       	subi	r24, 0xCC	; 204
    16f2:	9f 4f       	sbci	r25, 0xFF	; 255
    16f4:	fc 01       	movw	r30, r24
    16f6:	24 90       	lpm	r2, Z+

  int32_t currLatSec100 = wgs84ToSec100(currLat); // Convert wgs84 to sec * 100
    16f8:	c8 01       	movw	r24, r16
    16fa:	b7 01       	movw	r22, r14
    16fc:	e5 d4       	rcall	.+2506   	; 0x20c8 <__data_load_end+0x62>
    16fe:	6d 83       	std	Y+5, r22	; 0x05
    1700:	7e 83       	std	Y+6, r23	; 0x06
    1702:	8f 83       	std	Y+7, r24	; 0x07
    1704:	98 87       	std	Y+8, r25	; 0x08
  int32_t homeLatSec100 = wgs84ToSec100(homeLat);
    1706:	c6 01       	movw	r24, r12
    1708:	b5 01       	movw	r22, r10
    170a:	de d4       	rcall	.+2492   	; 0x20c8 <__data_load_end+0x62>
    170c:	5b 01       	movw	r10, r22
    170e:	6c 01       	movw	r12, r24
  int32_t currLongSec100 = wgs84ToSec100(currLong);
    1710:	c4 01       	movw	r24, r8
    1712:	b3 01       	movw	r22, r6
    1714:	d9 d4       	rcall	.+2482   	; 0x20c8 <__data_load_end+0x62>
    1716:	7b 01       	movw	r14, r22
    1718:	8c 01       	movw	r16, r24
  int32_t homeLongSec100 = wgs84ToSec100(homeLong);
    171a:	69 81       	ldd	r22, Y+1	; 0x01
    171c:	7a 81       	ldd	r23, Y+2	; 0x02
    171e:	8b 81       	ldd	r24, Y+3	; 0x03
    1720:	9c 81       	ldd	r25, Y+4	; 0x04
    1722:	d2 d4       	rcall	.+2468   	; 0x20c8 <__data_load_end+0x62>
    1724:	9b 01       	movw	r18, r22
    1726:	ac 01       	movw	r20, r24

  deltaLong = homeLongSec100 - currLongSec100; // Calculate deltas
    1728:	2e 19       	sub	r18, r14
    172a:	3f 09       	sbc	r19, r15
    172c:	40 0b       	sbc	r20, r16
    172e:	51 0b       	sbc	r21, r17
  deltaLat = homeLatSec100 - currLatSec100; // delta long ainda com erro (Delta still long with error?)
    1730:	ed 80       	ldd	r14, Y+5	; 0x05
    1732:	fe 80       	ldd	r15, Y+6	; 0x06
    1734:	0f 81       	ldd	r16, Y+7	; 0x07
    1736:	18 85       	ldd	r17, Y+8	; 0x08
    1738:	ae 18       	sub	r10, r14
    173a:	bf 08       	sbc	r11, r15
    173c:	c0 0a       	sbc	r12, r16
    173e:	d1 0a       	sbc	r13, r17
    1740:	23 9c       	mul	r2, r3
    1742:	60 2d       	mov	r22, r0
    1744:	11 24       	eor	r1, r1

  deltaLong = deltaLong * c;   // corrige dla p/ lat da regio
    1746:	77 27       	eor	r23, r23
    1748:	67 fd       	sbrc	r22, 7
    174a:	70 95       	com	r23
    174c:	87 2f       	mov	r24, r23
    174e:	97 2f       	mov	r25, r23
    1750:	8e d3       	rcall	.+1820   	; 0x1e6e <__mulsi3>
  deltaLong = deltaLong / 100; // cosine is 0-100 so divide with 100
    1752:	24 e6       	ldi	r18, 0x64	; 100
    1754:	30 e0       	ldi	r19, 0x00	; 0
    1756:	40 e0       	ldi	r20, 0x00	; 0
    1758:	50 e0       	ldi	r21, 0x00	; 0
    175a:	fd d3       	rcall	.+2042   	; 0x1f56 <__divmodsi4>
    175c:	79 01       	movw	r14, r18
    175e:	8a 01       	movw	r16, r20

  // Make sure we don't go over uin32_t when doing sqr of deltaLong & deltaLat
  uint8_t mult = 1;
    1760:	33 24       	eor	r3, r3
    1762:	33 94       	inc	r3
    1764:	28 c0       	rjmp	.+80     	; 0x17b6 <main+0xbae>
  while ((absi32(deltaLong) >= 0xFFFF) 
    1766:	2f ef       	ldi	r18, 0xFF	; 255
    1768:	62 16       	cp	r6, r18
    176a:	2f ef       	ldi	r18, 0xFF	; 255
    176c:	72 06       	cpc	r7, r18
    176e:	20 e0       	ldi	r18, 0x00	; 0
    1770:	82 06       	cpc	r8, r18
    1772:	20 e0       	ldi	r18, 0x00	; 0
    1774:	92 06       	cpc	r9, r18
    1776:	60 f4       	brcc	.+24     	; 0x1790 <main+0xb88>
    1778:	d6 01       	movw	r26, r12
    177a:	c5 01       	movw	r24, r10
    177c:	d7 fc       	sbrc	r13, 7
    177e:	27 c0       	rjmp	.+78     	; 0x17ce <main+0xbc6>
         || (absi32(deltaLat) >= 0xFFFF)) {
    1780:	8f 3f       	cpi	r24, 0xFF	; 255
    1782:	3f ef       	ldi	r19, 0xFF	; 255
    1784:	93 07       	cpc	r25, r19
    1786:	30 e0       	ldi	r19, 0x00	; 0
    1788:	a3 07       	cpc	r26, r19
    178a:	30 e0       	ldi	r19, 0x00	; 0
    178c:	b3 07       	cpc	r27, r19
    178e:	38 f1       	brcs	.+78     	; 0x17de <main+0xbd6>
	  deltaLong /= 2;
    1790:	c8 01       	movw	r24, r16
    1792:	b7 01       	movw	r22, r14
    1794:	22 e0       	ldi	r18, 0x02	; 2
    1796:	30 e0       	ldi	r19, 0x00	; 0
    1798:	40 e0       	ldi	r20, 0x00	; 0
    179a:	50 e0       	ldi	r21, 0x00	; 0
    179c:	dc d3       	rcall	.+1976   	; 0x1f56 <__divmodsi4>
    179e:	79 01       	movw	r14, r18
    17a0:	8a 01       	movw	r16, r20
	  deltaLat /= 2;
    17a2:	c6 01       	movw	r24, r12
    17a4:	b5 01       	movw	r22, r10
    17a6:	22 e0       	ldi	r18, 0x02	; 2
    17a8:	30 e0       	ldi	r19, 0x00	; 0
    17aa:	40 e0       	ldi	r20, 0x00	; 0
    17ac:	50 e0       	ldi	r21, 0x00	; 0
    17ae:	d3 d3       	rcall	.+1958   	; 0x1f56 <__divmodsi4>
    17b0:	59 01       	movw	r10, r18
    17b2:	6a 01       	movw	r12, r20
	  mult *= 2;
    17b4:	33 0c       	add	r3, r3
    17b6:	37 01       	movw	r6, r14
    17b8:	48 01       	movw	r8, r16
    17ba:	17 ff       	sbrs	r17, 7
    17bc:	d4 cf       	rjmp	.-88     	; 0x1766 <main+0xb5e>
    17be:	66 24       	eor	r6, r6
    17c0:	77 24       	eor	r7, r7
    17c2:	43 01       	movw	r8, r6
    17c4:	6e 18       	sub	r6, r14
    17c6:	7f 08       	sbc	r7, r15
    17c8:	80 0a       	sbc	r8, r16
    17ca:	91 0a       	sbc	r9, r17
    17cc:	cc cf       	rjmp	.-104    	; 0x1766 <main+0xb5e>
    17ce:	88 27       	eor	r24, r24
    17d0:	99 27       	eor	r25, r25
    17d2:	dc 01       	movw	r26, r24
    17d4:	8a 19       	sub	r24, r10
    17d6:	9b 09       	sbc	r25, r11
    17d8:	ac 09       	sbc	r26, r12
    17da:	bd 09       	sbc	r27, r13
    17dc:	d1 cf       	rjmp	.-94     	; 0x1780 <main+0xb78>
    17de:	89 87       	std	Y+9, r24	; 0x09
    17e0:	9a 87       	std	Y+10, r25	; 0x0a
    17e2:	ab 87       	std	Y+11, r26	; 0x0b
    17e4:	bc 87       	std	Y+12, r27	; 0x0c
  }
  
  uint32_t a = (deltaLong * deltaLong);
    17e6:	c8 01       	movw	r24, r16
    17e8:	b7 01       	movw	r22, r14
    17ea:	a8 01       	movw	r20, r16
    17ec:	97 01       	movw	r18, r14
    17ee:	3f d3       	rcall	.+1662   	; 0x1e6e <__mulsi3>
    17f0:	69 83       	std	Y+1, r22	; 0x01
    17f2:	7a 83       	std	Y+2, r23	; 0x02
    17f4:	8b 83       	std	Y+3, r24	; 0x03
    17f6:	9c 83       	std	Y+4, r25	; 0x04
  uint32_t b = (deltaLat * deltaLat);
    17f8:	c6 01       	movw	r24, r12
    17fa:	b5 01       	movw	r22, r10
    17fc:	a6 01       	movw	r20, r12
    17fe:	95 01       	movw	r18, r10
    1800:	36 d3       	rcall	.+1644   	; 0x1e6e <__mulsi3>
    1802:	69 8b       	std	Y+17, r22	; 0x11
    1804:	7a 8b       	std	Y+18, r23	; 0x12
    1806:	8b 8b       	std	Y+19, r24	; 0x13
    1808:	9c 8b       	std	Y+20, r25	; 0x14

  // Make sure that the squared deltas don't go over uin32_t when adding them together.
  // This should only activate at long distances!
  uint8_t mult2 = 1;
  while ((a >> 24) + (b >> 24) > 0xFF) {
    180a:	69 81       	ldd	r22, Y+1	; 0x01
    180c:	7a 81       	ldd	r23, Y+2	; 0x02
    180e:	8b 81       	ldd	r24, Y+3	; 0x03
    1810:	9c 81       	ldd	r25, Y+4	; 0x04
    1812:	49 2f       	mov	r20, r25
    1814:	55 27       	eor	r21, r21
    1816:	66 27       	eor	r22, r22
    1818:	77 27       	eor	r23, r23
    181a:	89 89       	ldd	r24, Y+17	; 0x11
    181c:	9a 89       	ldd	r25, Y+18	; 0x12
    181e:	ab 89       	ldd	r26, Y+19	; 0x13
    1820:	bc 89       	ldd	r27, Y+20	; 0x14
    1822:	8b 2f       	mov	r24, r27
    1824:	99 27       	eor	r25, r25
    1826:	aa 27       	eor	r26, r26
    1828:	bb 27       	eor	r27, r27
    182a:	8d 87       	std	Y+13, r24	; 0x0d
    182c:	9e 87       	std	Y+14, r25	; 0x0e
    182e:	af 87       	std	Y+15, r26	; 0x0f
    1830:	b8 8b       	std	Y+16, r27	; 0x10
    1832:	48 0f       	add	r20, r24
    1834:	59 1f       	adc	r21, r25
    1836:	6a 1f       	adc	r22, r26
    1838:	7b 1f       	adc	r23, r27
    183a:	4f 3f       	cpi	r20, 0xFF	; 255
    183c:	51 05       	cpc	r21, r1
    183e:	61 05       	cpc	r22, r1
    1840:	71 05       	cpc	r23, r1
    1842:	09 f0       	breq	.+2      	; 0x1846 <main+0xc3e>
    1844:	08 f4       	brcc	.+2      	; 0x1848 <main+0xc40>
    1846:	4c c1       	rjmp	.+664    	; 0x1ae0 <main+0xed8>
    1848:	22 24       	eor	r2, r2
    184a:	23 94       	inc	r2
    184c:	29 89       	ldd	r18, Y+17	; 0x11
    184e:	3a 89       	ldd	r19, Y+18	; 0x12
    1850:	4b 89       	ldd	r20, Y+19	; 0x13
    1852:	5c 89       	ldd	r21, Y+20	; 0x14
    1854:	ed 82       	std	Y+5, r14	; 0x05
    1856:	fe 82       	std	Y+6, r15	; 0x06
    1858:	0f 83       	std	Y+7, r16	; 0x07
    185a:	18 87       	std	Y+8, r17	; 0x08
    185c:	ad 86       	std	Y+13, r10	; 0x0d
    185e:	be 86       	std	Y+14, r11	; 0x0e
    1860:	cf 86       	std	Y+15, r12	; 0x0f
    1862:	d8 8a       	std	Y+16, r13	; 0x10
    a /= 4;
    1864:	a9 80       	ldd	r10, Y+1	; 0x01
    1866:	ba 80       	ldd	r11, Y+2	; 0x02
    1868:	cb 80       	ldd	r12, Y+3	; 0x03
    186a:	dc 80       	ldd	r13, Y+4	; 0x04
    186c:	d6 94       	lsr	r13
    186e:	c7 94       	ror	r12
    1870:	b7 94       	ror	r11
    1872:	a7 94       	ror	r10
    1874:	d6 94       	lsr	r13
    1876:	c7 94       	ror	r12
    1878:	b7 94       	ror	r11
    187a:	a7 94       	ror	r10
    187c:	a9 82       	std	Y+1, r10	; 0x01
    187e:	ba 82       	std	Y+2, r11	; 0x02
    1880:	cb 82       	std	Y+3, r12	; 0x03
    1882:	dc 82       	std	Y+4, r13	; 0x04
    b /= 4;
    1884:	56 95       	lsr	r21
    1886:	47 95       	ror	r20
    1888:	37 95       	ror	r19
    188a:	27 95       	ror	r18
    188c:	56 95       	lsr	r21
    188e:	47 95       	ror	r20
    1890:	37 95       	ror	r19
    1892:	27 95       	ror	r18
    mult2 *= 2;
    1894:	22 0c       	add	r2, r2
  uint32_t b = (deltaLat * deltaLat);

  // Make sure that the squared deltas don't go over uin32_t when adding them together.
  // This should only activate at long distances!
  uint8_t mult2 = 1;
  while ((a >> 24) + (b >> 24) > 0xFF) {
    1896:	e5 2e       	mov	r14, r21
    1898:	ff 24       	eor	r15, r15
    189a:	00 27       	eor	r16, r16
    189c:	11 27       	eor	r17, r17
    189e:	8d 2d       	mov	r24, r13
    18a0:	99 27       	eor	r25, r25
    18a2:	aa 27       	eor	r26, r26
    18a4:	bb 27       	eor	r27, r27
    18a6:	e8 0e       	add	r14, r24
    18a8:	f9 1e       	adc	r15, r25
    18aa:	0a 1f       	adc	r16, r26
    18ac:	1b 1f       	adc	r17, r27
    18ae:	6f ef       	ldi	r22, 0xFF	; 255
    18b0:	e6 16       	cp	r14, r22
    18b2:	f1 04       	cpc	r15, r1
    18b4:	01 05       	cpc	r16, r1
    18b6:	11 05       	cpc	r17, r1
    18b8:	09 f0       	breq	.+2      	; 0x18bc <main+0xcb4>
    18ba:	a0 f6       	brcc	.-88     	; 0x1864 <main+0xc5c>
    18bc:	29 8b       	std	Y+17, r18	; 0x11
    18be:	3a 8b       	std	Y+18, r19	; 0x12
    18c0:	4b 8b       	std	Y+19, r20	; 0x13
    18c2:	5c 8b       	std	Y+20, r21	; 0x14
    18c4:	ed 80       	ldd	r14, Y+5	; 0x05
    18c6:	fe 80       	ldd	r15, Y+6	; 0x06
    18c8:	0f 81       	ldd	r16, Y+7	; 0x07
    18ca:	18 85       	ldd	r17, Y+8	; 0x08
    18cc:	ad 84       	ldd	r10, Y+13	; 0x0d
    18ce:	be 84       	ldd	r11, Y+14	; 0x0e
    18d0:	cf 84       	ldd	r12, Y+15	; 0x0f
    18d2:	d8 88       	ldd	r13, Y+16	; 0x10
    a /= 4;
    b /= 4;
    mult2 *= 2;
  }
  
  distance = calcSqrt(a + b);
    18d4:	89 81       	ldd	r24, Y+1	; 0x01
    18d6:	9a 81       	ldd	r25, Y+2	; 0x02
    18d8:	ab 81       	ldd	r26, Y+3	; 0x03
    18da:	bc 81       	ldd	r27, Y+4	; 0x04
    18dc:	29 89       	ldd	r18, Y+17	; 0x11
    18de:	3a 89       	ldd	r19, Y+18	; 0x12
    18e0:	4b 89       	ldd	r20, Y+19	; 0x13
    18e2:	5c 89       	ldd	r21, Y+20	; 0x14
    18e4:	82 0f       	add	r24, r18
    18e6:	93 1f       	adc	r25, r19
    18e8:	a4 1f       	adc	r26, r20
    18ea:	b5 1f       	adc	r27, r21
    18ec:	89 83       	std	Y+1, r24	; 0x01
    18ee:	9a 83       	std	Y+2, r25	; 0x02
    18f0:	ab 83       	std	Y+3, r26	; 0x03
    18f2:	bc 83       	std	Y+4, r27	; 0x04
}

static uint32_t calcSqrt(uint32_t input)
{
  int32_t nv;
  int32_t v = input>>1;
    18f4:	b6 95       	lsr	r27
    18f6:	a7 95       	ror	r26
    18f8:	97 95       	ror	r25
    18fa:	87 95       	ror	r24
    18fc:	8d 83       	std	Y+5, r24	; 0x05
    18fe:	9e 83       	std	Y+6, r25	; 0x06
    1900:	af 83       	std	Y+7, r26	; 0x07
    1902:	b8 87       	std	Y+8, r27	; 0x08
  int32_t c = 0;
  if (!v) {
    1904:	00 97       	sbiw	r24, 0x00	; 0
    1906:	a1 05       	cpc	r26, r1
    1908:	b1 05       	cpc	r27, r1
    190a:	09 f4       	brne	.+2      	; 0x190e <main+0xd06>
    190c:	d2 c0       	rjmp	.+420    	; 0x1ab2 <main+0xeaa>
    190e:	80 e0       	ldi	r24, 0x00	; 0
    1910:	90 e0       	ldi	r25, 0x00	; 0
    1912:	9e 87       	std	Y+14, r25	; 0x0e
    1914:	8d 87       	std	Y+13, r24	; 0x0d
    1916:	0c c0       	rjmp	.+24     	; 0x1930 <main+0xd28>
    return input;
  }	
  do {
    nv = (v + input / v)>>1;
    if (absu32(v - nv) <= 1) {
    1918:	8d 85       	ldd	r24, Y+13	; 0x0d
    191a:	9e 85       	ldd	r25, Y+14	; 0x0e
    191c:	01 96       	adiw	r24, 0x01	; 1
    191e:	9e 87       	std	Y+14, r25	; 0x0e
    1920:	8d 87       	std	Y+13, r24	; 0x0d
      return nv;
	  }	  
    v = nv;
  } while (c++ < 25);
    1922:	8a 31       	cpi	r24, 0x1A	; 26
    1924:	91 05       	cpc	r25, r1
    1926:	21 f1       	breq	.+72     	; 0x1970 <main+0xd68>
  do {
    nv = (v + input / v)>>1;
    if (absu32(v - nv) <= 1) {
      return nv;
	  }	  
    v = nv;
    1928:	2d 83       	std	Y+5, r18	; 0x05
    192a:	3e 83       	std	Y+6, r19	; 0x06
    192c:	4f 83       	std	Y+7, r20	; 0x07
    192e:	58 87       	std	Y+8, r21	; 0x08
  int32_t c = 0;
  if (!v) {
    return input;
  }	
  do {
    nv = (v + input / v)>>1;
    1930:	69 81       	ldd	r22, Y+1	; 0x01
    1932:	7a 81       	ldd	r23, Y+2	; 0x02
    1934:	8b 81       	ldd	r24, Y+3	; 0x03
    1936:	9c 81       	ldd	r25, Y+4	; 0x04
    1938:	2d 81       	ldd	r18, Y+5	; 0x05
    193a:	3e 81       	ldd	r19, Y+6	; 0x06
    193c:	4f 81       	ldd	r20, Y+7	; 0x07
    193e:	58 85       	ldd	r21, Y+8	; 0x08
    1940:	e8 d2       	rcall	.+1488   	; 0x1f12 <__udivmodsi4>
    1942:	6d 81       	ldd	r22, Y+5	; 0x05
    1944:	7e 81       	ldd	r23, Y+6	; 0x06
    1946:	8f 81       	ldd	r24, Y+7	; 0x07
    1948:	98 85       	ldd	r25, Y+8	; 0x08
    194a:	26 0f       	add	r18, r22
    194c:	37 1f       	adc	r19, r23
    194e:	48 1f       	adc	r20, r24
    1950:	59 1f       	adc	r21, r25
    1952:	56 95       	lsr	r21
    1954:	47 95       	ror	r20
    1956:	37 95       	ror	r19
    1958:	27 95       	ror	r18
    if (absu32(v - nv) <= 1) {
    195a:	dc 01       	movw	r26, r24
    195c:	cb 01       	movw	r24, r22
    195e:	82 1b       	sub	r24, r18
    1960:	93 0b       	sbc	r25, r19
    1962:	a4 0b       	sbc	r26, r20
    1964:	b5 0b       	sbc	r27, r21
    1966:	82 30       	cpi	r24, 0x02	; 2
    1968:	91 05       	cpc	r25, r1
    196a:	a1 05       	cpc	r26, r1
    196c:	b1 05       	cpc	r27, r1
    196e:	a0 f6       	brcc	.-88     	; 0x1918 <main+0xd10>
    1970:	ca 01       	movw	r24, r20
    1972:	b9 01       	movw	r22, r18
  distance *= mult2;
    1974:	22 2d       	mov	r18, r2
    1976:	30 e0       	ldi	r19, 0x00	; 0
    1978:	40 e0       	ldi	r20, 0x00	; 0
    197a:	50 e0       	ldi	r21, 0x00	; 0
    197c:	78 d2       	rcall	.+1264   	; 0x1e6e <__mulsi3>
    197e:	69 83       	std	Y+1, r22	; 0x01
    1980:	7a 83       	std	Y+2, r23	; 0x02
    1982:	8b 83       	std	Y+3, r24	; 0x03
    1984:	9c 83       	std	Y+4, r25	; 0x04

  // Only calculate bearing if bearing pointer is set.
  if (bearingResult != NULL) {
    bearing = 0;
    if (distance > 0) { // Over home -> do not compute; Home forced to 0
    1986:	61 15       	cp	r22, r1
    1988:	71 05       	cpc	r23, r1
    198a:	81 05       	cpc	r24, r1
    198c:	91 05       	cpc	r25, r1
    198e:	09 f4       	brne	.+2      	; 0x1992 <main+0xd8a>
    1990:	46 c0       	rjmp	.+140    	; 0x1a1e <main+0xe16>
      if (absi32(deltaLong) >= absi32(deltaLat)) { // low angle, sine is better
    1992:	29 85       	ldd	r18, Y+9	; 0x09
    1994:	3a 85       	ldd	r19, Y+10	; 0x0a
    1996:	4b 85       	ldd	r20, Y+11	; 0x0b
    1998:	5c 85       	ldd	r21, Y+12	; 0x0c
    199a:	62 16       	cp	r6, r18
    199c:	73 06       	cpc	r7, r19
    199e:	84 06       	cpc	r8, r20
    19a0:	95 06       	cpc	r9, r21
    19a2:	08 f4       	brcc	.+2      	; 0x19a6 <main+0xd9e>
    19a4:	a0 c0       	rjmp	.+320    	; 0x1ae6 <main+0xede>
        c = (absi32(deltaLat) * 100) / distance; // computes sine -> dist > 0
    19a6:	ca 01       	movw	r24, r20
    19a8:	b9 01       	movw	r22, r18
    19aa:	24 e6       	ldi	r18, 0x64	; 100
    19ac:	30 e0       	ldi	r19, 0x00	; 0
    19ae:	40 e0       	ldi	r20, 0x00	; 0
    19b0:	50 e0       	ldi	r21, 0x00	; 0
    19b2:	5d d2       	rcall	.+1210   	; 0x1e6e <__mulsi3>
    19b4:	29 81       	ldd	r18, Y+1	; 0x01
    19b6:	3a 81       	ldd	r19, Y+2	; 0x02
    19b8:	4b 81       	ldd	r20, Y+3	; 0x03
    19ba:	5c 81       	ldd	r21, Y+4	; 0x04
    19bc:	aa d2       	rcall	.+1364   	; 0x1f12 <__udivmodsi4>
    19be:	62 2e       	mov	r6, r18
  distance = calcSqrt(a + b);
  distance *= mult2;

  // Only calculate bearing if bearing pointer is set.
  if (bearingResult != NULL) {
    bearing = 0;
    19c0:	20 e0       	ldi	r18, 0x00	; 0
    19c2:	30 e0       	ldi	r19, 0x00	; 0
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
	int8_t mult = 1;
    19c4:	41 e0       	ldi	r20, 0x01	; 1
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    19c6:	80 e0       	ldi	r24, 0x00	; 0
    19c8:	90 e0       	ldi	r25, 0x00	; 0
		pos = pos - 180;
		mult = -1;
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
		pos = 180 - pos;
    19ca:	64 eb       	ldi	r22, 0xB4	; 180
    19cc:	86 2e       	mov	r8, r22
    19ce:	91 2c       	mov	r9, r1
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
    19d0:	8c 5c       	subi	r24, 0xCC	; 204
    19d2:	9f 4f       	sbci	r25, 0xFF	; 255
    19d4:	fc 01       	movw	r30, r24
    19d6:	84 91       	lpm	r24, Z+
    19d8:	84 9f       	mul	r24, r20
    19da:	40 2d       	mov	r20, r0
    19dc:	11 24       	eor	r1, r1
    if (distance > 0) { // Over home -> do not compute; Home forced to 0
      if (absi32(deltaLong) >= absi32(deltaLat)) { // low angle, sine is better
        c = (absi32(deltaLat) * 100) / distance; // computes sine -> dist > 0
        while((mySin(bearing) <= c) && (bearing < 90)) {
    19de:	64 16       	cp	r6, r20
    19e0:	0c f4       	brge	.+2      	; 0x19e4 <main+0xddc>
    19e2:	49 c0       	rjmp	.+146    	; 0x1a76 <main+0xe6e>
    19e4:	2a 35       	cpi	r18, 0x5A	; 90
    19e6:	31 05       	cpc	r19, r1
    19e8:	09 f4       	brne	.+2      	; 0x19ec <main+0xde4>
    19ea:	45 c0       	rjmp	.+138    	; 0x1a76 <main+0xe6e>
          ++bearing;
    19ec:	2f 5f       	subi	r18, 0xFF	; 255
    19ee:	3f 4f       	sbci	r19, 0xFF	; 255
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    19f0:	c9 01       	movw	r24, r18
    19f2:	68 e6       	ldi	r22, 0x68	; 104
    19f4:	71 e0       	ldi	r23, 0x01	; 1
    19f6:	66 d2       	rcall	.+1228   	; 0x1ec4 <__udivmodhi4>
	int8_t mult = 1;
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    19f8:	84 3b       	cpi	r24, 0xB4	; 180
    19fa:	91 05       	cpc	r25, r1
    19fc:	58 f0       	brcs	.+22     	; 0x1a14 <main+0xe0c>
		pos = pos - 180;
    19fe:	84 5b       	subi	r24, 0xB4	; 180
    1a00:	90 40       	sbci	r25, 0x00	; 0
		mult = -1;
    1a02:	4f ef       	ldi	r20, 0xFF	; 255
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
    1a04:	8a 35       	cpi	r24, 0x5A	; 90
    1a06:	91 05       	cpc	r25, r1
    1a08:	18 f3       	brcs	.-58     	; 0x19d0 <main+0xdc8>
		pos = 180 - pos;
    1a0a:	b4 01       	movw	r22, r8
    1a0c:	68 1b       	sub	r22, r24
    1a0e:	79 0b       	sbc	r23, r25
    1a10:	cb 01       	movw	r24, r22
    1a12:	de cf       	rjmp	.-68     	; 0x19d0 <main+0xdc8>
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
	int8_t mult = 1;
    1a14:	41 e0       	ldi	r20, 0x01	; 1
    1a16:	f6 cf       	rjmp	.-20     	; 0x1a04 <main+0xdfc>
		level *= outMax - outMin;
		level /= inMax - inMin;
		level += outMin;
	}
	else {
		level = outMin;
    1a18:	60 e0       	ldi	r22, 0x00	; 0
    1a1a:	70 e0       	ldi	r23, 0x00	; 0
    1a1c:	e8 cc       	rjmp	.-1584   	; 0x13ee <main+0x7e6>
  distance = calcSqrt(a + b);
  distance *= mult2;

  // Only calculate bearing if bearing pointer is set.
  if (bearingResult != NULL) {
    bearing = 0;
    1a1e:	80 e0       	ldi	r24, 0x00	; 0
    1a20:	90 e0       	ldi	r25, 0x00	; 0
	      else { // SW quadrant
          bearing = 270 - bearing;
        }
      }
    }
    *bearingResult = bearing;
    1a22:	90 93 3e 04 	sts	0x043E, r25
    1a26:	80 93 3d 04 	sts	0x043D, r24
	}
  distance = distance * 309; // ate aqui em segundo * 100
    1a2a:	69 81       	ldd	r22, Y+1	; 0x01
    1a2c:	7a 81       	ldd	r23, Y+2	; 0x02
    1a2e:	8b 81       	ldd	r24, Y+3	; 0x03
    1a30:	9c 81       	ldd	r25, Y+4	; 0x04
    1a32:	25 e3       	ldi	r18, 0x35	; 53
    1a34:	31 e0       	ldi	r19, 0x01	; 1
    1a36:	40 e0       	ldi	r20, 0x00	; 0
    1a38:	50 e0       	ldi	r21, 0x00	; 0
    1a3a:	19 d2       	rcall	.+1074   	; 0x1e6e <__mulsi3>
  distance = distance / 1000; // metros, agora
    1a3c:	28 ee       	ldi	r18, 0xE8	; 232
    1a3e:	33 e0       	ldi	r19, 0x03	; 3
    1a40:	40 e0       	ldi	r20, 0x00	; 0
    1a42:	50 e0       	ldi	r21, 0x00	; 0
    1a44:	66 d2       	rcall	.+1228   	; 0x1f12 <__udivmodsi4>
    1a46:	79 01       	movw	r14, r18
    1a48:	8a 01       	movw	r16, r20
  distance *= mult;
    1a4a:	23 2d       	mov	r18, r3
    1a4c:	30 e0       	ldi	r19, 0x00	; 0
    1a4e:	40 e0       	ldi	r20, 0x00	; 0
    1a50:	50 e0       	ldi	r21, 0x00	; 0
    1a52:	c8 01       	movw	r24, r16
    1a54:	b7 01       	movw	r22, r14
    1a56:	0b d2       	rcall	.+1046   	; 0x1e6e <__mulsi3>
#ifdef IMPERIAL_SYSTEM  
  distance *= 3281;
	distance /= 1000;
#endif //IMPERIAL_SYSTEM
  *distanceResult = distance;
    1a58:	60 93 39 04 	sts	0x0439, r22
    1a5c:	70 93 3a 04 	sts	0x043A, r23
    1a60:	80 93 3b 04 	sts	0x043B, r24
    1a64:	90 93 3c 04 	sts	0x043C, r25
    1a68:	fa cb       	rjmp	.-2060   	; 0x125e <main+0x656>
    1a6a:	6d 81       	ldd	r22, Y+5	; 0x05
    1a6c:	7e 81       	ldd	r23, Y+6	; 0x06
	    else { // high angle, cosine is better
        c = (absi32(deltaLong) * 100) / distance; // Computes cosine
        while((mySin(bearing) <= c) && (bearing < 90)) {
          ++bearing;
        }
        bearing = 90 - bearing;
    1a6e:	2a e5       	ldi	r18, 0x5A	; 90
    1a70:	30 e0       	ldi	r19, 0x00	; 0
    1a72:	26 1b       	sub	r18, r22
    1a74:	37 0b       	sbc	r19, r23
      }
      if (deltaLat == 0) {
    1a76:	a1 14       	cp	r10, r1
    1a78:	b1 04       	cpc	r11, r1
    1a7a:	c1 04       	cpc	r12, r1
    1a7c:	d1 04       	cpc	r13, r1
    1a7e:	09 f0       	breq	.+2      	; 0x1a82 <main+0xe7a>
    1a80:	77 c0       	rjmp	.+238    	; 0x1b70 <main+0xf68>
        if (deltaLong >= 0) { // Home = East
    1a82:	17 fd       	sbrc	r17, 7
    1a84:	72 c0       	rjmp	.+228    	; 0x1b6a <main+0xf62>
          bearing = 90; 
    1a86:	8a e5       	ldi	r24, 0x5A	; 90
    1a88:	90 e0       	ldi	r25, 0x00	; 0
    1a8a:	cb cf       	rjmp	.-106    	; 0x1a22 <main+0xe1a>

  // considers flat earth around vehicle and reference

  // Ernani Reis, Aug 2011
  
  if (currLat == homeLat && currLong == homeLong) {
    1a8c:	62 16       	cp	r6, r18
    1a8e:	73 06       	cpc	r7, r19
    1a90:	84 06       	cpc	r8, r20
    1a92:	95 06       	cpc	r9, r21
    1a94:	09 f0       	breq	.+2      	; 0x1a98 <main+0xe90>
    1a96:	08 ce       	rjmp	.-1008   	; 0x16a8 <main+0xaa0>
	  *distanceResult = 0;
    1a98:	10 92 39 04 	sts	0x0439, r1
    1a9c:	10 92 3a 04 	sts	0x043A, r1
    1aa0:	10 92 3b 04 	sts	0x043B, r1
    1aa4:	10 92 3c 04 	sts	0x043C, r1
	  *bearingResult = 0;
    1aa8:	10 92 3e 04 	sts	0x043E, r1
    1aac:	10 92 3d 04 	sts	0x043D, r1
    1ab0:	d6 cb       	rjmp	.-2132   	; 0x125e <main+0x656>
{
  int32_t nv;
  int32_t v = input>>1;
  int32_t c = 0;
  if (!v) {
    return input;
    1ab2:	69 81       	ldd	r22, Y+1	; 0x01
    1ab4:	7a 81       	ldd	r23, Y+2	; 0x02
    1ab6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ab8:	9c 81       	ldd	r25, Y+4	; 0x04
    1aba:	5c cf       	rjmp	.-328    	; 0x1974 <main+0xd6c>
static void finishGpsDecoding() {
	
if (gGpsLastData.pos.altitude > gGpsLastValidData.pos.altitude) 
altitudeArrow = 1;
		
else if (gGpsLastData.pos.altitude < gGpsLastValidData.pos.altitude)
    1abc:	28 17       	cp	r18, r24
    1abe:	39 07       	cpc	r19, r25
    1ac0:	0c f0       	brlt	.+2      	; 0x1ac4 <main+0xebc>
    1ac2:	a0 cd       	rjmp	.-1216   	; 0x1604 <main+0x9fc>
altitudeArrow = -1;
    1ac4:	40 93 dd 03 	sts	0x03DD, r20
    1ac8:	9d cd       	rjmp	.-1222   	; 0x1604 <main+0x9fc>
    1aca:	33 24       	eor	r3, r3
    1acc:	33 94       	inc	r3
    1ace:	07 ce       	rjmp	.-1010   	; 0x16de <main+0xad6>
#ifndef COMMONUTILS_H_
#define COMMONUTILS_H_

// abs seems to only support 16 bits so I had to make my own.
static uint32_t absi32(int32_t a) {
	return (a > 0) ? a : -a;
    1ad0:	90 95       	com	r25
    1ad2:	80 95       	com	r24
    1ad4:	70 95       	com	r23
    1ad6:	61 95       	neg	r22
    1ad8:	7f 4f       	sbci	r23, 0xFF	; 255
    1ada:	8f 4f       	sbci	r24, 0xFF	; 255
    1adc:	9f 4f       	sbci	r25, 0xFF	; 255
    1ade:	ec cd       	rjmp	.-1064   	; 0x16b8 <main+0xab0>
  uint32_t a = (deltaLong * deltaLong);
  uint32_t b = (deltaLat * deltaLat);

  // Make sure that the squared deltas don't go over uin32_t when adding them together.
  // This should only activate at long distances!
  uint8_t mult2 = 1;
    1ae0:	22 24       	eor	r2, r2
    1ae2:	23 94       	inc	r2
    1ae4:	f7 ce       	rjmp	.-530    	; 0x18d4 <main+0xccc>
        while((mySin(bearing) <= c) && (bearing < 90)) {
          ++bearing;
        }
      } 
	    else { // high angle, cosine is better
        c = (absi32(deltaLong) * 100) / distance; // Computes cosine
    1ae6:	c4 01       	movw	r24, r8
    1ae8:	b3 01       	movw	r22, r6
    1aea:	24 e6       	ldi	r18, 0x64	; 100
    1aec:	30 e0       	ldi	r19, 0x00	; 0
    1aee:	40 e0       	ldi	r20, 0x00	; 0
    1af0:	50 e0       	ldi	r21, 0x00	; 0
    1af2:	bd d1       	rcall	.+890    	; 0x1e6e <__mulsi3>
    1af4:	29 81       	ldd	r18, Y+1	; 0x01
    1af6:	3a 81       	ldd	r19, Y+2	; 0x02
    1af8:	4b 81       	ldd	r20, Y+3	; 0x03
    1afa:	5c 81       	ldd	r21, Y+4	; 0x04
    1afc:	0a d2       	rcall	.+1044   	; 0x1f12 <__udivmodsi4>
    1afe:	62 2e       	mov	r6, r18
  distance = calcSqrt(a + b);
  distance *= mult2;

  // Only calculate bearing if bearing pointer is set.
  if (bearingResult != NULL) {
    bearing = 0;
    1b00:	60 e0       	ldi	r22, 0x00	; 0
    1b02:	70 e0       	ldi	r23, 0x00	; 0
    1b04:	41 e0       	ldi	r20, 0x01	; 1
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    1b06:	80 e0       	ldi	r24, 0x00	; 0
    1b08:	90 e0       	ldi	r25, 0x00	; 0
    1b0a:	28 e6       	ldi	r18, 0x68	; 104
    1b0c:	31 e0       	ldi	r19, 0x01	; 1
		pos = pos - 180;
		mult = -1;
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
		pos = 180 - pos;
    1b0e:	54 eb       	ldi	r21, 0xB4	; 180
    1b10:	85 2e       	mov	r8, r21
    1b12:	91 2c       	mov	r9, r1
    1b14:	7e 83       	std	Y+6, r23	; 0x06
    1b16:	6d 83       	std	Y+5, r22	; 0x05
	}
	return mult * (int8_t)(pgm_read_byte(&sinData[pos]));
    1b18:	8c 5c       	subi	r24, 0xCC	; 204
    1b1a:	9f 4f       	sbci	r25, 0xFF	; 255
    1b1c:	fc 01       	movw	r30, r24
    1b1e:	84 91       	lpm	r24, Z+
    1b20:	84 9f       	mul	r24, r20
    1b22:	40 2d       	mov	r20, r0
    1b24:	11 24       	eor	r1, r1
          ++bearing;
        }
      } 
	    else { // high angle, cosine is better
        c = (absi32(deltaLong) * 100) / distance; // Computes cosine
        while((mySin(bearing) <= c) && (bearing < 90)) {
    1b26:	64 16       	cp	r6, r20
    1b28:	0c f4       	brge	.+2      	; 0x1b2c <main+0xf24>
    1b2a:	9f cf       	rjmp	.-194    	; 0x1a6a <main+0xe62>
    1b2c:	4d 81       	ldd	r20, Y+5	; 0x05
    1b2e:	5e 81       	ldd	r21, Y+6	; 0x06
    1b30:	4a 35       	cpi	r20, 0x5A	; 90
    1b32:	51 05       	cpc	r21, r1
    1b34:	09 f4       	brne	.+2      	; 0x1b38 <main+0xf30>
    1b36:	99 cf       	rjmp	.-206    	; 0x1a6a <main+0xe62>
          ++bearing;
    1b38:	4d 81       	ldd	r20, Y+5	; 0x05
    1b3a:	5e 81       	ldd	r21, Y+6	; 0x06
    1b3c:	4f 5f       	subi	r20, 0xFF	; 255
    1b3e:	5f 4f       	sbci	r21, 0xFF	; 255
    1b40:	5e 83       	std	Y+6, r21	; 0x06
    1b42:	4d 83       	std	Y+5, r20	; 0x05
  85, 86, 87, 87, 88, 89, 90, 91, 91, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97,
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
    1b44:	ca 01       	movw	r24, r20
    1b46:	b9 01       	movw	r22, r18
    1b48:	bd d1       	rcall	.+890    	; 0x1ec4 <__udivmodhi4>
	int8_t mult = 1;
	// 180-359 is same as 0-179 but negative.
	if (pos >= 180) { 
    1b4a:	84 3b       	cpi	r24, 0xB4	; 180
    1b4c:	91 05       	cpc	r25, r1
    1b4e:	58 f0       	brcs	.+22     	; 0x1b66 <main+0xf5e>
		pos = pos - 180;
    1b50:	84 5b       	subi	r24, 0xB4	; 180
    1b52:	90 40       	sbci	r25, 0x00	; 0
		mult = -1;
    1b54:	4f ef       	ldi	r20, 0xFF	; 255
	}
	// 0-89 is equal to 90-179 except backwards.
	if (pos >= 90) { 
    1b56:	8a 35       	cpi	r24, 0x5A	; 90
    1b58:	91 05       	cpc	r25, r1
    1b5a:	f0 f2       	brcs	.-68     	; 0x1b18 <main+0xf10>
		pos = 180 - pos;
    1b5c:	b4 01       	movw	r22, r8
    1b5e:	68 1b       	sub	r22, r24
    1b60:	79 0b       	sbc	r23, r25
    1b62:	cb 01       	movw	r24, r22
    1b64:	d9 cf       	rjmp	.-78     	; 0x1b18 <main+0xf10>
  97, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100};

static int8_t mySin(uint16_t angle) {
	uint16_t pos = 0;
	pos = angle % 360;
	int8_t mult = 1;
    1b66:	41 e0       	ldi	r20, 0x01	; 1
    1b68:	f6 cf       	rjmp	.-20     	; 0x1b56 <main+0xf4e>
      if (deltaLat == 0) {
        if (deltaLong >= 0) { // Home = East
          bearing = 90; 
        } 
	      else { // Home = West
          bearing = 270;
    1b6a:	8e e0       	ldi	r24, 0x0E	; 14
    1b6c:	91 e0       	ldi	r25, 0x01	; 1
    1b6e:	59 cf       	rjmp	.-334    	; 0x1a22 <main+0xe1a>
        }
      } 
      else if (deltaLat > 0) {
    1b70:	1a 14       	cp	r1, r10
    1b72:	1b 04       	cpc	r1, r11
    1b74:	1c 04       	cpc	r1, r12
    1b76:	1d 04       	cpc	r1, r13
    1b78:	3c f4       	brge	.+14     	; 0x1b88 <main+0xf80>
        if (deltaLong >= 0) { // NE quadrant
    1b7a:	17 fd       	sbrc	r17, 7
    1b7c:	0b c0       	rjmp	.+22     	; 0x1b94 <main+0xf8c>
          bearing = 90 - bearing;
    1b7e:	8a e5       	ldi	r24, 0x5A	; 90
    1b80:	90 e0       	ldi	r25, 0x00	; 0
    1b82:	82 1b       	sub	r24, r18
    1b84:	93 0b       	sbc	r25, r19
    1b86:	4d cf       	rjmp	.-358    	; 0x1a22 <main+0xe1a>
	      else { // NW quadrant
          bearing = 270 + bearing;
        }
      } 
	    else {
        if (deltaLong >= 0) { // SE quadrant
    1b88:	17 fd       	sbrc	r17, 7
    1b8a:	08 c0       	rjmp	.+16     	; 0x1b9c <main+0xf94>
          bearing = 90 + bearing;
    1b8c:	c9 01       	movw	r24, r18
    1b8e:	86 5a       	subi	r24, 0xA6	; 166
    1b90:	9f 4f       	sbci	r25, 0xFF	; 255
    1b92:	47 cf       	rjmp	.-370    	; 0x1a22 <main+0xe1a>
      else if (deltaLat > 0) {
        if (deltaLong >= 0) { // NE quadrant
          bearing = 90 - bearing;
        } 
	      else { // NW quadrant
          bearing = 270 + bearing;
    1b94:	c9 01       	movw	r24, r18
    1b96:	82 5f       	subi	r24, 0xF2	; 242
    1b98:	9e 4f       	sbci	r25, 0xFE	; 254
    1b9a:	43 cf       	rjmp	.-378    	; 0x1a22 <main+0xe1a>
	    else {
        if (deltaLong >= 0) { // SE quadrant
          bearing = 90 + bearing;
        } 
	      else { // SW quadrant
          bearing = 270 - bearing;
    1b9c:	8e e0       	ldi	r24, 0x0E	; 14
    1b9e:	91 e0       	ldi	r25, 0x01	; 1
    1ba0:	82 1b       	sub	r24, r18
    1ba2:	93 0b       	sbc	r25, r19
    1ba4:	3e cf       	rjmp	.-388    	; 0x1a22 <main+0xe1a>

00001ba6 <__vector_1>:
			//DDRB &= ~OUT1;
		}
	}
}

ISR(INT0_vect) {
    1ba6:	1f 92       	push	r1
    1ba8:	0f 92       	push	r0
    1baa:	0f b6       	in	r0, 0x3f	; 63
    1bac:	0f 92       	push	r0
    1bae:	11 24       	eor	r1, r1
    1bb0:	2f 93       	push	r18
    1bb2:	3f 93       	push	r19
    1bb4:	4f 93       	push	r20
    1bb6:	5f 93       	push	r21
    1bb8:	6f 93       	push	r22
    1bba:	7f 93       	push	r23
    1bbc:	8f 93       	push	r24
    1bbe:	9f 93       	push	r25
    1bc0:	af 93       	push	r26
    1bc2:	bf 93       	push	r27
    1bc4:	ef 93       	push	r30
    1bc6:	ff 93       	push	r31
	TCNT1 = 0; // Reset sync lost timeout.
    1bc8:	10 92 85 00 	sts	0x0085, r1
    1bcc:	10 92 84 00 	sts	0x0084, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1bd0:	28 e2       	ldi	r18, 0x28	; 40
    1bd2:	2a 95       	dec	r18
    1bd4:	f1 f7       	brne	.-4      	; 0x1bd2 <__vector_1+0x2c>
}  

static void updateLine() {
  _delay_us(5); // wait 5us to see if H or V sync

	if(!(PIND & LTRIG)) { // H sync
    1bd6:	4a 99       	sbic	0x09, 2	; 9
    1bd8:	7a c0       	rjmp	.+244    	; 0x1cce <__vector_1+0x128>
		if (gActiveLine != 0) {
    1bda:	80 91 7c 01 	lds	r24, 0x017C
    1bde:	90 91 7d 01 	lds	r25, 0x017D
    1be2:	00 97       	sbiw	r24, 0x00	; 0
    1be4:	09 f4       	brne	.+2      	; 0x1be8 <__vector_1+0x42>
    1be6:	35 c0       	rjmp	.+106    	; 0x1c52 <__vector_1+0xac>
			switch(gLineType) {
    1be8:	20 91 7f 01 	lds	r18, 0x017F
    1bec:	21 30       	cpi	r18, 0x01	; 1
    1bee:	09 f4       	brne	.+2      	; 0x1bf2 <__vector_1+0x4c>
    1bf0:	91 c0       	rjmp	.+290    	; 0x1d14 <__vector_1+0x16e>
    1bf2:	22 30       	cpi	r18, 0x02	; 2
    1bf4:	09 f0       	breq	.+2      	; 0x1bf8 <__vector_1+0x52>
    1bf6:	2d c0       	rjmp	.+90     	; 0x1c52 <__vector_1+0xac>
    1bf8:	e3 e1       	ldi	r30, 0x13	; 19
    1bfa:	f1 e0       	ldi	r31, 0x01	; 1
    1bfc:	31 97       	sbiw	r30, 0x01	; 1
    1bfe:	f1 f7       	brne	.-4      	; 0x1bfc <__vector_1+0x56>
    1c00:	00 c0       	rjmp	.+0      	; 0x1c02 <__vector_1+0x5c>
    1c02:	00 00       	nop
{
#ifdef TEXT_SMALL_ENABLED
	SPSR &= ~(1<<SPI2X); // Set normal speed
#endif //TEXT_SMALL_ENABLED
  _delay_us(GRAPHICS_OFFSET);
  uint16_t currLine = gActivePixmapLine;
    1c04:	e0 91 84 01 	lds	r30, 0x0184
    1c08:	f0 e0       	ldi	r31, 0x00	; 0
			//DDRB &= ~OUT1;
		}
	}
}

ISR(INT0_vect) {
    1c0a:	ed 5a       	subi	r30, 0xAD	; 173
    1c0c:	fc 4f       	sbci	r31, 0xFC	; 252
  for (uint8_t i = 0; i < GRAPHICS_WIDTH; ++i) {
    1c0e:	20 e0       	ldi	r18, 0x00	; 0
	  SPDR = gPixelData[i][currLine];
    1c10:	30 81       	ld	r19, Z
    1c12:	3e bd       	out	0x2e, r19	; 46
	  DDRB |= OUT1;
    1c14:	21 9a       	sbi	0x04, 1	; 4
	...
	  DELAY_9_NOP();
	  DELAY_9_NOP();
	  DELAY_5_NOP();
    1c42:	00 00       	nop
#ifdef TEXT_SMALL_ENABLED
	SPSR &= ~(1<<SPI2X); // Set normal speed
#endif //TEXT_SMALL_ENABLED
  _delay_us(GRAPHICS_OFFSET);
  uint16_t currLine = gActivePixmapLine;
  for (uint8_t i = 0; i < GRAPHICS_WIDTH; ++i) {
    1c44:	2f 5f       	subi	r18, 0xFF	; 255
    1c46:	78 96       	adiw	r30, 0x18	; 24
    1c48:	23 30       	cpi	r18, 0x03	; 3
    1c4a:	11 f7       	brne	.-60     	; 0x1c10 <__vector_1+0x6a>
	  DDRB |= OUT1;
	  DELAY_9_NOP();
	  DELAY_9_NOP();
	  DELAY_5_NOP();
  }
  DDRB &= ~OUT1;
    1c4c:	21 98       	cbi	0x04, 1	; 4
  DELAY_1_NOP();
    1c4e:	00 00       	nop
  SPDR = 0x00;
    1c50:	1e bc       	out	0x2e, r1	; 46
					break;
			}
		}
		
		// We save some time in beginning of line by pre-calculating next type.
		gLineType = LINE_TYPE_UNKNOWN; // Default case
    1c52:	10 92 7f 01 	sts	0x017F, r1
		gActiveLine++;
    1c56:	01 96       	adiw	r24, 0x01	; 1
    1c58:	90 93 7d 01 	sts	0x017D, r25
    1c5c:	80 93 7c 01 	sts	0x017C, r24
		if (gActiveLine == UPDATE_LINE) {
    1c60:	8e 36       	cpi	r24, 0x6E	; 110
    1c62:	91 05       	cpc	r25, r1
    1c64:	09 f4       	brne	.+2      	; 0x1c68 <__vector_1+0xc2>
    1c66:	44 c0       	rjmp	.+136    	; 0x1cf0 <__vector_1+0x14a>
			gUpdateScreenData = 1;
		}
		else if (gActiveLine == UPDATE_LINE + 1) {
    1c68:	8f 36       	cpi	r24, 0x6F	; 111
    1c6a:	91 05       	cpc	r25, r1
    1c6c:	09 f4       	brne	.+2      	; 0x1c70 <__vector_1+0xca>
    1c6e:	8f c0       	rjmp	.+286    	; 0x1d8e <__vector_1+0x1e8>
			gUpdateScreenData = 2;
		}

#ifdef TEXT_ENABLED	
		if (gActiveLine >= gActiveTextLine && gActiveLine < gActiveTextLastLine) {
    1c70:	40 91 82 01 	lds	r20, 0x0182
    1c74:	50 91 83 01 	lds	r21, 0x0183
    1c78:	84 17       	cp	r24, r20
    1c7a:	95 07       	cpc	r25, r21
    1c7c:	a0 f1       	brcs	.+104    	; 0x1ce6 <__vector_1+0x140>
    1c7e:	20 91 5d 01 	lds	r18, 0x015D
    1c82:	30 91 5e 01 	lds	r19, 0x015E
    1c86:	82 17       	cp	r24, r18
    1c88:	93 07       	cpc	r25, r19
    1c8a:	b0 f1       	brcs	.+108    	; 0x1cf8 <__vector_1+0x152>
		  gActivePixmapLine = (gActiveLine - gActiveTextLine);
		  if (gActiveTextSize == TEXT_SIZE_LARGE_MULT) {
		    gActivePixmapLine /= TEXT_SIZE_LARGE_MULT;
		  }
		}
		else if (gActiveLine == gActiveTextLastLine) {
    1c8c:	82 17       	cp	r24, r18
    1c8e:	93 07       	cpc	r25, r19
    1c90:	09 f4       	brne	.+2      	; 0x1c94 <__vector_1+0xee>
    1c92:	8e c0       	rjmp	.+284    	; 0x1db0 <__vector_1+0x20a>
			gActivePixmapLine = 1;
			return;
		}
#endif //TEXT_ENABLED		
#ifdef GRAPICSENABLED		
		else if (gActiveLine >= GRAPHICS_LINE && gActiveLine < (GRAPHICS_LINE + GRAPHICS_HEIGHT)) {
    1c94:	9c 01       	movw	r18, r24
    1c96:	29 56       	subi	r18, 0x69	; 105
    1c98:	30 40       	sbci	r19, 0x00	; 0
    1c9a:	28 31       	cpi	r18, 0x18	; 24
    1c9c:	31 05       	cpc	r19, r1
    1c9e:	30 f4       	brcc	.+12     	; 0x1cac <__vector_1+0x106>
			gLineType = LINE_TYPE_GRAPHICS;
    1ca0:	22 e0       	ldi	r18, 0x02	; 2
    1ca2:	20 93 7f 01 	sts	0x017F, r18
			gActivePixmapLine = (gActiveLine - GRAPHICS_LINE);
    1ca6:	89 56       	subi	r24, 0x69	; 105
    1ca8:	80 93 84 01 	sts	0x0184, r24
	TCNT1 = 0; // Reset sync lost timeout.
	updateLine();
}
    1cac:	ff 91       	pop	r31
    1cae:	ef 91       	pop	r30
    1cb0:	bf 91       	pop	r27
    1cb2:	af 91       	pop	r26
    1cb4:	9f 91       	pop	r25
    1cb6:	8f 91       	pop	r24
    1cb8:	7f 91       	pop	r23
    1cba:	6f 91       	pop	r22
    1cbc:	5f 91       	pop	r21
    1cbe:	4f 91       	pop	r20
    1cc0:	3f 91       	pop	r19
    1cc2:	2f 91       	pop	r18
    1cc4:	0f 90       	pop	r0
    1cc6:	0f be       	out	0x3f, r0	; 63
    1cc8:	0f 90       	pop	r0
    1cca:	1f 90       	pop	r1
    1ccc:	18 95       	reti
		}
#endif //GRAPICSENABLED
	}
	else { // V sync
		if(gActiveLine > 200) {
    1cce:	80 91 7c 01 	lds	r24, 0x017C
    1cd2:	90 91 7d 01 	lds	r25, 0x017D
    1cd6:	89 3c       	cpi	r24, 0xC9	; 201
    1cd8:	91 05       	cpc	r25, r1
    1cda:	40 f3       	brcs	.-48     	; 0x1cac <__vector_1+0x106>
			gActiveLine = 0;
    1cdc:	10 92 7d 01 	sts	0x017D, r1
    1ce0:	10 92 7c 01 	sts	0x017C, r1
    1ce4:	e3 cf       	rjmp	.-58     	; 0x1cac <__vector_1+0x106>
#ifdef TEXT_ENABLED	
		if (gActiveLine >= gActiveTextLine && gActiveLine < gActiveTextLastLine) {
	    gLineType = LINE_TYPE_TEXT;
		  gActivePixmapLine = (gActiveLine - gActiveTextLine);
		  if (gActiveTextSize == TEXT_SIZE_LARGE_MULT) {
		    gActivePixmapLine /= TEXT_SIZE_LARGE_MULT;
    1ce6:	20 91 5d 01 	lds	r18, 0x015D
    1cea:	30 91 5e 01 	lds	r19, 0x015E
    1cee:	ce cf       	rjmp	.-100    	; 0x1c8c <__vector_1+0xe6>
		
		// We save some time in beginning of line by pre-calculating next type.
		gLineType = LINE_TYPE_UNKNOWN; // Default case
		gActiveLine++;
		if (gActiveLine == UPDATE_LINE) {
			gUpdateScreenData = 1;
    1cf0:	21 e0       	ldi	r18, 0x01	; 1
    1cf2:	20 93 81 01 	sts	0x0181, r18
    1cf6:	bc cf       	rjmp	.-136    	; 0x1c70 <__vector_1+0xca>
			gUpdateScreenData = 2;
		}

#ifdef TEXT_ENABLED	
		if (gActiveLine >= gActiveTextLine && gActiveLine < gActiveTextLastLine) {
	    gLineType = LINE_TYPE_TEXT;
    1cf8:	21 e0       	ldi	r18, 0x01	; 1
    1cfa:	20 93 7f 01 	sts	0x017F, r18
		  gActivePixmapLine = (gActiveLine - gActiveTextLine);
    1cfe:	84 1b       	sub	r24, r20
    1d00:	80 93 84 01 	sts	0x0184, r24
		  if (gActiveTextSize == TEXT_SIZE_LARGE_MULT) {
    1d04:	90 91 5f 01 	lds	r25, 0x015F
    1d08:	92 30       	cpi	r25, 0x02	; 2
    1d0a:	81 f6       	brne	.-96     	; 0x1cac <__vector_1+0x106>
		    gActivePixmapLine /= TEXT_SIZE_LARGE_MULT;
    1d0c:	86 95       	lsr	r24
    1d0e:	80 93 84 01 	sts	0x0184, r24
    1d12:	cc cf       	rjmp	.-104    	; 0x1cac <__vector_1+0x106>
	if(!(PIND & LTRIG)) { // H sync
		if (gActiveLine != 0) {
			switch(gLineType) {
				case LINE_TYPE_TEXT:
#ifdef TEXT_ENABLED				
					drawTextLine(gActiveTextId);
    1d14:	60 91 80 01 	lds	r22, 0x0180
    1d18:	e8 e1       	ldi	r30, 0x18	; 24
    1d1a:	ea 95       	dec	r30
    1d1c:	f1 f7       	brne	.-4      	; 0x1d1a <__vector_1+0x174>
    1d1e:	40 91 84 01 	lds	r20, 0x0184
    1d22:	50 e0       	ldi	r21, 0x00	; 0
			//DDRB &= ~OUT1;
		}
	}
}

ISR(INT0_vect) {
    1d24:	70 e0       	ldi	r23, 0x00	; 0
    1d26:	21 e2       	ldi	r18, 0x21	; 33
    1d28:	30 e0       	ldi	r19, 0x00	; 0
    1d2a:	62 9f       	mul	r22, r18
    1d2c:	d0 01       	movw	r26, r0
    1d2e:	63 9f       	mul	r22, r19
    1d30:	b0 0d       	add	r27, r0
    1d32:	72 9f       	mul	r23, r18
    1d34:	b0 0d       	add	r27, r0
    1d36:	11 24       	eor	r1, r1
    1d38:	ab 57       	subi	r26, 0x7B	; 123
    1d3a:	be 4f       	sbci	r27, 0xFE	; 254
    1d3c:	42 9f       	mul	r20, r18
    1d3e:	f0 01       	movw	r30, r0
    1d40:	43 9f       	mul	r20, r19
    1d42:	f0 0d       	add	r31, r0
    1d44:	52 9f       	mul	r21, r18
    1d46:	f0 0d       	add	r31, r0
    1d48:	11 24       	eor	r1, r1
    1d4a:	e5 5b       	subi	r30, 0xB5	; 181
    1d4c:	fd 4f       	sbci	r31, 0xFD	; 253
    1d4e:	21 e2       	ldi	r18, 0x21	; 33
    1d50:	16 c0       	rjmp	.+44     	; 0x1d7e <__vector_1+0x1d8>
{
	_delay_us(3);
	uint8_t currLine = gActivePixmapLine;
	for (uint8_t i = 0; i < TEXT_LINE_MAX_CHARS; ++i) {
		if (gText[textId][i] != ' ' && gText[textId][i] != 0) {
			DDRB |= OUT1;
    1d52:	21 9a       	sbi	0x04, 1	; 4
		}
		else {
			DDRB &= ~OUT1;
			DELAY_1_NOP();
		}
		SPDR = gTextPixmap[(uint16_t)(currLine)*TEXT_LINE_MAX_CHARS + i];
    1d54:	31 91       	ld	r19, Z+
    1d56:	3e bd       	out	0x2e, r19	; 46
	...
		DELAY_4_NOP();
#ifndef TEXT_SMALL_ENABLED
		DELAY_6_NOP();
		DELAY_7_NOP();
    1d78:	00 00       	nop
    1d7a:	21 50       	subi	r18, 0x01	; 1

static void drawTextLine(uint8_t textId)
{
	_delay_us(3);
	uint8_t currLine = gActivePixmapLine;
	for (uint8_t i = 0; i < TEXT_LINE_MAX_CHARS; ++i) {
    1d7c:	61 f0       	breq	.+24     	; 0x1d96 <__vector_1+0x1f0>
		if (gText[textId][i] != ' ' && gText[textId][i] != 0) {
    1d7e:	3d 91       	ld	r19, X+
    1d80:	30 32       	cpi	r19, 0x20	; 32
    1d82:	11 f0       	breq	.+4      	; 0x1d88 <__vector_1+0x1e2>
    1d84:	33 23       	and	r19, r19
    1d86:	29 f7       	brne	.-54     	; 0x1d52 <__vector_1+0x1ac>
			DDRB |= OUT1;
		}
		else {
			DDRB &= ~OUT1;
    1d88:	21 98       	cbi	0x04, 1	; 4
			DELAY_1_NOP();
    1d8a:	00 00       	nop
    1d8c:	e3 cf       	rjmp	.-58     	; 0x1d54 <__vector_1+0x1ae>
		gActiveLine++;
		if (gActiveLine == UPDATE_LINE) {
			gUpdateScreenData = 1;
		}
		else if (gActiveLine == UPDATE_LINE + 1) {
			gUpdateScreenData = 2;
    1d8e:	22 e0       	ldi	r18, 0x02	; 2
    1d90:	20 93 81 01 	sts	0x0181, r18
    1d94:	6d cf       	rjmp	.-294    	; 0x1c70 <__vector_1+0xca>
	...
		DELAY_6_NOP();
		DELAY_7_NOP();
#endif //TEXT_SMALL_ENABLED	
	}
	DELAY_10_NOP();
	SPDR = 0x00;
    1daa:	1e bc       	out	0x2e, r1	; 46
	DDRB &= ~OUT1;
    1dac:	21 98       	cbi	0x04, 1	; 4
    1dae:	51 cf       	rjmp	.-350    	; 0x1c52 <__vector_1+0xac>
		  if (gActiveTextSize == TEXT_SIZE_LARGE_MULT) {
		    gActivePixmapLine /= TEXT_SIZE_LARGE_MULT;
		  }
		}
		else if (gActiveLine == gActiveTextLastLine) {
		  gUpdateScreenData = 2;
    1db0:	82 e0       	ldi	r24, 0x02	; 2
    1db2:	80 93 81 01 	sts	0x0181, r24
			gActiveTextId = (gActiveTextId+1) % TEXT_LINES;
    1db6:	80 91 80 01 	lds	r24, 0x0180
    1dba:	90 e0       	ldi	r25, 0x00	; 0
    1dbc:	01 96       	adiw	r24, 0x01	; 1
    1dbe:	66 e0       	ldi	r22, 0x06	; 6
    1dc0:	70 e0       	ldi	r23, 0x00	; 0
    1dc2:	94 d0       	rcall	.+296    	; 0x1eec <__divmodhi4>
    1dc4:	80 93 80 01 	sts	0x0180, r24
			gActiveTextLine = gTextLines[gActiveTextId];
    1dc8:	fc 01       	movw	r30, r24
    1dca:	ee 0f       	add	r30, r30
    1dcc:	ff 1f       	adc	r31, r31
    1dce:	e0 5a       	subi	r30, 0xA0	; 160
    1dd0:	fe 4f       	sbci	r31, 0xFE	; 254
    1dd2:	20 81       	ld	r18, Z
    1dd4:	31 81       	ldd	r19, Z+1	; 0x01
    1dd6:	30 93 83 01 	sts	0x0183, r19
    1dda:	20 93 82 01 	sts	0x0182, r18
			gActiveTextSize = gTextLineSizes[gActiveTextId];
    1dde:	84 59       	subi	r24, 0x94	; 148
    1de0:	9e 4f       	sbci	r25, 0xFE	; 254
    1de2:	fc 01       	movw	r30, r24
    1de4:	80 81       	ld	r24, Z
    1de6:	80 93 5f 01 	sts	0x015F, r24
			gActiveTextLastLine = gActiveTextLine + TEXT_CHAR_HEIGHT * gActiveTextSize;
    1dea:	90 e0       	ldi	r25, 0x00	; 0
    1dec:	88 0f       	add	r24, r24
    1dee:	99 1f       	adc	r25, r25
    1df0:	88 0f       	add	r24, r24
    1df2:	99 1f       	adc	r25, r25
    1df4:	88 0f       	add	r24, r24
    1df6:	99 1f       	adc	r25, r25
    1df8:	82 0f       	add	r24, r18
    1dfa:	93 1f       	adc	r25, r19
    1dfc:	90 93 5e 01 	sts	0x015E, r25
    1e00:	80 93 5d 01 	sts	0x015D, r24
			gActivePixmapLine = 1;
    1e04:	81 e0       	ldi	r24, 0x01	; 1
    1e06:	80 93 84 01 	sts	0x0184, r24
    1e0a:	50 cf       	rjmp	.-352    	; 0x1cac <__vector_1+0x106>

00001e0c <__vector_13>:
	TCNT1 = 0; // Reset sync lost timeout.
	updateLine();
}

ISR(TIMER1_OVF_vect)
{
    1e0c:	1f 92       	push	r1
    1e0e:	0f 92       	push	r0
    1e10:	0f b6       	in	r0, 0x3f	; 63
    1e12:	0f 92       	push	r0
    1e14:	11 24       	eor	r1, r1
    1e16:	2f 93       	push	r18
    1e18:	3f 93       	push	r19
    1e1a:	8f 93       	push	r24
    1e1c:	9f 93       	push	r25
	static uint8_t lastLine = 0;
	if (lastLine == gActiveLine) {
    1e1e:	80 91 7c 01 	lds	r24, 0x017C
    1e22:	90 91 7d 01 	lds	r25, 0x017D
    1e26:	20 91 7e 01 	lds	r18, 0x017E
    1e2a:	30 e0       	ldi	r19, 0x00	; 0
    1e2c:	28 17       	cp	r18, r24
    1e2e:	39 07       	cpc	r19, r25
    1e30:	21 f4       	brne	.+8      	; 0x1e3a <__vector_13+0x2e>
    PORTD ^= LED; // Toggle the LED
    1e32:	2b b1       	in	r18, 0x0b	; 11
    1e34:	38 e0       	ldi	r19, 0x08	; 8
    1e36:	23 27       	eor	r18, r19
    1e38:	2b b9       	out	0x0b, r18	; 11
	}
	lastLine = gActiveLine;
    1e3a:	80 93 7e 01 	sts	0x017E, r24
}
    1e3e:	9f 91       	pop	r25
    1e40:	8f 91       	pop	r24
    1e42:	3f 91       	pop	r19
    1e44:	2f 91       	pop	r18
    1e46:	0f 90       	pop	r0
    1e48:	0f be       	out	0x3f, r0	; 63
    1e4a:	0f 90       	pop	r0
    1e4c:	1f 90       	pop	r1
    1e4e:	18 95       	reti

00001e50 <__umulhisi3>:
    1e50:	53 9f       	mul	r21, r19
    1e52:	c0 01       	movw	r24, r0
    1e54:	42 9f       	mul	r20, r18
    1e56:	b0 01       	movw	r22, r0
    1e58:	52 9f       	mul	r21, r18
    1e5a:	70 0d       	add	r23, r0
    1e5c:	81 1d       	adc	r24, r1
    1e5e:	11 24       	eor	r1, r1
    1e60:	91 1d       	adc	r25, r1
    1e62:	34 9f       	mul	r19, r20
    1e64:	70 0d       	add	r23, r0
    1e66:	81 1d       	adc	r24, r1
    1e68:	11 24       	eor	r1, r1
    1e6a:	91 1d       	adc	r25, r1
    1e6c:	08 95       	ret

00001e6e <__mulsi3>:
    1e6e:	62 9f       	mul	r22, r18
    1e70:	d0 01       	movw	r26, r0
    1e72:	73 9f       	mul	r23, r19
    1e74:	f0 01       	movw	r30, r0
    1e76:	82 9f       	mul	r24, r18
    1e78:	e0 0d       	add	r30, r0
    1e7a:	f1 1d       	adc	r31, r1
    1e7c:	64 9f       	mul	r22, r20
    1e7e:	e0 0d       	add	r30, r0
    1e80:	f1 1d       	adc	r31, r1
    1e82:	92 9f       	mul	r25, r18
    1e84:	f0 0d       	add	r31, r0
    1e86:	83 9f       	mul	r24, r19
    1e88:	f0 0d       	add	r31, r0
    1e8a:	74 9f       	mul	r23, r20
    1e8c:	f0 0d       	add	r31, r0
    1e8e:	65 9f       	mul	r22, r21
    1e90:	f0 0d       	add	r31, r0
    1e92:	99 27       	eor	r25, r25
    1e94:	72 9f       	mul	r23, r18
    1e96:	b0 0d       	add	r27, r0
    1e98:	e1 1d       	adc	r30, r1
    1e9a:	f9 1f       	adc	r31, r25
    1e9c:	63 9f       	mul	r22, r19
    1e9e:	b0 0d       	add	r27, r0
    1ea0:	e1 1d       	adc	r30, r1
    1ea2:	f9 1f       	adc	r31, r25
    1ea4:	bd 01       	movw	r22, r26
    1ea6:	cf 01       	movw	r24, r30
    1ea8:	11 24       	eor	r1, r1
    1eaa:	08 95       	ret

00001eac <__udivmodqi4>:
    1eac:	99 1b       	sub	r25, r25
    1eae:	79 e0       	ldi	r23, 0x09	; 9
    1eb0:	04 c0       	rjmp	.+8      	; 0x1eba <__udivmodqi4_ep>

00001eb2 <__udivmodqi4_loop>:
    1eb2:	99 1f       	adc	r25, r25
    1eb4:	96 17       	cp	r25, r22
    1eb6:	08 f0       	brcs	.+2      	; 0x1eba <__udivmodqi4_ep>
    1eb8:	96 1b       	sub	r25, r22

00001eba <__udivmodqi4_ep>:
    1eba:	88 1f       	adc	r24, r24
    1ebc:	7a 95       	dec	r23
    1ebe:	c9 f7       	brne	.-14     	; 0x1eb2 <__udivmodqi4_loop>
    1ec0:	80 95       	com	r24
    1ec2:	08 95       	ret

00001ec4 <__udivmodhi4>:
    1ec4:	aa 1b       	sub	r26, r26
    1ec6:	bb 1b       	sub	r27, r27
    1ec8:	51 e1       	ldi	r21, 0x11	; 17
    1eca:	07 c0       	rjmp	.+14     	; 0x1eda <__udivmodhi4_ep>

00001ecc <__udivmodhi4_loop>:
    1ecc:	aa 1f       	adc	r26, r26
    1ece:	bb 1f       	adc	r27, r27
    1ed0:	a6 17       	cp	r26, r22
    1ed2:	b7 07       	cpc	r27, r23
    1ed4:	10 f0       	brcs	.+4      	; 0x1eda <__udivmodhi4_ep>
    1ed6:	a6 1b       	sub	r26, r22
    1ed8:	b7 0b       	sbc	r27, r23

00001eda <__udivmodhi4_ep>:
    1eda:	88 1f       	adc	r24, r24
    1edc:	99 1f       	adc	r25, r25
    1ede:	5a 95       	dec	r21
    1ee0:	a9 f7       	brne	.-22     	; 0x1ecc <__udivmodhi4_loop>
    1ee2:	80 95       	com	r24
    1ee4:	90 95       	com	r25
    1ee6:	bc 01       	movw	r22, r24
    1ee8:	cd 01       	movw	r24, r26
    1eea:	08 95       	ret

00001eec <__divmodhi4>:
    1eec:	97 fb       	bst	r25, 7
    1eee:	09 2e       	mov	r0, r25
    1ef0:	07 26       	eor	r0, r23
    1ef2:	0a d0       	rcall	.+20     	; 0x1f08 <__divmodhi4_neg1>
    1ef4:	77 fd       	sbrc	r23, 7
    1ef6:	04 d0       	rcall	.+8      	; 0x1f00 <__divmodhi4_neg2>
    1ef8:	e5 df       	rcall	.-54     	; 0x1ec4 <__udivmodhi4>
    1efa:	06 d0       	rcall	.+12     	; 0x1f08 <__divmodhi4_neg1>
    1efc:	00 20       	and	r0, r0
    1efe:	1a f4       	brpl	.+6      	; 0x1f06 <__divmodhi4_exit>

00001f00 <__divmodhi4_neg2>:
    1f00:	70 95       	com	r23
    1f02:	61 95       	neg	r22
    1f04:	7f 4f       	sbci	r23, 0xFF	; 255

00001f06 <__divmodhi4_exit>:
    1f06:	08 95       	ret

00001f08 <__divmodhi4_neg1>:
    1f08:	f6 f7       	brtc	.-4      	; 0x1f06 <__divmodhi4_exit>
    1f0a:	90 95       	com	r25
    1f0c:	81 95       	neg	r24
    1f0e:	9f 4f       	sbci	r25, 0xFF	; 255
    1f10:	08 95       	ret

00001f12 <__udivmodsi4>:
    1f12:	a1 e2       	ldi	r26, 0x21	; 33
    1f14:	1a 2e       	mov	r1, r26
    1f16:	aa 1b       	sub	r26, r26
    1f18:	bb 1b       	sub	r27, r27
    1f1a:	fd 01       	movw	r30, r26
    1f1c:	0d c0       	rjmp	.+26     	; 0x1f38 <__udivmodsi4_ep>

00001f1e <__udivmodsi4_loop>:
    1f1e:	aa 1f       	adc	r26, r26
    1f20:	bb 1f       	adc	r27, r27
    1f22:	ee 1f       	adc	r30, r30
    1f24:	ff 1f       	adc	r31, r31
    1f26:	a2 17       	cp	r26, r18
    1f28:	b3 07       	cpc	r27, r19
    1f2a:	e4 07       	cpc	r30, r20
    1f2c:	f5 07       	cpc	r31, r21
    1f2e:	20 f0       	brcs	.+8      	; 0x1f38 <__udivmodsi4_ep>
    1f30:	a2 1b       	sub	r26, r18
    1f32:	b3 0b       	sbc	r27, r19
    1f34:	e4 0b       	sbc	r30, r20
    1f36:	f5 0b       	sbc	r31, r21

00001f38 <__udivmodsi4_ep>:
    1f38:	66 1f       	adc	r22, r22
    1f3a:	77 1f       	adc	r23, r23
    1f3c:	88 1f       	adc	r24, r24
    1f3e:	99 1f       	adc	r25, r25
    1f40:	1a 94       	dec	r1
    1f42:	69 f7       	brne	.-38     	; 0x1f1e <__udivmodsi4_loop>
    1f44:	60 95       	com	r22
    1f46:	70 95       	com	r23
    1f48:	80 95       	com	r24
    1f4a:	90 95       	com	r25
    1f4c:	9b 01       	movw	r18, r22
    1f4e:	ac 01       	movw	r20, r24
    1f50:	bd 01       	movw	r22, r26
    1f52:	cf 01       	movw	r24, r30
    1f54:	08 95       	ret

00001f56 <__divmodsi4>:
    1f56:	97 fb       	bst	r25, 7
    1f58:	09 2e       	mov	r0, r25
    1f5a:	05 26       	eor	r0, r21
    1f5c:	0e d0       	rcall	.+28     	; 0x1f7a <__divmodsi4_neg1>
    1f5e:	57 fd       	sbrc	r21, 7
    1f60:	04 d0       	rcall	.+8      	; 0x1f6a <__divmodsi4_neg2>
    1f62:	d7 df       	rcall	.-82     	; 0x1f12 <__udivmodsi4>
    1f64:	0a d0       	rcall	.+20     	; 0x1f7a <__divmodsi4_neg1>
    1f66:	00 1c       	adc	r0, r0
    1f68:	38 f4       	brcc	.+14     	; 0x1f78 <__divmodsi4_exit>

00001f6a <__divmodsi4_neg2>:
    1f6a:	50 95       	com	r21
    1f6c:	40 95       	com	r20
    1f6e:	30 95       	com	r19
    1f70:	21 95       	neg	r18
    1f72:	3f 4f       	sbci	r19, 0xFF	; 255
    1f74:	4f 4f       	sbci	r20, 0xFF	; 255
    1f76:	5f 4f       	sbci	r21, 0xFF	; 255

00001f78 <__divmodsi4_exit>:
    1f78:	08 95       	ret

00001f7a <__divmodsi4_neg1>:
    1f7a:	f6 f7       	brtc	.-4      	; 0x1f78 <__divmodsi4_exit>
    1f7c:	90 95       	com	r25
    1f7e:	80 95       	com	r24
    1f80:	70 95       	com	r23
    1f82:	61 95       	neg	r22
    1f84:	7f 4f       	sbci	r23, 0xFF	; 255
    1f86:	8f 4f       	sbci	r24, 0xFF	; 255
    1f88:	9f 4f       	sbci	r25, 0xFF	; 255
    1f8a:	08 95       	ret

00001f8c <strncmp>:
    1f8c:	fb 01       	movw	r30, r22
    1f8e:	dc 01       	movw	r26, r24
    1f90:	41 50       	subi	r20, 0x01	; 1
    1f92:	50 40       	sbci	r21, 0x00	; 0
    1f94:	30 f0       	brcs	.+12     	; 0x1fa2 <strncmp+0x16>
    1f96:	8d 91       	ld	r24, X+
    1f98:	01 90       	ld	r0, Z+
    1f9a:	80 19       	sub	r24, r0
    1f9c:	19 f4       	brne	.+6      	; 0x1fa4 <strncmp+0x18>
    1f9e:	00 20       	and	r0, r0
    1fa0:	b9 f7       	brne	.-18     	; 0x1f90 <strncmp+0x4>
    1fa2:	88 1b       	sub	r24, r24
    1fa4:	99 0b       	sbc	r25, r25
    1fa6:	08 95       	ret

00001fa8 <strncpy>:
    1fa8:	fb 01       	movw	r30, r22
    1faa:	dc 01       	movw	r26, r24
    1fac:	41 50       	subi	r20, 0x01	; 1
    1fae:	50 40       	sbci	r21, 0x00	; 0
    1fb0:	48 f0       	brcs	.+18     	; 0x1fc4 <strncpy+0x1c>
    1fb2:	01 90       	ld	r0, Z+
    1fb4:	0d 92       	st	X+, r0
    1fb6:	00 20       	and	r0, r0
    1fb8:	c9 f7       	brne	.-14     	; 0x1fac <strncpy+0x4>
    1fba:	01 c0       	rjmp	.+2      	; 0x1fbe <strncpy+0x16>
    1fbc:	1d 92       	st	X+, r1
    1fbe:	41 50       	subi	r20, 0x01	; 1
    1fc0:	50 40       	sbci	r21, 0x00	; 0
    1fc2:	e0 f7       	brcc	.-8      	; 0x1fbc <strncpy+0x14>
    1fc4:	08 95       	ret

00001fc6 <__eerd_block_m88pa>:
    1fc6:	dc 01       	movw	r26, r24
    1fc8:	cb 01       	movw	r24, r22

00001fca <__eerd_blraw_m88pa>:
    1fca:	fc 01       	movw	r30, r24
    1fcc:	f9 99       	sbic	0x1f, 1	; 31
    1fce:	fe cf       	rjmp	.-4      	; 0x1fcc <__eerd_blraw_m88pa+0x2>
    1fd0:	06 c0       	rjmp	.+12     	; 0x1fde <__eerd_blraw_m88pa+0x14>
    1fd2:	f2 bd       	out	0x22, r31	; 34
    1fd4:	e1 bd       	out	0x21, r30	; 33
    1fd6:	f8 9a       	sbi	0x1f, 0	; 31
    1fd8:	31 96       	adiw	r30, 0x01	; 1
    1fda:	00 b4       	in	r0, 0x20	; 32
    1fdc:	0d 92       	st	X+, r0
    1fde:	41 50       	subi	r20, 0x01	; 1
    1fe0:	50 40       	sbci	r21, 0x00	; 0
    1fe2:	b8 f7       	brcc	.-18     	; 0x1fd2 <__eerd_blraw_m88pa+0x8>
    1fe4:	08 95       	ret

00001fe6 <_exit>:
    1fe6:	f8 94       	cli

00001fe8 <__stop_program>:
    1fe8:	ff cf       	rjmp	.-2      	; 0x1fe8 <__stop_program>
